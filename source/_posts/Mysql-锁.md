---
title: Mysql-锁
date: 2017-11-20 00:00:00
categories: Mysql
tags:
    - Mysql
---

这篇文章主要介绍了MySQL行级锁、表级锁、页级锁详细介绍,同时列举了一些实例说明

<!-- more -->

页级:引擎 BDB。
表级:引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行
行级:引擎 INNODB ， 单独的一行记录加锁

表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许
行级，仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。
页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

MySQL 5.1支持对MyISAM和MEMORY表进行表级锁定，对BDB表进行页级锁定，对InnoDB表进行行级锁定。
对WRITE，MySQL使用的表锁定方法原理如下：
如果在表上没有锁，在它上面放一个写锁。 否则，把锁定请求放在写锁定队列中。
对READ，MySQL使用的锁定方法原理如下： 如果在表上没有写锁定，把一个读锁定放在它上面   否则，把锁请求放在读锁定队列中。

InnoDB使用行锁定，BDB使用页锁定。对于这两种存储引擎，都可能存在死锁。这是因为，在SQL语句处理期间，InnoDB自动获得行锁定和BDB获得页锁定，而不是在事务启动时获得。 

行级锁定的优点：

- 当在许多线程中访问不同的行时只存在少量锁定冲突。
- 回滚时只有少量的更改。
- 可以长时间锁定单一的行。

行级锁定的缺点：

- 比页级或表级锁定占用更多的内存。
- 当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。
- 如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。
- 用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。

在以下情况下，表锁定优先于页级或行级锁定：

- 表的大部分语句用于读取。
- 对严格的关键字进行读取和更新，你可以更新或删除可以用单一的读取的关键字来提取的一行：
- UPDATE tbl_name SET column=value WHERE unique_key_col=key_value;
- DELETE FROM tbl_name WHERE unique_key_col=key_value;
- SELECT 结合并行的INSERT语句，并且只有很少的UPDATE或DELETE语句。
- 在整个表上有许多扫描或GROUP BY操作，没有任何写操作。

## mysql 锁表类型和解锁语句

如果想要在一个表上做大量的 INSERT 和 SELECT 操作，但是并行的插入却不可能时，可以将记录插入到临时表中，然后定期将临时表中的数据更新到实际的表里。可以用以下命令实现：
```
mysql> LOCK TABLES real_table WRITE, insert_table WRITE;
mysql> INSERT INTO real_table SELECT * FROM insert_table;
mysql> TRUNCATE TABLE insert_table;
mysql> UNLOCK TABLES;
```

## 行级锁的优点有：

- 在很多线程请求不同记录时减少冲突锁。
- 事务回滚时减少改变数据。
- 使长时间对单独的一行记录加锁成为可能。

行级锁的缺点有：

- 比页级锁和表级锁消耗更多的内存。
- 锁是计算机协调多个进程或线程并发访问某一资源的机制，不同的数据库的锁机制大同小异。由于数据库资源是一种供许多用户共享的资源，所以如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。了解锁机制不仅可以使我们更有效的开发利用数据库资源，也使我们能够更好地维护数据库，从而提高数据库的性能。
