---
title: 设计模式-组合模式
date: 2017-11-07 00:00:00
categories: 设计模式
tags:
    - 设计模式
---
 
组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念
，客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。组合模式让你可以优化处理递
归或分级数据结构。有许多关于分级数据结构的例子，使得组合模式非常有用武之地。关于分级数据结构的一个普遍性的例子是你每
次使用电脑时所遇到的:文件系统。文件系统由目录和文件组成。每个目录都可以装内容。目录的内容可以是文件，也可以是目录。
按照这种方式，计算机的文件系统就是以递归结构来组织的。如果你想要描述这样的数据结构，那么你可以使用组合模式Composite。
文件和目录都执行相同的接口，这是组合模式的关键。通过执行相同的接口，你就可以用相同的方式对待文件和目录，
从而实现将文件或者目录储存为目录的子级元素。

**定义**(GoF《设计模式》):将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和使用具有一致性。

<!-- more -->

## 结构
{% asset_img 1340694955_4501.jpg %}

涉及角色:

1. Component 是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component
子部件。
2. Leaf 在组合中表示叶子结点对象，叶子结点没有子结点。
3. Composite 定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。

```java
import java.util.ArrayList;  
import java.util.List;  
  
public class ComponentDemo {  
    public abstract class Component {  
        String name;  
  
        public abstract void add(Component c);  
        public abstract void remove(Component c);  
        public abstract void eachChild();  
    }  
  
    // 组合部件类  
    public class Leaf extends Component {  
  
        // 叶子节点不具备添加的能力，所以不实现  
        @Override  
        public void add(Component c) {  
            System.out.println("");  
        }  
  
        // 叶子节点不具备添加的能力必然也不能删除  
        @Override  
        public void remove(Component c) {  
            System.out.println("");  
        }  
  
        // 叶子节点没有子节点所以显示自己的执行结果  
        @Override  
        public void eachChild() {  
            System.out.println(name + "执行了");  
        }  
    }  
  
    // 组合类  
    public class Composite extends Component {  
  
        // 用来保存节点的子节点  
        List<Component> list = new ArrayList<Component>();  
  
        // 添加节点 添加部件  
        @Override  
        public void add(Component c) {  
            list.add(c);  
        }  
  
        // 删除节点 删除部件  
        @Override  
        public void remove(Component c) {  
            list.remove(c);  
        }  
  
        // 遍历子节点  
        @Override  
        public void eachChild() {  
            System.out.println(name + "执行了");  
            for (Component c : list) {  
                c.eachChild();  
            }  
        }  
    }  
  
    public static void main(String[] args) {  
        ComponentDemo demo = new ComponentDemo();  
        // 构造根节点  
        Composite rootComposite = demo.new Composite();  
        rootComposite.name = "根节点";  
  
        // 左节点  
        Composite compositeLeft = demo.new Composite();  
        compositeLeft.name = "左节点";  
  
        // 构建右节点，添加两个叶子几点，也就是子部件  
        Composite compositeRight = demo.new Composite();  
        compositeRight.name = "右节点";  
        Leaf leaf1 = demo.new Leaf();  
        leaf1.name = "右-子节点1";  
        Leaf leaf2 = demo.new Leaf();  
        leaf2.name = "右-子节点2";  
        compositeRight.add(leaf1);  
        compositeRight.add(leaf2);  
  
        // 左右节点加入 根节点  
        rootComposite.add(compositeRight);  
        rootComposite.add(compositeLeft);  
        // 遍历组合部件  
        rootComposite.eachChild();  
    }  
} 
```
执行结果如下:
```
根节点执行了
右节点执行了
右-子节点1执行了
右-子节点2执行了
左节点执行了
```

## 实例

就拿剪发办卡的事情来分析一下吧。
首先，一张卡可以在总部，分店，加盟店使用，那么总部可以刷卡，分店也可以刷卡，加盟店也可以刷卡，这个属性结构的店面层级关系就明确啦。
那么，总店刷卡消费与分店刷卡消费是一样的道理，那么总店与分店对会员卡的使用也具有一致性。
{% asset_img 20140331075052640.jpg %}

那么我们就根据我们会员卡的消费，来模拟一下组合模式的实现吧
首先:
1.我们的部件有，总店，分店，加盟店！
2.我们的部件共有的行为是:刷会员卡
3.部件之间的层次关系，也就是店面的层次关系是，总店下有分店、分店下可以拥有加盟店。
有了我们这几个必要条件后，我的要求就是目前店面搞活动当我在总店刷卡后，就可以累积相当于在所有下级店面刷卡的积分总额，设计的代码如下:
```java
import java.util.ArrayList;  
import java.util.List;  
  
public class PayDemo {  
    public abstract class Market {  
        String name;  
        public abstract void add(Market m);  
        public abstract void remove(Market m);  
        public abstract void PayByCard();  
    }  
  
    // 分店 下面可以有加盟店  
    public class MarketBranch extends Market {  
        // 加盟店列表  
        List<Market> list = new ArrayList<PayDemo.Market>();  
  
        public MarketBranch(String s) {  
            this.name = s;  
        }  
  
        @Override  
        public void add(Market m) {  
            list.add(m);  
        }  
  
        @Override  
        public void remove(Market m) {  
            list.remove(m);  
        }  
  
        // 消费之后，该分店下的加盟店自动累加积分  
        @Override  
        public void PayByCard() {  
            System.out.println(name + "消费,积分已累加入该会员卡");  
            for (Market m : list) {  
                m.PayByCard();  
            }  
        }  
    }  
  
    // 加盟店 下面不在有分店和加盟店，最底层  
    public class MarketJoin extends Market {  
        public MarketJoin(String s) {  
            this.name = s;  
        }  
  
        @Override  
        public void add(Market m) {  }  
  
        @Override  
        public void remove(Market m) {  }  
  
        @Override  
        public void PayByCard() {  
            System.out.println(name + "消费,积分已累加入该会员卡");  
        }  
    }  
  
    public static void main(String[] args) {  
        PayDemo demo = new PayDemo();  
          
        MarketBranch rootBranch = demo.new MarketBranch("总店");  
        MarketBranch qhdBranch = demo.new MarketBranch("秦皇岛分店");  
        MarketJoin hgqJoin = demo.new MarketJoin("秦皇岛分店一海港区加盟店");  
        MarketJoin btlJoin = demo.new MarketJoin("秦皇岛分店二白塔岭加盟店");  
          
        qhdBranch.add(hgqJoin);  
        qhdBranch.add(btlJoin);  
        rootBranch.add(qhdBranch);  
        rootBranch.PayByCard();  
    }  
}
```
运行结果如下:
{% asset_img 20140331083848187.jpg %}
这样在累积所有子店面积分的时候，就不需要去关心子店面的个数了，也不用关系是否是叶子节点还是组合节点了，也就是说不管是总店刷卡，还是加盟店刷卡，都可以正确有效的计算出活动积分。


## 适用性

以下情况下适用Composite模式:

1. 你想表示对象的部分-整体层次结构
2. 你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。

## 总结

组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以向处理简单元素一样来处理复杂元素。
如果你想要创建层次结构，并可以在其中以相同的方式对待所有元素，那么组合模式就是最理想的选择。

ref: 
[http://blog.csdn.net/jason0539/article/details/22642281](http://blog.csdn.net/jason0539/article/details/22642281)
[http://blog.csdn.net/hfmbook/article/details/7693069](http://blog.csdn.net/hfmbook/article/details/7693069)
