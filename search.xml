<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2019/11/28/%E6%9E%B6%E6%9E%84-%E4%BA%AC%E4%B8%9C%E5%88%B0%E5%AE%B6%E5%BA%93%E5%AD%98%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="库存系统难破题？京东到家来分享"><a href="#库存系统难破题？京东到家来分享" class="headerlink" title="库存系统难破题？京东到家来分享"></a>库存系统难破题？京东到家来分享</h1><h2 id="库存系统数据流转"><a href="#库存系统数据流转" class="headerlink" title="库存系统数据流转"></a>库存系统数据流转</h2><p><img src="b4c7b06acfd04290ae949e77751557f3.jpeg" alt="b4c7b06acfd04290ae949e77751557f3.jpeg"></p>
<p>库存系统数据流转图解释说明：</p>
<p>库存系统的数据流转，指的都是销售库存的数据流转，在京东到家还有自营类业务板块，即上图中提到的城市仓，由于它涉及到采购入库及盘盈盘亏等问题, 所以会由一套 WMS 系统来支撑。</p>
<p>京东到家设计初衷就是希望商家下的商品各门店共享，带来的问题就是商家新建一个商品时，需要推送到商家下所有的门店中，即所有的门店均可以看到这个商品。或者商家新建一个门店时，需要将商家下所有的商品均推送到这个新建的门店中，所以这采用了 MQ 技术进行异步化批量处理。</p>
<p>写到这里，相信对大家对库存系统有了初步的了解，从上图来看功能上其实并不复杂，但是他面临的技术复杂度却是相当高的，比如秒杀品在高并发的情况下如何防止超卖。</p>
<p>另外库存系统还不是一个纯技术的系统，需要结合用户的行为特点来考虑，比如下文中提到什么时间进行库存的扣减最合适，我们先抛出几个问题和大家一起探讨下，如有不妥之处，欢迎大家拍砖。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><h3 id="库存什么时候进行预占-或者扣减-呢"><a href="#库存什么时候进行预占-或者扣减-呢" class="headerlink" title="库存什么时候进行预占 (或者扣减) 呢"></a>库存什么时候进行预占 (或者扣减) 呢</h3><p>商家销售的商品数量是有限的，用户下单后商品会被扣减，我们可以怎么实现呢？</p>
<p>举个例子： 一件商品有 1000 个库存，现在有 1000 个用户，每个用户计划同时购买 1000 个。</p>
<ul>
<li>实现方案 1：如果用户加入购物车时进行库存预占，那么将只能有 1 个用户将 1000 个商品加入购物车。</li>
<li>实现方案 2：如果用户提交订单时进行库存预占，那么将也只能有 1 个用户将 1000 个商品提单成功，其它的人均提示“库存不足，提单失败”。</li>
<li>实现方案 3：如果用户提交订单 &amp; 支付成功时进行库存预占，那么这 1000 个人都能生成订单，但是只有 1 个人可以支付成功，其它的订单均会被自动取消。</li>
</ul>
<p>京东到家目前采用的是 方案 2，理由如下：</p>
<p>用户可能只是暂时加入购物车，并不表示用户最终会提单并支付。</p>
<p>所以在购物车进行库存校验并预占，会造成其它真正想买的用户不能加入购物车的情况，但是之前加车的用户一直不付款，最终损失的是公司。</p>
<p>方案 3 会造成生成 1000 个订单，无论是在支付前校验库存还是在支付成功后再检验库存，都会造成用户准备好支付条件后却会出现 99.9% 的系统取消订单的概率，也就是说会给 99.9% 的用户体验到不爽的感觉。</p>
<p>数据表明用户提交订单不支付的占比是非常小的（相对于加入购物车不购买的行为），目前京东到家给用户预留的最长支付时间是 30 分钟，超过 30 分钟订单自动取消，预占的库存自动释放。</p>
<p>综上所述，方案 2 也可能由于用户下单预占库存但最终未支付，造成库存 30 分钟后才能被其它用户使用的情况，但是相较于方案 1，方案 3 无疑是折中的最好方案。</p>
<h3 id="重复提交订单的问题"><a href="#重复提交订单的问题" class="headerlink" title="重复提交订单的问题"></a>重复提交订单的问题</h3><p>重复提交订单造成的库存重复扣减的后果是比较严重的。比如商家设置有 1000 件商品，而实际情况可能卖了 900 件就提示用户无货了，给商家造成无形的损失</p>
<p>可能出现重复提交订单的情况：</p>
<ol>
<li>用户善意行为：app 上用户单击“提交订单”按钮后由于后端接口没有返回，用户以为没有操作成功会再次单击“提交订单”按钮</li>
<li>用户恶意行为：黑客直接刷提单接口，绕过 App 端防重提交功能</li>
<li>提单系统重试：比如提单系统为了提高系统的可用性，在第一次调用库存系统扣减接口超时后会重试再次提交扣减请求</li>
</ol>
<p>好了，既然问题根源缕清楚了，我们一一对症下药</p>
<ol>
<li>用户善意行为：App 侧在用户第一次单击“提交订单”按钮后对按钮进行置灰，禁止再次提交订单</li>
<li>用户恶意行为：采用令牌机制，用户每次进入结算页，提单系统会颁发一个令牌 ID（全局唯一），当用户点击“提交订单”按钮时发起的网络请求中会带上这个令牌 ID, 这个时候提单系统会优先进行令牌 ID 验证，令牌 ID 存在 &amp; 令牌 ID 访问次数 =1 的话才会放行处理后续逻辑，否则直接返回</li>
<li>提单系统重试：这种情况则需要后端系统（比如库存系统）来保证接口的幂等性，每次调用库存系统时均带上订单号，库存系统会基于订单号增加一个分布式事务锁。</li>
</ol>
<p>伪代码如下：<br><img src="053a21792d714ae992bae86ca146c662.jpeg" alt="053a21792d714ae992bae86ca146c662.jpeg"></p>
<h3 id="库存数据的回滚机制如何做"><a href="#库存数据的回滚机制如何做" class="headerlink" title="库存数据的回滚机制如何做"></a>库存数据的回滚机制如何做</h3><p>需要库存回滚的场景也是比较多的，比如：</p>
<ol>
<li>用户未支付：用户下单后后悔了</li>
<li>用户支付后取消：用户下单 &amp; 支付后后悔了</li>
<li>风控取消：风控识别到异常行为，强制取消订单</li>
<li>耦合系统故障：比如提交订单时提单系统 T1 同时会调用积分扣减系统 X1、库存扣减系统 X2、优惠券系统 X3，假如 X1、X2 成功后，调用 X3 失败，需要回滚用户积分与商家库存。</li>
</ol>
<p>其中场景 1、2、3 比较类似，都会造成订单取消，订单中心取消后会发送 MQ 出来，各个系统保证自己能够正确消费订单取消 MQ 即可。</p>
<p>而场景 4 订单其实尚未生成，相对来说要复杂些，如上面提到的，提单系统 T1 需要主动发起库存系统 X2、优惠券系统 X3 的回滚请求（入参必须带上订单号），X2、X3 回滚接口需要支持幂等性。</p>
<p>其实针对场景 4，还存在一种极端情况，如果提单系统 T1 准备回滚时自身也宕机了，那么库存系统 X2、优惠券系统 X3 就必须依靠自己来完成回滚操作了，也就是说具备自我数据健康检查的能力，具体来说怎么实现呢？</p>
<p>可以利用当前订单号所属的订单尚未生成的特点，可以通过 worker 机制，每次捞取 40 分钟（这里的 40 一定要大于容忍用户的支付时间）前的订单，调用订单中心查询订单的状态，确保不是已取消的，否则进行自我数据的回滚。</p>
<p>多人同时购买 1 件商品，如何安全地库存扣减？</p>
<p>现实中同一件商品可能会出现多人同时购买的情况，我们可以如何做到并发安全呢？</p>
<p>伪代码片段 1：<br><img src="d8b425d8e20a41829ee6b0ef3408f86d.jpeg" alt="d8b425d8e20a41829ee6b0ef3408f86d.jpeg"></p>
<p>伪代码片段 1 的设计思想是所有的请求过来之后首先加锁，强制其串行化处理，可见其效率一定不高。</p>
<p>伪代码片段 2：<br><img src="45ea66020e2d462690831c4906042c3b.jpeg" alt="45ea66020e2d462690831c4906042c3b.jpeg"></p>
<p>这段代码只是在 where 条件里增加了and stockNum&gt;=”+requestBuyNum即可防止超卖的行为，达到了与上述伪代码 1 的功能。</p>
<p>如果商品是促销品（比如参与了秒杀的商品）并发扣减的机率会更高，那么数据库的压力会更高，这个时候还可以怎么做呢?</p>
<p>海量的用户秒杀请求，本质上是一个排序，先到先得。但是如此之多的请求，注定了有些人是抢不到的，可以在进入上述伪代码 Dao 层之前增加一个计数器进行控制，比如有 50% 的流量将直接告诉其抢购失败，伪代码如下：</p>
<p><img src="a6c71c7b8ab84c0591f0091b1b848038.jpeg" alt="a6c71c7b8ab84c0591f0091b1b848038.jpeg"></p>
<p>另外同一个用户，不允许多次抢购同一件商品，我们又该如何做呢?</p>
<p><img src="a9715822bbbc40af8f5dcf06d4ab1348.jpeg" alt="a9715822bbbc40af8f5dcf06d4ab1348.jpeg"></p>
<p>如果同一个用户拥有不同的帐号，来抢购同一件商品，上面的策略就失效了。一些公司在发展早期几乎是没有限制的，很容易就可以注册很多个账号。也即是网络所谓的“僵尸账号”，数量庞大，如果我们使用几万个“僵尸号”混进去抢购，这样就可以大大提升我们中奖的概率，那我们如何应对呢？</p>
<p><img src="0e717ef8a61a4b1c965e1f9755a80373.jpeg" alt="0e717ef8a61a4b1c965e1f9755a80373.jpeg"></p>
<h3 id="库存系统的核心表结构设计"><a href="#库存系统的核心表结构设计" class="headerlink" title="库存系统的核心表结构设计"></a>库存系统的核心表结构设计</h3><p>下面列出了库存系统的核心表结构，提供出来供大家在工作中能够有所参考。</p>
<p><img src="cbbf1248853a49f6bcebd79fdab5c4e7.jpeg" alt="cbbf1248853a49f6bcebd79fdab5c4e7.jpeg"></p>
<p>库存主表，命名规则：stock_center_00~99 库存主表</p>
<p><img src="cc4347b772d24c0886ae80499d31d66e.jpeg" alt="cc4347b772d24c0886ae80499d31d66e.jpeg"></p>
<p>库存流水表，命名规则：stock_center_flow_00~99 库存流水表</p>
<p><img src="dd4342740bce4a549129c70c1e6dabc0.jpeg" alt="dd4342740bce4a549129c70c1e6dabc0.jpeg"></p>
<p>库存批量操作日志表，命名规则：batch_upload_log 库存批量操作日志表</p>
<p>ref:<br><a href="https://www.cnblogs.com/davidwang456/articles/10251560.html" target="_blank" rel="external">库存系统难破题？京东到家来分享</a></p>
<p>ref:<br><a href="https://www.cnblogs.com/davidwang456/articles/10251560.html" target="_blank" rel="external">https://www.cnblogs.com/davidwang456/articles/10251560.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>Java-Java8-Optional</title>
    <url>/2018/09/21/Java-Java8-Optional/</url>
    <content><![CDATA[<p>Optional是Java8提供的为了解决null安全问题的一个API。善用Optional可以使我们代码中很多繁琐、丑陋的设计变得十分优雅。</p>
<a id="more"></a>
<p>使用Optional，我们就可以把下面这样的代码进行改写。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static String getName(User u) &#123;</div><div class="line">    if (u == null)</div><div class="line">        return &quot;Unknown&quot;;</div><div class="line">    return u.name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不过，千万不要改写成这副样子。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static String getName(User u) &#123;</div><div class="line">    Optional&lt;User&gt; user = Optional.ofNullable(u);</div><div class="line">    if (!user.isPresent())</div><div class="line">        return &quot;Unknown&quot;;</div><div class="line">    return user.get().name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样改写非但不简洁，而且其操作还是和第一段代码一样。无非就是用isPresent方法来替代u==null。这样的改写并不是Optional正确的用法，我们再来改写一次。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static String getName(User u) &#123;</div><div class="line">    return Optional.ofNullable(u)</div><div class="line">                    .map(user-&gt;user.name)</div><div class="line">                    .orElse(&quot;Unknown&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样才是正确使用Optional的姿势。那么按照这种思路，我们可以安心的进行链式调用，而不是一层层判断了。看一段代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static String getChampionName(Competition comp) throws IllegalArgumentException &#123;</div><div class="line">    if (comp != null) &#123;</div><div class="line">        CompResult result = comp.getResult();</div><div class="line">        if (result != null) &#123;</div><div class="line">            User champion = result.getChampion();</div><div class="line">            if (champion != null) &#123;</div><div class="line">                return champion.getName();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    throw new IllegalArgumentException(&quot;The value of param comp isn&apos;t available.&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于种种原因（比如：比赛还没有产生冠军、方法的非正常调用、某个方法的实现里埋藏的大礼包等等），我们并不能开心的一路comp.getResult().getChampion().getName()到底。而其他语言比如kotlin，就提供了在语法层面的操作符加持：comp?.getResult()?.getChampion()?.getName()。所以讲道理在Java里我们怎么办！</p>
<p>让我们看看经过Optional加持过后，这些代码会变成什么样子。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static String getChampionName(Competition comp) throws IllegalArgumentException &#123;</div><div class="line">    return Optional.ofNullable(comp)</div><div class="line">            .map(c-&gt;c.getResult())</div><div class="line">            .map(r-&gt;r.getChampion())</div><div class="line">            .map(u-&gt;u.getName())</div><div class="line">            .orElseThrow(()-&gt;new IllegalArgumentException(&quot;The value of param comp isn&apos;t available.&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这就很舒服了。Optional给了我们一个真正优雅的Java风格的方法来解决null安全问题。虽然没有直接提供一个操作符写起来短，但是代码看起来依然很爽很舒服。更何况?.这样的语法好不好看还见仁见智呢。</p>
<p>解决这种结构的深层嵌套路径是有点麻烦的。我们必须编写一堆 null 检查来确保不会导致一个 NullPointerException：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Outer outer = new Outer();</div><div class="line">if (outer != null &amp;&amp; outer.nested != null &amp;&amp; outer.nested.inner != null) &#123;</div><div class="line">    System.out.println(outer.nested.inner.foo);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以通过利用 Java 8 的 Optional 类型来摆脱所有这些 null 检查。map 方法接收一个 Function 类型的 lambda 表达式，并自动将每个 function 的结果包装成一个 Optional 对象。这使我们能够在一行中进行多个 map 操作。Null 检查是在底层自动处理的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Optional.of(new Outer())</div><div class="line">    .map(Outer::getNested)</div><div class="line">    .map(Nested::getInner)</div><div class="line">    .map(Inner::getFoo)</div><div class="line">    .ifPresent(System.out::println);</div></pre></td></tr></table></figure></p>
<p>请记住，这种解决方案可能没有传统 null 检查那么高的性能。不过在大多数情况下不会有太大问题。</p>
<p>Optional的魅力还不止于此，Optional还有一些神奇的用法，比如Optional可以用来检验参数的合法性。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void setName(String name) throws IllegalArgumentException &#123;</div><div class="line">    this.name = Optional.ofNullable(name).filter(User::isNameValid)</div><div class="line">                        .orElseThrow(()-&gt;new IllegalArgumentException(&quot;Invalid username.&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>存在即返回, 无则提供默认值<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">return user.orElse(null);  //而不是 return user.isPresent() ? user.get() : null;</div><div class="line">return user.orElse(UNKNOWN_USER);</div></pre></td></tr></table></figure></p>
<p>存在即返回, 无则由函数来产生<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">return user.orElseGet(() -&gt; fetchAUserFromDatabase()); //而不要 return user.isPresent() ? user: fetchAUserFromDatabase();</div></pre></td></tr></table></figure></p>
<p>存在才对它做点什么<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">user.ifPresent(System.out::println);</div></pre></td></tr></table></figure></p>
<p>ref:<br><a href="http://www.importnew.com/26066.html" target="_blank" rel="external">Java8 如何正确使用 Optional</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Java8-Lambda</title>
    <url>/2018/09/21/Java-Java8-lambda/</url>
    <content><![CDATA[<p>Java 8 lambda表达式示例</p>
<a id="more"></a>
<h2 id="用lambda表达式实现Runnable"><a href="#用lambda表达式实现Runnable" class="headerlink" title="用lambda表达式实现Runnable"></a>用lambda表达式实现Runnable</h2><p>毫无疑问，lambda表达式用得最多的场合就是替代匿名内部类，而实现Runnable接口是匿名内部类的经典例子。lambda表达式的功能相当强大，用()-&gt;就可以代替整个匿名内部类！请看代码：</p>
<p>如果使用匿名内部类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// Java 8之前：</div><div class="line">new Thread(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">    System.out.println(&quot;Before Java8, too much code for too little to do&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;).start();</div><div class="line"></div><div class="line">//Java 8方式：</div><div class="line">new Thread( () -&gt; System.out.println(&quot;In Java8, Lambda expression rocks !!&quot;) ).start();</div></pre></td></tr></table></figure></p>
<p>这个例子向我们展示了Java 8 lambda表达式的语法。你可以使用lambda写出如下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(params) -&gt; expression</div><div class="line">(params) -&gt; statement</div><div class="line">(params) -&gt; &#123; statements &#125;</div></pre></td></tr></table></figure></p>
<p>例如，如果你的方法不对参数进行修改、重写，只是在控制台打印点东西的话，那么可以这样写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">() -&gt; System.out.println(&quot;Hello Lambda Expressions&quot;);</div></pre></td></tr></table></figure></p>
<p>如果你的方法接收两个参数，那么可以写成如下这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(int even, int odd) -&gt; even + odd</div></pre></td></tr></table></figure></p>
<p>顺便提一句，通常都会把lambda表达式内部变量的名字起得短一些。这样能使代码更简短，放在同一行。所以，在上述代码中，变量名选用a、b或者x、y会比even、odd要好。</p>
<h2 id="使用Java-8-lambda表达式进行事件处理"><a href="#使用Java-8-lambda表达式进行事件处理" class="headerlink" title="使用Java 8 lambda表达式进行事件处理"></a>使用Java 8 lambda表达式进行事件处理</h2><p>如果你用过Swing API编程，你就会记得怎样写事件监听代码。这又是一个旧版本简单匿名类的经典用例，但现在可以不这样了。你可以用lambda表达式写出更好的事件监听代码，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// Java 8之前：</div><div class="line">JButton show =  new JButton(&quot;Show&quot;);</div><div class="line">show.addActionListener(new ActionListener() &#123;</div><div class="line">    @Override</div><div class="line">    public void actionPerformed(ActionEvent e) &#123;</div><div class="line">    System.out.println(&quot;Event handling without lambda expression is boring&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// Java 8方式：</div><div class="line">show.addActionListener((e) -&gt; &#123;</div><div class="line">    System.out.println(&quot;Light, Camera, Action !! Lambda expressions Rocks&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Java开发者经常使用匿名类的另一个地方是为 Collections.sort() 定制 Comparator。在Java 8中，你可以用更可读的lambda表达式换掉丑陋的匿名类。我把这个留做练习，应该不难，可以按照我在使用lambda表达式实现 Runnable 和 ActionListener 的过程中的套路来做。</p>
<h2 id="使用lambda表达式对集合进行迭代"><a href="#使用lambda表达式对集合进行迭代" class="headerlink" title="使用lambda表达式对集合进行迭代"></a>使用lambda表达式对集合进行迭代</h2><p>请看对比：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//before java8</div><div class="line">List&lt;String&gt; languages = Arrays.asList(&quot;java&quot;,&quot;scala&quot;,&quot;python&quot;);</div><div class="line">for(String each:languages) &#123;</div><div class="line">    System.out.println(each);</div><div class="line">&#125;</div><div class="line">//after java8</div><div class="line">languages.forEach(x -&gt; System.out.println(x));</div><div class="line">// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，</div><div class="line">// 看起来像C++的作用域解析运算符</div><div class="line">languages.forEach(System.out::println);</div></pre></td></tr></table></figure></p>
<h2 id="Java-8中使用lambda表达式的Map和Reduce示例"><a href="#Java-8中使用lambda表达式的Map和Reduce示例" class="headerlink" title="Java 8中使用lambda表达式的Map和Reduce示例"></a>Java 8中使用lambda表达式的Map和Reduce示例</h2><p>本例介绍最广为人知的函数式编程概念map。它允许你将对象进行转换。例如在本例中，我们将 costBeforeTax 列表的每个元素转换成为税后的值。我们将 x -&gt; x*x lambda表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 forEach() 将列表元素打印出来。使用流API的收集器类，可以得到所有含税的开销。有 toList() 这样的方法将 map 或任何其他操作的结果合并起来。由于收集器在流上做终端操作，因此之后便不能重用流了。你甚至可以用流API的 reduce() 方法将所有数字合成一个，下一个例子将会讲到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 不使用lambda表达式为每个订单加上12%的税</div><div class="line">List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);</div><div class="line">for (Integer cost : costBeforeTax) &#123;</div><div class="line">    double price = cost + .12*cost;</div><div class="line">    System.out.println(price);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 使用lambda表达式</div><div class="line">List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);</div><div class="line">costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).forEach(System.out::println);</div></pre></td></tr></table></figure>
<p>结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">112.0</div><div class="line">224.0</div><div class="line">336.0</div><div class="line">448.0</div><div class="line">560.0</div><div class="line"></div><div class="line">112.0</div><div class="line">224.0</div><div class="line">336.0</div><div class="line">448.0</div><div class="line">560.0</div></pre></td></tr></table></figure></p>
<p>在上个例子中，可以看到map将集合类（例如列表）元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。流API定义的 reduceh() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。这并不会限制你，你可以用内建方法，也可以自己定义。在这个Java 8的Map Reduce示例里，我们首先对所有价格应用 12% 的VAT，然后用 reduce() 方法计算总和。</p>
<p>既然提到了map，又怎能不提到reduce。reduce与map一样，也是函数式编程里最重要的几个方法之一。。。map的作用是将一个对象变为另外一个，而reduce实现的则是将所有值合并为一个，请看：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 为每个订单加上12%的税</div><div class="line">// 老方法：</div><div class="line">List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);</div><div class="line">double total = 0;</div><div class="line">for (Integer cost : costBeforeTax) &#123;</div><div class="line">    double price = cost + .12*cost;</div><div class="line">    total = total + price;</div><div class="line">&#125;</div><div class="line">System.out.println(&quot;Total : &quot; + total);</div><div class="line"> </div><div class="line">// 新方法：</div><div class="line">List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);</div><div class="line">double bill = costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).reduce((sum, cost) -&gt; sum + cost).get();</div><div class="line">System.out.println(&quot;Total : &quot; + bill);</div></pre></td></tr></table></figure></p>
<p>结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Total : 1680.0</div><div class="line">Total : 1680.0</div></pre></td></tr></table></figure></p>
<h2 id="filter操作"><a href="#filter操作" class="headerlink" title="filter操作"></a>filter操作</h2><p>filter也是我们经常使用的一个操作。在操作集合的时候，经常需要从原始的集合中过滤掉一部分元素。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">List&lt;Double&gt; cost = Arrays.asList(10.0, 20.0, 30.0, 40.0);</div><div class="line">List&lt;Double&gt; filteredCost = cost.stream().filter(x -&gt; x &gt; 25.0).collect(Collectors.toList());</div><div class="line">filteredCost.forEach(x -&gt; System.out.println(x));</div></pre></td></tr></table></figure></p>
<p>最后的结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">30.0</div><div class="line">40.0</div></pre></td></tr></table></figure></p>
<h2 id="使用lambda表达式和函数式接口Predicate"><a href="#使用lambda表达式和函数式接口Predicate" class="headerlink" title="使用lambda表达式和函数式接口Predicate"></a>使用lambda表达式和函数式接口Predicate</h2><p>除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。Predicate接口非常适用于做过滤。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void filter(List&lt;String&gt; languages, Predicate&lt;String&gt; condition) &#123;</div><div class="line">    languages.stream().filter(x -&gt; condition.test(x)).forEach(x -&gt; System.out.println(x + &quot; &quot;));</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    List&lt;String&gt; languages = Arrays.asList(&quot;Java&quot;,&quot;Python&quot;,&quot;scala&quot;,&quot;Shell&quot;,&quot;R&quot;);</div><div class="line">    System.out.println(&quot;Language starts with J: &quot;);</div><div class="line">    filter(languages,x -&gt; x.startsWith(&quot;J&quot;));</div><div class="line">    System.out.println(&quot;\nLanguage ends with a: &quot;);</div><div class="line">    filter(languages,x -&gt; x.endsWith(&quot;a&quot;));</div><div class="line">    System.out.println(&quot;\nAll languages: &quot;);</div><div class="line">    filter(languages,x -&gt; true);</div><div class="line">    System.out.println(&quot;\nNo languages: &quot;);</div><div class="line">    filter(languages,x -&gt; false);</div><div class="line">    System.out.println(&quot;\nLanguage length bigger three: &quot;);</div><div class="line">    filter(languages,x -&gt; x.length() &gt; 4);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，Stream API的过滤方法也接受一个Predicate，这意味着可以将我们定制的 filter() 方法替换成写在里面的内联代码，这就是lambda表达式的魔力。另外，Predicate接口也允许进行多重条件的测试，下个例子将要讲到。</p>
<h2 id="如何在lambda表达式中加入Predicate"><a href="#如何在lambda表达式中加入Predicate" class="headerlink" title="如何在lambda表达式中加入Predicate"></a>如何在lambda表达式中加入Predicate</h2><p>上个例子说到，java.util.function.Predicate 允许将两个或更多的 Predicate 合成一个。它提供类似于逻辑操作符AND和OR的方法，名字叫做and()、or()和xor()，用于将传入 filter() 方法的条件合并起来。例如，要得到所有以J开始，长度为四个字母的语言，可以定义两个独立的 Predicate 示例分别表示每一个条件，然后用 Predicate.and() 方法将它们合并起来，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 甚至可以用and()、or()和xor()逻辑函数来合并Predicate，</div><div class="line">// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入</div><div class="line">Predicate&lt;String&gt; startsWithJ = (n) -&gt; n.startsWith(&quot;J&quot;);</div><div class="line">Predicate&lt;String&gt; fourLetterLong = (n) -&gt; n.length() == 4;</div><div class="line">names.stream()</div><div class="line">    .filter(startsWithJ.and(fourLetterLong))</div><div class="line">    .forEach((n) -&gt; System.out.print(&quot;nName, which starts with &apos;J&apos; and four letter long is : &quot; + n));</div></pre></td></tr></table></figure></p>
<p>类似地，也可以使用 or() 和 xor() 方法。本例着重介绍了如下要点：可按需要将 Predicate 作为单独条件然后将其合并起来使用。简而言之，你可以以传统Java命令方式使用 Predicate 接口，也可以充分利用lambda表达式达到事半功倍的效果。</p>
<h2 id="对列表的每个元素应用函数"><a href="#对列表的每个元素应用函数" class="headerlink" title="对列表的每个元素应用函数"></a>对列表的每个元素应用函数</h2><p>我们通常需要对列表的每个元素使用某个函数，例如逐一乘以某个数、除以某个数或者做其它操作。这些操作都很适合用 map() 方法，可以将转换逻辑以lambda表达式的形式放在 map() 方法里，就可以对集合的各个元素进行转换了，如下所示。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 将字符串换成大写并用逗号链接起来</div><div class="line">List&lt;String&gt; G7 = Arrays.asList(&quot;USA&quot;, &quot;Japan&quot;, &quot;France&quot;, &quot;Germany&quot;, &quot;Italy&quot;, &quot;U.K.&quot;,&quot;Canada&quot;);</div><div class="line">String G7Countries = G7.stream().map(x -&gt; x.toUpperCase()).collect(Collectors.joining(&quot;, &quot;));</div><div class="line">System.out.println(G7Countries);</div></pre></td></tr></table></figure></p>
<h2 id="计算集合元素的最大值、最小值、总和以及平均值"><a href="#计算集合元素的最大值、最小值、总和以及平均值" class="headerlink" title="计算集合元素的最大值、最小值、总和以及平均值"></a>计算集合元素的最大值、最小值、总和以及平均值</h2><p>IntStream、LongStream 和 DoubleStream 等流的类中，有个非常有用的方法叫做 summaryStatistics() 。可以返回 IntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistic s，描述流中元素的各种摘要数据。在本例中，我们用这个方法来计算列表的最大值和最小值。它也有 getSum() 和 getAverage() 方法来获得列表的所有元素的总和及平均值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//获取数字的个数、最小值、最大值、总和以及平均值</div><div class="line">List&lt;Integer&gt; primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);</div><div class="line">IntSummaryStatistics stats = primes.stream().mapToInt((x) -&gt; x).summaryStatistics();</div><div class="line">System.out.println(&quot;Highest prime number in List : &quot; + stats.getMax());</div><div class="line">System.out.println(&quot;Lowest prime number in List : &quot; + stats.getMin());</div><div class="line">System.out.println(&quot;Sum of all prime numbers : &quot; + stats.getSum());</div><div class="line">System.out.println(&quot;Average of all prime numbers : &quot; + stats.getAverage());</div></pre></td></tr></table></figure></p>
<h2 id="Lambda表达式-vs-匿名类"><a href="#Lambda表达式-vs-匿名类" class="headerlink" title="Lambda表达式 vs 匿名类"></a>Lambda表达式 vs 匿名类</h2><p>既然lambda表达式即将正式取代Java代码中的匿名内部类，那么有必要对二者做一个比较分析。一个关键的不同点就是关键字 this。匿名类的 this 关键字指向匿名类，而lambda表达式的 this 关键字指向包围lambda表达式的类。另一个不同点是二者的编译方式。Java编译器将lambda表达式编译成类的私有方法。使用了Java 7的 invokedynamic 字节码指令来动态绑定这个方法。</p>
<h2 id="Java-8-Lambda表达式要点"><a href="#Java-8-Lambda表达式要点" class="headerlink" title="Java 8 Lambda表达式要点"></a>Java 8 Lambda表达式要点</h2><p>1）lambda表达式仅能放入如下代码：预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法，或者SAM（Single Abstract Method 单个抽象方法）类型。这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。例如，若一个方法接收Runnable、Comparable或者 Callable 接口，都有单个抽象方法，可以传入lambda表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 Predicate、Function、Consumer 或 Supplier，那么可以向其传lambda表达式。</p>
<p>2）lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。本例中的lambda表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">list.forEach(n -&gt; System.out.println(n)); </div><div class="line">list.forEach(System.out::println);  // 使用方法引用</div></pre></td></tr></table></figure></p>
<p>然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">list.forEach((String s) -&gt; System.out.println(&quot;*&quot; + s + &quot;*&quot;));</div></pre></td></tr></table></figure></p>
<p>事实上，可以省略这里的lambda参数的类型声明，编译器可以从列表的类属性推测出来。</p>
<p>3）lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。</p>
<p>4）Lambda表达式在Java中又称为闭包或匿名函数，所以如果有同事把它叫闭包的时候，不用惊讶。</p>
<p>5）Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用JDK中的 javap 工具来反编译class文件。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static java.lang.Object lambda$0(java.lang.String);</div></pre></td></tr></table></figure></p>
<p>6）lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">List&lt;Integer&gt; primes = Arrays.asList(new Integer[]&#123;2, 3,5,7&#125;);</div><div class="line">int factor = 2;</div><div class="line">primes.forEach(element -&gt; &#123; factor++; &#125;);</div></pre></td></tr></table></figure></p>
<p>Compile time error : “local variables referenced from a lambda expression must be final or effectively final”<br>另外，只是访问它而不作修改是可以的，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">List&lt;Integer&gt; primes = Arrays.asList(new Integer[]&#123;2, 3,5,7&#125;);</div><div class="line">int factor = 2;</div><div class="line">primes.forEach(element -&gt; &#123; System.out.println(factor*element); &#125;);</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">4</div><div class="line">6</div><div class="line">10</div><div class="line">14</div></pre></td></tr></table></figure></p>
<p>因此，它看起来更像不可变闭包，类似于Python。</p>
<p>以上就是Java 8的lambda表达式的全部10个例子。此次修改将成为Java史上最大的一次，将深远影响未来Java开发者使用集合框架的方式。我想规模最相似的一次修改就是Java 5的发布了，它带来了很多优点，提升了代码质量，例如：泛型、枚举、自动装箱（Autoboxing）、静态导入、并发API和变量参数。上述特性使得Java代码更加清晰，我想lambda表达式也将进一步改进它。我在期待着开发并行第三方库，这可以使高性能应用变得更容易写。</p>
<p>ref:<br><a href="http://www.importnew.com/16436.html" target="_blank" rel="external">Java8 lambda表达式10个示例</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java8</tag>
        <tag>Lambda</tag>
      </tags>
  </entry>
  <entry>
    <title>Editplus-Theme支持</title>
    <url>/2018/01/17/Editplus-theme/</url>
    <content><![CDATA[<p>Editplus 配色方案改为 Monokai</p>
<a id="more"></a>
<p>找到配置文件: editplus_u.ini 配置文件 , 做好备份, 然后将其内容替换为以下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">[Options]</div><div class="line">Placement=2C0000000200000003000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB9000000090100002B0600001F040000FF</div><div class="line">Window List=00000000000000000000000000000000FF</div><div class="line">Marker List=00000000000000000000000000000000FF</div><div class="line">Function List=00000000000000000000000000000000FF</div><div class="line">Open Remote=00000000000000000000000000000000FF</div><div class="line">Expand=00000000000000000000000000000000FF</div><div class="line">Project Pos=00000000000000000000000000000000FF</div><div class="line">Workspace Path=C:\Users\Administrator\Desktop</div><div class="line">Cliptext Window=375</div><div class="line">Cliptext Window 2=574</div><div class="line">Output=90</div><div class="line">Output 2=170</div><div class="line">Folding=1</div><div class="line">FindX=990</div><div class="line">FindY=587</div><div class="line">Find=align</div><div class="line">Tab Index=1</div><div class="line">Cliptext=2</div><div class="line">Custom colors=6D6D7200FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF0031282700FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FFFFFF00FF</div><div class="line">Matching Brace=1</div><div class="line">Indent guide=1</div><div class="line">Cliptext Edit=00000000000000000000000000000000FF</div><div class="line">[Files]</div><div class="line">Encoding=65001</div><div class="line">Backup=0</div><div class="line">Backup Remote=0</div><div class="line">[Fonts]</div><div class="line">Edit Window=F0FFFFFF00000000000000000000000090010000000000000302013143006F007500720069006500720020004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF</div><div class="line">Printer=F4FFFFFF00000000000000000000000090010000000000000000003143006F007500720069006500720020004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF</div><div class="line">Output Window=F4FFFFFF00000000000000000000000090010000000000000000003143006F007500720069006500720020004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF</div><div class="line">Cliptext Window=F4FFFFFF0000000000000000000000009001000000000001000000004D006900630072006F0073006F006600740020005900610048006500690020005500490000000000000000000000000000000000000000000000000000000000FF</div><div class="line">Document Selector=F4FFFFFF0000000000000000000000009001000000000001000000004D006900630072006F0073006F006600740020005900610048006500690020005500490000000000000000000000000000000000000000000000000000000000FF</div><div class="line">Hex Viewer=F4FFFFFF00000000000000000000000090010000000000010000003143006F007500720069006500720020004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF</div><div class="line">Custom 1=F4FFFFFF00000000000000000000000090010000000000000000002241007200690061006C000000720020004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF</div><div class="line">Custom 2=F5FFFFFF000000000000000000000000900100000000000000000022560065007200640061006E00610000004E0065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF</div><div class="line">Custom 3=F4FFFFFF000000000000000000000000900100000000000000000012540069006D006500730020004E0065007700200052006F006D0061006E0000000000000000000000000000000000000000000000000000000000000000000000FF</div><div class="line">Custom 4=F5FFFFFF0000000000000000000000009001000000000000000000224D0053002000530061006E0073002000530065007200690066000000000000000000000000000000000000000000000000000000000000000000000000000000FF</div><div class="line">Custom 5=F3FFFFFF00000000000000000000000090010000000000FF000000315400650072006D0069006E0061006C00000065007700000000000000000000000000000000000000000000000000000000000000000000000000000000000000FF</div><div class="line">[Tool Option]</div><div class="line">Top Selector=1</div><div class="line">[Colors\Text]</div><div class="line">Background=2238503</div><div class="line">Default=0</div><div class="line">Foreground=16777215</div><div class="line">[Colors\Keyword 1]</div><div class="line">Foreground=8272368</div><div class="line">Default=0</div><div class="line">[Colors\Embedded script]</div><div class="line">Foreground=16777215</div><div class="line">Default=0</div><div class="line">[Colors\Keyword 3]</div><div class="line">Foreground=16777215</div><div class="line">Default=0</div><div class="line">[Colors\Keyword 6]</div><div class="line">Foreground=8716287</div><div class="line">Default=0</div><div class="line">[Colors\Keyword 7]</div><div class="line">Foreground=8716287</div><div class="line">Default=0</div><div class="line">[Colors\Keyword 8]</div><div class="line">Foreground=8716287</div><div class="line">Default=0</div><div class="line">[Colors\Keyword 9]</div><div class="line">Foreground=8454143</div><div class="line">Default=0</div><div class="line">[Colors\Keyword 10]</div><div class="line">Foreground=8716287</div><div class="line">Default=0</div><div class="line">[Colors\Quotation]</div><div class="line">Foreground=8454143</div><div class="line">Default=0</div><div class="line">[Colors\Quotation 2]</div><div class="line">Foreground=5107956</div><div class="line">Default=0</div><div class="line">[Colors\Line comment]</div><div class="line">Foreground=10789024</div><div class="line">Default=0</div><div class="line">[Colors\Line number]</div><div class="line">Foreground=12632256</div><div class="line">Background=2238503</div><div class="line">Default=0</div><div class="line">[Colors\Folding mark -]</div><div class="line">Background=2238503</div><div class="line">Default=0</div><div class="line">[Colors\Matching words]</div><div class="line">Default=0</div><div class="line">Background=718314</div><div class="line">[Colors\Keyword 2]</div><div class="line">Foreground=16379142</div><div class="line">Default=0</div><div class="line">[Colors\Folding mark +]</div><div class="line">Background=2238503</div><div class="line">Default=0</div><div class="line">[Colors\Text selection]</div><div class="line">Background=7039851</div><div class="line">Default=0</div><div class="line">[Colors\Number]</div><div class="line">Foreground=16524240</div><div class="line">Default=0</div><div class="line">[Colors\Block comment]</div><div class="line">Foreground=8421504</div><div class="line">Default=0</div><div class="line">[Colors\Keyword 5]</div><div class="line">Foreground=15574913</div><div class="line">Default=0</div><div class="line">[Colors\Ruler]</div><div class="line">Foreground=12632256</div><div class="line">Default=0</div><div class="line">Background=2566187</div><div class="line">[Colors\Cursor indicator]</div><div class="line">Background=16777215</div><div class="line">Default=0</div><div class="line">[Colors\Indent Guide]</div><div class="line">Foreground=7499117</div><div class="line">Default=0</div></pre></td></tr></table></figure></p>
<p>效果如下:</p>
<img src="/2018/01/17/Editplus-theme/20150804154814057" alt="20150804154814057" title="">
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IDE</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Pattern&amp;Matcher</title>
    <url>/2018/01/11/Java-Pattern-Matcher/</url>
    <content><![CDATA[<p>Pattern与Matcher一起合作.Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持. 单独用Pattern只能使用Pattern.matcher(String regex,CharSequence input)一种最基础最简单的匹配。</p>
<a id="more"></a>
<p>java正则表达式通过java.util.regex包下的Pattern类与Matcher类实现(建议在阅读本文时,打开java API文档,当介绍到哪个方法时,查看java API中的方法说明,效果会更佳). </p>
<p>Pattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式,<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(<span class="string">"\\w+"</span>); </div><div class="line">p.pattern();<span class="comment">//返回 \w+</span></div></pre></td></tr></table></figure></p>
<p>pattern() 返回正则表达式的字符串形式,其实就是返回Pattern.complile(String regex)的regex参数 </p>
<h3 id="Pattern-split-CharSequence-input"><a href="#Pattern-split-CharSequence-input" class="headerlink" title="Pattern.split(CharSequence input)"></a>Pattern.split(CharSequence input)</h3><p>Pattern有一个split(CharSequence input)方法,用于分隔字符串,并返回一个String[],我猜String.split(String regex)就是通过Pattern.split(CharSequence input)来实现的.<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </div><div class="line">String[] str=p.split(<span class="string">"我的QQ是:456456我的电话是:0532214我的邮箱是:aaa@aaa.com"</span>); </div><div class="line"><span class="comment">//结果:str[0]="我的QQ是:" str[1]="我的电话是:" str[2]="我的邮箱是:aaa@aaa.com"</span></div></pre></td></tr></table></figure></p>
<h3 id="Pattern-matcher-String-regex-CharSequence-input-是一个静态方法-用于快速匹配字符串-该方法适合用于只匹配一次-且匹配全部字符串"><a href="#Pattern-matcher-String-regex-CharSequence-input-是一个静态方法-用于快速匹配字符串-该方法适合用于只匹配一次-且匹配全部字符串" class="headerlink" title="Pattern.matcher(String regex,CharSequence input)是一个静态方法,用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串."></a>Pattern.matcher(String regex,CharSequence input)是一个静态方法,用于快速匹配字符串,该方法适合用于只匹配一次,且匹配全部字符串.</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"2223"</span>);<span class="comment">//返回true </span></div><div class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"2223aa"</span>);<span class="comment">//返回false,需要匹配到所有字符串才能返回true,这里aa不能匹配到 </span></div><div class="line">Pattern.matches(<span class="string">"\\d+"</span>,<span class="string">"22bb23"</span>);<span class="comment">//返回false,需要匹配到所有字符串才能返回true,这里bb不能匹配到</span></div></pre></td></tr></table></figure>
<h3 id="Pattern-matcher-CharSequence-input"><a href="#Pattern-matcher-CharSequence-input" class="headerlink" title="Pattern.matcher(CharSequence input)"></a>Pattern.matcher(CharSequence input)</h3><p>说了这么多,终于轮到Matcher类登场了,Pattern.matcher(CharSequence input)返回一个Matcher对象.<br>Matcher类的构造方法也是私有的,不能随意创建,只能通过Pattern.matcher(CharSequence input)方法得到该类的实例.<br>Pattern类只能做一些简单的匹配操作,要想得到更强更便捷的正则匹配操作,那就需要将Pattern与Matcher一起合作.Matcher类提供了对正则表达式的分组支持,以及对正则表达式的多次匹配支持.<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </div><div class="line">Matcher m=p.matcher(<span class="string">"22bb23"</span>); </div><div class="line">m.pattern();<span class="comment">//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的</span></div></pre></td></tr></table></figure></p>
<h3 id="Matcher-matches-Matcher-lookingAt-Matcher-find"><a href="#Matcher-matches-Matcher-lookingAt-Matcher-find" class="headerlink" title="Matcher.matches()/ Matcher.lookingAt()/ Matcher.find()"></a>Matcher.matches()/ Matcher.lookingAt()/ Matcher.find()</h3><p>Matcher类提供三个匹配操作方法,三个方法均返回boolean类型,当匹配到时返回true,没匹配到则返回false </p>
<h4 id="matches-对整个字符串进行匹配-只有整个字符串都匹配了才返回true"><a href="#matches-对整个字符串进行匹配-只有整个字符串都匹配了才返回true" class="headerlink" title="matches()对整个字符串进行匹配,只有整个字符串都匹配了才返回true"></a>matches()对整个字符串进行匹配,只有整个字符串都匹配了才返回true</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </div><div class="line">Matcher m=p.matcher(<span class="string">"22bb23"</span>); </div><div class="line">m.matches();<span class="comment">//返回false,因为bb不能被\d+匹配,导致整个字符串匹配未成功. </span></div><div class="line">Matcher m2=p.matcher(<span class="string">"2223"</span>); </div><div class="line">m2.matches();<span class="comment">//返回true,因为\d+匹配到了整个字符串</span></div></pre></td></tr></table></figure>
<p>我们现在回头看一下Pattern.matcher(String regex,CharSequence input),它与下面这段代码等价<br>Pattern.compile(regex).matcher(input).matches() </p>
<h4 id="lookingAt-对前面的字符串进行匹配-只有匹配到的字符串在最前面才返回true"><a href="#lookingAt-对前面的字符串进行匹配-只有匹配到的字符串在最前面才返回true" class="headerlink" title="lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true"></a>lookingAt()对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </div><div class="line">Matcher m=p.matcher(<span class="string">"22bb23"</span>); </div><div class="line">m.lookingAt();<span class="comment">//返回true,因为\d+匹配到了前面的22 </span></div><div class="line">Matcher m2=p.matcher(<span class="string">"aa2223"</span>); </div><div class="line">m2.lookingAt();<span class="comment">//返回false,因为\d+不能匹配前面的aa</span></div></pre></td></tr></table></figure>
<h4 id="find-对字符串进行匹配-匹配到的字符串可以在任何位置"><a href="#find-对字符串进行匹配-匹配到的字符串可以在任何位置" class="headerlink" title="find()对字符串进行匹配,匹配到的字符串可以在任何位置."></a>find()对字符串进行匹配,匹配到的字符串可以在任何位置.</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </div><div class="line">Matcher m=p.matcher(<span class="string">"22bb23"</span>); </div><div class="line">m.find();<span class="comment">//返回true </span></div><div class="line">Matcher m2=p.matcher(<span class="string">"aa2223"</span>); </div><div class="line">m2.find();<span class="comment">//返回true </span></div><div class="line">Matcher m3=p.matcher(<span class="string">"aa2223bb"</span>); </div><div class="line">m3.find();<span class="comment">//返回true </span></div><div class="line">Matcher m4=p.matcher(<span class="string">"aabb"</span>); </div><div class="line">m4.find();<span class="comment">//返回false</span></div></pre></td></tr></table></figure>
<h3 id="Mathcer-start-Matcher-end-Matcher-group"><a href="#Mathcer-start-Matcher-end-Matcher-group" class="headerlink" title="Mathcer.start()/ Matcher.end()/ Matcher.group()"></a>Mathcer.start()/ Matcher.end()/ Matcher.group()</h3><p>当使用matches(),lookingAt(),find()执行匹配操作后,就可以利用以上三个方法得到更详细的信息.<br>start()返回匹配到的子字符串在字符串中的索引位置.<br>end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置.<br>group()返回匹配到的子字符串<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </div><div class="line">Matcher m=p.matcher(<span class="string">"aaa2223bb"</span>); </div><div class="line">m.find();<span class="comment">//匹配2223 </span></div><div class="line">m.start();<span class="comment">//返回3 </span></div><div class="line">m.end();<span class="comment">//返回7,返回的是2223后的索引号 </span></div><div class="line">m.group();<span class="comment">//返回2223 </span></div><div class="line"></div><div class="line">Mathcer m2=p.matcher(<span class="string">"2223bb"</span>); </div><div class="line">m2.lookingAt();   <span class="comment">//匹配2223 </span></div><div class="line">m2.start();   <span class="comment">//返回0,由于lookingAt()只能匹配前面的字符串,所以当使用lookingAt()匹配时,start()方法总是返回0 </span></div><div class="line">m2.end();   <span class="comment">//返回4 </span></div><div class="line">m2.group();   <span class="comment">//返回2223 </span></div><div class="line"></div><div class="line">Matcher m3=p.matcher(<span class="string">"2223"</span>); <span class="comment">//如果Matcher m3=p.matcher("2223bb"); 那么下面的方法出错，因为不匹配返回false</span></div><div class="line">m3.matches();   <span class="comment">//匹配整个字符串 </span></div><div class="line">m3.start();   <span class="comment">//返回0</span></div><div class="line">m3.end();   <span class="comment">//返回3,原因相信大家也清楚了,因为matches()需要匹配所有字符串 </span></div><div class="line">m3.group();   <span class="comment">//返回2223</span></div></pre></td></tr></table></figure></p>
<p>说了这么多,相信大家都明白了以上几个方法的使用,该说说正则表达式的分组在java中是怎么使用的.<br>start(),end(),group()均有一个重载方法它们是start(int i),end(int i),group(int i)专用于分组操作,Mathcer类还有一个groupCount()用于返回有多少组.<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(<span class="string">"([a-z]+)(\\d+)"</span>); </div><div class="line">Matcher m=p.matcher(<span class="string">"aaa2223bb"</span>); </div><div class="line">m.find();   <span class="comment">//匹配aaa2223 </span></div><div class="line">m.groupCount();   <span class="comment">//返回2,因为有2组 </span></div><div class="line">m.start(<span class="number">1</span>);   <span class="comment">//返回0 返回第一组匹配到的子字符串在字符串中的索引号 </span></div><div class="line">m.start(<span class="number">2</span>);   <span class="comment">//返回3 </span></div><div class="line">m.end(<span class="number">1</span>);   <span class="comment">//返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置. </span></div><div class="line">m.end(<span class="number">2</span>);   <span class="comment">//返回7 </span></div><div class="line">m.group(<span class="number">1</span>);   <span class="comment">//返回aaa,返回第一组匹配到的子字符串 </span></div><div class="line">m.group(<span class="number">2</span>);   <span class="comment">//返回2223,返回第二组匹配到的子字符串</span></div></pre></td></tr></table></figure></p>
<p>现在我们使用一下稍微高级点的正则匹配操作,例如有一段文本,里面有很多数字,而且这些数字是分开的,我们现在要将文本中所有数字都取出来,利用java的正则操作是那么的简单.<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(<span class="string">"\\d+"</span>); </div><div class="line">Matcher m=p.matcher(<span class="string">"我的QQ是:456456 我的电话是:0532214 我的邮箱是:aaa123@aaa.com"</span>); </div><div class="line"><span class="keyword">while</span>(m.find()) &#123; </div><div class="line">     System.out.println(m.group()); </div><div class="line">&#125; </div><div class="line"><span class="comment">/*</span></div><div class="line">输出: </div><div class="line">456456 </div><div class="line">0532214 </div><div class="line">123 </div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>如将以上while()循环替换成<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span>(m.find()) &#123; </div><div class="line">     System.out.println(m.group()); </div><div class="line">     System.out.print(<span class="string">"start:"</span>+m.start()); </div><div class="line">     System.out.println(<span class="string">" end:"</span>+m.end()); </div><div class="line">&#125; </div><div class="line"><span class="comment">/*</span></div><div class="line">则输出: </div><div class="line">456456 </div><div class="line">start:6 end:12 </div><div class="line">0532214 </div><div class="line">start:19 end:26 </div><div class="line">123 </div><div class="line">start:36 end:39 </div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>现在大家应该知道,每次执行匹配操作后start(),end(),group()三个方法的值都会改变,改变成匹配到的子字符串的信息,以及它们的重载方法,也会改变成相应的信息.<br>注意:只有当匹配操作成功,才可以使用start(),end(),group()三个方法,否则会抛出java.lang.IllegalStateException,也就是当matches(),lookingAt(),find()其中任意一个方法返回true时,才可以使用.</p>
<p>ref:<br><a href="http://blog.csdn.net/cclovett/article/details/12448843/" target="_blank" rel="external">http://blog.csdn.net/cclovett/article/details/12448843/</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>regularExpression</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux_通过源码编译安装程序</title>
    <url>/2018/01/10/Linux_%E9%80%9A%E8%BF%87%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>本文简单的记录了下，在linux下如何通过源码安装程序，以及相关的知识。</p>
<a id="more"></a>
<h2 id="程序的组成部分"><a href="#程序的组成部分" class="headerlink" title="程序的组成部分"></a>程序的组成部分</h2><p>Linux下程序大都是由以下几部分组成:</p>
<ul>
<li>二进制文件:也就是可以运行的程序文件</li>
<li>库文件:就是通常我们见到的lib目录下的文件</li>
<li>配置文件:这个不必多说，都知道</li>
<li>帮助文档:通常是我们在linux下用man命令查看的命令的文档</li>
</ul>
<h2 id="linux下程序的存放目录"><a href="#linux下程序的存放目录" class="headerlink" title="linux下程序的存放目录"></a>linux下程序的存放目录</h2><p>linux程序的存放目录大致有三个地方:</p>
<ul>
<li>/etc, /bin, /sbin, /lib  :系统启动就需要用到的程序，这些目录不能挂载额外的分区，必须在根文件系统的分区上</li>
<li>/usr/bin,/usr/sbin,/usr/lib:操作系统核心功能，可以单独分区</li>
<li>/usr/local/bin,/usr/local/sbin,/usr/local/lib,/usr/local/etc,/usr/local/man:这个用于安装第三方程序，分别对应了二进制文件、库文件、配置文件、帮助文档的目录</li>
</ul>
<p>通常来说我们安装程序就安装在 /usr/local目录下</p>
<h2 id="编译安装源程序"><a href="#编译安装源程序" class="headerlink" title="编译安装源程序"></a>编译安装源程序</h2><p>步骤:</p>
<ol>
<li><p>使用如下命令查看当前是否安装了gcc编译器，没有可以先用yum安装gcc</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gcc --version  #查看是否安装gcc</div></pre></td></tr></table></figure>
</li>
<li><p>解压源码包，例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tar -xvf nginx-1.7.7.tar.gz #解压源码包</div></pre></td></tr></table></figure>
</li>
<li><p>进入解压好的源码包:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cd nginx-1.7.7 #进入源码包</div></pre></td></tr></table></figure>
</li>
<li><p>执行configure文件，此文件有两个功能:1、让用户选定编译特性；2、检查编译环境。configure执行后将生成MakeFile文件。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">./configure --prefix=/usr/local/nginx --conf-path=/etc/nginx/nginx.conf</div></pre></td></tr></table></figure>
<p> 其中我们通过–prefix制定了安装路径，通过–conf-path制定了配置文件的具体位置。注意:不是所有的程序的configure参数都是一样的 可以使用 ./configure –help查看详细参数说明。如果该程序所依赖的库在当前系统中没有安装，则会导致configure最后报错，遇到这种情况就需要你先安装依赖库。</p>
</li>
<li><p>执行make命令，编译程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">make</div></pre></td></tr></table></figure>
</li>
<li><p>编译成功后就可以安装了，执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">make install</div></pre></td></tr></table></figure>
</li>
</ol>
<p>到此程序就算安装完成了，但是不要忘了还有后续的配置哦</p>
<h2 id="配置程序"><a href="#配置程序" class="headerlink" title="配置程序"></a>配置程序</h2><p>步骤:</p>
<ol>
<li>修改PATH环境变量，以能够识别此程序的二进制文件路径；<br>修改/etc/profile文件，在文件中 添加<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">export PATH=$PATH:/path/to/somewhere　　#记得是可执行文件所在的目录，路径中不要包含可执行文件。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">source /etc/profile #是我们的修改生效</div></pre></td></tr></table></figure></p>
<ol>
<li><p>默认情况下，系统搜索库文件的路径/lib, /usr/lib; 要增添额外搜寻路径(注意:有的程序不提供库文件，那就不需要此设置了)<br>在/etc/ld.so.conf.d/中创建以.conf为后缀名的文件，而后把要增添的路径直接写至此文件中；然后执行如下命令使其生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ldconfig</div></pre></td></tr></table></figure>
</li>
<li><p>如果程序提供了库文件，也会相应的提供头文件，一般在安装目录的include目录下，系统默认扫描头文件的路径是:/usr/include。我们可以在/usr/include下用链接连接到我们安装程序的头文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ln -s /usr/local/nginx/include  /usr/include/yourname</div></pre></td></tr></table></figure>
</li>
<li><p>可能程序还提供了帮助文档，一般是安装目录下的man目录，为了我们可以使用man命令查看我们程序的帮助文档，我们需要:在/etc/man.config中添加一条MANPATH，指向我们的文档目录</p>
</li>
</ol>
<h2 id="删除软件"><a href="#删除软件" class="headerlink" title="删除软件"></a>删除软件</h2><p>方法一、如果你知道要删除软件的具体名称，可以使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo apt-get remove --purge 软件名称  </div><div class="line">sudo apt-get autoremove --purge 软件名称</div></pre></td></tr></table></figure></p>
<p>方法二、如果不知道要删除软件的具体名称，可以使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dpkg --get-selections | grep ‘软件相关名称’</div><div class="line">sudo apt-get purge 一个带core的package，如果没有带core的package，则是情况而定。</div></pre></td></tr></table></figure></p>
<p>清理残留数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dpkg -l |grep ^rc|awk &apos;&#123;print $2&#125;&apos; |sudo xargs dpkg -P</div></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-Linux-自启动</title>
    <url>/2018/01/02/Mysql-Linux-%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>这篇文章主要介绍了MySQL的自启动相关</p>
<a id="more"></a>
<p>##自启动</p>
<ol>
<li><p>欲使mysql开机自启动，首先需要注册mysql为ubuntu下的服务。<br>直接拷贝mysql.server文件至/etc/init.d/目录下即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo cp $MYSQL_HOME/support-files/mysql.server /etc/init.d/mysql.server</div><div class="line">sudo chmod +x /etc/init.d/mysql.server</div></pre></td></tr></table></figure>
</li>
<li><p>修改my.cnf，指定mysql的启动用户<br>定义：命令1=”./mysql.server start –user=user1“，命令2=”./mysql.server start”。（注意，命令1、2的区别在于红色部分）</p>
</li>
</ol>
<p>在编译安装mysql的过程中，若执行configure命令时指定“–user=user1”参数，则mysql将由用户user1启动，在mysql.server文件中会有“user=user1”这样一行来指定mysql的启动用户，但该行指定的启动用户并未生效。即，需要使用命令1来启动mysql，命令2启动失败。</p>
<p>为了使命令2生效，同时为了mysql开机自启动，需要修改my.cnf，在[mysqld]区块下添加“user=user1”这样一行。如此，便可使用命令2启动mysql，mysql也可以成功开机自启动。</p>
<ol>
<li>设置mysql开机自启动</li>
</ol>
<p>让mysql开机自己启动<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo update-rc.d -f mysql.server defaults  </div><div class="line">root@leroy-linux:/etc/init.d# update-rc.d -f mysql.server defaults</div><div class="line">　　Adding system startup for /etc/init.d/mysql ...</div><div class="line">　　/etc/rc0.d/K20mysql.server -&gt; ../init.d/mysql.server</div><div class="line">　　/etc/rc1.d/K20mysql.server -&gt; ../init.d/mysql.server</div><div class="line">　　/etc/rc6.d/K20mysql.server -&gt; ../init.d/mysql.server</div><div class="line">　　/etc/rc2.d/S20mysql.server -&gt; ../init.d/mysql.server</div><div class="line">　　/etc/rc3.d/S20mysql.server -&gt; ../init.d/mysql.server</div><div class="line">　　/etc/rc4.d/S20mysql.server -&gt; ../init.d/mysql.server</div><div class="line">　　/etc/rc5.d/S20mysql.server -&gt; ../init.d/mysql.server</div></pre></td></tr></table></figure></p>
<p>如果不想让mysql开机自己启动，可以使用<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo update-rc.d -f mysql.server remove  </div><div class="line">root@sean-linux:/etc/init.d# update-rc.d -f mysql remove</div><div class="line">　　Removing any system startup links for /etc/init.d/mysql ...</div><div class="line">　　/etc/rc0.d/K21mysql.server</div><div class="line">　　/etc/rc1.d/K21mysql.server</div><div class="line">　　/etc/rc2.d/S19mysql.server</div><div class="line">　　/etc/rc3.d/S19mysql.server</div><div class="line">　　/etc/rc4.d/S19mysql.server</div><div class="line">　　/etc/rc5.d/S19mysql.server</div><div class="line">　　/etc/rc6.d/K21mysql.server</div></pre></td></tr></table></figure></p>
<ol>
<li>服务的使用<br>启动mysql：service mysql.server start；<br>停止mysql：service mysql.server  stop；<br>查看mysql运行状态：service mysql.server  status。</li>
</ol>
<p>另外，要确保mysql启动用户user1对$MYSQL_HOME具有读写权限，否则会因权限问题导致mysql启动失败。<br>（若无法启动 可考虑加上sudo）</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>Ubuntu 取消 Apache及MySQL等自启动</p>
<ol>
<li>装个 sysv-conf-rc</li>
<li>sudo update-rc.d -f mysql remove 删除mysql随机器启动的服务<br>sudo update-rc.d -f apache2 remove 删除apache2随机器启动的服务</li>
<li>查看/etc/rc2.d/里面的apache和mysql启动脚本，通常都是两个阿拉伯数字后再接一个英文字母，再加脚本名称。英文字母是S的都是会自动启动的，K则相反。所以只要找到apache和mysql的启动脚本，把S改成K就可以了</li>
</ol>
<p>ref:<br><a href="http://blog.csdn.net/hackerwin7/article/details/22686819" target="_blank" rel="external">http://blog.csdn.net/hackerwin7/article/details/22686819a</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite-创建库表</title>
    <url>/2018/01/01/SQLite-%E5%88%9B%E5%BB%BA%E5%BA%93%E8%A1%A8/</url>
    <content><![CDATA[<p>SQLite 创建库表</p>
<a id="more"></a>
<h2 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h2><p>SQLite 的 sqlite3 命令被用来创建新的 SQLite 数据库。您不需要任何特殊的权限即可创建一个数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">E:\py_wkspc\pswstoreapi&gt;sqlite3 pswstore.db</div><div class="line">SQLite version 3.24.0 2018-06-04 19:24:41</div><div class="line">Enter &quot;.help&quot; for usage hints.</div><div class="line">sqlite&gt;</div><div class="line">sqlite&gt;</div><div class="line">sqlite&gt; .databases</div><div class="line">main: E:\py_wkspc\pswstoreapi\pswstore.db</div><div class="line">sqlite&gt;</div></pre></td></tr></table></figure>
<p>创建库的位置, 即为命令执行的目录</p>
<h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>ref:<br><a href="http://www.runoob.com/sqlite/sqlite-create-database.html" target="_blank" rel="external">http://www.runoob.com/sqlite/sqlite-create-database.html</a><br><a href="https://www.yiibai.com/sqlite/create-table.html" target="_blank" rel="external">https://www.yiibai.com/sqlite/create-table.html</a></p>
]]></content>
      <categories>
        <category>SQLite</category>
      </categories>
      <tags>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite</title>
    <url>/2018/01/01/SQLite-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>SQLite 的一个重要的特性是零配置的，这意味着不需要复杂的安装或管理。本章将讲解 Windows、Linux 上的安装设置。</p>
<a id="more"></a>
<h2 id="在-Windows-上安装-SQLite"><a href="#在-Windows-上安装-SQLite" class="headerlink" title="在 Windows 上安装 SQLite"></a>在 Windows 上安装 SQLite</h2><ul>
<li>请访问 <a href="http://www.sqlite.org/download.html" target="_blank" rel="external">SQLite 下载页面</a>，从 Windows 区下载预编译的二进制文件。</li>
<li>您需要下载 <code>sqlite-tools-win32-*.zip</code> 和 <code>sqlite-dll-win32-*.zip</code> 压缩文件。</li>
<li>创建文件夹 C:\sqlite，并在此文件夹下解压上面两个压缩文件，将得到 sqlite3.def、sqlite3.dll 和 sqlite3.exe 文件。</li>
<li>添加 C:\sqlite 到 PATH 环境变量，最后在命令提示符下，使用 sqlite3 命令，将显示如下结果。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">C:\&gt;sqlite3</div><div class="line">SQLite version 3.7.15.2 2013-01-09 11:53:05</div><div class="line">Enter &quot;.help&quot; for instructions</div><div class="line">Enter SQL statements terminated with a &quot;;&quot;</div><div class="line">sqlite&gt;</div></pre></td></tr></table></figure>
<h2 id="在-Linux-上安装-SQLite"><a href="#在-Linux-上安装-SQLite" class="headerlink" title="在 Linux 上安装 SQLite"></a>在 Linux 上安装 SQLite</h2><p>目前，几乎所有版本的 Linux 操作系统都附带 SQLite。所以，只要使用下面的命令来检查您的机器上是否已经安装了 SQLite。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$sqlite3</div><div class="line">SQLite version 3.7.15.2 2013-01-09 11:53:05</div><div class="line">Enter &quot;.help&quot; for instructions</div><div class="line">Enter SQL statements terminated with a &quot;;&quot;</div><div class="line">sqlite&gt;</div></pre></td></tr></table></figure></p>
<p>如果没有看到上面的结果，那么就意味着没有在 Linux 机器上安装 SQLite。因此，让我们按照下面的步骤安装 SQLite：</p>
<p>请访问 SQLite 下载页面，从源代码区下载 <code>sqlite-autoconf-*.tar.gz</code>。</p>
<p>步骤如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$tar xvfz sqlite-autoconf-3071502.tar.gz</div><div class="line">$cd sqlite-autoconf-3071502</div><div class="line">$./configure --prefix=/usr/local</div><div class="line">$make</div><div class="line">$make install</div></pre></td></tr></table></figure></p>
<p>上述步骤将在 Linux 机器上安装 SQLite，您可以按照上述讲解的进行验证。</p>
<p>ref:<br><a href="http://www.runoob.com/sqlite/sqlite-installation.html" target="_blank" rel="external">http://www.runoob.com/sqlite/sqlite-installation.html</a></p>
]]></content>
      <categories>
        <category>SQLite</category>
      </categories>
      <tags>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite-数据类型</title>
    <url>/2018/01/01/SQLite-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>SQLite 数据类型是一个用来指定任何对象的数据类型的属性。SQLite 中的每一列，每个变量和表达式都有相关的数据类型。</p>
<p>您可以在创建表的同时使用这些数据类型。SQLite 使用一个更普遍的动态类型系统。在 SQLite 中，值的数据类型与值本身是相关的，而不是与它的容器相关。</p>
<a id="more"></a>
<h2 id="SQLite-存储类"><a href="#SQLite-存储类" class="headerlink" title="SQLite 存储类"></a>SQLite 存储类</h2><p>每个存储在 SQLite 数据库中的值都具有以下存储类之一：</p>
<table>
<thead>
<tr>
<th style="text-align:left">存储类</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">NULL</td>
<td style="text-align:left">值是一个 NULL 值。</td>
</tr>
<tr>
<td style="text-align:left">INTEGER</td>
<td style="text-align:left">值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。</td>
</tr>
<tr>
<td style="text-align:left">REAL</td>
<td style="text-align:left">值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。</td>
</tr>
<tr>
<td style="text-align:left">TEXT</td>
<td style="text-align:left">值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。</td>
</tr>
<tr>
<td style="text-align:left">BLOB</td>
<td style="text-align:left">值是一个 blob 数据，完全根据它的输入存储。</td>
</tr>
</tbody>
</table>
<p>SQLite 的存储类稍微比数据类型更普遍。INTEGER 存储类，例如，包含 6 种不同的不同长度的整数数据类型。</p>
<h2 id="SQLite-亲和-Affinity-类型"><a href="#SQLite-亲和-Affinity-类型" class="headerlink" title="SQLite 亲和(Affinity)类型"></a>SQLite 亲和(Affinity)类型</h2><p>SQLite支持列的亲和类型概念。任何列仍然可以存储任何类型的数据，当数据插入时，该字段的数据将会优先采用亲缘类型作为该值的存储方式。SQLite目前的版本支持以下五种亲缘类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">亲和类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TEXT</td>
<td style="text-align:left">数值型数据在被插入之前，需要先被转换为文本格式，之后再插入到目标字段中。</td>
</tr>
<tr>
<td style="text-align:left">NUMERIC</td>
<td style="text-align:left">当文本数据被插入到亲缘性为NUMERIC的字段中时，如果转换操作不会导致数据信息丢失以及完全可逆，那么SQLite就会将该文本数据转换为INTEGER或REAL类型的数据，如果转换失败，SQLite仍会以TEXT方式存储该数据。对于NULL或BLOB类型的新数据，SQLite将不做任何转换，直接以NULL或BLOB的方式存储该数据。需要额外说明的是，对于浮点格式的常量文本，如”30000.0”，如果该值可以转换为INTEGER同时又不会丢失数值信息，那么SQLite就会将其转换为INTEGER的存储方式。</td>
</tr>
<tr>
<td style="text-align:left">INTEGER</td>
<td style="text-align:left">对于亲缘类型为INTEGER的字段，其规则等同于NUMERIC，唯一差别是在执行CAST表达式时。</td>
</tr>
<tr>
<td style="text-align:left">REAL</td>
<td style="text-align:left">其规则基本等同于NUMERIC，唯一的差别是不会将”30000.0”这样的文本数据转换为INTEGER存储方式。</td>
</tr>
<tr>
<td style="text-align:left">NONE</td>
<td style="text-align:left">不做任何的转换，直接以该数据所属的数据类型进行存储。　</td>
</tr>
</tbody>
</table>
<h2 id="SQLite-亲和类型-Affinity-及类型名称"><a href="#SQLite-亲和类型-Affinity-及类型名称" class="headerlink" title="SQLite 亲和类型(Affinity)及类型名称"></a>SQLite 亲和类型(Affinity)及类型名称</h2><p>下表列出了当创建 SQLite3 表时可使用的各种数据类型名称，同时也显示了相应的亲和类型：</p>
<p><img src="001.png" alt="001.png"></p>
<h2 id="Boolean-数据类型"><a href="#Boolean-数据类型" class="headerlink" title="Boolean 数据类型"></a>Boolean 数据类型</h2><p>SQLite 没有单独的 Boolean 存储类。相反，布尔值被存储为整数 0（false）和 1（true）。</p>
<h2 id="Date-与-Time-数据类型"><a href="#Date-与-Time-数据类型" class="headerlink" title="Date 与 Time 数据类型"></a>Date 与 Time 数据类型</h2><p>SQLite 没有一个单独的用于存储日期和/或时间的存储类，但 SQLite 能够把日期和时间存储为 TEXT、REAL 或 INTEGER 值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">存储类</th>
<th style="text-align:left">日期格式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TEXT</td>
<td style="text-align:left">格式为 “YYYY-MM-DD HH:MM:SS.SSS” 的日期。</td>
</tr>
<tr>
<td style="text-align:left">REAL</td>
<td style="text-align:left">从公元前 4714 年 11 月 24 日格林尼治时间的正午开始算起的天数。</td>
</tr>
<tr>
<td style="text-align:left">INTEGER</td>
<td style="text-align:left">从 1970-01-01 00:00:00 UTC 算起的秒数。</td>
</tr>
</tbody>
</table>
<p>您可以以任何上述格式来存储日期和时间，并且可以使用内置的日期和时间函数来自由转换不同格式。</p>
<p>ref:<br><a href="http://www.runoob.com/sqlite/sqlite-data-types.html" target="_blank" rel="external">http://www.runoob.com/sqlite/sqlite-data-types.html</a></p>
]]></content>
      <categories>
        <category>SQLite</category>
      </categories>
      <tags>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>Git-管理多个ssh密钥</title>
    <url>/2017/12/24/Git-%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAssh%E5%AF%86%E9%92%A5/</url>
    <content><![CDATA[<p>对于Git多帐号的情况,它可以动态管理SSH-KEY。</p>
<a id="more"></a>
<h2 id="SSH之于Git的原理"><a href="#SSH之于Git的原理" class="headerlink" title="SSH之于Git的原理"></a>SSH之于Git的原理</h2><p>Git提交时有Https和SSH两种验证方式,Https的方式需要帐号和密码比较好理解,不过它需要在每次提交时输入帐号和密码,有点麻烦；而SSH的功能可以粗暴的理解为记住帐号密码,不过对这个过程有人会有点疑惑。首先,我们用SSH命令生成一个公钥-私钥对,我们会把公钥添加到Git的服务器,把私钥放在本地。提交文件的时候Git服务器会用公钥和客户端提交私钥做验证（具体细节不究）,如果验证通过则提交成功,那么我们在把公钥添加到服务器的时候肯定是需要登录Git服务器的,这个过程其实可以理解为帐号和密码托管给SSH了,所以也是相当于输入了帐号密码,但是由SSH帮你记住了。这么理解是可以,但是SSH的意义不仅仅是这样,关于SSH的更详细内容看客可以自行再了解。</p>
<h2 id="生成SSH-KEY"><a href="#生成SSH-KEY" class="headerlink" title="生成SSH-KEY"></a>生成SSH-KEY</h2><p>打开命令行、终端,用命令进入到你要保存SSH-KEY文件的文件夹,我们先用命令测试下终端是否支持SSH:<br>如果你的终端支持SSH,那么你可能看到类似如下的版本信息:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ ssh -V</div><div class="line">OpenSSH_7.2p2 Ubuntu-4ubuntu2.2, OpenSSL 1.0.2g  1 Mar 2016</div></pre></td></tr></table></figure></p>
<p>测试时如果提示不识别SSH命令,需要安装SSH。<br>Ubuntu安装SSH:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo apt-get install openssh-client openssh-server</div></pre></td></tr></table></figure></p>
<p>CentOS安装SSH:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">yum install openssh-client openssh-server</div></pre></td></tr></table></figure></p>
<p>接下来在刚才的文件夹,使用SSH命令在当前文件夹生成一对SSH-KEY:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ssh-keygen -t rsa -C &quot;邮箱地址&quot;</div></pre></td></tr></table></figure></p>
<p>接下来会出来提示信息,完整的大概是这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C &quot;smallajax@foxmail.com&quot;</div><div class="line">Generating public/private rsa key pair.</div><div class="line">Enter file in which to save the key (~/.ssh/id_rsa):</div></pre></td></tr></table></figure></p>
<p>这里需要输入SSH-KEY的文件名字,这里名字理论上可以随便取,但是我们今天要说配置多个SSH-KEY,所以请分别查看以下两节:</p>
<ul>
<li>单个Git帐号的配置——全局Git配置</li>
<li>多个Git帐号的配置——局部Git配置</li>
</ul>
<h2 id="单个Git帐号的配置——全局Git配置"><a href="#单个Git帐号的配置——全局Git配置" class="headerlink" title="单个Git帐号的配置——全局Git配置"></a>单个Git帐号的配置——全局Git配置</h2><p>大部分人使用Git一般是一个帐号,所以接着上面的讲。<br>上面说到输入ssh-keygen命令生成SSH-KEY密钥对文件时需要输入文件名称,如果你仅仅要配置一个帐号,那么我们输入默认名称即可:id_rsa。<br>接着会要求输入私钥的密码,并且需要确认密码,为了安全在密码输入的时候不会反显,什么都看不到,这个密码你自己设置,但是你一定要记住:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Enter passphrase (empty for no passphrase):</div><div class="line">Enter same passphrase again:</div></pre></td></tr></table></figure></p>
<p>到这里生成SSH-KEY的事就完成了,你在当前文件夹会看到两个文件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">id_rsa  id_rsa.pub</div></pre></td></tr></table></figure></p>
<p>SSH-KEY生成了,接着给服务器和客户端配置SSH-KEY。<br>第一步把id_rsa.pub中的公钥内容添加到Git的SSH中,如果你使用Github或者Gitlib,在个人设置中会找到。<br>第二步把SSH-KEY配置给SSH,让系统的SSH知道这个KEY。<br>Linux把id_rsa文件拷贝到~/.ssh文件夹下,命令如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">cp id_rsa ~/.ssh/</div></pre></td></tr></table></figure></p>
<p>Window把id_rsa文件拷贝到C:/Users/你的用户名/.ssh文件夹下。</p>
<p>拷贝完成后,把.ssh文件夹下的id_rsa文件添加到SSH-Agent,命令如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ssh-add id_rsa文件的路径</div></pre></td></tr></table></figure></p>
<p>例如Linux:ssh-add ~/.ssh/id_rsa,如果命令行此时正在.ssh文件夹下:ssh-add id_rsa即可,Windows同理。</p>
<p>最后,执行以下命名配置Git全局用户和邮箱:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git config --global user.name &quot;你的名字&quot;</div><div class="line">git config --global user.email &quot;你的邮箱&quot;</div></pre></td></tr></table></figure></p>
<p>例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git config --global user.name &quot;YanZhenjie&quot;</div><div class="line">git config --global user.email &quot;smallajax@foxmail.com&quot;</div></pre></td></tr></table></figure></p>
<p>配置全局用户和邮箱完成后,我们可以查看:<br>Linux用户打开~/.gitconfig文件即可看到配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim ~/.gitconfig</div></pre></td></tr></table></figure></p>
<p>Windows用户打开C:/Users/你的用户名/.gitconfig即可看到配置,内容大概如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[user]</div><div class="line">    name = YanZhenjie</div><div class="line">    email = smallajax@foxmail.com</div></pre></td></tr></table></figure></p>
<p>此时配置全部结束,请查看下方测试SSH-KEY配置是否成功进行测试。</p>
<h2 id="多个Git帐号的配置——局部Git配置"><a href="#多个Git帐号的配置——局部Git配置" class="headerlink" title="多个Git帐号的配置——局部Git配置"></a>多个Git帐号的配置——局部Git配置</h2><p>又有很多人同时使用多个Git帐号,比如Github、OSChina、Gitlib等,再接着上面讲配置多个Git帐号。</p>
<p>上面说到输入ssh-keygen命令生成SSH-KEY密钥对文件时需要输入文件名称,如果你要配置多个帐号,就根据爱好输入KEY文件的名字吧,例如为Github配置就输入:id_rsa_github,为OSChina配置就输入:id_rsa_oschina。</p>
<p>接着会要求输入私钥的密码,并且需要确认密码,为了安全在密码输入的时候不会反显,什么都看不到,这个密码你自己设置,但是你一定要记住:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Enter passphrase (empty for no passphrase):</div><div class="line">Enter same passphrase again:</div></pre></td></tr></table></figure></p>
<p>到这里生成SSH-KEY的事就完成了,你在当前文件夹会看到两个文件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">id_rsa_github  id_rsa_github.pub</div></pre></td></tr></table></figure></p>
<p>SSH-KEY生成了,接着给服务器和客户端配置SSH-KEY。</p>
<p>第一步把id_rsa_github.pub中的公钥内容添加到Git的SSH中,如果你使用Github或者Gitlib,在个人设置中会找到。<br>第二步为SSH配置私钥位置,这里和上面配置单个Git帐号不一样,不过单个帐号也可以按照多个帐号的配置方法来配置。<br>下面我们需要在.ssh文件夹新建一个名为config的文件,用它来配置多个SSH-KEY的管理。<br>Linux进入.ssh文件夹:cd ~/.ssh,新建config文件:touch config；或者:touch ~/.ssh/config。这里要注意,没有.ssh文件夹的要新建一个.ssh名的文件夹。<br>Window进入C:/Users/你的用户名/.ssh文件夹,右键新建一个文本文件,改名为config即可。这里要注意,没有.ssh文件夹的要新建一个.ssh名的文件夹。</p>
<p>下面来填写config文件的内容,我以Github、Gitlib、OSChina,局域网为例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Host github.com</div><div class="line">    HostName github.com</div><div class="line">    User smallajax@foxmail.com</div><div class="line">    PreferredAuthentications publickey</div><div class="line">    IdentityFile /home/Workspace/ssh/id_rsa_github</div><div class="line">Host gitlib.com</div><div class="line">    HostName gitlib.com</div><div class="line">    User smallajax@foxmail.com</div><div class="line">    PreferredAuthentications publickey</div><div class="line">    IdentityFile id_rsa_gitlib</div><div class="line">Host oschina.com</div><div class="line">    HostName oschina.com</div><div class="line">    User smallajax@foxmail.com</div><div class="line">    PreferredAuthentications publickey</div><div class="line">    IdentityFile /D/Workspace/ssh/id_rsa_oschina</div><div class="line">Host 192.168.1.222</div><div class="line">    HostName 192.168.1.222</div><div class="line">    User smallajax@foxmail.com</div><div class="line">    PreferredAuthentications publickey</div><div class="line">    IdentityFile /D/Workspace/ssh/id_rsa_oschina</div></pre></td></tr></table></figure></p>
<p>解释一下,HostName是服务器的地址,User是用户名,PreferredAuthentications照抄即可,这里主要说的是IdentityFile,上面我们看到了三种情况,所以它的书写原则是:<br>填私钥文件的本地路径。<br>不论是Linux还是Windows都可以写相对路径,比如把id_rsa_xxx私钥文件放在.ssh文件夹下。<br>文件放在不同跟路径下时,需要写绝对路径<br>Linux中没有放在.ssh文件夹内或者子文件夹。<br>Windows中没有放在C盘下时。注意据对路径变化,比如C盘下是/C/xo/abc、比如D盘下/D/ssh/id_rsa这样,还看不懂请参考上方例子。<br>拷贝完成后,把所有的id_rsa私钥文件添加到SSH-Agent,命令如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ssh-add id_rsa文件的路径</div></pre></td></tr></table></figure></p>
<p>例如添加.ssh文件夹下的,Linux这样做:ssh-add ~/.ssh/id_rsa,如果你在.ssh文件夹下:ssh-add id_rsa即可,Windows同理。</p>
<p>最后,还剩下项目的用户和邮箱没有配置,和配个单个Git帐号的方式不同,这里我们需要为每个项目分别配置,所以要命令行进入仓库文件夹再设置。第一种情况是先从Git上pull仓库下来,第二种情况是本地初始化Git仓库,总之进入改仓库文件夹后:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git config --local user.name &quot;你的名字&quot;</div><div class="line">git config --local user.email &quot;你的邮箱&quot;</div></pre></td></tr></table></figure></p>
<p>不过麻烦的一点是如果是多个项目就需要挨个配置,不过我们一般是pull一个项目就配置一下,也仅仅需要配置一次即可。<br>注意配置单个Git帐号时,是不进入项目文件夹就可以,不过不是使用–local,而是使用–global就可以全局配置。<br>配置项目用户和邮箱完成后,我们可以进入项目文件夹下的.git文件夹查看config文件内容,大概内容如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">...</div><div class="line">[user]</div><div class="line">    name = YanZhenjie</div><div class="line">    email = smallajax@foxmail.com</div></pre></td></tr></table></figure></p>
<p>此时配置全部结束,请查看下方测试SSH-KEY配置是否成功进行测试。如果配置成功,你就可以clone和commit了。</p>
<h2 id="测试SSH-KEY配置是否成功"><a href="#测试SSH-KEY配置是否成功" class="headerlink" title="测试SSH-KEY配置是否成功"></a>测试SSH-KEY配置是否成功</h2><p>配置全部结束，我们来测试一下配置是否成功：</p>
<p>如果你是Github：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ssh -T git@github.com</div></pre></td></tr></table></figure></p>
<p>如果是你Gitlib：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ssh -T git@gitlib.com</div></pre></td></tr></table></figure></p>
<p>如果你是局域网192.168.1.222：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ssh -T git@192.168.1.222</div></pre></td></tr></table></figure></p>
<p>其它自行举一反三吧。<br>此时需要输入刚才生成SSH-KEY时输入的私钥密码，输入后自行观察信息判断是否连接成功。</p>
<p>比如Github的信息是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hi yanzhenjie! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</div></pre></td></tr></table></figure></p>
<p>比如Gitlib的信息是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Welcome to GitLab, YanZhenjie!</div></pre></td></tr></table></figure></p>
<p>添加SSH到SSH-Agent时报错</p>
<p>如果执行ssh-add …命令提示如下错误：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Could not open a connection to your authentication agent.</div></pre></td></tr></table></figure></p>
<p>那么请执行eval $(ssh-agent)命令后再重试，如果还不行，请再执行ssh-agent bash命令后重试。<br>ref:<br><a href="http://blog.csdn.net/yanzhenjie1003/article/details/69487932?locationNum=4&amp;fps=1" target="_blank" rel="external">http://blog.csdn.net/yanzhenjie1003/article/details/69487932?locationNum=4&amp;fps=1</a></p>
<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑:"></a>踩坑:</h2><p>直接 clone git协议的链接，提示 permission denied…, 网友说不是自己建的库,git clone http: ,自己建的库 git clone git:<br>至于具体原理 ref: <a href="http://blog.csdn.net/liangpz521/article/details/21534849" target="_blank" rel="external">http://blog.csdn.net/liangpz521/article/details/21534849</a><br>ran@ranux:~/Documents/xxx_src$ git clone git@git.xxx.com:xxx/xxx-service-wechat.git<br>Cloning into ‘xxx-service-wechat’…<br>The authenticity of host ‘git.xxx.com (61.149.179.190)’ can’t be established.<br>RSA key fingerprint is SHA256:dk7bjq40xJ9oEFm4NS7Uo+lDvgVPilONMLheB6suFB0.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘git.xxx.com,61.149.179.190’ (RSA) to the list of known hosts.<br>git@git.xxx.com’s password:<br>Permission denied, please try again.<br>git@git.xxx.com’s password:<br>Connection to git.xxx.com closed by remote host.<br>fatal: Could not read from remote repository.</p>
<p>Please make sure you have the correct access rights<br>and the repository exists.<br>ran@ranux:~/Documents/xxx_src$ git clone git@git.xxx.com:xxx/xxx-service-wechat.git<br>Cloning into ‘xxx-service-wechat’…<br>The authenticity of host ‘git.xxx.com (61.149.179.190)’ can’t be established.<br>RSA key fingerprint is SHA256:dk7bjq40xJ9oEFm4NS7Uo+lDvgVPilONMLheB6suFB0.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘git.xxx.com,61.149.179.190’ (RSA) to the list of known hosts.<br>git@git.xxx.com’s password:<br>Permission denied, please try again.<br>git@git.xxx.com’s password: </p>
<p>ran@ranux:~/Documents/xxx_src$ git clone <a href="http://git.xxx.com/xxx/xxx-service-wechat.git" target="_blank" rel="external">http://git.xxx.com/xxx/xxx-service-wechat.git</a><br>Cloning into ‘xxx-service-wechat’…<br>Username for ‘<a href="http://git.xxx.com" target="_blank" rel="external">http://git.xxx.com</a>‘: xxx@xxx.com<br>Password for ‘<a href="http://xxx@xxx.com@git.xxx.com" target="_blank" rel="external">http://xxx@xxx.com@git.xxx.com</a>‘:<br>fatal: Authentication failed for ‘<a href="http://git.xxx.com/xxx/xxx-service-wechat.git/" target="_blank" rel="external">http://git.xxx.com/xxx/xxx-service-wechat.git/</a>‘<br>ran@ranux:~/Documents/xxx_src$ git clone <a href="http://git.xxx.com/xxx/xxx-service-wechat.git" target="_blank" rel="external">http://git.xxx.com/xxx/xxx-service-wechat.git</a><br>Cloning into ‘xxx-service-wechat’…<br>Username for ‘<a href="http://git.xxx.com" target="_blank" rel="external">http://git.xxx.com</a>‘: xxx<br>Password for ‘<a href="http://xxx@git.xxx.com" target="_blank" rel="external">http://xxx@git.xxx.com</a>‘:<br>remote: Counting objects: 825, done.<br>remote: Compressing objects: 100% (330/330), done.<br>remote: Total 825 (delta 276), reused 739 (delta 256)<br>Receiving objects: 100% (825/825), 178.90 KiB | 0 bytes/s, done.<br>Resolving deltas: 100% (276/276), done.<br>Checking connectivity… done.</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-锁</title>
    <url>/2017/11/20/Mysql-%E9%94%81/</url>
    <content><![CDATA[<p>这篇文章主要介绍了MySQL行级锁、表级锁、页级锁详细介绍,同时列举了一些实例说明</p>
<a id="more"></a>
<p>页级:引擎 BDB。<br>表级:引擎 MyISAM ， 理解为锁住整个表，可以同时读，写不行<br>行级:引擎 INNODB ， 单独的一行记录加锁</p>
<p>表级，直接锁定整张表，在你锁定期间，其它进程无法对该表进行写操作。如果你是写锁，则其它进程则读也不允许<br>行级，仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操作。<br>页级，表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>
<p>MySQL 5.1支持对MyISAM和MEMORY表进行表级锁定，对BDB表进行页级锁定，对InnoDB表进行行级锁定。<br>对WRITE，MySQL使用的表锁定方法原理如下：<br>如果在表上没有锁，在它上面放一个写锁。 否则，把锁定请求放在写锁定队列中。<br>对READ，MySQL使用的锁定方法原理如下： 如果在表上没有写锁定，把一个读锁定放在它上面   否则，把锁请求放在读锁定队列中。</p>
<p>InnoDB使用行锁定，BDB使用页锁定。对于这两种存储引擎，都可能存在死锁。这是因为，在SQL语句处理期间，InnoDB自动获得行锁定和BDB获得页锁定，而不是在事务启动时获得。 </p>
<p>行级锁定的优点：</p>
<ul>
<li>当在许多线程中访问不同的行时只存在少量锁定冲突。</li>
<li>回滚时只有少量的更改。</li>
<li>可以长时间锁定单一的行。</li>
</ul>
<p>行级锁定的缺点：</p>
<ul>
<li>比页级或表级锁定占用更多的内存。</li>
<li>当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。</li>
<li>如果你在大部分数据上经常进行GROUP BY操作或者必须经常扫描整个表，比其它锁定明显慢很多。</li>
<li>用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。</li>
</ul>
<p>在以下情况下，表锁定优先于页级或行级锁定：</p>
<ul>
<li>表的大部分语句用于读取。</li>
<li>对严格的关键字进行读取和更新，你可以更新或删除可以用单一的读取的关键字来提取的一行：</li>
<li>UPDATE tbl_name SET column=value WHERE unique_key_col=key_value;</li>
<li>DELETE FROM tbl_name WHERE unique_key_col=key_value;</li>
<li>SELECT 结合并行的INSERT语句，并且只有很少的UPDATE或DELETE语句。</li>
<li>在整个表上有许多扫描或GROUP BY操作，没有任何写操作。</li>
</ul>
<h2 id="mysql-锁表类型和解锁语句"><a href="#mysql-锁表类型和解锁语句" class="headerlink" title="mysql 锁表类型和解锁语句"></a>mysql 锁表类型和解锁语句</h2><p>如果想要在一个表上做大量的 INSERT 和 SELECT 操作，但是并行的插入却不可能时，可以将记录插入到临时表中，然后定期将临时表中的数据更新到实际的表里。可以用以下命令实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; LOCK TABLES real_table WRITE, insert_table WRITE;</div><div class="line">mysql&gt; INSERT INTO real_table SELECT * FROM insert_table;</div><div class="line">mysql&gt; TRUNCATE TABLE insert_table;</div><div class="line">mysql&gt; UNLOCK TABLES;</div></pre></td></tr></table></figure></p>
<h2 id="行级锁的优点有："><a href="#行级锁的优点有：" class="headerlink" title="行级锁的优点有："></a>行级锁的优点有：</h2><ul>
<li>在很多线程请求不同记录时减少冲突锁。</li>
<li>事务回滚时减少改变数据。</li>
<li>使长时间对单独的一行记录加锁成为可能。</li>
</ul>
<p>行级锁的缺点有：</p>
<ul>
<li>比页级锁和表级锁消耗更多的内存。</li>
<li>锁是计算机协调多个进程或线程并发访问某一资源的机制，不同的数据库的锁机制大同小异。由于数据库资源是一种供许多用户共享的资源，所以如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。了解锁机制不仅可以使我们更有效的开发利用数据库资源，也使我们能够更好地维护数据库，从而提高数据库的性能。</li>
</ul>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-锁机制-InnoDB</title>
    <url>/2017/11/20/Mysql-%E9%94%81%E6%9C%BA%E5%88%B6-InnoDB/</url>
    <content><![CDATA[<p>锁是计算机协调多个进程或线程并发访问某一资源的机制，不同的数据库的锁机制大同小异。由于数据库资源是一种供许多用户共享的资源，所以如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。了解锁机制不仅可以使我们更有效的开发利用数据库资源，也使我们能够更好地维护数据库，从而提高数据库的性能。</p>
<a id="more"></a>
<p>MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。<br>例如，MyISAM和MEMORY存储引擎采用的是表级锁（table-level-locking）；BDB存储引擎采用的是页面锁（page-level-locking），同时也支持表级锁；InnoDB存储引擎既支持行级锁，也支持表级锁，默认情况下是采用行级锁。</p>
<p>上述三种锁的特性可大致归纳如下：</p>
<ol>
<li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ol>
<p>MyISAM表的读和写是串行的，即在进行读操作时不能进行写操作，反之也是一样。但在一定条件下MyISAM表也支持查询和插入的操作的并发进行，其机制是通过控制一个系统变量（concurrent_insert）来进行的，当其值设置为0时，不允许并发插入；当其值设置为1 时，如果MyISAM表中没有空洞（即表中没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录；当其值设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</p>
<p>MyISAM锁调度是如何实现的呢，这也是一个很关键的问题。例如，当一个进程请求某个MyISAM表的读锁，同时另一个进程也请求同一表的写锁，此时MySQL将会如优先处理进程呢？通过研究表明，写进程将先获得锁（即使读请求先到锁等待队列）。但这也造成一个很大的缺陷，即大量的写操作会造成查询操作很难获得读锁，从而可能造成永远阻塞。所幸我们可以通过一些设置来调节MyISAM的调度行为。我们可通过指定参数low-priority-updates，使MyISAM默认引擎给予读请求以优先的权利，设置其值为1（set low_priority_updates=1),使优先级降低。</p>
<p>InnoDB锁与MyISAM锁的最大不同在于：一是支持事务（TRANCSACTION），二是采用了行级锁。我们知道事务是由一组SQL语句组成的逻辑处理单元，其有四个属性（简称ACID属性），分别为：</p>
<ul>
<li>原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全部执行，要么全都不执行；</li>
<li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态；</li>
<li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行；</li>
<li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</li>
</ul>
<h2 id="InnoDB锁模式"><a href="#InnoDB锁模式" class="headerlink" title="InnoDB锁模式"></a>InnoDB锁模式</h2><p>InnoDB实现了两种类型的行锁。</p>
<ul>
<li>共享锁（S）:允许一个事务去读一行，阻止其他事务获得相同的数据集的排他锁。</li>
<li>排他锁（X）:允许获得排他锁的事务更新数据，但是组织其他事务获得相同数据集的共享锁和排他锁。</li>
</ul>
<p>可以这么理解:<br>共享锁就是我读的时候，你可以读，但是不能写。排他锁就是我写的时候，你不能读也不能写。其实就是MyISAM的读锁和写锁，但是针对的对象不同了而已。</p>
<p>为了允许行锁和表锁共存，实现多粒度锁机制；同时还有两种内部使用的意向锁（都是表锁），分别为意向共享锁和意向排他锁</p>
<ul>
<li>意向共享锁（IS）:表示事务准备给数据行加入共享锁，也就是说一个数据行加共享锁前必须先取得该表的IS锁</li>
<li>意向排他锁（IX）:类似上面，表示事务准备给数据行加入排他锁，说明事务在一个数据行加排他锁前必须先取得该表的IX锁。</li>
</ul>
<p>InnoDB行锁模式兼容列表:<br><img src="/2017/11/20/Mysql-锁机制-InnoDB/20150810092332320.png" alt="20150810092332320.png" title=""></p>
<p>注意:<br>当一个事务请求的锁模式与当前的锁兼容，InnoDB就将请求的锁授予该事务；反之如果请求不兼容，则该事务就等待锁释放。<br><strong>意向锁是InnoDB自动加的，不需要用户干预。</strong></p>
<p>对于insert、update、delete，InnoDB会自动给涉及的数据加排他锁（X）；对于一般的Select语句，InnoDB不会加任何锁，事务可以通过以下语句给显示加共享锁或排他锁。</p>
<p>共享锁:select <em> from table_name where …..lock in share mode<br>排他锁:select </em> from table_name where …..for update</p>
<p>加入共享锁的例子:<br><img src="/2017/11/20/Mysql-锁机制-InnoDB/20150810092332321.png" alt="20150810092332321.png" title=""></p>
<p>利用select ….for update加入排他锁<br><img src="/2017/11/20/Mysql-锁机制-InnoDB/20150810092333322.png" alt="20150810092333322.png" title=""></p>
<h2 id="锁的实现方式"><a href="#锁的实现方式" class="headerlink" title="锁的实现方式"></a>锁的实现方式</h2><p>InnoDB行锁是通过给索引项加锁实现的，如果没有索引，InnoDB会通过隐藏的聚簇索引来对记录加锁。<br>也就是说:如果不通过索引条件检索数据，那么InnoDB将对表中所有数据加锁，实际效果跟表锁一样。</p>
<p>行锁分为三种情形:</p>
<ul>
<li>Record lock :对索引项加锁，即锁定一条记录。</li>
<li>Gap lock:对索引项之间的‘间隙’、对第一条记录前的间隙或最后一条记录后的间隙加锁，即锁定一个范围的记录，不包含记录本身</li>
<li>Next-key Lock:锁定一个范围的记录并包含记录本身（上面两者的结合）。</li>
</ul>
<p>注意:InnoDB默认级别是repeatable-read级别，所以下面说的都是在RR级别中的。</p>
<p>Next-Key Lock是行锁与间隙锁的组合，这样，当InnoDB扫描索引记录的时候，会首先对选中的索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。如果一个间隙被事务T1加了锁，其它事务是不能在这个间隙插入记录的。</p>
<p>干巴巴的说没意思，我们来看看具体实例:</p>
<p>假设我们有一张表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">+----+------+</div><div class="line">| id | age |</div><div class="line">+----+------+</div><div class="line">| 1 | 3 |</div><div class="line">| 2 | 6 |</div><div class="line">| 3 | 9 |</div><div class="line">+----+------+</div></pre></td></tr></table></figure></p>
<p>表结构如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE `test` (</div><div class="line">`id` int(11) NOT NULL AUTO_INCREMENT,</div><div class="line">`age` int(11) DEFAULT NULL,</div><div class="line">PRIMARY KEY (`id`),</div><div class="line">KEY `keyname` (`age`)</div><div class="line">) ENGINE=InnoDB AUTO_INCREMENT=302 DEFAULT CHARSET=gbk ;</div></pre></td></tr></table></figure></p>
<p>这样我们age段的索引就分为<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(negative infinity, 3],</div><div class="line">(3,6],</div><div class="line">(6,9],</div><div class="line">(9,positive infinity)；</div></pre></td></tr></table></figure></p>
<p>我们来看一下几种情况:<br>1、当事务A执行以下语句:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; select * from fenye where age=6 for update ;</div></pre></td></tr></table></figure></p>
<p>不仅使用行锁锁住了相应的数据行，同时也在两边的区间，（3,6]和（6，9] 都加入了gap锁。<br>这样事务B就无法在这个两个区间insert进新数据,但是事务B可以在两个区间外的区间插入数据。</p>
<p>2、当事务A执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">select * from fenye where age=7 for update ;</div></pre></td></tr></table></figure></p>
<p>那么就会给(6,9]这个区间加锁，别的事务无法在此区间插入或更新数据。</p>
<p>3、如果查询的数据不再范围内，<br>比如事务A执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">select * from fenye where age=100 for update ;</div></pre></td></tr></table></figure></p>
<p>那么加锁区间就是(9,positive infinity)。</p>
<p>小结:<br>行锁防止别的事务修改或删除，GAP锁防止别的事务新增，行锁和GAP锁结合形成的的Next-Key锁共同解决了RR级别在写数据时的幻读问题。</p>
<h2 id="何时在InnoDB中使用表锁"><a href="#何时在InnoDB中使用表锁" class="headerlink" title="何时在InnoDB中使用表锁"></a>何时在InnoDB中使用表锁</h2><p>InnoDB在绝大部分情况会使用行级锁，因为事务和行锁往往是我们选择InnoDB的原因，但是有些情况我们也考虑使用表级锁。</p>
<ol>
<li>当事务需要更新大部分数据时，表又比较大，如果使用默认的行锁，不仅效率低，而且还容易造成其他事务长时间等待和锁冲突。</li>
<li>事务比较复杂，很可能引起死锁导致回滚。</li>
</ol>
<h2 id="InnoDB-锁表与锁行实例"><a href="#InnoDB-锁表与锁行实例" class="headerlink" title="InnoDB 锁表与锁行实例"></a>InnoDB 锁表与锁行实例</h2><p>由于InnoDB预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL才会执行Row lock (只锁住被选取的资料例) ，否则MySQL将会执行Table Lock (将整个资料表单给锁住)。<br>举个例子: 假设有个表单products ，里面有id跟name二个栏位，id是主键。<br>例1: (明确指定主键，并且有此笔资料，row lock)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT * FROM products WHERE id=&apos;3&apos; FOR UPDATE;</div><div class="line">SELECT * FROM products WHERE id=&apos;3&apos; and type=1 FOR UPDATE;</div></pre></td></tr></table></figure></p>
<p>例2: (明确指定主键，若查无此笔资料，无lock)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT * FROM products WHERE id=&apos;-1&apos; FOR UPDATE;</div></pre></td></tr></table></figure></p>
<p>例3: (无主键，table lock)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT * FROM products WHERE name=&apos;Mouse&apos; FOR UPDATE;</div></pre></td></tr></table></figure></p>
<p>例4: (主键不明确，table lock)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT * FROM products WHERE id&lt;&gt;&apos;3&apos; FOR UPDATE;</div></pre></td></tr></table></figure></p>
<p>例5: (主键不明确，table lock)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT * FROM products WHERE id LIKE &apos;3&apos; FOR UPDATE;</div></pre></td></tr></table></figure></p>
<p>注1: FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。<br>注2: 要测试锁定的状况，可以利用MySQL的Command Mode ，开二个视窗来做测试。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>我们说过MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。</p>
<p>在上面的例子中我们可以看到，当两个事务都需要获得对方持有的锁才能够继续完成事务，导致双方都在等待，产生死锁。<br>发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p>
<p>避免死锁:<br>有多种方法可以避免死锁，这里只介绍常见的三种:</p>
<ol>
<li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
</ol>
<p>ref:<br><a href="https://www.2cto.com/database/201508/429967.html" target="_blank" rel="external">https://www.2cto.com/database/201508/429967.html</a><br><a href="http://www.jb51.net/article/50047.htm" target="_blank" rel="external">http://www.jb51.net/article/50047.htm</a><br><a href="https://www.cnblogs.com/chenqionghe/p/4845693.html" target="_blank" rel="external">https://www.cnblogs.com/chenqionghe/p/4845693.html</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-装饰模式</title>
    <url>/2017/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在阎宏博士的《JAVA与模式》一书中开头是这样描述装饰（Decorator）模式的:<br>装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。</p>
<a id="more"></a>
<h2 id="装饰模式的结构"><a href="#装饰模式的结构" class="headerlink" title="装饰模式的结构"></a>装饰模式的结构</h2><p>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。</p>
<p>装饰模式的类图如下:<br><img src="/2017/11/12/设计模式-装饰模式/download.png" alt="download.png" title=""></p>
<p>在装饰模式中的角色有:</p>
<ul>
<li>抽象构件(Component)角色:给出一个抽象接口，以规范准备接收附加责任的对象。</li>
<li>具体构件(ConcreteComponent)角色:定义一个将要接收附加责任的类。</li>
<li>装饰(Decorator)角色:持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。</li>
<li>具体装饰(ConcreteDecorator)角色:负责给构件对象“贴上”附加的责任。</li>
</ul>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>抽象构件角色<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体构件角色<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 写相关的业务代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>装饰角色<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Component component;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.component = component;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 委派给构件</span></div><div class="line">        component.sampleOperation();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体装饰角色<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorA</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorA</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(component);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation</span><span class="params">()</span> </span>&#123;</div><div class="line">　　　　　<span class="keyword">super</span>.sampleOperation();</div><div class="line">        <span class="comment">// 写相关的业务代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecoratorB</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteDecoratorB</span><span class="params">(Component component)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(component);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation</span><span class="params">()</span> </span>&#123;</div><div class="line">　　　　  <span class="keyword">super</span>.sampleOperation();</div><div class="line">        <span class="comment">// 写相关的业务代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="齐天大圣的例子"><a href="#齐天大圣的例子" class="headerlink" title="齐天大圣的例子"></a>齐天大圣的例子</h2><p>孙悟空有七十二般变化，他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。</p>
<p>本例中，Component的角色便由鼎鼎大名的齐天大圣扮演；ConcreteComponent的角色属于大圣的本尊，就是猢狲本人；Decorator的角色由大圣的七十二变扮演。而ConcreteDecorator的角色便是鱼儿、鸟儿等七十二般变化。<br><img src="/2017/11/12/设计模式-装饰模式/download1.png" alt="download1.png" title=""></p>
<p>抽象构件角色“齐天大圣”接口定义了一个move()方法，这是所有的具体构件类和装饰类必须实现的。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//大圣的尊号</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TheGreatestSage</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体构件角色“大圣本尊”猢狲类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">TheGreatestSage</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Monkey Move"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>抽象装饰角色“七十二变”<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Change</span> <span class="keyword">implements</span> <span class="title">TheGreatestSage</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> TheGreatestSage sage;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Change</span><span class="params">(TheGreatestSage sage)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.sage = sage;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        sage.move();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体装饰角色“鱼儿”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Change</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fish</span><span class="params">(TheGreatestSage sage)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(sage);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 代码</span></div><div class="line">        System.out.println(<span class="string">"Fish Move"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>具体装饰角色“鸟儿”<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Change</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(TheGreatestSage sage)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(sage);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 代码</span></div><div class="line">        System.out.println(<span class="string">"Bird Move"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        TheGreatestSage sage = <span class="keyword">new</span> Monkey();</div><div class="line">        <span class="comment">// 第一种写法</span></div><div class="line">        TheGreatestSage bird = <span class="keyword">new</span> Bird(sage);</div><div class="line">        TheGreatestSage fish = <span class="keyword">new</span> Fish(bird);</div><div class="line">        <span class="comment">// 第二种写法</span></div><div class="line">        <span class="comment">//TheGreatestSage fish = new Fish(new Bird(sage));</span></div><div class="line">        fish.move(); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>“大圣本尊”是ConcreteComponent类，而“鸟儿”、“鱼儿”是装饰类。要装饰的是“大圣本尊”，也即“猢狲”实例。</p>
<p>上面的例子中，系统把大圣从一只猢狲装饰成了一只鸟儿（把鸟儿的功能加到了猢狲身上），然后又把鸟儿装饰成了一条鱼儿（把鱼儿的功能加到了猢狲+鸟儿身上，得到了猢狲+鸟儿+鱼儿）。<br><img src="/2017/11/12/设计模式-装饰模式/download2.png" alt="download2.png" title=""><br>如上图所示，大圣的变化首先将鸟儿的功能附加到了猢狲身上，然后又将鱼儿的功能附加到猢狲+鸟儿身上。</p>
<h2 id="装饰模式的简化"><a href="#装饰模式的简化" class="headerlink" title="装饰模式的简化"></a>装饰模式的简化</h2><p>大多数情况下，装饰模式的实现都要比上面给出的示意性例子要简单。</p>
<p>如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类。如下图所示<br><img src="/2017/11/12/设计模式-装饰模式/download3.png" alt="download3.png" title=""><br>如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。如下图所示:<br><img src="/2017/11/12/设计模式-装饰模式/download4.png" alt="download4.png" title=""></p>
<h2 id="透明性的要求"><a href="#透明性的要求" class="headerlink" title="透明性的要求"></a>透明性的要求</h2><p>装饰模式对客户端的透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量。</p>
<p>用孙悟空的例子来说，必须永远把孙悟空的所有变化都当成孙悟空来对待，而如果把老孙变成的鱼儿当成鱼儿，而不是老孙，那就被老孙骗了，而这时不应当发生的。下面的做法是对的:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">TheGreatestSage sage = <span class="keyword">new</span> Monkey();</div><div class="line">TheGreatestSage bird = <span class="keyword">new</span> Bird(sage);</div></pre></td></tr></table></figure></p>
<p>而下面的做法是不对的:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Monkey sage = <span class="keyword">new</span> Monkey();</div><div class="line">Bird bird = <span class="keyword">new</span> Bird(sage);</div></pre></td></tr></table></figure></p>
<h2 id="半透明的装饰模式"><a href="#半透明的装饰模式" class="headerlink" title="半透明的装饰模式"></a>半透明的装饰模式</h2><p>然而，纯粹的装饰模式很难找到。装饰模式的用意是在不改变接口的前提下，增强所考虑的类的性能。在增强性能的时候，往往需要建立新的公开的方法。即便是在孙大圣的系统里，也需要新的方法。比如齐天大圣类并没有飞行的能力，而鸟儿有。这就意味着鸟儿应当有一个新的fly()方法。再比如，齐天大圣类并没有游泳的能力，而鱼儿有，这就意味着在鱼儿类里应当有一个新的swim()方法。</p>
<p>这就导致了大多数的装饰模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰模式改变接口，增加新的方法。这意味着客户端可以声明ConcreteDecorator类型的变量，从而可以调用ConcreteDecorator类中才有的方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">TheGreatestSage sage = <span class="keyword">new</span> Monkey();</div><div class="line">Bird bird = <span class="keyword">new</span> Bird(sage);</div><div class="line">bird.fly();</div></pre></td></tr></table></figure></p>
<p>半透明的装饰模式是介于装饰模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。大多数的装饰模式实际上是半透明的装饰模式，这样的装饰模式也称做半装饰、半适配器模式。</p>
<h2 id="装饰模式的优点"><a href="#装饰模式的优点" class="headerlink" title="装饰模式的优点"></a>装饰模式的优点</h2><ol>
<li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。</li>
<li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。</li>
</ol>
<h2 id="装饰模式的缺点"><a href="#装饰模式的缺点" class="headerlink" title="装饰模式的缺点"></a>装饰模式的缺点</h2><p>由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。</p>
<h2 id="设计模式在JAVA-I-O库中的应用"><a href="#设计模式在JAVA-I-O库中的应用" class="headerlink" title="设计模式在JAVA I/O库中的应用"></a>设计模式在JAVA I/O库中的应用</h2><p>装饰模式在Java语言中的最著名的应用莫过于Java I/O标准库的设计了。</p>
<p>由于Java I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。而如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是Java I/O库的基本模式。</p>
<p>Java I/O库的对象结构图如下，由于Java I/O的对象众多，因此只画出InputStream的部分。<br><img src="/2017/11/12/设计模式-装饰模式/download5.png" alt="download5.png" title=""><br>根据上图可以看出:</p>
<ul>
<li>抽象构件(Component)角色:由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</li>
<li>具体构件(ConcreteComponent)角色:由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。</li>
<li>抽象装饰(Decorator)角色:由FilterInputStream扮演。它实现了InputStream所规定的接口。</li>
<li>具体装饰(ConcreteDecorator)角色:由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。</li>
</ul>
<h2 id="半透明的装饰模式-1"><a href="#半透明的装饰模式-1" class="headerlink" title="半透明的装饰模式"></a>半透明的装饰模式</h2><p>装饰模式和适配器模式都是“包装模式(Wrapper Pattern)”，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。</p>
<p>理想的装饰模式在对被装饰对象进行功能增强的同时，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。而适配器模式则不然，一般而言，适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合。</p>
<p>装饰模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。相反，如果装饰角色的接口与抽象构件角色接口不一致，也就是说装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色，这种装饰模式也是可以接受的，称为“半透明”的装饰模式，如下图所示。<br><img src="/2017/11/12/设计模式-装饰模式/download6.png" alt="download6.png" title=""><br>在适配器模式里面，适配器类的接口通常会与目标类的接口重叠，但往往并不完全相同。换言之，适配器类的接口会比被装饰的目标类接口宽。</p>
<p>显然，半透明的装饰模式实际上就是处于适配器模式与装饰模式之间的灰色地带。如果将装饰模式与适配器模式合并成为一个“包装模式”的话，那么半透明的装饰模式倒可以成为这种合并后的“包装模式”的代表。</p>
<h2 id="InputStream类型中的装饰模式"><a href="#InputStream类型中的装饰模式" class="headerlink" title="InputStream类型中的装饰模式"></a>InputStream类型中的装饰模式</h2><p>InputStream类型中的装饰模式是半透明的。为了说明这一点，不妨看一看作装饰模式的抽象构件角色的InputStream的源代码。这个抽象类声明了九个方法，并给出了其中八个的实现，另外一个是抽象方法，需要由子类实现。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是作为装饰模式的抽象装饰角色FilterInputStream类的源代码。可以看出，FilterInputStream的接口与InputStream的接口是完全一致的。也就是说，直到这一步，还是与装饰模式相符合的。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是具体装饰角色PushbackInputStream的源代码。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushbackInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureOpen</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PushbackInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PushbackInputStream</span><span class="params">(InputStream in)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">byte</span>[] b)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;&#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>查看源码，你会发现，这个装饰类提供了额外的方法unread()，这就意味着PushbackInputStream是一个半透明的装饰类。换言 之，它破坏了理想的装饰模式的要求。如果客户端持有一个类型为InputStream对象的引用in的话，那么如果in的真实类型是 PushbackInputStream的话，只要客户端不需要使用unread()方法，那么客户端一般没有问题。但是如果客户端必须使用这个方法，就 必须进行向下类型转换。将in的类型转换成为PushbackInputStream之后才可能调用这个方法。但是，这个类型转换意味着客户端必须知道它 拿到的引用是指向一个类型为PushbackInputStream的对象。这就破坏了使用装饰模式的原始用意。</p>
<p>现实世界与理论总归是有一段差距的。纯粹的装饰模式在真实的系统中很难找到。一般所遇到的，都是这种半透明的装饰模式。</p>
<p>下面是使用I/O流读取文件内容的简单操作示例。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">// 流式读取文件</span></div><div class="line">        DataInputStream dis = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            dis = <span class="keyword">new</span> DataInputStream(</div><div class="line">                    <span class="keyword">new</span> BufferedInputStream(</div><div class="line">                            <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>)</div><div class="line">                    )</div><div class="line">            );</div><div class="line">            <span class="comment">//读取文件内容</span></div><div class="line">            <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[dis.available()];</div><div class="line">            dis.read(bs);</div><div class="line">            String content = <span class="keyword">new</span> String(bs);</div><div class="line">            System.out.println(content);</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">            dis.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>观察上面的代码，会发现最里层是一个FileInputStream对象，然后把它传递给一个BufferedInputStream对象，经过BufferedInputStream处理，再把处理后的对象传递给了DataInputStream对象进行处理，这个过程其实就是装饰器的组装过程，FileInputStream对象相当于原始的被装饰的对象，而BufferedInputStream对象和DataInputStream对象则相当于装饰器。</p>
<p>ref: <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-门面模式</title>
    <url>/2017/11/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>门面模式(Facade Pattern):外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。门面模式又称为外观模式，它是一种对象结构型模式。</p>
<a id="more"></a>
<h2 id="医院的例子"><a href="#医院的例子" class="headerlink" title="医院的例子"></a>医院的例子</h2><p>现代的软件系统都是比较复杂的，设计师处理复杂系统的一个常见方法便是将其“分而治之”，把一个系统划分为几个较小的子系统。如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情。<br>首先病人必须先挂号，然后门诊。如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验。化验后再回到门诊室。<br><img src="/2017/11/12/设计模式-门面模式/20140402071054062.png" alt="20140402071054062.png" title=""><br>上图描述的是病人在医院里的体验，图中的方框代表医院。<br>解决这种不便的方法便是引进门面模式，医院可以设置一个接待员的位置，由接待员负责代为挂号、划价、缴费、取药等。这个接待员就是门面模式的体现，病人只接触接待员，由接待员与各个部门打交道。<br><img src="/2017/11/12/设计模式-门面模式/20140402071134046.png" alt="20140402071134046.png" title=""></p>
<h2 id="门面模式的结构"><a href="#门面模式的结构" class="headerlink" title="门面模式的结构"></a>门面模式的结构</h2><p>门面模式没有一个一般化的类图描述，最好的描述方法实际上就是以一个例子说明<br><img src="/2017/11/12/设计模式-门面模式/20140402071217953.png" alt="20140402071217953.png" title=""><br>由于门面模式的结构图过于抽象，因此把它稍稍具体点。假设子系统内有三个模块，分别是ModuleA、ModuleB和ModuleC，它们分别有一个示例方法，那么此时示例的整体结构图如下:<br><img src="/2017/11/12/设计模式-门面模式/20140402071243265.png" alt="20140402071243265.png" title=""><br>在这个对象图中，出现了两个角色:</p>
<ul>
<li>门面(Facade)角色 :客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。</li>
<li>子系统(SubSystem)角色 :可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。</li>
</ul>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>子系统角色中的类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleA</span> </span>&#123;  </div><div class="line">    <span class="comment">//示意方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"调用ModuleA中的testA方法"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleB</span> </span>&#123;  </div><div class="line">    <span class="comment">//示意方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testB</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"调用ModuleB中的testB方法"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleC</span> </span>&#123;  </div><div class="line">    <span class="comment">//示意方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testC</span><span class="params">()</span></span>&#123;  </div><div class="line">        System.out.println(<span class="string">"调用ModuleC中的testC方法"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>门面角色类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;  </div><div class="line">    <span class="comment">//示意方法，满足客户端需要的功能  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;  </div><div class="line">        ModuleA a = <span class="keyword">new</span> ModuleA();  </div><div class="line">        a.testA();  </div><div class="line">        ModuleB b = <span class="keyword">new</span> ModuleB();  </div><div class="line">        b.testB();  </div><div class="line">        ModuleC c = <span class="keyword">new</span> ModuleC();  </div><div class="line">        c.testC();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端角色类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        Facade facade = <span class="keyword">new</span> Facade();  </div><div class="line">        facade.test();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Facade类其实相当于A、B、C模块的外观界面，有了这个Facade类，那么客户端就不需要亲自调用子系统中的A、B、C模块了，也不需要知道系统内部的实现细节，甚至都不需要知道A、B、C模块的存在，客户端只需要跟Facade类交互就好了，从而更好地实现了客户端和子系统中A、B、C模块的解耦，让客户端更容易地使用系统。</p>
<h2 id="门面模式的实现"><a href="#门面模式的实现" class="headerlink" title="门面模式的实现"></a>门面模式的实现</h2><p>使用门面模式还有一个附带的好处，就是能够有选择性地暴露方法。一个模块中定义的方法可以分成两部分，一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。有了Facade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。<br>比如，定义如下A、B、C模块。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Module</span> </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 提供给子系统外部使用的方法 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a1</span><span class="params">()</span></span>&#123;&#125;;  </div><div class="line">      </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 子系统内部模块之间相互调用时使用的方法 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a2</span><span class="params">()</span></span>&#123;&#125;;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">a3</span><span class="params">()</span></span>&#123;&#125;;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleB</span> </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 提供给子系统外部使用的方法 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b1</span><span class="params">()</span></span>&#123;&#125;;  </div><div class="line">      </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 子系统内部模块之间相互调用时使用的方法 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">b2</span><span class="params">()</span></span>&#123;&#125;;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">b3</span><span class="params">()</span></span>&#123;&#125;;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleC</span> </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 提供给子系统外部使用的方法 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c1</span><span class="params">()</span></span>&#123;&#125;;  </div><div class="line">      </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 子系统内部模块之间相互调用时使用的方法 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">c2</span><span class="params">()</span></span>&#123;&#125;;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">c3</span><span class="params">()</span></span>&#123;&#125;;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleFacade</span> </span>&#123;  </div><div class="line">      </div><div class="line">    ModuleA a = <span class="keyword">new</span> ModuleA();  </div><div class="line">    ModuleB b = <span class="keyword">new</span> ModuleB();  </div><div class="line">    ModuleC c = <span class="keyword">new</span> ModuleC();  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 下面这些是A、B、C模块对子系统外部提供的方法 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a1</span><span class="params">()</span></span>&#123;  </div><div class="line">        a.a1();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b1</span><span class="params">()</span></span>&#123;  </div><div class="line">        b.b1();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c1</span><span class="params">()</span></span>&#123;  </div><div class="line">        c.c1();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样定义一个ModuleFacade类可以有效地屏蔽内部的细节，免得客户端去调用Module类时，发现一些不需要它知道的方法。比如a2()和a3()方法就不需要让客户端知道，否则既暴露了内部的细节，又让客户端迷惑。对客户端来说，他可能还要去思考a2()、a3()方法用来干什么呢？其实a2()和a3()方法是内部模块之间交互的，原本就不是对子系统外部的，所以干脆就不要让客户端知道。</p>
<h2 id="一个系统可以有几个门面类"><a href="#一个系统可以有几个门面类" class="headerlink" title="一个系统可以有几个门面类"></a>一个系统可以有几个门面类</h2><p>在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。</p>
<h2 id="为子系统增加新行为"><a href="#为子系统增加新行为" class="headerlink" title="为子系统增加新行为"></a>为子系统增加新行为</h2><p>初学者往往以为通过继承一个门面类便可在子系统中加入新的行为，这是错误的。门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。</p>
<h2 id="模式的优缺点"><a href="#模式的优缺点" class="headerlink" title="模式的优缺点"></a>模式的优缺点</h2><p>优点:</p>
<ul>
<li>对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入门面模式，客户代码将变得很简单，与之关联的对象也很少。</li>
<li>实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。</li>
<li>降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li>
<li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。</li>
</ul>
<p>缺点:</p>
<ul>
<li>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</li>
<li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol>
<li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。 </li>
<li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。 </li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li>
</ol>
<h2 id="需要注意的几点"><a href="#需要注意的几点" class="headerlink" title="需要注意的几点"></a>需要注意的几点</h2><ul>
<li>一个系统有多个外观类<br>在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。在很多情况下为了节约系统资源，一般将外观类设计为单例类。当然这并不意味着在整个系统里只能有一个外观类，在一个系统中可以设计多个外观类，每个外观类都负责和一些特定的子系统交互，向用户提供相应的业务功能。 </li>
<li><p>不要试图通过外观类为子系统增加新行为<br>不要通过继承一个外观类在子系统中加入新的行为，这种做法是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现。 </p>
</li>
<li><p>外观模式与迪米特法则<br>外观模式创造出一个外观对象，将客户端所涉及的属于一个子系统的协作伙伴的数量减到最少，使得客户端与子系统内部的对象的相互作用被外观对象所取代。外观类充当了客户类与子系统类之间的“第三者”，降低了客户类与子系统类之间的耦合度，外观模式就是实现代码重构以便达到“迪米特法则”要求的一个强有力的武器。 </p>
</li>
<li>抽象外观类的引入<br>外观模式最大的缺点在于违背了“开闭原则”，当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。</li>
</ul>
<p>ref: <a href="http://blog.csdn.net/xingjiarong/article/details/50066133" target="_blank" rel="external">http://blog.csdn.net/xingjiarong/article/details/50066133</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-事务管理</title>
    <url>/2017/11/07/Spring-%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>事务的理论知识以及Spring中事务的实现和实例</p>
<a id="more"></a>
<h2 id="初步理解"><a href="#初步理解" class="headerlink" title="初步理解"></a>初步理解</h2><p>理解事务之前，先讲一个你日常生活中最常干的事:取钱。<br>比如你去ATM机取1000块钱，大体有两个步骤:首先输入密码金额，银行卡扣掉1000元钱；然后ATM出1000元钱。这两个步骤必须是要么都执行要么都不执行。如果银行卡扣除了1000块但是ATM出钱失败的话，你将会损失1000元；如果银行卡扣钱失败但是ATM却出了1000块，那么银行将损失1000元。所以，如果一个步骤成功另一个步骤失败对双方都不是好事，如果不管哪一个步骤失败了以后，整个取钱过程都能回滚，也就是完全取消所有操作的话，这对双方都是极好的。<br>事务就是用来解决类似问题的。事务是一系列的动作，它们综合在一起才是一个完整的工作单元，这些动作必须全部完成，如果有一个失败的话，那么事务就会回滚到最开始的状态，仿佛什么都没发生过一样。<br>在企业级应用程序开发中，事务管理必不可少的技术，用来确保数据的完整性和一致性。<br>事务有四个特性:ACID</p>
<ul>
<li>原子性（Atomicity）:事务是一个原子操作，由一系列动作组成。事务的原子性确保动作要么全部完成，要么完全不起作用。</li>
<li>一致性（Consistency）:一旦事务完成（不管成功还是失败），系统必须确保它所建模的业务处于一致的状态，而不会是部分完成部分失败。在现实中的数据不应该被破坏。</li>
<li>隔离性（Isolation）:可能有许多事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏。</li>
<li>持久性（Durability）:一旦事务完成，无论发生什么系统错误，它的结果都不应该受到影响，这样就能从任何系统崩溃中恢复过来。通常情况下，事务的结果被写到持久化存储器中。</li>
</ul>
<h2 id="核心接口"><a href="#核心接口" class="headerlink" title="核心接口"></a>核心接口</h2><p>Spring事务管理的实现有许多细节，如果对整个接口框架有个大体了解会非常有利于我们理解事务，下面通过讲解Spring的事务接口来了解Spring实现事务的具体策略。<br>Spring事务管理涉及的接口的联系如下:<br><img src="20160324011156424" alt="20160324011156424"></p>
<h3 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h3><p>Spring并不直接管理事务，而是提供了多种事务管理器，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。<br>Spring事务管理器的接口是org.springframework.transaction.PlatformTransactionManager，通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。此接口的内容如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function">Public interface <span class="title">PlatformTransactionManager</span><span class="params">()</span>...</span>&#123;  </div><div class="line">    <span class="comment">// 由TransactionDefinition得到TransactionStatus对象</span></div><div class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>; </div><div class="line">    <span class="comment">// 提交</span></div><div class="line">    <span class="function">Void <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </div><div class="line">    <span class="comment">// 回滚</span></div><div class="line">    <span class="function">Void <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这里可知具体的具体的事务管理机制对Spring来说是透明的，它并不关心那些，那些是对应各个平台需要关心的，所以Spring事务管理的一个优点就是为不同的事务API提供一致的编程模型，如JTA、JDBC、Hibernate、JPA。下面分别介绍各个平台框架实现事务管理的机制。</p>
<h4 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h4><p>如果应用程序中直接使用JDBC来进行持久化，DataSourceTransactionManager会为你处理事务边界。为了使用DataSourceTransactionManager，你需要使用如下的XML将其装配到应用程序的上下文定义中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</div><div class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>实际上，DataSourceTransactionManager是通过调用java.sql.Connection来管理事务，而后者是通过DataSource获取到的。通过调用连接的commit()方法来提交事务，同样，事务失败则通过调用rollback()方法进行回滚。</p>
<h4 id="Hibernate事务"><a href="#Hibernate事务" class="headerlink" title="Hibernate事务"></a>Hibernate事务</h4><p>如果应用程序的持久化是通过Hibernate实习的，那么你需要使用HibernateTransactionManager。对于Hibernate3，需要在Spring上下文定义中添加如下的<bean>声明:</bean></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</div><div class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>sessionFactory属性需要装配一个Hibernate的session工厂，HibernateTransactionManager的实现细节是它将事务管理的职责委托给org.hibernate.Transaction对象，而后者是从Hibernate Session中获取到的。当事务成功完成时，HibernateTransactionManager将会调用Transaction对象的commit()方法，反之，将会调用rollback()方法。</p>
<h4 id="Java持久化API事务（JPA）"><a href="#Java持久化API事务（JPA）" class="headerlink" title="Java持久化API事务（JPA）"></a>Java持久化API事务（JPA）</h4><p>Hibernate多年来一直是事实上的Java持久化标准，但是现在Java持久化API作为真正的Java持久化标准进入大家的视野。如果你计划使用JPA的话，那你需要使用Spring的JpaTransactionManager来处理事务。你需要在Spring中这样配置JpaTransactionManager:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&gt;</div><div class="line">    &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>JpaTransactionManager只需要装配一个JPA实体管理工厂（javax.persistence.EntityManagerFactory接口的任意实现）。JpaTransactionManager将与由工厂所产生的JPA EntityManager合作来构建事务。</p>
<h4 id="Java原生API事务"><a href="#Java原生API事务" class="headerlink" title="Java原生API事务"></a>Java原生API事务</h4><p>如果你没有使用以上所述的事务管理，或者是跨越了多个事务管理源（比如两个或者是多个不同的数据源），你就需要使用JtaTransactionManager:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&gt;</div><div class="line">    &lt;property name=&quot;transactionManagerName&quot; value=&quot;java:/TransactionManager&quot; /&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>JtaTransactionManager将事务管理的责任委托给javax.transaction.UserTransaction和javax.transaction.TransactionManager对象，其中事务成功完成通过UserTransaction.commit()方法提交，事务失败通过UserTransaction.rollback()方法回滚。</p>
<h3 id="基本事务属性的定义"><a href="#基本事务属性的定义" class="headerlink" title="基本事务属性的定义"></a>基本事务属性的定义</h3><p>上面讲到的事务管理器接口PlatformTransactionManager通过getTransaction(TransactionDefinition definition)方法来得到事务，这个方法里面的参数是TransactionDefinition类，这个类就定义了一些基本的事务属性。<br>那么什么是事务属性呢？事务属性可以理解成事务的一些基本配置，描述了事务策略如何应用到方法上。事务属性包含了5个方面，如图所示:</p>
<p><img src="20160325003448793" alt="20160325003448793"></p>
<p>而TransactionDefinition接口内容如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span></span>; <span class="comment">// 返回事务的传播行为</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span></span>; <span class="comment">// 返回事务的隔离级别，事务管理器根据它来控制另外一个事务可以看到本事务内的哪些数据</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span></span>;  <span class="comment">// 返回事务必须在多少秒内完成</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>; <span class="comment">// 事务是否只读，事务管理器能够根据这个返回值进行优化，确保事务是只读的</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以发现TransactionDefinition正好用来定义事务属性，下面详细介绍一下各个事务属性。</p>
<h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><p>事务的第一个方面是传播行为（propagation behavior）。当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如:方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。Spring定义了七种传播行为:</p>
<table>
<thead>
<tr>
<th style="text-align:left">传播行为</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PROPAGATION_REQUIRED</td>
<td style="text-align:left">表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_SUPPORTS</td>
<td style="text-align:left">表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_MANDATORY</td>
<td style="text-align:left">表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_REQUIRED_NEW</td>
<td style="text-align:left">表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_NOT_SUPPORTED</td>
<td style="text-align:left">表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_NEVER</td>
<td style="text-align:left">表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常</td>
</tr>
<tr>
<td style="text-align:left">PROPAGATION_NESTED</td>
<td style="text-align:left">表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务</td>
</tr>
</tbody>
</table>
<p>注:以下具体讲解传播行为的内容参考自Spring事务机制详解<br>（1）PROPAGATION_REQUIRED 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。<br>可以把事务想像成一个胶囊，在这个场景下方法B用的是方法A产生的胶囊（事务）</p>
<p><img src="20170420213050220.bmp" alt="20170420213050220.bmp"></p>
<p>举例有两个方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Transactional(propagation = Propagation.REQUIRED)</div><div class="line">public void methodA() &#123;</div><div class="line">    methodB();</div><div class="line">    // do something</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@Transactional(propagation = Propagation.REQUIRED)</div><div class="line">public void methodB() &#123;</div><div class="line">    // do something</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单独调用methodB方法时，因为当前上下文不存在事务，所以会开启一个新的事务。<br>调用methodA方法时，因为当前上下文不存在事务，所以会开启一个新的事务。当执行到methodB时，methodB发现当前上下文有事务，因此就加入到当前事务中来</p>
<p>（2）PROPAGATION_SUPPORTS 如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。但是对于事务同步的事务管理器，PROPAGATION_SUPPORTS与不使用事务有少许不同。</p>
<p>举例有两个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Transactional(propagation = Propagation.REQUIRED)</div><div class="line">public void methodA() &#123;</div><div class="line">    methodB();</div><div class="line">    // do something</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 事务属性为SUPPORTS</div><div class="line">@Transactional(propagation = Propagation.SUPPORTS)</div><div class="line">public void methodB() &#123;</div><div class="line">    // do something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>单纯的调用methodB时，methodB方法是非事务的执行的。当调用methdA时,methodB则加入了methodA的事务中,事务地执行</p>
<p>（3）PROPAGATION_MANDATORY 如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">@Transactional(propagation = Propagation.REQUIRED)</div><div class="line">public void methodA() &#123;</div><div class="line">    methodB();</div><div class="line">    // do something</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 事务属性为MANDATORY</div><div class="line">@Transactional(propagation = Propagation.MANDATORY)</div><div class="line">public void methodB() &#123;</div><div class="line">    // do something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当单独调用methodB时，因为当前没有一个活动的事务，则会抛出异常throw new IllegalTransactionStateException(“Transaction propagation ‘mandatory’ but no existing transaction found”);当调用methodA时，methodB则加入到methodA的事务中，事务地执行。</p>
<p>（4）PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>
<p><img src="20170420213308563.png" alt="20170420213308563.png"></p>
<p>使用PROPAGATION_REQUIRES_NEW,需要使用 JtaTransactionManager作为事务管理器。<br>它会开启一个新的事务。如果一个事务已经存在，则先将这个存在的事务挂起</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Transactional(propagation = Propagation.REQUIRED)</div><div class="line">public void methodA() &#123;</div><div class="line">    doSomeThingA();</div><div class="line">    methodB();</div><div class="line">    doSomeThingB();</div><div class="line">    // do something else</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">// 事务属性为REQUIRES_NEW</div><div class="line">@Transactional(propagation = Propagation.REQUIRES_NEW)</div><div class="line">public void methodB() &#123;</div><div class="line">    // do something</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">main&#123;  </div><div class="line">    methodA();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相当于调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">main()&#123;</div><div class="line">    TransactionManager tm = null;</div><div class="line">    try&#123;</div><div class="line">        //获得一个JTA事务管理器</div><div class="line">        tm = getTransactionManager();</div><div class="line">        tm.begin();//开启一个新的事务</div><div class="line">        Transaction ts1 = tm.getTransaction();</div><div class="line">        doSomeThing();</div><div class="line">        tm.suspend();//挂起当前事务</div><div class="line">        try&#123;</div><div class="line">            tm.begin();//重新开启第二个事务</div><div class="line">            Transaction ts2 = tm.getTransaction();</div><div class="line">            methodB();</div><div class="line">            ts2.commit();//提交第二个事务</div><div class="line">        &#125; Catch(RunTimeException ex) &#123;</div><div class="line">            ts2.rollback();//回滚第二个事务</div><div class="line">        &#125; finally &#123;</div><div class="line">            //释放资源</div><div class="line">        &#125;</div><div class="line">        //methodB执行完后，恢复第一个事务</div><div class="line">        tm.resume(ts1);</div><div class="line">        doSomeThingB();</div><div class="line">        ts1.commit();//提交第一个事务</div><div class="line">    &#125; catch(RunTimeException ex) &#123;</div><div class="line">        ts1.rollback();//回滚第一个事务</div><div class="line">    &#125; finally &#123;</div><div class="line">        //释放资源</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，我把ts1称为外层事务，ts2称为内层事务。从上面的代码可以看出，ts2与ts1是两个独立的事务，互不相干。Ts2是否成功并不依赖于 ts1。如果methodA方法在调用methodB方法后的doSomeThingB方法失败了，而methodB方法所做的结果依然被提交。而除了 methodB之外的其它代码导致的结果却被回滚了。</p>
<p>（5）PROPAGATION_NOT_SUPPORTED<br>PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。<br>PROPAGATION_NOT_SUPPORTED 也需要使用JtaTransactionManager作为事务管理器。</p>
<p><img src="20170420213400079.png" alt="20170420213400079.png"></p>
<p>（6）PROPAGATION_NEVER<br>总是非事务地执行，如果存在一个活动事务，则抛出异常。</p>
<p>（7）PROPAGATION_NESTED</p>
<p><img src="20170420213432872.png" alt="20170420213432872.png"></p>
<p>如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。这是一个嵌套事务,使用JDBC 3.0驱动时,仅仅支持DataSourceTransactionManager作为事务管理器。需要JDBC 驱动的java.sql.Savepoint类。有一些JTA的事务管理器实现可能也提供了同样的功能。使用PROPAGATION_NESTED，还需要把PlatformTransactionManager的nestedTransactionAllowed属性设为true;而 nestedTransactionAllowed属性值默认为false。</p>
<p>这里关键是嵌套执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Transactional(propagation = Propagation.REQUIRED)</div><div class="line">methodA()&#123;</div><div class="line">    doSomeThingA();</div><div class="line">    methodB();</div><div class="line">    doSomeThingB();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@Transactional(propagation = Propagation.NEWSTED)</div><div class="line">methodB()&#123;</div><div class="line">    //...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果单独调用methodB方法，则按REQUIRED属性执行。如果调用methodA方法，相当于下面的效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">main()&#123;</div><div class="line">    Connection con = null;</div><div class="line">    Savepoint savepoint = null;</div><div class="line">    try&#123;</div><div class="line">        con = getConnection();</div><div class="line">        con.setAutoCommit(false);</div><div class="line">        doSomeThingA();</div><div class="line">        savepoint = con2.setSavepoint();</div><div class="line">        try&#123;</div><div class="line">            methodB();</div><div class="line">        &#125; catch(RuntimeException ex) &#123;</div><div class="line">            con.rollback(savepoint);</div><div class="line">        &#125; finally &#123;</div><div class="line">            //释放资源</div><div class="line">        &#125;</div><div class="line">        doSomeThingB();</div><div class="line">        con.commit();</div><div class="line">    &#125; catch(RuntimeException ex) &#123;</div><div class="line">        con.rollback();</div><div class="line">    &#125; finally &#123;</div><div class="line">        //释放资源</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当methodB方法调用之前，调用setSavepoint方法，保存当前的状态到savepoint。如果methodB方法调用失败，则恢复到之前保存的状态。但是需要注意的是，这时的事务并没有进行提交，如果后续的代码(doSomeThingB()方法)调用失败，则回滚包括methodB方法的所有操作。</p>
<p>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</p>
<p><strong>PROPAGATION_NESTED 与PROPAGATION_REQUIRES_NEW的区别</strong><br>它们非常类似,都像一个嵌套事务，如果不存在一个活动的事务，都会开启一个新的事务。使用 PROPAGATION_REQUIRES_NEW时，内层事务与外层事务就像两个独立的事务一样，一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。两个事务不是一个真正的嵌套事务。同时它需要JTA事务管理器的支持。</p>
<p>使用PROPAGATION_NESTED时，外层事务的回滚可以引起内层事务的回滚。而内层事务的异常并不会导致外层事务的回滚，它是一个真正的嵌套事务。DataSourceTransactionManager使用savepoint支持PROPAGATION_NESTED时，需要JDBC 3.0以上驱动及1.4以上的JDK版本支持。其它的JTA TrasactionManager实现可能有不同的支持方式。</p>
<p>PROPAGATION_REQUIRES_NEW 启动一个新的, 不依赖于环境的 “内部” 事务. 这个事务将被完全 commited 或 rolled back 而不依赖于外部事务, 它拥有自己的隔离范围, 自己的锁, 等等. 当内部事务开始执行时, 外部事务将被挂起, 内务事务结束时, 外部事务将继续执行。</p>
<p>另一方面, PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 潜套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 潜套事务是外部事务的一部分, 只有外部事务结束后它才会被提交。</p>
<p>由此可见, PROPAGATION_REQUIRES_NEW 和 PROPAGATION_NESTED 的最大区别在于, PROPAGATION_REQUIRES_NEW 完全是一个新的事务, 而 PROPAGATION_NESTED 则是外部事务的子事务, 如果外部事务 commit, 嵌套事务也会被 commit, 这个规则同样适用于 roll back.</p>
<p>PROPAGATION_REQUIRED应该是我们首选的事务传播行为。它能够满足我们大多数的事务需求。</p>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>事务的第二个维度就是隔离级别（isolation level）。隔离级别定义了一个事务可能受其他并发事务影响的程度。<br>（1）并发事务引起的问题<br>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务。并发虽然是必须的，但可能会导致一下的问题。</p>
<ul>
<li><strong>脏读</strong>（Dirty reads）——脏读发生在一个事务读取了另一个事务改写但尚未提交的数据时。如果改写在稍后被回滚了，那么第一个事务获取的数据就是无效的。</li>
<li><strong>不可重复读</strong>（Nonrepeatable read）——不可重复读发生在一个事务执行相同的查询两次或两次以上，但是每次都得到不同的数据时。这通常是因为另一个并发事务在两次查询期间进行了更新。</li>
<li><strong>幻读</strong>（Phantom read）——幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录。</li>
</ul>
<p><strong>不可重复读与幻读的区别</strong></p>
<p><strong>不可重复读的重点是修改</strong>:<br>同样的条件, 你读取过的数据, 再次读取出来发现值不一样了<br>例如:在事务1中，Mary 读取了自己的工资为1000,操作并没有完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">con1 = getConnection();  </div><div class="line">select salary from employee empId =&quot;Mary&quot;;</div></pre></td></tr></table></figure>
<p>在事务2中，这时财务人员修改了Mary的工资为2000,并提交了事务.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">con2 = getConnection();  </div><div class="line">update employee set salary = 2000;  </div><div class="line">con2.commit();</div></pre></td></tr></table></figure>
<p>在事务1中，Mary 再次读取自己的工资时，工资变为了2000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//con1  </div><div class="line">select salary from employee empId =&quot;Mary&quot;;</div></pre></td></tr></table></figure>
<p>在一个事务中前后两次读取的结果并不一致，导致了不可重复读。</p>
<p><strong>幻读的重点在于新增或者删除</strong>:<br>同样的条件, 第1次和第2次读出来的记录数不一样<br>例如:目前工资为1000的员工有10人。事务1,读取所有工资为1000的员工。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">con1 = getConnection();  </div><div class="line">Select * from employee where salary =1000;</div></pre></td></tr></table></figure>
<p>共读取10条记录</p>
<p>这时另一个事务向employee表插入了一条员工记录，工资也为1000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">con2 = getConnection();  </div><div class="line">Insert into employee(empId,salary) values(&quot;Lili&quot;,1000);  </div><div class="line">con2.commit();</div></pre></td></tr></table></figure>
<p>事务1再次读取所有工资为1000的员工</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//con1  </div><div class="line">select * from employee where salary =1000;</div></pre></td></tr></table></figure>
<p>共读取到了11条记录，这就产生了幻像读。</p>
<p>从总的结果来看, 似乎不可重复读和幻读都表现为两次读取的结果不一致。但如果你从控制的角度来看, 两者的区别就比较大。<br>对于前者, 只需要锁住满足条件的记录。<br>对于后者, 要锁住满足条件及其相近的记录。</p>
<p>（2）隔离级别</p>
<table>
<thead>
<tr>
<th style="text-align:left">隔离级别</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ISOLATION_DEFAULT</td>
<td style="text-align:left">使用后端数据库默认的隔离级别</td>
</tr>
<tr>
<td style="text-align:left">ISOLATION_READ_UNCOMMITTED</td>
<td style="text-align:left">最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</td>
</tr>
<tr>
<td style="text-align:left">ISOLATION_READ_COMMITTED</td>
<td style="text-align:left">允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</td>
</tr>
<tr>
<td style="text-align:left">ISOLATION_REPEATABLE_READ</td>
<td style="text-align:left">对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</td>
</tr>
<tr>
<td style="text-align:left">ISOLATION_SERIALIZABLE</td>
<td style="text-align:left">最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的</td>
</tr>
</tbody>
</table>
<h4 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h4><p>事务的第三个特性是它是否为只读事务。如果事务只对后端的数据库进行该操作，数据库可以利用事务的只读特性来进行一些特定的优化。通过将事务设置为只读，你就可以给数据库一个机会，让它应用它认为合适的优化措施。</p>
<h4 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h4><p>为了使应用程序很好地运行，事务不能运行太长的时间。因为事务可能涉及对后端数据库的锁定，所以长时间的事务会不必要的占用数据库资源。事务超时就是事务的一个定时器，在特定时间内事务如果没有执行完毕，那么就会自动回滚，而不是一直等待其结束。</p>
<h4 id="回滚规则"><a href="#回滚规则" class="headerlink" title="回滚规则"></a>回滚规则</h4><p>事务五边形的最后一个方面是一组规则，这些规则定义了哪些异常会导致事务回滚而哪些不会。默认情况下，事务只有遇到运行期异常时才会回滚，而在遇到检查型异常时不会回滚（这一行为与EJB的回滚行为是一致的）<br>但是你可以声明事务在遇到特定的检查型异常时像遇到运行期异常那样回滚。同样，你还可以声明事务遇到特定的异常不回滚，即使这些异常是运行期异常。</p>
<h3 id="事务状态"><a href="#事务状态" class="headerlink" title="事务状态"></a>事务状态</h3><p>上面讲到的调用PlatformTransactionManager接口的getTransaction()的方法得到的是TransactionStatus接口的一个实现，这个接口的内容如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>; <span class="comment">// 是否是新的事物</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>; <span class="comment">// 是否有恢复点</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  <span class="comment">// 设置为只回滚</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>; <span class="comment">// 是否为只回滚</span></div><div class="line">    <span class="keyword">boolean</span> isCompleted; <span class="comment">// 是否已完成</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以发现这个接口描述的是一些处理事务提供简单的控制事务执行和查询事务状态的方法，在回滚或提交的时候需要应用对应的事务状态。</p>
<h2 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h2><h3 id="编程式和声明式事务的区别"><a href="#编程式和声明式事务的区别" class="headerlink" title="编程式和声明式事务的区别"></a>编程式和声明式事务的区别</h3><p>Spring提供了对编程式事务和声明式事务的支持，编程式事务允许用户在代码中精确定义事务的边界，而声明式事务（基于AOP）有助于用户将操作与事务规则进行解耦。<br>简单地说，编程式事务侵入到了业务代码里面，但是提供了更加详细的事务管理；而声明式事务由于基于AOP，所以既能起到事务管理的作用，又可以不影响业务代码的具体实现。</p>
<h3 id="如何实现编程式事务？"><a href="#如何实现编程式事务？" class="headerlink" title="如何实现编程式事务？"></a>如何实现编程式事务？</h3><p>Spring提供两种方式的编程式事务管理，分别是:使用TransactionTemplate和直接使用PlatformTransactionManager。</p>
<h4 id="使用TransactionTemplate"><a href="#使用TransactionTemplate" class="headerlink" title="使用TransactionTemplate"></a>使用TransactionTemplate</h4><p>采用TransactionTemplate和采用其他Spring模板，如JdbcTempalte和HibernateTemplate是一样的方法。它使用回调方法，把应用程序从处理取得和释放资源中解脱出来。如同其他模板，TransactionTemplate是线程安全的。代码片段:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">TransactionTemplate tt = <span class="keyword">new</span> TransactionTemplate(); <span class="comment">// 新建一个TransactionTemplate</span></div><div class="line">Object result = tt.execute(</div><div class="line">    <span class="keyword">new</span> TransactionCallback()&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">doTransaction</span><span class="params">(TransactionStatus status)</span></span>&#123;  </div><div class="line">            updateOperation();  </div><div class="line">            <span class="keyword">return</span> resultOfUpdateOperation();  </div><div class="line">        &#125;  </div><div class="line">&#125;); <span class="comment">// 执行execute方法进行事务管理</span></div></pre></td></tr></table></figure>
<p>使用TransactionCallback()可以返回一个值。如果使用TransactionCallbackWithoutResult则没有返回值。</p>
<h4 id="使用PlatformTransactionManager"><a href="#使用PlatformTransactionManager" class="headerlink" title="使用PlatformTransactionManager"></a>使用PlatformTransactionManager</h4><p>示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DataSourceTransactionManager dataSourceTransactionManager = <span class="keyword">new</span> DataSourceTransactionManager(); <span class="comment">//定义一个某个框架平台的TransactionManager，如JDBC、Hibernate</span></div><div class="line">dataSourceTransactionManager.setDataSource(<span class="keyword">this</span>.getJdbcTemplate().getDataSource()); <span class="comment">// 设置数据源</span></div><div class="line">DefaultTransactionDefinition transDef = <span class="keyword">new</span> DefaultTransactionDefinition(); <span class="comment">// 定义事务属性</span></div><div class="line">transDef.setPropagationBehavior(DefaultTransactionDefinition.PROPAGATION_REQUIRED); <span class="comment">// 设置传播行为属性</span></div><div class="line">TransactionStatus status = dataSourceTransactionManager.getTransaction(transDef); <span class="comment">// 获得事务状态</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// 数据库操作</span></div><div class="line">    dataSourceTransactionManager.commit(status);<span class="comment">// 提交</span></div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    dataSourceTransactionManager.rollback(status);<span class="comment">// 回滚</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><p>注:以下配置代码参考自Spring事务配置的五种方式</p>
<p>根据代理机制的不同，总结了五种Spring事务的配置方式，配置文件如下:</p>
<p>（1）每个Bean都有一个代理<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div class="line">           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/context</div><div class="line">           http://www.springframework.org/schema/context/spring-context-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt; </div><div class="line">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt; </div><div class="line">        &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;</div><div class="line">    &lt;/bean&gt; </div><div class="line"></div><div class="line">    &lt;!-- 定义事务管理器（声明式的事务） --&gt; </div><div class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</div><div class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;!-- 配置DAO --&gt;</div><div class="line">    &lt;bean id=&quot;userDaoTarget&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;</div><div class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;&gt; </div><div class="line">       &lt;!-- 配置事务管理器 --&gt; </div><div class="line">        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt;    </div><div class="line">        &lt;property name=&quot;target&quot; ref=&quot;userDaoTarget&quot; /&gt; </div><div class="line">         &lt;property name=&quot;proxyInterfaces&quot; value=&quot;com.bluesky.spring.dao.GeneratorDao&quot; /&gt;</div><div class="line">        &lt;!-- 配置事务属性 --&gt; </div><div class="line">        &lt;property name=&quot;transactionAttributes&quot;&gt; </div><div class="line">            &lt;props&gt; </div><div class="line">                &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt;</div><div class="line">            &lt;/props&gt; </div><div class="line">        &lt;/property&gt; </div><div class="line">    &lt;/bean&gt; </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>（2）所有Bean共享一个代理基类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div class="line">           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/context</div><div class="line">           http://www.springframework.org/schema/context/spring-context-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt; </div><div class="line">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt; </div><div class="line">        &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;</div><div class="line">    &lt;/bean&gt; </div><div class="line"></div><div class="line">    &lt;!-- 定义事务管理器（声明式的事务） --&gt; </div><div class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</div><div class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;bean id=&quot;transactionBase&quot; class=&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot; </div><div class="line">            lazy-init=&quot;true&quot; abstract=&quot;true&quot;&gt; </div><div class="line">        &lt;!-- 配置事务管理器 --&gt; </div><div class="line">        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt; </div><div class="line">        &lt;!-- 配置事务属性 --&gt; </div><div class="line">        &lt;property name=&quot;transactionAttributes&quot;&gt; </div><div class="line">            &lt;props&gt; </div><div class="line">                &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt; </div><div class="line">            &lt;/props&gt; </div><div class="line">        &lt;/property&gt; </div><div class="line">    &lt;/bean&gt;   </div><div class="line"></div><div class="line">    &lt;!-- 配置DAO --&gt;</div><div class="line">    &lt;bean id=&quot;userDaoTarget&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;</div><div class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;bean id=&quot;userDao&quot; parent=&quot;transactionBase&quot; &gt; </div><div class="line">        &lt;property name=&quot;target&quot; ref=&quot;userDaoTarget&quot; /&gt;  </div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>（3）使用拦截器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div class="line">           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/context</div><div class="line">           http://www.springframework.org/schema/context/spring-context-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt; </div><div class="line">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt; </div><div class="line">        &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;</div><div class="line">    &lt;/bean&gt; </div><div class="line"></div><div class="line">    &lt;!-- 定义事务管理器（声明式的事务） --&gt; </div><div class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</div><div class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">    &lt;/bean&gt; </div><div class="line"></div><div class="line">    &lt;bean id=&quot;transactionInterceptor&quot; class=&quot;org.springframework.transaction.interceptor.TransactionInterceptor&quot;&gt; </div><div class="line">        &lt;property name=&quot;transactionManager&quot; ref=&quot;transactionManager&quot; /&gt; </div><div class="line">        &lt;!-- 配置事务属性 --&gt; </div><div class="line">        &lt;property name=&quot;transactionAttributes&quot;&gt; </div><div class="line">            &lt;props&gt; </div><div class="line">                &lt;prop key=&quot;*&quot;&gt;PROPAGATION_REQUIRED&lt;/prop&gt; </div><div class="line">            &lt;/props&gt; </div><div class="line">        &lt;/property&gt; </div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;bean class=&quot;org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator&quot;&gt; </div><div class="line">        &lt;property name=&quot;beanNames&quot;&gt; </div><div class="line">            &lt;list&gt; </div><div class="line">                &lt;value&gt;*Dao&lt;/value&gt;</div><div class="line">            &lt;/list&gt; </div><div class="line">        &lt;/property&gt; </div><div class="line">        &lt;property name=&quot;interceptorNames&quot;&gt; </div><div class="line">            &lt;list&gt; </div><div class="line">                &lt;value&gt;transactionInterceptor&lt;/value&gt; </div><div class="line">            &lt;/list&gt; </div><div class="line">        &lt;/property&gt; </div><div class="line">    &lt;/bean&gt; </div><div class="line"></div><div class="line">    &lt;!-- 配置DAO --&gt;</div><div class="line">    &lt;bean id=&quot;userDao&quot; class=&quot;com.bluesky.spring.dao.UserDaoImpl&quot;&gt;</div><div class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>（4）使用tx标签配置的拦截器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</div><div class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div class="line">           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/context</div><div class="line">           http://www.springframework.org/schema/context/spring-context-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;context:annotation-config /&gt;</div><div class="line">    &lt;context:component-scan base-package=&quot;com.bluesky&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt; </div><div class="line">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt; </div><div class="line">        &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;</div><div class="line">    &lt;/bean&gt; </div><div class="line"></div><div class="line">    &lt;!-- 定义事务管理器（声明式的事务） --&gt; </div><div class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</div><div class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line"></div><div class="line">    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</div><div class="line">        &lt;tx:attributes&gt;</div><div class="line">            &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; /&gt;</div><div class="line">        &lt;/tx:attributes&gt;</div><div class="line">    &lt;/tx:advice&gt;</div><div class="line"></div><div class="line">    &lt;aop:config&gt;</div><div class="line">        &lt;aop:pointcut id=&quot;interceptorPointCuts&quot; expression=&quot;execution(* com.bluesky.spring.dao.*.*(..))&quot; /&gt;</div><div class="line">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;interceptorPointCuts&quot; /&gt;       </div><div class="line">    &lt;/aop:config&gt;     </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>（5）全注解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</div><div class="line">    xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div class="line">           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/context</div><div class="line">           http://www.springframework.org/schema/context/spring-context-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</div><div class="line">           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;context:annotation-config /&gt;</div><div class="line">    &lt;context:component-scan base-package=&quot;com.bluesky&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt; </div><div class="line">        &lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot; /&gt; </div><div class="line">        &lt;property name=&quot;configurationClass&quot; value=&quot;org.hibernate.cfg.AnnotationConfiguration&quot; /&gt;</div><div class="line">    &lt;/bean&gt; </div><div class="line"></div><div class="line">    &lt;!-- 定义事务管理器（声明式的事务） --&gt; </div><div class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate3.HibernateTransactionManager&quot;&gt;</div><div class="line">        &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>此时在DAO上需加上@Transactional注解，如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.bluesky.spring.dao;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.orm.hibernate3.support.HibernateDaoSupport;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</div><div class="line"><span class="keyword">import</span> com.bluesky.spring.domain.User;</div><div class="line"></div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="meta">@Component</span>(<span class="string">"userDao"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">HibernateDaoSupport</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">listUsers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getSession().createQuery(<span class="string">"from User"</span>).list();</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="一个声明式事务的实例"><a href="#一个声明式事务的实例" class="headerlink" title="一个声明式事务的实例"></a>一个声明式事务的实例</h3><p>注:该实例参考自Spring中的事务管理实例详解</p>
<p>首先是数据库表<br>book(isbn, book_name, price)<br>account(username, balance)<br>book_stock(isbn, stock)</p>
<p>然后是XML配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</div><div class="line">xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</div><div class="line">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</div><div class="line">xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</div><div class="line">http://www.springframework.org/schema/context</div><div class="line">http://www.springframework.org/schema/context/spring-context-3.0.xsd</div><div class="line">http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd</div><div class="line">http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd&quot;&gt;</div><div class="line"></div><div class="line">    &lt;import resource=&quot;applicationContext-db.xml&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;context:component-scan base-package=&quot;com.springinaction.transaction&quot;&gt;&lt;/context:component-scan&gt;</div><div class="line"></div><div class="line">    &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;</div><div class="line"></div><div class="line">    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</div><div class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</div><div class="line">    &lt;/bean&gt;</div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>使用的类<br>BookShopDao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.springinaction.transaction;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookShopDao</span> </span>&#123;</div><div class="line">    <span class="comment">// 根据书号获取书的单价</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBookPriceByIsbn</span><span class="params">(String isbn)</span></span>;</div><div class="line">    <span class="comment">// 更新书的库存，使书号对应的库存-1</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBookStock</span><span class="params">(String isbn)</span></span>;</div><div class="line">    <span class="comment">// 更新用户的账户余额:account的balance-price</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUserAccount</span><span class="params">(String username, <span class="keyword">int</span> price)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BookShopDaoImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.springinaction.transaction;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</div><div class="line"></div><div class="line"><span class="meta">@Repository</span>(<span class="string">"bookShopDao"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShopDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookShopDao</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> JdbcTemplate JdbcTemplate;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findBookPriceByIsbn</span><span class="params">(String isbn)</span> </span>&#123;</div><div class="line">        String sql = <span class="string">"SELECT price FROM book WHERE isbn = ?"</span>;</div><div class="line">        <span class="keyword">return</span> JdbcTemplate.queryForObject(sql, Integer.class, isbn);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBookStock</span><span class="params">(String isbn)</span> </span>&#123;</div><div class="line">        <span class="comment">//检查书的库存是否足够，若不够，则抛出异常</span></div><div class="line">        String sql2 = <span class="string">"SELECT stock FROM book_stock WHERE isbn = ?"</span>;</div><div class="line">        <span class="keyword">int</span> stock = JdbcTemplate.queryForObject(sql2, Integer.class, isbn);</div><div class="line">        <span class="keyword">if</span> (stock == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BookStockException(<span class="string">"库存不足！"</span>);</div><div class="line">        &#125;</div><div class="line">        String sql = <span class="string">"UPDATE book_stock SET stock = stock - 1 WHERE isbn = ?"</span>;</div><div class="line">        JdbcTemplate.update(sql, isbn);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUserAccount</span><span class="params">(String username, <span class="keyword">int</span> price)</span> </span>&#123;</div><div class="line">        <span class="comment">//检查余额是否不足，若不足，则抛出异常</span></div><div class="line">        String sql2 = <span class="string">"SELECT balance FROM account WHERE username = ?"</span>;</div><div class="line">        <span class="keyword">int</span> balance = JdbcTemplate.queryForObject(sql2, Integer.class, username);</div><div class="line">        <span class="keyword">if</span> (balance &lt; price) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UserAccountException(<span class="string">"余额不足！"</span>);</div><div class="line">        &#125;       </div><div class="line">        String sql = <span class="string">"UPDATE account SET balance = balance - ? WHERE username = ?"</span>;</div><div class="line">        JdbcTemplate.update(sql, price, username);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BookShopService</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.springinaction.transaction;</div><div class="line">public interface BookShopService &#123;</div><div class="line">     public void purchase(String username, String isbn);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BookShopServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.springinaction.transaction;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</div><div class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Isolation;</div><div class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Propagation;</div><div class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</div><div class="line"></div><div class="line"><span class="meta">@Service</span>(<span class="string">"bookShopService"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookShopServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookShopService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> BookShopDao bookShopDao;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 1.添加事务注解</div><div class="line">     * 使用propagation 指定事务的传播行为，即当前的事务方法被另外一个事务方法调用时如何使用事务。</div><div class="line">     * 默认取值为REQUIRED，即使用调用方法的事务</div><div class="line">     * REQUIRES_NEW:使用自己的事务，调用的事务方法的事务被挂起。</div><div class="line">     *</div><div class="line">     * 2.使用isolation 指定事务的隔离级别，最常用的取值为READ_COMMITTED</div><div class="line">     * 3.默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚，也可以通过对应的属性进行设置。通常情况下，默认值即可。</div><div class="line">     * 4.使用readOnly 指定事务是否为只读。 表示这个事务只读取数据但不更新数据，这样可以帮助数据库引擎优化事务。若真的是一个只读取数据库值得方法，应设置readOnly=true</div><div class="line">     * 5.使用timeOut 指定强制回滚之前事务可以占用的时间。</div><div class="line">     */</div><div class="line">    <span class="meta">@Transactional</span>(propagation=Propagation.REQUIRES_NEW,</div><div class="line">            isolation=Isolation.READ_COMMITTED,</div><div class="line">            noRollbackFor=&#123;UserAccountException.class&#125;,</div><div class="line">            readOnly=<span class="keyword">true</span>, timeout=<span class="number">3</span>)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchase</span><span class="params">(String username, String isbn)</span> </span>&#123;</div><div class="line">        <span class="comment">//1.获取书的单价</span></div><div class="line">        <span class="keyword">int</span> price = bookShopDao.findBookPriceByIsbn(isbn);</div><div class="line">        <span class="comment">//2.更新书的库存</span></div><div class="line">        bookShopDao.updateBookStock(isbn);</div><div class="line">        <span class="comment">//3.更新用户余额</span></div><div class="line">        bookShopDao.updateUserAccount(username, price);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Cashier</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.springinaction.transaction;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cashier</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkout</span><span class="params">(String username, List&lt;String&gt;isbns)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CashierImpl:CashierImpl.checkout和bookShopService.purchase联合测试了事务的传播行为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.springinaction.transaction;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</div><div class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</div><div class="line"></div><div class="line"><span class="meta">@Service</span>(<span class="string">"cashier"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashierImpl</span> <span class="keyword">implements</span> <span class="title">Cashier</span> </span>&#123;</div><div class="line">    <span class="meta">@Autowired</span></div><div class="line">    <span class="keyword">private</span> BookShopService bookShopService;</div><div class="line"></div><div class="line">    <span class="meta">@Transactional</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkout</span><span class="params">(String username, List&lt;String&gt; isbns)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(String isbn : isbns) &#123;</div><div class="line">            bookShopService.purchase(username, isbn);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BookStockException</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.springinaction.transaction;</div><div class="line">public class BookStockException extends RuntimeException &#123;</div><div class="line"></div><div class="line">    private static final long serialVersionUID = 1L;</div><div class="line"></div><div class="line">    public BookStockException() &#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BookStockException(String arg0, Throwable arg1, boolean arg2, boolean arg3) &#123;</div><div class="line">        super(arg0, arg1, arg2, arg3);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BookStockException(String arg0, Throwable arg1) &#123;</div><div class="line">        super(arg0, arg1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BookStockException(String arg0) &#123;</div><div class="line">        super(arg0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public BookStockException(Throwable arg0) &#123;</div><div class="line">        super(arg0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>UserAccountException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.springinaction.transaction;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAccountException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAccountException</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAccountException</span><span class="params">(String arg0, Throwable arg1, <span class="keyword">boolean</span> arg2, <span class="keyword">boolean</span> arg3)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(arg0, arg1, arg2, arg3);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAccountException</span><span class="params">(String arg0, Throwable arg1)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(arg0, arg1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAccountException</span><span class="params">(String arg0)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(arg0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserAccountException</span><span class="params">(Throwable arg0)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(arg0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.springinaction.transaction;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTransitionTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ApplicationContext ctx = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> BookShopDao bookShopDao = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> BookShopService bookShopService = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> Cashier cashier = <span class="keyword">null</span>;</div><div class="line">    &#123;</div><div class="line">        ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config/transaction.xml"</span>);</div><div class="line">        bookShopDao = ctx.getBean(BookShopDao.class);</div><div class="line">        bookShopService = ctx.getBean(BookShopService.class);</div><div class="line">        cashier = ctx.getBean(Cashier.class);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBookShopDaoFindPriceByIsbn</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(bookShopDao.findBookPriceByIsbn(<span class="string">"1001"</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBookShopDaoUpdateBookStock</span><span class="params">()</span></span>&#123;</div><div class="line">        bookShopDao.updateBookStock(<span class="string">"1001"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBookShopDaoUpdateUserAccount</span><span class="params">()</span></span>&#123;</div><div class="line">        bookShopDao.updateUserAccount(<span class="string">"AA"</span>, <span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBookShopService</span><span class="params">()</span></span>&#123;</div><div class="line">        bookShopService.purchase(<span class="string">"AA"</span>, <span class="string">"1001"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTransactionPropagation</span><span class="params">()</span></span>&#123;</div><div class="line">        cashier.checkout(<span class="string">"AA"</span>, Arrays.asList(<span class="string">"1001"</span>, <span class="string">"1002"</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OVER</p>
<p>ref:<br><a href="http://www.mamicode.com/info-detail-1248286.html" target="_blank" rel="external">http://www.mamicode.com/info-detail-1248286.html</a><br><a href="https://blog.csdn.net/weixin_39625809/article/details/80707695" target="_blank" rel="external">https://blog.csdn.net/weixin_39625809/article/details/80707695</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-组合模式</title>
    <url>/2017/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念<br>，客户程序可以向处理简单元素一样来处理复杂元素,从而使得客户程序与复杂元素的内部结构解耦。组合模式让你可以优化处理递<br>归或分级数据结构。有许多关于分级数据结构的例子，使得组合模式非常有用武之地。关于分级数据结构的一个普遍性的例子是你每<br>次使用电脑时所遇到的:文件系统。文件系统由目录和文件组成。每个目录都可以装内容。目录的内容可以是文件，也可以是目录。<br>按照这种方式，计算机的文件系统就是以递归结构来组织的。如果你想要描述这样的数据结构，那么你可以使用组合模式Composite。<br>文件和目录都执行相同的接口，这是组合模式的关键。通过执行相同的接口，你就可以用相同的方式对待文件和目录，<br>从而实现将文件或者目录储存为目录的子级元素。</p>
<p><strong>定义</strong>(GoF《设计模式》):将对象组合成树形结构以表示“部分整体”的层次结构。组合模式使得用户对单个对象和使用具有一致性。</p>
<a id="more"></a>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><img src="/2017/11/07/设计模式-组合模式/1340694955_4501.jpg" alt="1340694955_4501.jpg" title="">
<p>涉及角色:</p>
<ol>
<li>Component 是组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component<br>子部件。</li>
<li>Leaf 在组合中表示叶子结点对象，叶子结点没有子结点。</li>
<li>Composite 定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;  </div><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentDemo</span> </span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;  </div><div class="line">        String name;  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span></span>;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span></span>;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eachChild</span><span class="params">()</span></span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 组合部件类  </span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;  </div><div class="line">  </div><div class="line">        <span class="comment">// 叶子节点不具备添加的能力，所以不实现  </span></div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span> </span>&#123;  </div><div class="line">            System.out.println(<span class="string">""</span>);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// 叶子节点不具备添加的能力必然也不能删除  </span></div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span> </span>&#123;  </div><div class="line">            System.out.println(<span class="string">""</span>);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// 叶子节点没有子节点所以显示自己的执行结果  </span></div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eachChild</span><span class="params">()</span> </span>&#123;  </div><div class="line">            System.out.println(name + <span class="string">"执行了"</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 组合类  </span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;  </div><div class="line">  </div><div class="line">        <span class="comment">// 用来保存节点的子节点  </span></div><div class="line">        List&lt;Component&gt; list = <span class="keyword">new</span> ArrayList&lt;Component&gt;();  </div><div class="line">  </div><div class="line">        <span class="comment">// 添加节点 添加部件  </span></div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component c)</span> </span>&#123;  </div><div class="line">            list.add(c);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// 删除节点 删除部件  </span></div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component c)</span> </span>&#123;  </div><div class="line">            list.remove(c);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// 遍历子节点  </span></div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eachChild</span><span class="params">()</span> </span>&#123;  </div><div class="line">            System.out.println(name + <span class="string">"执行了"</span>);  </div><div class="line">            <span class="keyword">for</span> (Component c : list) &#123;  </div><div class="line">                c.eachChild();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        ComponentDemo demo = <span class="keyword">new</span> ComponentDemo();  </div><div class="line">        <span class="comment">// 构造根节点  </span></div><div class="line">        Composite rootComposite = demo.new Composite();  </div><div class="line">        rootComposite.name = <span class="string">"根节点"</span>;  </div><div class="line">  </div><div class="line">        <span class="comment">// 左节点  </span></div><div class="line">        Composite compositeLeft = demo.new Composite();  </div><div class="line">        compositeLeft.name = <span class="string">"左节点"</span>;  </div><div class="line">  </div><div class="line">        <span class="comment">// 构建右节点，添加两个叶子几点，也就是子部件  </span></div><div class="line">        Composite compositeRight = demo.new Composite();  </div><div class="line">        compositeRight.name = <span class="string">"右节点"</span>;  </div><div class="line">        Leaf leaf1 = demo.new Leaf();  </div><div class="line">        leaf1.name = <span class="string">"右-子节点1"</span>;  </div><div class="line">        Leaf leaf2 = demo.new Leaf();  </div><div class="line">        leaf2.name = <span class="string">"右-子节点2"</span>;  </div><div class="line">        compositeRight.add(leaf1);  </div><div class="line">        compositeRight.add(leaf2);  </div><div class="line">  </div><div class="line">        <span class="comment">// 左右节点加入 根节点  </span></div><div class="line">        rootComposite.add(compositeRight);  </div><div class="line">        rootComposite.add(compositeLeft);  </div><div class="line">        <span class="comment">// 遍历组合部件  </span></div><div class="line">        rootComposite.eachChild();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">根节点执行了</div><div class="line">右节点执行了</div><div class="line">右-子节点1执行了</div><div class="line">右-子节点2执行了</div><div class="line">左节点执行了</div></pre></td></tr></table></figure></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>就拿剪发办卡的事情来分析一下吧。<br>首先，一张卡可以在总部，分店，加盟店使用，那么总部可以刷卡，分店也可以刷卡，加盟店也可以刷卡，这个属性结构的店面层级关系就明确啦。<br>那么，总店刷卡消费与分店刷卡消费是一样的道理，那么总店与分店对会员卡的使用也具有一致性。<br><img src="/2017/11/07/设计模式-组合模式/20140331075052640.jpg" alt="20140331075052640.jpg" title=""></p>
<p>那么我们就根据我们会员卡的消费，来模拟一下组合模式的实现吧<br>首先:<br>1.我们的部件有，总店，分店，加盟店！<br>2.我们的部件共有的行为是:刷会员卡<br>3.部件之间的层次关系，也就是店面的层次关系是，总店下有分店、分店下可以拥有加盟店。<br>有了我们这几个必要条件后，我的要求就是目前店面搞活动当我在总店刷卡后，就可以累积相当于在所有下级店面刷卡的积分总额，设计的代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;  </div><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line">  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayDemo</span> </span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Market</span> </span>&#123;  </div><div class="line">        String name;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Market m)</span></span>;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Market m)</span></span>;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">PayByCard</span><span class="params">()</span></span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 分店 下面可以有加盟店  </span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarketBranch</span> <span class="keyword">extends</span> <span class="title">Market</span> </span>&#123;  </div><div class="line">        <span class="comment">// 加盟店列表  </span></div><div class="line">        List&lt;Market&gt; list = <span class="keyword">new</span> ArrayList&lt;PayDemo.Market&gt;();  </div><div class="line">  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MarketBranch</span><span class="params">(String s)</span> </span>&#123;  </div><div class="line">            <span class="keyword">this</span>.name = s;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Market m)</span> </span>&#123;  </div><div class="line">            list.add(m);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Market m)</span> </span>&#123;  </div><div class="line">            list.remove(m);  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="comment">// 消费之后，该分店下的加盟店自动累加积分  </span></div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PayByCard</span><span class="params">()</span> </span>&#123;  </div><div class="line">            System.out.println(name + <span class="string">"消费,积分已累加入该会员卡"</span>);  </div><div class="line">            <span class="keyword">for</span> (Market m : list) &#123;  </div><div class="line">                m.PayByCard();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="comment">// 加盟店 下面不在有分店和加盟店，最底层  </span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarketJoin</span> <span class="keyword">extends</span> <span class="title">Market</span> </span>&#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MarketJoin</span><span class="params">(String s)</span> </span>&#123;  </div><div class="line">            <span class="keyword">this</span>.name = s;  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Market m)</span> </span>&#123;  &#125;  </div><div class="line">  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Market m)</span> </span>&#123;  &#125;  </div><div class="line">  </div><div class="line">        <span class="meta">@Override</span>  </div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PayByCard</span><span class="params">()</span> </span>&#123;  </div><div class="line">            System.out.println(name + <span class="string">"消费,积分已累加入该会员卡"</span>);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        PayDemo demo = <span class="keyword">new</span> PayDemo();  </div><div class="line">          </div><div class="line">        MarketBranch rootBranch = demo.new MarketBranch(<span class="string">"总店"</span>);  </div><div class="line">        MarketBranch qhdBranch = demo.new MarketBranch(<span class="string">"秦皇岛分店"</span>);  </div><div class="line">        MarketJoin hgqJoin = demo.new MarketJoin(<span class="string">"秦皇岛分店一海港区加盟店"</span>);  </div><div class="line">        MarketJoin btlJoin = demo.new MarketJoin(<span class="string">"秦皇岛分店二白塔岭加盟店"</span>);  </div><div class="line">          </div><div class="line">        qhdBranch.add(hgqJoin);  </div><div class="line">        qhdBranch.add(btlJoin);  </div><div class="line">        rootBranch.add(qhdBranch);  </div><div class="line">        rootBranch.PayByCard();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果如下:<br><img src="/2017/11/07/设计模式-组合模式/20140331083848187.jpg" alt="20140331083848187.jpg" title=""><br>这样在累积所有子店面积分的时候，就不需要去关心子店面的个数了，也不用关系是否是叶子节点还是组合节点了，也就是说不管是总店刷卡，还是加盟店刷卡，都可以正确有效的计算出活动积分。</p>
<h2 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h2><p>以下情况下适用Composite模式:</p>
<ol>
<li>你想表示对象的部分-整体层次结构</li>
<li>你希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>组合模式解耦了客户程序与复杂元素内部结构，从而使客户程序可以向处理简单元素一样来处理复杂元素。<br>如果你想要创建层次结构，并可以在其中以相同的方式对待所有元素，那么组合模式就是最理想的选择。</p>
<p>ref:<br><a href="http://blog.csdn.net/jason0539/article/details/22642281" target="_blank" rel="external">http://blog.csdn.net/jason0539/article/details/22642281</a><br><a href="http://blog.csdn.net/hfmbook/article/details/7693069" target="_blank" rel="external">http://blog.csdn.net/hfmbook/article/details/7693069</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-适配模式</title>
    <url>/2017/11/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在阎宏博士的《JAVA与模式》一书中开头是这样描述适配器（Adapter）模式的:</p>
<p>适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p>
<a id="more"></a>
<h2 id="适配器模式的用途"><a href="#适配器模式的用途" class="headerlink" title="适配器模式的用途"></a>适配器模式的用途</h2><p>用电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。</p>
<p>适配器模式的结构<br>适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。</p>
<h2 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h2><p>类的适配器模式把适配的类的API转换成为目标类的API。<br><img src="/2017/11/07/设计模式-适配器模式/download.png" alt="download.png" title=""><br>在上图中可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的:</p>
<p>模式所涉及的角色有:</p>
<ul>
<li>目标(Target)角色:这就是所期待得到的接口。注意:由于这里讨论的是类适配器模式，因此目标不可以是类。</li>
<li>源(Adapee)角色:现在需要适配的接口。</li>
<li>适配器(Adaper)角色:适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 这是源类Adaptee也有的方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>; </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 这是源类Adapteee没有的方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span></span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面给出的是目标角色的源代码，这个角色是以一个JAVA接口的形式实现的。可以看出，这个接口声明了两个方法:sampleOperation1()和sampleOperation2()。而源角色Adaptee是一个具体类，它有一个sampleOperation1()方法，但是没有sampleOperation2()方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>适配器角色Adapter扩展了Adaptee,同时又实现了目标(Target)接口。由于Adaptee没有提供sampleOperation2()方法，而目标接口又要求这个方法，因此适配器角色Adapter实现了这个方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 由于源类Adaptee没有方法sampleOperation2()</div><div class="line">     * 因此适配器补充上这个方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//写相关的代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h2><p>与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。<br><img src="/2017/11/07/设计模式-适配器模式/download1.png" alt="download1.png" title=""><br>从上图可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装(Wrapper)类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 这是源类Adaptee也有的方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>; </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 这是源类Adapteee没有的方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span></span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Adaptee adaptee;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee = adaptee;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 源类Adaptee有方法sampleOperation1</div><div class="line">     * 因此适配器类直接委派即可</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation1</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.adaptee.sampleOperation1();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 源类Adaptee没有方法sampleOperation2</div><div class="line">     * 因此由适配器类需要补充此方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sampleOperation2</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//写相关的代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类适配器和对象适配器的权衡"><a href="#类适配器和对象适配器的权衡" class="headerlink" title="类适配器和对象适配器的权衡"></a>类适配器和对象适配器的权衡</h2><ul>
<li>类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。</li>
<li>对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理  Adaptee的子类了。<br>对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。</li>
<li>对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。<br>对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。</li>
<li>对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。<br>对于对象适配器，需要额外的引用来间接得到Adaptee。</li>
</ul>
<p>建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。</p>
<h2 id="适配器模式的优点"><a href="#适配器模式的优点" class="headerlink" title="适配器模式的优点"></a>适配器模式的优点</h2><ul>
<li>更好的复用性<br>系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li>
<li>更好的扩展性<br>在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</li>
</ul>
<h2 id="适配器模式的缺点"><a href="#适配器模式的缺点" class="headerlink" title="适配器模式的缺点"></a>适配器模式的缺点</h2><p>过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p>
<h2 id="缺省适配模式"><a href="#缺省适配模式" class="headerlink" title="缺省适配模式"></a>缺省适配模式</h2><p>缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。作为适配器模式的一个特例，缺省是适配模式在JAVA语言中有着特殊的应用。</p>
<p>鲁智深的故事<br>和尚要做什么呢？吃斋、念经、打坐、撞钟、习武等。如果设计一个和尚接口，给出所有的和尚都需要实现的方法，那么这个接口应当如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 和尚 </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 吃斋（）；</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 念经（）；</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 打坐（）；</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 撞钟（）；</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 习武（）；</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然，所有的和尚类都应当实现接口所定义的全部方法，不然就根本通不过JAVA语言编辑器。像下面的鲁智深类就不行。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 鲁智深 <span class="keyword">implements</span> 和尚</span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 习武()&#123;</div><div class="line">        拳打镇关西；</div><div class="line">        大闹五台山；</div><div class="line">        大闹桃花村；</div><div class="line">        火烧瓦官寺；</div><div class="line">        倒拔垂杨柳；</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"鲁智深"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于鲁智深只实现了getName()和习武()方法，而没有实现任何其他的方法。因此，它根本就通不过Java语言编译器。鲁智深类只有实现和尚接口的所有的方法才可以通过Java语言编译器，但是这样一来鲁智深就不再是鲁智深了。以史为鉴，可以知天下。研究一下几百年前鲁智深是怎么剃度成和尚的，会对Java编程有很大的启发。不错，当初鲁达剃度，众僧说:“此人形容丑恶、相貌凶顽，不可剃度他”,但是长老却说:”此人上应天星、心地刚直。虽然时下凶顽，命中驳杂，久后却得清净。证果非凡，汝等皆不及他。”</p>
<p>原来如此！看来只要这里也应上一个天星的话，问题就解决了！使用面向对象的语言来说，“应”者，实现也；“天星”者，抽象类也。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 天星 <span class="keyword">implements</span> 和尚 </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 吃斋()&#123;&#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 念经()&#123;&#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 打坐()&#123;&#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 撞钟()&#123;&#125;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 习武()&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>鲁智深类继承抽象类“天星”<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 鲁智深 <span class="keyword">extends</span> 和尚</span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> 习武()&#123;</div><div class="line">        拳打镇关西；</div><div class="line">        大闹五台山；</div><div class="line">        大闹桃花村；</div><div class="line">        火烧瓦官寺；</div><div class="line">        倒拔垂杨柳；</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"鲁智深"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个抽象的天星类便是一个适配器类，鲁智深实际上借助于适配器模式达到了剃度的目的。此适配器类实现了和尚接口所要求的所有方法。但是与通常的适配器模式不同的是，此适配器类给出的所有的方法的实现都是“平庸”的。这种“平庸化”的适配器模式称作缺省适配模式。</p>
<p>在很多情况下，必须让一个具体类实现某一个接口，但是这个类又用不到接口所规定的所有的方法。通常的处理方法是，这个具体类要实现所有的方法，那些有用的方法要有实现，那些没有用的方法也要有空的、平庸的实现。</p>
<p>这些空的方法是一种浪费，有时也是一种混乱。除非看过这些空方法的代码，程序员可能会以为这些方法不是空的。即便他知道其中有一些方法是空的，也不一定知道哪些方法是空的，哪些方法不是空的，除非看过这些方法的源代码或是文档。</p>
<p>缺省适配模式可以很好的处理这一情况。可以设计一个抽象的适配器类实现接口，此抽象类要给接口所要求的每一种方法都提供一个空的方法。就像帮助了鲁智深的“上应天星”一样，此抽象类可以使它的具体子类免于被迫实现空的方法。</p>
<h2 id="缺省适配模式的结构"><a href="#缺省适配模式的结构" class="headerlink" title="缺省适配模式的结构"></a>缺省适配模式的结构</h2><p>缺省适配模式是一种“平庸”化的适配器模式。<br><img src="/2017/11/07/设计模式-适配器模式/download3.png" alt="download3.png" title=""><br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractService</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceOperation1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">serviceOperation2</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serviceOperation3</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceAdapter</span> <span class="keyword">implements</span> <span class="title">AbstractService</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceOperation1</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">serviceOperation2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serviceOperation3</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，接口AbstractService要求定义三个方法，分别是serviceOperation1()、serviceOperation2()、serviceOperation3()；而抽象适配器类ServiceAdapter则为这三种方法都提供了平庸的实现。因此，任何继承自抽象类ServiceAdapter的具体类都可以选择它所需要的方法实现，而不必理会其他的不需要的方法。</p>
<p>适配器模式的用意是要改变源的接口，以便于目标接口相容。缺省适配的用意稍有不同，它是为了方便建立一个不平庸的适配器类而提供的一种平庸实现。</p>
<p>在任何时候，如果不准备实现一个接口的所有方法时，就可以使用“缺省适配模式”制造一个抽象类，给出所有方法的平庸的具体实现。这样，从这个抽象类再继承下去的子类就不必实现所有的方法了。</p>
<p>ref: <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/04/13/2442795.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-Fibonacci</title>
    <url>/2017/10/30/Python-Fibonacci/</url>
    <content><![CDATA[<p>Fibonacci 斐波那契数列的几种写法、时间复杂度对比</p>
<a id="more"></a>
<p>斐波那契数列（Fibonacci）最早由印度数学家Gopala提出，第一个真正研究斐波那契数列的是意大利数学家 Leonardo Fibonacci，斐波那契数列的定义很简单，用数学函数可表示为:<br><img src="/2017/10/30/Python-Fibonacci/640" alt="640" title=""><br>数列从0和1开始，之后的数由前两个数相加而得出，例如斐波那契数列的前10个数是:0, 1, 1, 2, 3, 5, 8, 13, 21, 34。</p>
<p>用 Python 实现斐波那契数列常见的写法有三种，各算法的执行效率也有很大差别</p>
<h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><p>所谓递归就是指函数的定义中使用了函数自身的方法<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_recur</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">assert</span> n &gt;= <span class="number">0</span></div><div class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> (<span class="number">0</span>, <span class="number">1</span>):</div><div class="line">        <span class="keyword">return</span> n</div><div class="line">    <span class="keyword">return</span> fib_recur(n - <span class="number">1</span>) + fib_recur(n - <span class="number">2</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</div><div class="line">    print(fib_recur(i), end=<span class="string">" "</span>)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181</div></pre></td></tr></table></figure>
<p>递归是一种写法最简洁的方法，但它是效率非常低，因为会出现大量的重复计算，时间复杂度是:O(1.618 ^ n)，1.618 是黄金分割点。同时受限于 Python 中递归的最大深度是 1000，所以用递归来求解并不是一种可取的办法。</p>
<h2 id="递推法"><a href="#递推法" class="headerlink" title="递推法"></a>递推法</h2><p>递推法就是从0和1开始，前两项相加逐个求出第3、第4个数，直到求出第n个数的值<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_loop</span><span class="params">(n)</span>:</span></div><div class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</div><div class="line">        a, b = b, a + b</div><div class="line">    <span class="keyword">return</span> a</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</div><div class="line">    print(fib_loop(i), end=<span class="string">" "</span>)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181</div></pre></td></tr></table></figure>
<p>这种算法的时间复杂是O(n)，呈线性增长，如果数据量巨大，速度越到后面会越慢。</p>
<p>上面两种方式都是使用分而治之的思想，把一个大的问题化小，然后利用小问题的求解得到目标问题的答案。</p>
<h2 id="矩阵法"><a href="#矩阵法" class="headerlink" title="矩阵法"></a>矩阵法</h2><p>《线性代数》是大学计算机专业的一门课程，教的就是矩阵，那时候觉得这东西学起来很枯燥，没什么用处，工作后你才发现搞机器学习、数据分析、数据建模时大有用处，书到用时方恨少。其实矩阵的本质就是线性方程式。</p>
<p>斐波那契数列中两个相邻的项分别为:F(n) 和 F(n - 1)，如果把这两个数当作一个2行1列的矩阵可表示为:<br><img src="/2017/10/30/Python-Fibonacci/641" alt="641" title=""><br>因为 F(n) = F(n-1)+F(n-2)，所以就有:<br><img src="/2017/10/30/Python-Fibonacci/642" alt="642" title=""><br>通过反推，其实它是由两个矩阵的乘积得来的<br><img src="/2017/10/30/Python-Fibonacci/643" alt="643" title=""><br>依此类推:<br><img src="/2017/10/30/Python-Fibonacci/644" alt="644" title=""><br>最后可推出:<br><img src="/2017/10/30/Python-Fibonacci/645" alt="645" title=""><br>因此想要求出F(n)的值，只要能求出右边矩阵的n-1次方的值，最后求得两矩阵乘积，取新矩阵的第一行的第一列的值即可，比如n=3时，<br><img src="/2017/10/30/Python-Fibonacci/646" alt="646" title=""><br>可以得知F(3)的值2，F(2)的值为1，因为幂运算可以使用二分加速，所以矩阵法的时间复杂度为 O(log n)</p>
<p>我们可以用科学计算包 numpy 来实现矩阵法:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib_matr</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> (numpy.matrix([[<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]]) ** (n - <span class="number">1</span>) * numpy.matrix([[<span class="number">1</span>], [<span class="number">0</span>]]))[<span class="number">0</span>, <span class="number">0</span>]</div><div class="line"></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</div><div class="line">    print(int(fib_matr(i)), end=<span class="string">" "</span>)</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181</div></pre></td></tr></table></figure>
<p>3中不同的算法效率对比:<br><img src="/2017/10/30/Python-Fibonacci/647" alt="647" title=""><br>从上面图可以看出递归法效率惊人的低，矩阵法在数据量比较大的时候才突显出它的优势，递推法随着数据的变大，所花的时间也越来越大。</p>
<p>ref: <a href="https://mp.weixin.qq.com/s?__biz=MjM5MzgyODQxMQ==&amp;mid=2650367512&amp;idx=1&amp;sn=efd8c737e353aab35a2fe8eeb322f70e&amp;chksm=be9cdd4c89eb545a3b810e53ca77a4f5008ba6f18f89881358476aaa9a7172eb26873b719a3c&amp;scene=0#rd" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MjM5MzgyODQxMQ==&amp;mid=2650367512&amp;idx=1&amp;sn=efd8c737e353aab35a2fe8eeb322f70e&amp;chksm=be9cdd4c89eb545a3b810e53ca77a4f5008ba6f18f89881358476aaa9a7172eb26873b719a3c&amp;scene=0#rd</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/2017/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在阎宏博士的《JAVA与模式》一书中开头是这样描述单例模式的:<br>作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。</p>
<a id="more"></a>
<h2 id="单例模式的结构"><a href="#单例模式的结构" class="headerlink" title="单例模式的结构"></a>单例模式的结构</h2><p>单例模式的特点:</p>
<ul>
<li>单例类只能有一个实例。</li>
<li>单例类必须自己创建自己的唯一实例。</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<h2 id="饿汉式单例类"><a href="#饿汉式单例类" class="headerlink" title="饿汉式单例类"></a>饿汉式单例类</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerSingleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EagerSingleton instance = <span class="keyword">new</span> EagerSingleton();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 私有默认构造子</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerSingleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 静态工厂方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子中，在这个类被加载时，静态变量instance会被初始化，此时类的私有构造子会被调用。这时候，单例类的唯一实例就被创建出来了。</p>
<p>饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。<br>饿汉式是典型的空间换时间，当类装载的时候就会创建类的实例，不管你用不用，先创建出来，然后每次调用的时候，就不需要再判断，节省了运行时间。</p>
<h2 id="懒汉式单例类"><a href="#懒汉式单例类" class="headerlink" title="懒汉式单例类　"></a>懒汉式单例类　</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 私有默认构造子</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 静态工厂方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">            instance = <span class="keyword">new</span> LazySingleton();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的懒汉式单例类实现里对静态工厂方法使用了同步化，以处理多线程环境。<br>懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。</p>
<p>懒汉式是典型的时间换空间,就是每次获取实例都会进行判断，看是否需要创建实例，浪费判断的时间。当然，如果一直没有人使用的话，那就不会创建实例，则节约内存空间</p>
<p>由于懒汉式的实现是线程安全的，这样会降低整个访问的速度，而且每次都要判断。那么有没有更好的方式实现呢？</p>
<h3 id="双重检查加锁"><a href="#双重检查加锁" class="headerlink" title="双重检查加锁"></a>双重检查加锁</h3><p>可以使用“双重检查加锁”的方式来实现，就可以既实现线程安全，又能够使性能不受很大的影响。那么什么是“双重检查加锁”机制呢？</p>
<p>所谓“双重检查加锁”机制，指的是:并不是每次进入getInstance方法都需要同步，而是先不同步，进入方法后，先检查实例是否存在，如果不存在才进行下面的同步块，这是第一重检查，进入同步块过后，再次检查实例是否存在，如果不存在，就在同步的情况下创建一个实例，这是第二重检查。这样一来，就只需要同步一次了，从而减少了多次在同步情况下进行判断所浪费的时间。</p>
<p>“双重检查加锁”机制的实现会使用关键字volatile，它的意思是:被volatile修饰的变量的值，将不会被本地线程缓存，所有对该变量的读写都是直接操作共享内存，从而确保多个线程能正确的处理该变量。</p>
<p>注意:在java1.4及以前版本中，很多JVM对于volatile关键字的实现的问题，会导致“双重检查加锁”的失败，因此“双重检查加锁”机制只只能用在java5及以上的版本。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//先检查实例是否存在，如果不存在才进入下面的同步块</span></div><div class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="comment">//同步块，线程安全的创建实例</span></div><div class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</div><div class="line">                <span class="comment">//再次检查实例是否存在，如果不存在才真正的创建实例</span></div><div class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</div><div class="line">                    instance = <span class="keyword">new</span> Singleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种实现方式既可以实现线程安全地创建实例，而又不会对性能造成太大的影响。它只是第一次创建实例的时候同步，以后就不需要同步了，从而加快了运行速度。</p>
<p>提示:由于volatile关键字可能会屏蔽掉虚拟机中一些必要的代码优化，所以运行效率并不是很高。因此一般建议，没有特别的需要，不要使用。也就是说，虽然可以使用“双重检查加锁”机制来实现线程安全的单例，但并不建议大量采用，可以根据情况来选用。</p>
<p>根据上面的分析，常见的两种单例实现方式都存在小小的缺陷，那么有没有一种方案，既能实现延迟加载，又能实现线程安全呢？</p>
<h3 id="Lazy-initialization-holder-class模式"><a href="#Lazy-initialization-holder-class模式" class="headerlink" title="Lazy initialization holder class模式"></a>Lazy initialization holder class模式</h3><p>这个模式综合使用了Java的类级内部类和多线程缺省同步锁的知识，很巧妙地同时实现了延迟加载和线程安全。</p>
<h4 id="相应的基础知识"><a href="#相应的基础知识" class="headerlink" title="相应的基础知识"></a>相应的基础知识</h4><p>什么是<strong>类级内部类</strong>？<br>简单点说，类级内部类指的是，有static修饰的成员式内部类。如果没有static修饰的成员式内部类被称为对象级内部类。<br>类级内部类相当于其外部类的static成分，它的对象与外部类对象间不存在依赖关系，因此可直接创建。而对象级内部类的实例，是绑定在外部对象实例中的。<br>类级内部类中，可以定义静态的方法。在静态方法中只能够引用外部类中的静态成员方法或者成员变量。<br>类级内部类相当于其外部类的成员，只有在第一次被使用的时候才被会装载。</p>
<p>多线程<strong>缺省同步锁</strong>的知识<br>大家都知道，在多线程开发中，为了解决并发问题，主要是通过使用synchronized来加互斥锁进行同步控制。但是在某些情况中，JVM已经隐含地为您执行了同步，这些情况下就不用自己再来进行同步控制了。这些情况包括:</p>
<ol>
<li>由静态初始化器（在静态字段上或static{}块中的初始化器）初始化数据时</li>
<li>访问final字段时</li>
<li>在创建线程之前创建对象时</li>
<li>线程可以看见它将要处理的对象时</li>
</ol>
<h4 id="解决方案的思路"><a href="#解决方案的思路" class="headerlink" title="解决方案的思路"></a>解决方案的思路</h4><p>要想很简单地实现线程安全，可以采用静态初始化器的方式，它可以由JVM来保证线程的安全性。比如前面的饿汉式实现方式。但是这样一来，不是会浪费一定的空间吗？因为这种实现方式，会在类装载的时候就初始化对象，不管你需不需要。</p>
<p>如果现在有一种方法能够让类装载的时候不去初始化对象，那不就解决问题了？一种可行的方式就是采用类级内部类，在这个类级内部类里面去创建对象实例。这样一来，只要不使用到这个类级内部类，那就不会创建对象实例，从而同时实现延迟加载和线程安全。</p>
<p>示例代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *    类级的内部类，也就是静态的成员式内部类，该内部类的实例与外部类的实例</div><div class="line">     *    没有绑定关系，而且只有被调用到时才会装载，从而实现了延迟加载。</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 静态初始化器，由JVM来保证线程安全</div><div class="line">         */</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当getInstance方法第一次被调用的时候，它第一次读取SingletonHolder.instance，导致SingletonHolder类得到初始化；而这个类在装载并被初始化的时候，会初始化它的静态域，从而创建Singleton的实例，由于是静态的域，因此只会在虚拟机装载类的时候初始化一次，并由虚拟机来保证它的线程安全性。</p>
<p>这个模式的优势在于，getInstance方法并没有被同步，并且只是执行一个域的访问，因此延迟初始化并没有增加任何访问成本。</p>
<h2 id="单例和枚举"><a href="#单例和枚举" class="headerlink" title="单例和枚举"></a>单例和枚举</h2><p>按照《高效Java 第二版》中的说法:单元素的枚举类型已经成为实现Singleton的最佳方法。用枚举来实现单例非常简单，只需要编写一个包含单个元素的枚举类型即可。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 定义一个枚举的元素，它就代表了Singleton的一个实例。</div><div class="line">     */</div><div class="line">    uniqueInstance;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 单例可以有自己的操作</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//功能处理</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p>
<p>ref: <a href="http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-原型模式</title>
    <url>/2017/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在阎宏博士的《JAVA与模式》一书中开头是这样描述原型（Prototype）模式的:</p>
<p>原型模式属于对象的创建模式。通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。这就是选型模式的用意。</p>
<a id="more"></a>
<h2 id="原型模式的结构"><a href="#原型模式的结构" class="headerlink" title="原型模式的结构"></a>原型模式的结构</h2><p>原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。这样一来，通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身的方法，就可以通过这个方法来获取新的对象，而无须再去通过new来创建。</p>
<p>原型模式有两种表现形式:（1）简单形式、（2）登记形式，这两种表现形式仅仅是原型模式的不同实现。</p>
<h3 id="简单形式的原型模式"><a href="#简单形式的原型模式" class="headerlink" title="简单形式的原型模式"></a>简单形式的原型模式</h3><img src="/2017/10/30/设计模式-原型模式/download.png" alt="download.png" title="">
<p>这种形式涉及到三个角色:</p>
<ol>
<li>客户(Client)角色:客户类提出创建对象的请求。</li>
<li>抽象原型(Prototype)角色:这是一个抽象角色，通常由一个Java接口或Java抽象类实现。此角色给出所有的具体原型类所需的接口。</li>
<li>具体原型（Concrete Prototype）角色:被复制的对象。此角色需要实现抽象的原型角色所要求的接口。</li>
</ol>
<p>源代码<br>抽象原型角色<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Prototype</span></span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 克隆自身的方法</div><div class="line">     * <span class="doctag">@return</span> 一个从自身克隆出来的对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体原型角色<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype1</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//最简单的克隆，新建一个自身对象，由于没有属性就不再复制值了</span></div><div class="line">        Prototype prototype = <span class="keyword">new</span> ConcretePrototype1();</div><div class="line">        <span class="keyword">return</span> prototype;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype2</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//最简单的克隆，新建一个自身对象，由于没有属性就不再复制值了</span></div><div class="line">        Prototype prototype = <span class="keyword">new</span> ConcretePrototype2();</div><div class="line">        <span class="keyword">return</span> prototype;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端角色<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 持有需要使用的原型接口对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Prototype prototype;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造方法，传入需要使用的原型接口对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(Prototype prototype)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.prototype = prototype;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(Prototype example)</span></span>&#123;</div><div class="line">        <span class="comment">//需要创建原型接口的对象</span></div><div class="line">        Prototype copyPrototype = prototype.clone();</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="登记形式的原型模式"><a href="#登记形式的原型模式" class="headerlink" title="登记形式的原型模式"></a>登记形式的原型模式</h3><img src="/2017/10/30/设计模式-原型模式/download1.png" alt="download1.png" title="">
<p>作为原型模式的第二种形式，它多了一个原型管理器(PrototypeManager)角色，该角色的作用是:创建具体原型类的对象，并记录每一个被创建的对象。</p>
<p>源代码</p>
<p>抽象原型角色<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Prototype</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体原型角色<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype1</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span></span>&#123;</div><div class="line">        ConcretePrototype1 prototype = <span class="keyword">new</span> ConcretePrototype1();</div><div class="line">        prototype.setName(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">return</span> prototype;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Now in Prototype1 , name = "</span> + <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype2</span> <span class="keyword">implements</span> <span class="title">Prototype</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span></span>&#123;</div><div class="line">        ConcretePrototype2 prototype = <span class="keyword">new</span> ConcretePrototype2();</div><div class="line">        prototype.setName(<span class="keyword">this</span>.name);</div><div class="line">        <span class="keyword">return</span> prototype;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Now in Prototype2 , name = "</span> + <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原型管理器角色保持一个聚集，作为对所有原型对象的登记，这个角色提供必要的方法，供外界增加新的原型对象和取得已经登记过的原型对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeManager</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 用来记录原型的编号和原型实例的对应关系</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Prototype&gt; map = <span class="keyword">new</span> HashMap&lt;String,Prototype&gt;();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 私有化构造方法，避免外部创建实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PrototypeManager</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 向原型管理器里面添加或是修改某个原型注册</div><div class="line">     * <span class="doctag">@param</span> prototypeId 原型编号</div><div class="line">     * <span class="doctag">@param</span> prototype    原型实例</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPrototype</span><span class="params">(String prototypeId , Prototype prototype)</span></span>&#123;</div><div class="line">        map.put(prototypeId, prototype);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 从原型管理器里面删除某个原型注册</div><div class="line">     * <span class="doctag">@param</span> prototypeId 原型编号</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removePrototype</span><span class="params">(String prototypeId)</span></span>&#123;</div><div class="line">        map.remove(prototypeId);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取某个原型编号对应的原型实例</div><div class="line">     * <span class="doctag">@param</span> prototypeId    原型编号</div><div class="line">     * <span class="doctag">@return</span>    原型编号对应的原型实例</div><div class="line">     * <span class="doctag">@throws</span> Exception    如果原型编号对应的实例不存在，则抛出异常</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Prototype <span class="title">getPrototype</span><span class="params">(String prototypeId)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        Prototype prototype = map.get(prototypeId);</div><div class="line">        <span class="keyword">if</span>(prototype == <span class="keyword">null</span>)&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"您希望获取的原型还没有注册或已被销毁"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> prototype;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端角色<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            Prototype p1 = <span class="keyword">new</span> ConcretePrototype1();</div><div class="line">            PrototypeManager.setPrototype(<span class="string">"p1"</span>, p1);</div><div class="line">            <span class="comment">//获取原型来创建对象</span></div><div class="line">            Prototype p3 = PrototypeManager.getPrototype(<span class="string">"p1"</span>).clone();</div><div class="line">            p3.setName(<span class="string">"张三"</span>);</div><div class="line">            System.out.println(<span class="string">"第一个实例:"</span> + p3);</div><div class="line">            <span class="comment">//有人动态的切换了实现</span></div><div class="line">            Prototype p2 = <span class="keyword">new</span> ConcretePrototype2();</div><div class="line">            PrototypeManager.setPrototype(<span class="string">"p1"</span>, p2);</div><div class="line">            <span class="comment">//重新获取原型来创建对象</span></div><div class="line">            Prototype p4 = PrototypeManager.getPrototype(<span class="string">"p1"</span>).clone();</div><div class="line">            p4.setName(<span class="string">"李四"</span>);</div><div class="line">            System.out.println(<span class="string">"第二个实例:"</span> + p4);</div><div class="line">            <span class="comment">//有人注销了这个原型</span></div><div class="line">            PrototypeManager.removePrototype(<span class="string">"p1"</span>);</div><div class="line">            <span class="comment">//再次获取原型来创建对象</span></div><div class="line">            Prototype p5 = PrototypeManager.getPrototype(<span class="string">"p1"</span>).clone();</div><div class="line">            p5.setName(<span class="string">"王五"</span>);</div><div class="line">            System.out.println(<span class="string">"第三个实例:"</span> + p5);</div><div class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="两种形式的比较"><a href="#两种形式的比较" class="headerlink" title="两种形式的比较"></a>两种形式的比较</h3><p>简单形式和登记形式的原型模式各有其长处和短处。</p>
<p>如果需要创建的原型对象数目较少而且比较固定的话，可以采取第一种形式。在这种情况下，原型对象的引用可以由客户端自己保存。</p>
<p>如果要创建的原型对象数目不固定的话，可以采取第二种形式。在这种情况下，客户端不保存对原型对象的引用，这个任务被交给管理员对象。在复制一个原型对象之前，客户端可以查看管理员对象是否已经有一个满足要求的原型对象。如果有，可以直接从管理员类取得这个对象引用；如果没有，客户端就需要自行复制此原型对象。</p>
<h2 id="Java中的克隆方法"><a href="#Java中的克隆方法" class="headerlink" title="Java中的克隆方法"></a>Java中的克隆方法</h2><p>Java的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份</p>
<p>Java语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。</p>
<h3 id="克隆满足的条件"><a href="#克隆满足的条件" class="headerlink" title="克隆满足的条件"></a>克隆满足的条件</h3><p>clone()方法将对象复制了一份并返还给调用者。所谓“复制”的含义与clone()方法是怎么实现的。一般而言，clone()方法满足以下的描述:</p>
<ol>
<li>对任何的对象x，都有:x.clone()!=x。换言之，克隆对象与原对象不是同一个对象。</li>
<li>对任何的对象x，都有:x.clone().getClass() == x.getClass()，换言之，克隆对象与原对象的类型一样。</li>
<li>如果对象x的equals()方法定义其恰当的话，那么x.clone().equals(x)应当成立的。</li>
</ol>
<p>在JAVA语言的API中，凡是提供了clone()方法的类，都满足上面的这些条件。JAVA语言的设计师在设计自己的clone()方法时，也应当遵守着三个条件。一般来说，上面的三个条件中的前两个是必需的，而第三个是可选的。</p>
<h3 id="浅克隆和深克隆"><a href="#浅克隆和深克隆" class="headerlink" title="浅克隆和深克隆"></a>浅克隆和深克隆</h3><p>无论你是自己实现克隆方法，还是采用Java提供的克隆方法，都存在一个浅度克隆和深度克隆的问题。</p>
<ul>
<li>浅度克隆  只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用都仍然指向原来的对象。</li>
<li>深度克隆  除了浅度克隆要克隆的值外，还负责克隆引用类型的数据。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深度克隆把要复制的对象所引用的对象都复制了一遍，而这种对被引用到的对象的复制叫做间接复制。</li>
</ul>
<p>深度克隆要深入到多少层，是一个不易确定的问题。在决定以深度克隆的方式复制一个对象的时候，必须决定对间接复制的对象时采取浅度克隆还是继续采用深度克隆。因此，在采取深度克隆时，需要决定多深才算深。此外，在深度克隆的过程中，很可能会出现循环引用的问题，必须小心处理。</p>
<h3 id="利用序列化实现深度克隆"><a href="#利用序列化实现深度克隆" class="headerlink" title="利用序列化实现深度克隆"></a>利用序列化实现深度克隆</h3><p>把对象写到流里的过程是序列化(Serialization)过程；而把对象从流中读出来的过程则叫反序列化(Deserialization)过程。应当指出的是，写到流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。</p>
<p>在Java语言里深度克隆一个对象，常常可以先使对象实现Serializable接口，然后把对象（实际上只是对象的拷贝）写到一个流里（序列化），再从流里读回来（反序列化），便可以重建对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span>  Object <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</div><div class="line">    <span class="comment">//将对象写到流里</span></div><div class="line">    ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">    ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</div><div class="line">    oos.writeObject(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">//从流里读回来</span></div><div class="line">    ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</div><div class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</div><div class="line">    <span class="keyword">return</span> ois.readObject();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做的前提就是对象以及对象内部所有引用到的对象都是可序列化的，否则，就需要仔细考察那些不可序列化的对象可否设成transient，从而将之排除在复制过程之外。</p>
<p>浅度克隆显然比深度克隆更容易实现，因为Java语言的所有类都会继承一个clone()方法，而这个clone()方法所做的正式浅度克隆。</p>
<p>有一些对象，比如线程(Thread)对象或Socket对象，是不能简单复制或共享的。不管是使用浅度克隆还是深度克隆，只要涉及这样的间接对象，就必须把间接对象设成transient而不予复制；或者由程序自行创建出相当的同种对象，权且当做复制件使用。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>孙大圣的身外身本领如果在Java语言里使用原型模式来实现的话，会怎么样呢？首先，齐天大圣(The Greatest Sage)即TheGreatestSage类扮演客户角色。齐天大圣持有一个猢狲（Monkey）的实例，而猢狲就是大圣本尊。Monkey类具有继承自java.lang.Object的clone()方法，因此，可以通过调用这个克隆方法来复制一个Monkey实例。</p>
<p>孙大圣本人用TheGreatestSage类代表<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheGreatestSage</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Monkey monkey = <span class="keyword">new</span> Monkey();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//克隆大圣本尊</span></div><div class="line">        Monkey copyMonkey = (Monkey)monkey.clone();</div><div class="line">        System.out.println(<span class="string">"大圣本尊的生日是:"</span> + monkey.getBirthDate());</div><div class="line">        System.out.println(<span class="string">"克隆的大圣的生日是:"</span> + monkey.getBirthDate());</div><div class="line">        System.out.println(<span class="string">"大圣本尊跟克隆的大圣是否为同一个对象 "</span> + (monkey == copyMonkey));</div><div class="line">        System.out.println(<span class="string">"大圣本尊持有的金箍棒 跟 克隆的大圣持有的金箍棒是否为同一个对象？ "</span> + (monkey.getStaff() == copyMonkey.getStaff()));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</div><div class="line">        TheGreatestSage sage = <span class="keyword">new</span> TheGreatestSage();</div><div class="line">        sage.change();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大圣本尊由Monkey类代表，这个类扮演具体原型角色<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</div><div class="line">    <span class="comment">//身高</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</div><div class="line">    <span class="comment">//体重</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</div><div class="line">    <span class="comment">//生日</span></div><div class="line">    <span class="keyword">private</span> Date birthDate;</div><div class="line">    <span class="comment">//金箍棒</span></div><div class="line">    <span class="keyword">private</span> GoldRingedStaff staff;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造函数</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.birthDate = <span class="keyword">new</span> Date();</div><div class="line">        <span class="keyword">this</span>.staff = <span class="keyword">new</span> GoldRingedStaff();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 克隆方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</div><div class="line">        Monkey temp = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            temp = (Monkey) <span class="keyword">super</span>.clone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">return</span> temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> height;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.height = height;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> weight;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.weight = weight;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthDate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> birthDate;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthDate</span><span class="params">(Date birthDate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.birthDate = birthDate;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> GoldRingedStaff <span class="title">getStaff</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> staff;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStaff</span><span class="params">(GoldRingedStaff staff)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.staff = staff;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大圣还持有一个金箍棒的实例，金箍棒类GoldRingedStaff<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoldRingedStaff</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> height = <span class="number">100.0f</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> diameter = <span class="number">10.0f</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 增长行为，每次调用长度和半径增加一倍</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.diameter *= <span class="number">2</span>;</div><div class="line">        <span class="keyword">this</span>.height *= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 缩小行为，每次调用长度和半径减少一半</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shrink</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.diameter /= <span class="number">2</span>;</div><div class="line">        <span class="keyword">this</span>.height /= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当运行TheGreatestSage类时，首先创建大圣本尊对象，而后浅度克隆大圣本尊对象。程序在运行时打印出的信息如下:<br><img src="/2017/10/30/设计模式-原型模式/download2.png" alt="download2.png" title=""><br>可以看出，首先，复制的大圣本尊具有和原始的大圣本尊对象一样的birthDate，而本尊对象不相等，这表明他们二者是克隆关系；其次，复制的大圣本尊所持有的金箍棒和原始的大圣本尊所持有的金箍棒为同一个对象。这表明二者所持有的金箍棒根本是一根，而不是两根。</p>
<p>正如前面所述，继承自java.lang.Object类的clone()方法是浅克隆。换言之，齐天大圣的所有化身所持有的金箍棒引用全都是指向一个对象的，这与《西游记》中的描写并不一致。要纠正这一点，就需要考虑使用深克隆。</p>
<p>为做到深度克隆，所有需要复制的对象都需要实现java.io.Serializable接口。</p>
<p>孙大圣的源代码<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheGreatestSage</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Monkey monkey = <span class="keyword">new</span> Monkey();</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</div><div class="line">        Monkey copyMonkey = (Monkey)monkey.deepClone();</div><div class="line">        System.out.println(<span class="string">"大圣本尊的生日是:"</span> + monkey.getBirthDate());</div><div class="line">        System.out.println(<span class="string">"克隆的大圣的生日是:"</span> + monkey.getBirthDate());</div><div class="line">        System.out.println(<span class="string">"大圣本尊跟克隆的大圣是否为同一个对象 "</span> + (monkey == copyMonkey));</div><div class="line">        System.out.println(<span class="string">"大圣本尊持有的金箍棒 跟 克隆的大圣持有的金箍棒是否为同一个对象？ "</span> + (monkey.getStaff() == copyMonkey.getStaff()));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</div><div class="line">        TheGreatestSage sage = <span class="keyword">new</span> TheGreatestSage();</div><div class="line">        sage.change();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在大圣本尊Monkey类里面，有两个克隆方法，一个是clone()，也即浅克隆；另一个是deepClone()，也即深克隆。在深克隆方法里，大圣本尊对象（一个拷贝）被序列化，然后又被反序列化。反序列化的对象就成了一个深克隆的结果。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>,<span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="comment">//身高</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</div><div class="line">    <span class="comment">//体重</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight;</div><div class="line">    <span class="comment">//生日</span></div><div class="line">    <span class="keyword">private</span> Date birthDate;</div><div class="line">    <span class="comment">//金箍棒</span></div><div class="line">    <span class="keyword">private</span> GoldRingedStaff staff;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造函数</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monkey</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.birthDate = <span class="keyword">new</span> Date();</div><div class="line">        staff = <span class="keyword">new</span> GoldRingedStaff();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 克隆方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</div><div class="line">        Monkey temp = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            temp = (Monkey) <span class="keyword">super</span>.clone();</div><div class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">            <span class="comment">// TODO Auto-generated catch block</span></div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">return</span> temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span>  Object <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span>&#123;</div><div class="line">        <span class="comment">//将对象写到流里</span></div><div class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</div><div class="line">        oos.writeObject(<span class="keyword">this</span>);</div><div class="line">        <span class="comment">//从流里读回来</span></div><div class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</div><div class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</div><div class="line">        <span class="keyword">return</span> ois.readObject();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> height;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> height)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.height = height;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> weight;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWeight</span><span class="params">(<span class="keyword">int</span> weight)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.weight = weight;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthDate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> birthDate;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthDate</span><span class="params">(Date birthDate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.birthDate = birthDate;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> GoldRingedStaff <span class="title">getStaff</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> staff;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStaff</span><span class="params">(GoldRingedStaff staff)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.staff = staff;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，大圣本尊持有一个金箍棒（GoldRingedStaff）的实例。在大圣复制件里面，此金箍棒实例是原大圣本尊对象所持有的金箍棒对象的一个拷贝。在大圣本尊对象被序列化和反序列化时，它所持有的金箍棒对象也同时被序列化和反序列化，这使得复制的大圣的金箍棒和原大圣本尊对象所持有的金箍棒对象是两个独立的对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoldRingedStaff</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> height = <span class="number">100.0f</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> diameter = <span class="number">10.0f</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 增长行为，每次调用长度和半径增加一倍</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.diameter *= <span class="number">2</span>;</div><div class="line">        <span class="keyword">this</span>.height *= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 缩小行为，每次调用长度和半径减少一半</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shrink</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.diameter /= <span class="number">2</span>;</div><div class="line">        <span class="keyword">this</span>.height /= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:<br><img src="/2017/10/30/设计模式-原型模式/download3.png" alt="download3.png" title=""><br>从运行的结果可以看出，大圣的金箍棒和他的身外之身的金箍棒是不同的对象。这是因为使用了深克隆，从而把大圣本尊所引用的对象也都复制了一遍，其中也包括金箍棒。</p>
<h2 id="原型模式的优点"><a href="#原型模式的优点" class="headerlink" title="原型模式的优点"></a>原型模式的优点</h2><p>原型模式允许在运行时动态改变具体的实现类型。原型模式可以在运行期间，由客户来注册符合原型接口的实现类型，也可以动态地改变具体的实现类型，看起来接口没有任何变化，但其实运行的已经是另外一个类实例了。因为克隆一个原型就类似于实例化一个类。</p>
<h2 id="原型模式的缺点"><a href="#原型模式的缺点" class="headerlink" title="原型模式的缺点"></a>原型模式的缺点</h2><p>原型模式最主要的缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类来说不是很难，而对于已经有的类不一定很容易，特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候。</p>
<p>ref: <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策底理解单例模式</title>
    <url>/2017/10/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E5%BA%95%E7%90%86%E8%A7%A3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式是一种常用的设计模式、也可能是设计模式中代码量最少的设计模式。但是少并不意味着简单、想要用好、用对单例、就的费一番脑子了。因为它里面涉及到了很多Java底层的知识如类装载机制、Java内存模型、volatile等知识点</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单例模式属于23中设计模式中的创建型模式、定义是确保某一个类只有一个实例、并提供一个全局的访问点。</p>
<p>具有以下3个特性：</p>
<ul>
<li>只能有一个实例</li>
<li>必须自己创建自己唯一实例</li>
<li>提供全局访问点</li>
</ul>
<h2 id="基本实现思路"><a href="#基本实现思路" class="headerlink" title="基本实现思路"></a>基本实现思路</h2><p>单例要求类只能返回同一对象的引用、必须提供一个静态获取该实例的方法<br>实现可以通过以下两步：</p>
<ul>
<li>私有化构造方法、防止外部实例化、只有通过对外提供的静态方法来获取唯一实例</li>
<li>提供一个静态方法获取对象的实例。</li>
</ul>
<h2 id="单例的7种实现方式"><a href="#单例的7种实现方式" class="headerlink" title="单例的7种实现方式"></a>单例的7种实现方式</h2><h3 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class EagetSingleton &#123;</div><div class="line"></div><div class="line">    private static final EagetSingleton INSANCE = new EagetSingleton();</div><div class="line"></div><div class="line">    // 私有化构造函数、防止外部实例化</div><div class="line">    private EagetSingleton() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 提供静态外部访问方法</div><div class="line">    public static EagetSingleton getInstance() &#123;</div><div class="line">        return INSANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：写法简单、类装载时就实例化了静态变量、避免了线程并发问题。<br>缺点：在类装载过程中就实例化了对象、造成了资源浪费。</p>
<h3 id="2-饿汉式（静态代码块）"><a href="#2-饿汉式（静态代码块）" class="headerlink" title="2. 饿汉式（静态代码块）"></a>2. 饿汉式（静态代码块）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class StaticBlockSingleton &#123;</div><div class="line"></div><div class="line">    private static StaticBlockSingleton INSTANCE = null;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        try &#123;</div><div class="line">            INSTANCE = new StaticBlockSingleton();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 私有化构造函数、防止外部实例化</div><div class="line">    private StaticBlockSingleton() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 提供静态外部访问方法</div><div class="line">    public static StaticBlockSingleton getInstance() &#123;</div><div class="line">        return INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式和上述实现方式基本相同、只是把类实例化的过程放到了静态代码块中来实例化、同样也是在类装载过程执行静态代码块、优缺点基本相同但是它可以在类实例化过程中做一些额外的操作如异常处理等。</p>
<h3 id="3-懒汉式（线程不安全）"><a href="#3-懒汉式（线程不安全）" class="headerlink" title="3. 懒汉式（线程不安全）"></a>3. 懒汉式（线程不安全）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class LazySingleton &#123;</div><div class="line"></div><div class="line">    private static LazySingleton INSTANCE = null;</div><div class="line"></div><div class="line">    // 私有化构造函数、防止外部实例化</div><div class="line">    private LazySingleton() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 提供静态外部访问方法</div><div class="line">    public static LazySingleton getInstance() &#123;</div><div class="line">        if (null == INSTANCE) &#123; //-------- 1</div><div class="line">            INSTANCE = new LazySingleton(); //------2</div><div class="line">        &#125;</div><div class="line">        return INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：实现了懒加载、避免了资源的浪费。<br>缺点：线程不安全、在多线程情况下当一个线程执行到 1 处的时候、还没有来得及往下执行另一个线程也到 1 处 这样两个线程同时执行 2 处代码、破坏了单例。</p>
<h3 id="4-懒汉式（加锁）"><a href="#4-懒汉式（加锁）" class="headerlink" title="4. 懒汉式（加锁）"></a>4. 懒汉式（加锁）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class LazySyncSingleton &#123;</div><div class="line"></div><div class="line">    private static LazySyncSingleton INSTANCE = null;</div><div class="line"></div><div class="line">    // 私有化构造函数、防止外部实例化</div><div class="line">    private LazySyncSingleton() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 效率低下</div><div class="line">    // 提供静态外部访问方法</div><div class="line">    public static synchronized LazySyncSingleton getInstance() &#123;</div><div class="line"></div><div class="line">        if (null == INSTANCE) &#123;</div><div class="line">            INSTANCE = new LazySyncSingleton();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决了3中线程不安全的问题、利用synchronized对getInstance()方法加锁以达到同步访问。<br>优点：线程同步<br>缺点：效率低下、此方式对整个对象加锁、每次访问getInstance() 都需要同步访问、这种情况多线程并发效率非常低下、其实我们只需要在对象还没实例化前加锁就可以了、实例化后就不存在并发问题了</p>
<h3 id="5-懒汉式（双重锁）"><a href="#5-懒汉式（双重锁）" class="headerlink" title="5. 懒汉式（双重锁）"></a>5. 懒汉式（双重锁）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class DCheckSingleton &#123;</div><div class="line">    private static volatile DCheckSingleton INSTANCE = null;</div><div class="line"></div><div class="line">    // 私有化构造函数、防止外部实例化</div><div class="line">    private DCheckSingleton() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 提供静态外部访问方法</div><div class="line">    public static DCheckSingleton getInstance() &#123;</div><div class="line"></div><div class="line">        if (null == INSTANCE) &#123;</div><div class="line">            synchronized (DCheckSingleton.class) &#123;</div><div class="line">                if (null == INSTANCE) &#123;</div><div class="line">                    INSTANCE = new DCheckSingleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决了4中并发情况下效率低下的问题。<br>优点：线程安全、延迟加载、效率高<br>涉及到知识点：<br>1：volatile 关键字 确保内存的可见性和有序性。如果不加volatile关键字会有什么情况？ 我知道在对象实例化时INSTANCE = new DCheckSingleton();这一句代码JVM中并不是一步执行的而是分为三步（1）在栈内存中为 创建对象的引用指针 INSTANCE （2）在堆内存中开辟一块空间来存放实例化的对象 new DCheckSingleton(); （3）将INSTANCE指向堆内存空间地址JVM只保证了代码执行结果的正确性、并不保证执行顺序（这里涉及到Java内存模型知识点在这就不多说了、感兴趣的同学可以去了解下JVM一些底层实现原理）所以 1 ，2，3三步也可能是1 ，3 ，2 这样我们就可能拿到的时一个半成品的对象了。<br>2: 涉及到类实例化知识点<br>3: 涉及到Java内存模型<br>4:涉及到JVM的一些执行优化、指令重排等</p>
<h3 id="6-静态类部类"><a href="#6-静态类部类" class="headerlink" title="6. 静态类部类"></a>6. 静态类部类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class InnerSingleton &#123;</div><div class="line"></div><div class="line">    private  InnerSingleton() &#123;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static InnerSingleton getInstance() &#123;</div><div class="line">        return InnerClassSingleton.INSTANCE;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private static class InnerClassSingleton&#123;</div><div class="line">        private static final InnerSingleton INSTANCE = new InnerSingleton();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式和饿汉式的实现机制基本相同、都是利用了类装载机制来保证线程的安全、它和饿汉式的唯一区别就是实现了懒加载的机制、只有在调用getInstance()方法时才去进行InnerClassSingleton类的实例化。<br>优点：避免了线程不安全，延迟加载，效率高。</p>
<h3 id="7-枚举"><a href="#7-枚举" class="headerlink" title="7. 枚举"></a>7. 枚举</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public enum EnumsSingleton &#123;</div><div class="line">    INSTANCE;</div><div class="line"></div><div class="line">    @SuppressWarnings(&quot;unused&quot;)</div><div class="line">    private void method() &#123;</div><div class="line">        System.out.println(&quot;------- newInstance&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</p>
<h2 id="单例优点"><a href="#单例优点" class="headerlink" title="单例优点"></a>单例优点</h2><p>在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就 防止其它对象对自己的实例化，确保所有的对象都访问一个实例<br>单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。<br>提供了对唯一实例的受控访问。<br>由于在系统内存中只存在一个对象，因此可以 节约系统资源，当 需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。<br>允许可变数目的实例。<br>避免对共享资源的多重占用</p>
<h2 id="单例缺点"><a href="#单例缺点" class="headerlink" title="单例缺点"></a>单例缺点</h2><p>不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发 生变化，单例就会引起数据的错误，不能保存彼此的状态。<br>由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。<br>单例类的职责过重，在一定程度上违背了“单一职责原则”。<br>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设 计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢 出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收， 这将导致对象状态的丢失。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>需要频繁的进行创建和销毁的对象；<br>创建对象时耗时过多或耗费资源过多，但又经常用到的对象；<br>工具类对象；<br>频繁访问数据库或文件的对象。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>最后在简单聊一下如何防止暴力破坏单例。主要介绍两种方式以及如何来防范这两种方式。<br>1: 利用Java的反射方式<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">EagerSingleton instance = EagerSingleton.getInstance();</div><div class="line">Constructor instance2 = instance.getClass().getDeclaredConstructor();</div><div class="line">instance2.setAccessible(true);</div><div class="line">EagerSingleton instance3 = (EagerSingleton) instance2.newInstance();</div><div class="line">System.out.println(&quot;===&quot; + instance);</div><div class="line">System.out.println(&quot;===&quot; + instance3);</div></pre></td></tr></table></figure></p>
<p>利用Java的反射方式可以达到爆力破解单例的效果、运行结果我就不在这贴出了有兴趣的可以自己试试instance 和 instance3 肯定不是一个对象。<br>如何来防范这方式？ 其实也很简单Java Security 中为我们提供了现成的方法。只需要在私有构造中使用SecurityManager 进行检查下就可以代码如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 私有的构造方法，防止外部实例化</div><div class="line">private EagerSingleton() &#123;</div><div class="line"> SecurityManager sm = new SecurityManager();</div><div class="line"> sm.checkPermission(new ReflectPermission(&quot;禁止反射&quot;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2: 第二种方式是利用Java 序列化和反序列化来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;1.txt&quot;));</div><div class="line">out.writeObject(instance);</div><div class="line">out.close();</div><div class="line">ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;1.txt&quot;));</div><div class="line">EagerSingleton readObject = (EagerSingleton) in.readObject();</div><div class="line">in.close();</div><div class="line">System.out.println(&quot;==&quot; + instance);</div><div class="line">System.out.println(&quot;==&quot; + readObject);</div></pre></td></tr></table></figure>
<p>如何防范？ 很简单只需要重写readResolve() 反方就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private Object readResolve() &#123;</div><div class="line">    return EagerSingleton.instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>两种暴力破解和防范的方式都介绍完了，感兴趣的同志可以去试试我这里没有贴出完整的测试代码和运行结果。</p>
<p>ref:<br><a href="https://segmentfault.com/a/1190000018945930" target="_blank" rel="external">https://segmentfault.com/a/1190000018945930</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-建造模式</title>
    <url>/2017/10/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在阎宏博士的《JAVA与模式》一书中开头是这样描述建造(Builder)模式的:</p>
<p>建造模式是对象的创建模式。建造模式可以将一个产品的内部表象(internal representation)与产品的生产过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。</p>
<a id="more"></a>
<h2 id="产品的内部表象"><a href="#产品的内部表象" class="headerlink" title="产品的内部表象"></a>产品的内部表象</h2><p>一个产品常有不同的组成成分作为产品的零件，这些零件有可能是对象，也有可能不是对象，它们通常又叫做产品的内部表象(internal representation)。不同的产品可以有不同的内部表象，也就是不同的零件。使用建造模式可以使客户端不需要知道所生成的产品有哪些零件，每个产品的对应零件彼此有何不同，是怎么建造出来的，以及怎么组成产品。</p>
<h2 id="对象性质的建造"><a href="#对象性质的建造" class="headerlink" title="对象性质的建造"></a>对象性质的建造</h2><p>有些情况下，一个对象会有一些重要的性质，在它们没有恰当的值之前，对象不能作为一个完整的产品使用。比如，一个电子邮件有发件人地址、收件人地址、主题、内容、附录等部分，而在最起码的收件人地址得到赋值之前，这个电子邮件不能发送。</p>
<p>有些情况下，一个对象的一些性质必须按照某个顺序赋值才有意义。在某个性质没有赋值之前，另一个性质则无法赋值。这些情况使得性质本身的建造涉及到复杂的商业逻辑。这时候，此对象相当于一个有待建造的产品，而对象的这些性质相当于产品的零件，建造产品的过程是建造零件的过程。由于建造零件的过程很复杂，因此，这些零件的建造过程往往被“外部化”到另一个称做建造者的对象里，建造者对象返还给客户端的是一个全部零件都建造完毕的产品对象。</p>
<p>建造模式利用一个导演者对象和具体建造者对象一个个地建造出所有的零件，从而建造出完整的产品对象。建造者模式将产品的结构和产品的零件的建造过程对客户端隐藏起来，把对建造过程进行指挥的责任和具体建造者零件的责任分割开来，达到责任划分和封装的目的。　</p>
<h2 id="建造模式的结构"><a href="#建造模式的结构" class="headerlink" title="建造模式的结构"></a>建造模式的结构</h2><img src="/2017/10/28/设计模式-建造模式/download.png" alt="download.png" title="">
<p>在这个示意性的系统里，最终产品Product只有两个零件，即part1和part2。相应的建造方法也有两个:buildPart1()和buildPart2()、同时可以看出本模式涉及到四个角色，它们分别是:</p>
<ul>
<li><strong>抽象建造者(Builder)</strong>角色: 给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口独立于应用程序的商业逻辑。模式中直接创建产品对象的是具体建造者 (ConcreteBuilder)角色。具体建造者类必须实现这个接口所要求的两种方法:一种是建造方法(buildPart1和 buildPart2)，另一种是返还结构方法(retrieveResult)。一般来说，产品所包含的零件数目与建造方法的数目相符。换言之，有多少 零件，就有多少相应的建造方法。</li>
<li><strong>具体建造者(ConcreteBuilder)</strong>角色: 担任这个角色的是与应用程序紧密相关的一些类，它们在应用程序调用下创建产品的实例。这个角色要完成的任务包括:1.实现抽象建造者Builder所声明的接口，给出一步一步地完成创建产品实例的操作。2.在建造过程完成后，提供产品的实例。</li>
<li><strong>导演者(Director)</strong>角色: 担任这个角色的类调用具体建造者角色以创建产品对象。应当指出的是，导演者角色并没有产品类的具体知识，真正拥有产品类的具体知识的是具体建造者角色。</li>
<li><strong>产品(Product)</strong>角色: 产品便是建造中的复杂对象。一般来说，一个系统中会有多于一个的产品类，而且这些产品类并不一定有共同的接口，而完全可以是不相关联的。</li>
</ul>
<p>导演者角色是与客户端打交道的角色。导演者将客户端创建产品的请求划分为对各个零件的建造请求，再将这些请求委派给具体建造者角色。具体建造者角色是做具体建造工作的，但是却不为客户端所知。</p>
<p>一般来说，每有一个产品类，就有一个相应的具体建造者类。这些产品应当有一样数目的零件，而每有一个零件就相应地在所有的建造者角色里有一个建造方法。</p>
<p>产品类Product<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 定义一些关于产品的操作</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String part1;</div><div class="line">    <span class="keyword">private</span> String part2;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPart1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> part1;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart1</span><span class="params">(String part1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.part1 = part1;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPart2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> part2;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPart2</span><span class="params">(String part2)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.part2 = part2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>抽象建造者类Builder<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">retrieveResult</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体建造者类ConcreteBuilder<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 产品零件建造方法1</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//构建产品的第一个零件</span></div><div class="line"> 　　　　product.setPart1(<span class="string">"编号:9527"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 产品零件建造方法2</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPart2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//构建产品的第二个零件</span></div><div class="line"> 　　　　product.setPart2(<span class="string">"名称:XXX"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 产品返还方法</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">retrieveResult</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> product;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>导演者类Director<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 持有当前需要使用的建造器对象</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Builder builder;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造方法，传入建造器对象</div><div class="line">     * <span class="doctag">@param</span> builder 建造器对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.builder = builder;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 产品构造方法，负责调用各个零件建造方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">()</span></span>&#123;</div><div class="line">        builder.buildPart1();</div><div class="line">        builder.buildPart2();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端类Client<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</div><div class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</div><div class="line">        Director director = <span class="keyword">new</span> Director(builder);</div><div class="line">        director.construct();</div><div class="line">        Product product = builder.retrieveResult();</div><div class="line">        System.out.println(product.getPart1());</div><div class="line">        System.out.println(product.getPart2());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><img src="/2017/10/28/设计模式-建造模式/downloa2.png" alt="downloa2.png" title="">
<p>客户端负责创建导演者和具体建造者对象。然后，客户端把具体建造者对象交给导演者，导演者操作具体建造者，开始创建产品。当产品完成后，建造者把产品返还给客户端。<br>把创建具体建造者对象的任务交给客户端而不是导演者对象，是为了将导演者对象与具体建造者对象的耦合变成动态的，从而使导演者对象可以操纵数个具体建造者对象中的任何一个。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>假设有一个电子杂志系统，定期地向用户的电子邮件信箱发送电子杂志。用户可以通过网页订阅电子杂志，也可以通过网页结束订阅。当客户开始订阅时，系统发送一个电子邮件表示欢迎，当客户结束订阅时，系统发送一个电子邮件表示欢送。本例子就是这个系统负责发送“欢迎”和“欢送”邮件的模块。</p>
<p>在本例中，产品类就是发给某个客户的“欢迎”和“欢送”邮件，如下图所示。<br><img src="/2017/10/28/设计模式-建造模式/download3.png" alt="download3.png" title=""><br>虽然在这个例子里面各个产品类均有一个共同的接口，但这仅仅是本例子特有的，并不代表建造模式的特点。建造模式可以应用到具有完全不同接口的产品类上。大多数情况下是不知道最终构建出来的产品是什么样的，所以在标准的建造模式里面，一般是不需要对产品定义抽象接口的，因为最终构造的产品千差万别，给这些产品定义公共接口几乎是没有意义的。</p>
<p>下图所示就是这个系统的类图。<br><img src="/2017/10/28/设计模式-建造模式/download4.png" alt="download4.png" title=""><br>这个系统含有客户端(Client)、导演者(Director)、抽象建造者(Builder)、具体建造者(WelcomeBuilder和GoodbyeBuilder)、产品(WelcomeMessage和GoodbyeMessage)等角色。</p>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>抽象类AutoMessage源代码，send()操作仅仅是示意性的，并没有给出任何发送电子邮件的代码。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoMessage</span> </span>&#123;</div><div class="line">    <span class="comment">//收件人地址</span></div><div class="line">    <span class="keyword">private</span> String to;</div><div class="line">    <span class="comment">//发件人地址</span></div><div class="line">    <span class="keyword">private</span> String from;</div><div class="line">    <span class="comment">//标题</span></div><div class="line">    <span class="keyword">private</span> String subject;</div><div class="line">    <span class="comment">//内容</span></div><div class="line">    <span class="keyword">private</span> String body;</div><div class="line">    <span class="comment">//发送日期</span></div><div class="line">    <span class="keyword">private</span> Date sendDate;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"收件人地址:"</span> + to);</div><div class="line">        System.out.println(<span class="string">"发件人地址:"</span> + from);</div><div class="line">        System.out.println(<span class="string">"标题:"</span> + subject);</div><div class="line">        System.out.println(<span class="string">"内容:"</span> + body);</div><div class="line">        System.out.println(<span class="string">"发送日期:"</span> + sendDate);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTo</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> to;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTo</span><span class="params">(String to)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.to = to;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFrom</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> from;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFrom</span><span class="params">(String from)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.from = from;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> subject;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSubject</span><span class="params">(String subject)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subject = subject;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBody</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> body;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBody</span><span class="params">(String body)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.body = body;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getSendDate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sendDate;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSendDate</span><span class="params">(Date sendDate)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.sendDate = sendDate;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体产品类WelcomeMessage<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeMessage</span> <span class="keyword">extends</span> <span class="title">AutoMessage</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造子</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WelcomeMessage</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"发送欢迎信息"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体产品类GoodbyeMessage<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodbyeMessage</span> <span class="keyword">extends</span> <span class="title">AutoMessage</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GoodbyeMessage</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"发送欢送信息"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>抽象建造者类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">protected</span> AutoMessage msg;</div><div class="line">    <span class="comment">//标题零件的建造方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildSubject</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//内容零件的建造方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">//收件人零件的建造方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTo</span><span class="params">(String to)</span></span>&#123;</div><div class="line">        msg.setTo(to);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//发件人零件的建造方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFrom</span><span class="params">(String from)</span></span>&#123;</div><div class="line">        msg.setFrom(from);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//发送时间零件的建造方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSendDate</span><span class="params">()</span></span>&#123;</div><div class="line">        msg.setSendDate(<span class="keyword">new</span> Date());</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 邮件产品完成后，用此方法发送邮件</div><div class="line">     * 此方法相当于产品返还方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span></span>&#123;</div><div class="line">        msg.send();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体建造者WelcomeBuilder<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WelcomeBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WelcomeBuilder</span><span class="params">()</span></span>&#123;</div><div class="line">        msg = <span class="keyword">new</span> WelcomeMessage();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>&#123;</div><div class="line"> 　　　　msg.setBody(<span class="string">"欢迎内容"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSubject</span><span class="params">()</span> </span>&#123;</div><div class="line"> 　　　　msg.setSubject(<span class="string">"欢迎标题"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体建造者<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoodbyeBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GoodbyeBuilder</span><span class="params">()</span></span>&#123;</div><div class="line">        msg = <span class="keyword">new</span> GoodbyeMessage();</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildBody</span><span class="params">()</span> </span>&#123;</div><div class="line"> 　　　　msg.setBody(<span class="string">"欢送内容"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSubject</span><span class="params">()</span> </span>&#123;</div><div class="line"> 　　　　msg.setSubject(<span class="string">"欢送标题"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>导演者Director，这个类提供一个construct()方法，此方法调用建造者的建造方法，包括buildTo()、buildFrom()、buildSubject()、buildBody()、buildSendDate()等，从而一部分一部分地建造出产品对象，既AutoMessage对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</div><div class="line">    Builder builder;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造子</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.builder = builder;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 产品构造方法，负责调用各零件的建造方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(String toAddress , String fromAddress)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.builder.buildTo(toAddress);</div><div class="line">        <span class="keyword">this</span>.builder.buildFrom(fromAddress);</div><div class="line">        <span class="keyword">this</span>.builder.buildSubject();</div><div class="line">        <span class="keyword">this</span>.builder.buildBody();</div><div class="line">        <span class="keyword">this</span>.builder.buildSendDate();</div><div class="line">        <span class="keyword">this</span>.builder.sendMessage();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Builder builder = <span class="keyword">new</span> WelcomeBuilder();</div><div class="line">        Director director = <span class="keyword">new</span> Director(builder);</div><div class="line">        director.construct(<span class="string">"toAddress@126.com"</span>, <span class="string">"fromAddress@126.com"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="建造模式分成两个很重要的部分"><a href="#建造模式分成两个很重要的部分" class="headerlink" title="建造模式分成两个很重要的部分"></a>建造模式分成两个很重要的部分</h2><ol>
<li><strong>Builder接口</strong>，这里是定义了如何构建各个部件，也就是知道每个部件功能如何实现，以及如何装配这些部件到产品中去；</li>
<li><strong>Director</strong>，Director是知道如何组合来构建产品，也就是说Director负责整体的构建算法，而且通常是分步骤地来执行。</li>
</ol>
<p>不管如何变化，建造模式都存在这么两个部分，一个部分是部件构造和产品装配，另一个部分是整体构建的算法。认识这点是很重要的，因为在建造模式中，强调的是固定整体构建的算法，而灵活扩展和切换部件的具体构造和产品装配的方式。</p>
<p>再直白点说，建造模式的<strong>重心在于分离构建算法和具体的构造实现</strong>，从而使得构建算法可以重用。具体的构造实现可以很方便地扩展和切换，从而可以灵活地组合来构造出不同的产品对象。</p>
<h2 id="使用建造模式构建复杂对象"><a href="#使用建造模式构建复杂对象" class="headerlink" title="使用建造模式构建复杂对象"></a>使用建造模式构建复杂对象</h2><p>考虑这样一个实际应用，要创建一个保险合同的对象，里面很多属性的值都有约束，要求创建出来的对象是满足这些约束规则的。约束规则比如:保险合同通常情况下可以和个人签订，也可以和某个公司签订，但是一份保险合同不能同时与个人和公司签订。这个对象里有很多类似这样的约束，采用建造模式来构建复杂的对象，通常会对建造模式进行一定的简化，因为目标明确，就是创建某个复杂对象，因此做适当简化会使程序更简洁。大致简化如下:</p>
<ul>
<li>由于是用Builder模式来创建某个对象，因此就没有必要再定义一个Builder接口，直接提供一个具体的建造者类就可以了。</li>
<li>对于创建一个复杂的对象，可能会有很多种不同的选择和步骤，干脆去掉“导演者”，把导演者的功能和Client的功能合并起来，也就是说,Client这个时候就相当于导演者，它来指导构建器类去构建需要的复杂对象。</li>
</ul>
<p>保险合同类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 保险合同对象</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsuranceContract</span> </span>&#123;</div><div class="line">    <span class="comment">//保险合同编号</span></div><div class="line">　　<span class="keyword">private</span> String contractId;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 被保险人员的名称，同一份保险合同，要么跟人员签订，要么跟公司签订</div><div class="line">     * 也就是说，“被保险人员”和“被保险公司”这两个属性，不可能同时有值</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> String personName;</div><div class="line">    <span class="comment">//被保险公司的名称</span></div><div class="line">　　<span class="keyword">private</span> String companyName;</div><div class="line">    <span class="comment">//保险开始生效日期</span></div><div class="line">　　<span class="keyword">private</span> <span class="keyword">long</span> beginDate;</div><div class="line">    <span class="comment">//保险失效日期，一定会大于保险开始生效日期</span></div><div class="line">　　<span class="keyword">private</span> <span class="keyword">long</span> endDate;</div><div class="line">    <span class="comment">//其他数据</span></div><div class="line">　　<span class="keyword">private</span> String otherData;</div><div class="line">    <span class="comment">//私有构造方法</span></div><div class="line">　　<span class="function"><span class="keyword">private</span> <span class="title">InsuranceContract</span><span class="params">(ConcreteBuilder builder)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.contractId = builder.contractId;</div><div class="line">        <span class="keyword">this</span>.personName = builder.personName;</div><div class="line">        <span class="keyword">this</span>.companyName = builder.companyName;</div><div class="line">        <span class="keyword">this</span>.beginDate = builder.beginDate;</div><div class="line">        <span class="keyword">this</span>.endDate = builder.endDate;</div><div class="line">        <span class="keyword">this</span>.otherData = builder.otherData;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 保险合同的一些操作</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someOperation</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"当前正在操作的保险合同编号为【"</span>+<span class="keyword">this</span>.contractId+<span class="string">"】"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span></span>&#123;</div><div class="line">        <span class="keyword">private</span> String contractId;</div><div class="line">        <span class="keyword">private</span> String personName;</div><div class="line">        <span class="keyword">private</span> String companyName;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">long</span> beginDate;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">long</span> endDate;</div><div class="line">        <span class="keyword">private</span> String otherData;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 构造方法，传入必须要有的参数</div><div class="line">         * <span class="doctag">@param</span> contractId     保险合同编号</div><div class="line">         * <span class="doctag">@param</span> beginDate        保险合同开始生效日期</div><div class="line">         * <span class="doctag">@param</span> endDate        保险合同失效日期</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ConcreteBuilder</span><span class="params">(String contractId,<span class="keyword">long</span> beginDate,<span class="keyword">long</span> endDate)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.contractId = contractId;</div><div class="line">            <span class="keyword">this</span>.beginDate = beginDate;</div><div class="line">            <span class="keyword">this</span>.endDate = endDate;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//被保险人员的名称</span></div><div class="line">　　　　<span class="function"><span class="keyword">public</span> ConcreteBuilder <span class="title">setPersonName</span><span class="params">(String personName)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.personName = personName;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//被保险公司的名称</span></div><div class="line">　　　　<span class="function"><span class="keyword">public</span> ConcreteBuilder <span class="title">setCompanyName</span><span class="params">(String companyName)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.companyName = companyName;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//其他数据</span></div><div class="line">　　　　<span class="function"><span class="keyword">public</span> ConcreteBuilder <span class="title">setOtherData</span><span class="params">(String otherData)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.otherData = otherData;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 构建真正的对象并返回</div><div class="line">         * <span class="doctag">@return</span>    构建的保险合同对象</div><div class="line">         */</div><div class="line">        <span class="function"><span class="keyword">public</span> InsuranceContract <span class="title">build</span><span class="params">()</span></span>&#123;</div><div class="line">            <span class="keyword">if</span>(contractId == <span class="keyword">null</span> || contractId.trim().length()==<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"合同编号不能为空"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">boolean</span> signPerson = (personName != <span class="keyword">null</span> &amp;&amp; personName.trim().length() &gt; <span class="number">0</span>);</div><div class="line">            <span class="keyword">boolean</span> signCompany = (companyName != <span class="keyword">null</span> &amp;&amp; companyName.trim().length() &gt; <span class="number">0</span>);</div><div class="line">            <span class="keyword">if</span>(signPerson &amp;&amp; signCompany)&#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"一份保险合同不能同时与个人和公司签订"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(signPerson == <span class="keyword">false</span> &amp;&amp; signCompany == <span class="keyword">false</span>)&#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"一份保险合同不能没有签订对象"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(beginDate &lt;= <span class="number">0</span> )&#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"一份保险合同必须有开始生效的日期"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(endDate &lt;=<span class="number">0</span>)&#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"一份保险合同必须有失效的日期"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(endDate &lt; beginDate)&#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"一份保险合同的失效日期必须大于生效日期"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> InsuranceContract(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</div><div class="line">        <span class="comment">//创建构建器对象</span></div><div class="line"> 　　　　InsuranceContract.ConcreteBuilder builder =</div><div class="line">            <span class="keyword">new</span> InsuranceContract.ConcreteBuilder(<span class="string">"9527"</span>, <span class="number">123L</span>, <span class="number">456L</span>);</div><div class="line">        <span class="comment">//设置需要的数据，然后构建保险合同对象</span></div><div class="line"> 　　　　InsuranceContract contract = </div><div class="line">            builder.setPersonName(<span class="string">"小明"</span>).setOtherData(<span class="string">"test"</span>).build();</div><div class="line">        <span class="comment">//操作保险合同对象的方法</span></div><div class="line"> 　　　　contract.someOperation();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在本例中将具体建造者合并到了产品对象中，并将产品对象的构造函数私有化，防止客户端不使用构建器来构建产品对象，而是直接去使用new来构建产品对象所导致的问题。另外，这个构建器的功能就是为了创建被构建的对象，完全可以不用单独一个类。</p>
<h2 id="什么情况下使用建造模式"><a href="#什么情况下使用建造模式" class="headerlink" title="什么情况下使用建造模式"></a>什么情况下使用建造模式</h2><ol>
<li>需要生成的产品对象有复杂的内部结构，每一个内部成分本身可以是对象，也可以仅仅是一个对象(即产品对象)的一个组成部分。</li>
<li>需要生成的产品对象的属性相互依赖。建造模式可以强制实行一种分步骤进行的建造过程，因此，如果产品对象的一个属性必须在另一个属性被赋值之后才可以被赋值，使用建造模式是一个很好的设计思想。</li>
<li>在对象创建过程中会使用到系统中的其他一些对象，这些对象在产品对象的创建过程中不易得到。</li>
</ol>
<p>ref: <a href="http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/04/07/2433939.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-抽象工厂模式</title>
    <url>/2017/10/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>抽象工厂模式</p>
<h2 id="场景问题"><a href="#场景问题" class="headerlink" title="场景问题"></a>场景问题</h2><p>举个生活中常见的例子——组装电脑，我们在组装电脑的时候，通常需要选择一系列的配件，比如CPU、硬盘、内存、主板、电源、机箱等。为讨论使用简单点，只考虑选择CPU和主板的问题。</p>
<p>事实上，在选择CPU的时候，面临一系列的问题，比如品牌、型号、针脚数目、主频等问题，只有把这些问题都确定下来，才能确定具体的CPU。</p>
<p>同样，在选择主板的时候，也有一系列问题，比如品牌、芯片组、集成芯片、总线频率等问题，也只有这些都确定了，才能确定具体的主板。</p>
<p>选择不同的CPU和主板，是每个客户在组装电脑的时候，向装机公司提出的要求，也就是我们每个人自己拟定的装机方案。</p>
<p>在最终确定这个装机方案之前，还需要整体考虑各个配件之间的兼容性。比如:CPU和主板，如果使用Intel的CPU和AMD的主板是根本无法组装的。因为Intel的CPU针脚数与AMD主板提供的CPU插口不兼容，就是说如果使用Intel的CPU根本就插不到AMD的主板中，所以装机方案是整体性的，里面选择的各个配件之间是有关联的。</p>
<p>对于装机工程师而言，他只知道组装一台电脑，需要相应的配件，但是具体使用什么样的配件，还得由客户说了算。也就是说装机工程师只是负责组装，而客户负责选择装配所需要的具体的配件。因此，当装机工程师为不同的客户组装电脑时，只需要根据客户的装机方案，去获取相应的配件，然后组装即可。</p>
<h2 id="使用简单工厂模式的解决方案"><a href="#使用简单工厂模式的解决方案" class="headerlink" title="使用简单工厂模式的解决方案"></a>使用简单工厂模式的解决方案</h2><p>考虑客户的功能，需要选择自己需要的CPU和主板，然后告诉装机工程师自己的选择，接下来就等着装机工程师组装电脑了。</p>
<p>对装机工程师而言，只是知道CPU和主板的接口，而不知道具体实现，很明显可以用上简单工厂模式或工厂方法模式。为了简单，这里选用简单工厂。客户告诉装机工程师自己的选择，然后装机工程师会通过相应的工厂去获取相应的实例对象。<br><img src="/2017/10/28/设计模式-抽象工厂模式/download.png" alt="download.png" title=""></p>
<p>源代码<br>CPU接口与具体实现<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cpu</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelCpu</span> <span class="keyword">implements</span> <span class="title">Cpu</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pins = <span class="number">0</span>; <span class="comment">/* CPU的针脚数 */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntelCpu</span><span class="params">(<span class="keyword">int</span> pins)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.pins = pins;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Intel CPU的针脚数:"</span> + pins);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdCpu</span> <span class="keyword">implements</span> <span class="title">Cpu</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pins = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">AmdCpu</span><span class="params">(<span class="keyword">int</span> pins)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.pins = pins;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"AMD CPU的针脚数:"</span> + pins);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主板接口与具体实现<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mainboard</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installCPU</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class IntelMainboard implements Mainboard &#123;</div><div class="line">    private int cpuHoles = 0; /* CPU插槽的孔数 */</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 构造方法，传入CPU插槽的孔数</div><div class="line">     * @param cpuHoles</div><div class="line">     */</div><div class="line">    public IntelMainboard(int cpuHoles)&#123;</div><div class="line">        this.cpuHoles = cpuHoles;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void installCPU() &#123;</div><div class="line">        System.out.println(&quot;Intel主板的CPU插槽孔数是:&quot; + cpuHoles);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdMainboard</span> <span class="keyword">implements</span> <span class="title">Mainboard</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cpuHoles = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造方法，传入CPU插槽的孔数</div><div class="line">     * <span class="doctag">@param</span> cpuHoles</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AmdMainboard</span><span class="params">(<span class="keyword">int</span> cpuHoles)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.cpuHoles = cpuHoles;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installCPU</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"AMD主板的CPU插槽孔数是:"</span> + cpuHoles);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CPU与主板工厂类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CpuFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cpu <span class="title">createCpu</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</div><div class="line">        Cpu cpu = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)&#123;</div><div class="line">            cpu = <span class="keyword">new</span> IntelCpu(<span class="number">755</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)&#123;</div><div class="line">            cpu = <span class="keyword">new</span> AmdCpu(<span class="number">938</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> cpu;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainboardFactory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Mainboard <span class="title">createMainboard</span><span class="params">(<span class="keyword">int</span> type)</span></span>&#123;</div><div class="line">        Mainboard mainboard = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>(type == <span class="number">1</span>)&#123;</div><div class="line">            mainboard = <span class="keyword">new</span> IntelMainboard(<span class="number">755</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">2</span>)&#123;</div><div class="line">            mainboard = <span class="keyword">new</span> AmdMainboard(<span class="number">938</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> mainboard;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>装机工程师类与客户类运行结果如下<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerEngineer</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 定义组装机需要的CPU</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Cpu cpu = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 定义组装机需要的主板</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Mainboard mainboard = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeComputer</span><span class="params">(<span class="keyword">int</span> cpuType , <span class="keyword">int</span> mainboard)</span></span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 组装机器的基本步骤</div><div class="line">         */</div><div class="line">        <span class="comment">//1:首先准备好装机所需要的配件</span></div><div class="line">        prepareHardwares(cpuType, mainboard);</div><div class="line">        <span class="comment">//2:组装机器</span></div><div class="line">        <span class="comment">//3:测试机器</span></div><div class="line">        <span class="comment">//4:交付客户</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareHardwares</span><span class="params">(<span class="keyword">int</span> cpuType , <span class="keyword">int</span> mainboard)</span></span>&#123;</div><div class="line">        <span class="comment">//这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个</span></div><div class="line">        <span class="comment">//可是，装机工程师并不知道如何去创建，怎么办呢？</span></div><div class="line">        </div><div class="line">        <span class="comment">//直接找相应的工厂获取</span></div><div class="line">        <span class="keyword">this</span>.cpu = CpuFactory.createCpu(cpuType);</div><div class="line">        <span class="keyword">this</span>.mainboard = MainboardFactory.createMainboard(mainboard);</div><div class="line">        </div><div class="line">        <span class="comment">//测试配件是否好用</span></div><div class="line">        <span class="keyword">this</span>.cpu.calculate();</div><div class="line">        <span class="keyword">this</span>.mainboard.installCPU();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</div><div class="line">        ComputerEngineer cf = <span class="keyword">new</span> ComputerEngineer();</div><div class="line">        cf.makeComputer(<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下:<br><img src="/2017/10/28/设计模式-抽象工厂模式/download1.png" alt="download1.png" title=""><br>上面的实现，虽然通过简单工厂方法解决了:对于装机工程师，只知CPU和主板的接口，而不知道具体实现的问题。但还有一个问题没有解决，那就是这些CPU对象和主板对象其实是有关系的，需要相互匹配的。而上面的实现中，并没有维护这种关联关系，CPU和主板是由客户任意选择，这是有问题的。比如在客户端调用makeComputer时，传入参数为(1,2)，运行结果如下:<br><img src="/2017/10/28/设计模式-抽象工厂模式/download2.png" alt="download2.png" title=""><br>观察上面结果就会看出问题。客户选择的是Intel的CPU针脚数为755，而选择的主板是AMD，主板上的CPU插孔是938，根本无法组装，这就是没有维护配件之间的关系造成的。该怎么解决这个问题呢？　　</p>
<h2 id="引进抽象工厂模式"><a href="#引进抽象工厂模式" class="headerlink" title="引进抽象工厂模式"></a>引进抽象工厂模式</h2><p>每一个模式都是针对一定问题的解决方案。抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。</p>
<p>在学习抽象工厂具体实例之前，应该明白两个重要的概念:产品族和产品等级。</p>
<p>所谓产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。而这两个家族都来自于三个产品等级:主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成，示意图如下:<br><img src="/2017/10/28/设计模式-抽象工厂模式/download3.png" alt="download3.png" title=""><br>显然，每一个产品族中含有产品的数目，与产品等级结构的数目是相等的。产品的等级结构与产品族将产品按照不同方向划分，形成一个二维的坐标系。横轴表示产品的等级结构，纵轴表示产品族，上图共有两个产品族，分布于三个不同的产品等级结构中。只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一的确定这个产品。</p>
<p>上面所给出的三个不同的等级结构具有平行的结构。因此，如果采用工厂方法模式，就势必要使用三个独立的工厂等级结构来对付这三个产品等级结构。由于这三个产品等级结构的相似性，会导致三个平行的工厂等级结构。随着产品等级结构的数目的增加，工厂方法模式所给出的工厂等级结构的数目也会随之增加。如下图:<br><img src="/2017/10/28/设计模式-抽象工厂模式/download4.png" alt="download4.png" title=""><br>那么，是否可以使用同一个工厂等级结构来对付这些相同或者极为相似的产品等级结构呢？当然可以的，而且这就是抽象工厂模式的好处。同一个工厂等级结构负责三个不同产品等级结构中的产品对象的创建。<br><img src="/2017/10/28/设计模式-抽象工厂模式/download5.png" alt="download5.png" title=""><br>可以看出，一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。显然，这时候抽象工厂模式比简单工厂模式、工厂方法模式更有效率。对应于每一个产品族都有一个具体工厂。而每一个具体工厂负责创建属于同一个产品族，但是分属于不同等级结构的产品。</p>
<p>抽象工厂模式结构<br>抽象工厂模式是对象的创建模式，它是工厂方法模式的进一步推广。</p>
<p>假设一个子系统需要一些产品对象，而这些产品又属于一个以上的产品等级结构。那么为了将消费这些产品对象的责任和创建这些产品对象的责任分割开来，可以引进抽象工厂模式。这样的话，消费产品的一方不需要直接参与产品的创建工作，而只需要向一个公用的工厂接口请求所需要的产品。</p>
<p>通过使用抽象工厂模式，可以处理具有相同（或者相似）等级结构中的多个产品族中的产品对象的创建问题。如下图所示:<br><img src="/2017/10/28/设计模式-抽象工厂模式/download6.png" alt="download6.png" title=""><br>由于这两个产品族的等级结构相同，因此使用同一个工厂族也可以处理这两个产品族的创建问题，这就是抽象工厂模式。</p>
<p>根据产品角色的结构图，就不难给出工厂角色的结构设计图。<br><img src="/2017/10/28/设计模式-抽象工厂模式/download7.png" alt="download7.png" title=""><br>可以看出，每一个工厂角色都有两个工厂方法，分别负责创建分属不同产品等级结构的产品对象。<br><img src="/2017/10/28/设计模式-抽象工厂模式/download8.png" alt="download8.png" title=""></p>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>前面示例实现的CPU接口和CPU实现对象，主板接口和主板实现对象，都不需要变化。<br>前面示例中创建CPU的简单工厂和创建主板的简单工厂，都不再需要。<br>新加入的抽象工厂类和实现类:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建CPU对象</div><div class="line">     * <span class="doctag">@return</span> CPU对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">createCpu</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 创建主板对象</div><div class="line">     * <span class="doctag">@return</span> 主板对象</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> Mainboard <span class="title">createMainboard</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">createCpu</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelCpu(<span class="number">755</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Mainboard <span class="title">createMainboard</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelMainboard(<span class="number">755</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Cpu <span class="title">createCpu</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelCpu(<span class="number">938</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Mainboard <span class="title">createMainboard</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelMainboard(<span class="number">938</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>装机工程师类跟前面的实现相比，主要的变化是:从客户端不再传入选择CPU和主板的参数，而是直接传入客户已经选择好的产品对象。这样就避免了单独去选择CPU和主板所带来的兼容性问题，客户要选就是一套，就是一个系列。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerEngineer</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 定义组装机需要的CPU</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Cpu cpu = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 定义组装机需要的主板</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> Mainboard mainboard = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeComputer</span><span class="params">(AbstractFactory af)</span></span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 组装机器的基本步骤</div><div class="line">         */</div><div class="line">        <span class="comment">//1:首先准备好装机所需要的配件</span></div><div class="line">        prepareHardwares(af);</div><div class="line">        <span class="comment">//2:组装机器</span></div><div class="line">        <span class="comment">//3:测试机器</span></div><div class="line">        <span class="comment">//4:交付客户</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepareHardwares</span><span class="params">(AbstractFactory af)</span></span>&#123;</div><div class="line">        <span class="comment">//这里要去准备CPU和主板的具体实现，为了示例简单，这里只准备这两个</span></div><div class="line">        <span class="comment">//可是，装机工程师并不知道如何去创建，怎么办呢？</span></div><div class="line">        </div><div class="line">        <span class="comment">//直接找相应的工厂获取</span></div><div class="line">        <span class="keyword">this</span>.cpu = af.createCpu();</div><div class="line">        <span class="keyword">this</span>.mainboard = af.createMainboard();</div><div class="line">        </div><div class="line">        <span class="comment">//测试配件是否好用</span></div><div class="line">        <span class="keyword">this</span>.cpu.calculate();</div><div class="line">        <span class="keyword">this</span>.mainboard.installCPU();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>客户端代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</div><div class="line">        <span class="comment">//创建装机工程师对象</span></div><div class="line">        ComputerEngineer cf = <span class="keyword">new</span> ComputerEngineer();</div><div class="line">        <span class="comment">//客户选择并创建需要使用的产品对象</span></div><div class="line">        AbstractFactory af = <span class="keyword">new</span> IntelFactory();</div><div class="line">        <span class="comment">//告诉装机工程师自己选择的产品，让装机工程师组装电脑</span></div><div class="line">        cf.makeComputer(af);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>抽象工厂的功能是为一系列相关对象或相互依赖的对象创建一个接口。一定要注意，这个接口内的方法不是任意堆砌的，而是一系列相关或相互依赖的方法。比如上面例子中的主板和CPU，都是为了组装一台电脑的相关对象。不同的装机方案，代表一种具体的电脑系列。<br><img src="/2017/10/28/设计模式-抽象工厂模式/download9.png" alt="download9.png" title=""><br>由于抽象工厂定义的一系列对象通常是相关或相互依赖的，这些产品对象就构成了一个产品族，也就是抽象工厂定义了一个产品族。<br>这就带来非常大的灵活性，切换产品族的时候，只要提供不同的抽象工厂实现就可以了，也就是说现在是以一个产品族作为一个整体被切换。<br><img src="/2017/10/28/设计模式-抽象工厂模式/download10.png" alt="download10.png" title=""></p>
<h2 id="什么情况下应当使用抽象工厂模式"><a href="#什么情况下应当使用抽象工厂模式" class="headerlink" title="什么情况下应当使用抽象工厂模式"></a>什么情况下应当使用抽象工厂模式</h2><ol>
<li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。</li>
<li>这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</li>
<li>同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。（比如:Intel主板必须使用Intel CPU、Intel芯片组）</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。</li>
</ol>
<h2 id="抽象工厂模式的起源"><a href="#抽象工厂模式的起源" class="headerlink" title="抽象工厂模式的起源"></a>抽象工厂模式的起源</h2><p>抽象工厂模式的起源或者最早的应用，是用于创建分属于不同操作系统的视窗构建。比如:命令按键（Button）与文字框（Text)都是视窗构建，在UNIX操作系统的视窗环境和Windows操作系统的视窗环境中，这两个构建有不同的本地实现，它们的细节有所不同。</p>
<p>在每一个操作系统中，都有一个视窗构建组成的构建家族。在这里就是Button和Text组成的产品族。而每一个视窗构件都构成自己的等级结构，由一个抽象角色给出抽象的功能描述，而由具体子类给出不同操作系统下的具体实现。<br><img src="/2017/10/28/设计模式-抽象工厂模式/download11.png" alt="download11.png" title=""><br>可以发现在上面的产品类图中，有两个产品的等级结构，分别是Button等级结构和Text等级结构。同时有两个产品族，也就是UNIX产品族和Windows产品族。UNIX产品族由UNIX Button和UNIX Text产品构成；而Windows产品族由Windows Button和Windows Text产品构成。<br><img src="/2017/10/28/设计模式-抽象工厂模式/download12.png" alt="download12.png" title=""><br>系统对产品对象的创建需求由一个工程的等级结构满足，其中有两个具体工程角色，即UnixFactory和WindowsFactory。UnixFactory对象负责创建Unix产品族中的产品，而WindowsFactory对象负责创建Windows产品族中的产品。这就是抽象工厂模式的应用，抽象工厂模式的解决方案如下图:<br><img src="/2017/10/28/设计模式-抽象工厂模式/download13.png" alt="download13.png" title=""><br>显然，一个系统只能够在某一个操作系统的视窗环境下运行，而不能同时在不同的操作系统上运行。所以，系统实际上只能消费属于同一个产品族的产品。<br>在现代的应用中，抽象工厂模式的使用范围已经大大扩大了，不再要求系统只能消费某一个产品族了。因此，可以不必理会前面所提到的原始用意。</p>
<h2 id="抽象工厂模式的优点"><a href="#抽象工厂模式的优点" class="headerlink" title="抽象工厂模式的优点"></a>抽象工厂模式的优点</h2><ul>
<li>分离接口和实现<br>客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品的接口编程而已。也就是说，客户端从具体的产品实现中解耦。</li>
<li>使切换产品族变得容易<br>因为一个具体的工厂实现代表的是一个产品族，比如上面例子的从Intel系列到AMD系列只需要切换一下具体工厂。</li>
</ul>
<h2 id="抽象工厂模式的缺点"><a href="#抽象工厂模式的缺点" class="headerlink" title="抽象工厂模式的缺点"></a>抽象工厂模式的缺点</h2><ul>
<li>不太容易扩展新的产品<br>如果需要给整个产品族添加一个新的产品，那么就需要修改抽象工厂，这样就会导致修改所有的工厂实现类。</li>
</ul>
<p>ref:<br><a href="http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/03/28/2418836.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-模板方法模式</title>
    <url>/2017/10/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在阎宏博士的《JAVA与模式》一书中开头是这样描述模板方法（Template Method）模式的:</p>
<p>模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。</p>
<a id="more"></a>
<h2 id="模板方法模式的结构"><a href="#模板方法模式的结构" class="headerlink" title="模板方法模式的结构"></a>模板方法模式的结构</h2><p>模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。</p>
<p>模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。</p>
<p>模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示:<br><img src="/2017/10/28/设计模式-模板方法模式/download.png" alt="download.png" title=""><br>这里涉及到两个角色:<br><strong>抽象模板</strong>(Abstract Template)角色有如下责任:</p>
<ul>
<li>定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。</li>
<li>定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li>
</ul>
<p><strong>具体模板</strong>(Concrete Template)角色又如下责任:</p>
<ul>
<li>实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。</li>
<li>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</li>
</ul>
<p>源代码<br>抽象模板角色类，abstractMethod()、hookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由templateMethod()方法代表。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTemplate</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 模板方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//调用基本方法</span></div><div class="line">        abstractMethod();</div><div class="line">        hookMethod();</div><div class="line">        concreteMethod();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 基本方法的声明（由子类实现）</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 基本方法(空方法)</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookMethod</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 基本方法（已经实现）</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">concreteMethod</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="comment">//业务相关的代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而hookMethod()方法是可选择实现的逻辑，不是必须实现的。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title">AbstractTemplate</span></span>&#123;</div><div class="line">    <span class="comment">//基本方法的实现</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//业务相关的代码</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">//重写父类的方法</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hookMethod</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//业务相关的代码</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>模板模式的关键是:子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。</strong></p>
<p>每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照“责任”的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。</p>
<h2 id="模板方法模式中的方法"><a href="#模板方法模式中的方法" class="headerlink" title="模板方法模式中的方法"></a>模板方法模式中的方法</h2><p>模板方法中的方法可以分为两大类:模板方法和基本方法。</p>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。<br>一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。</p>
<h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>基本方法又可以分为三种:抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。</p>
<ul>
<li>抽象方法:一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。</li>
<li>具体方法:一个具体方法由抽象类声明并实现，而子类并不实现或置换。</li>
<li>钩子方法:一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。</li>
</ul>
<p>在上面的例子中，AbstractTemplate是一个抽象类，它带有三个方法。其中abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。concreteMethod()是一个具体方法，它由抽象类声明并实现。</p>
<h3 id="默认钩子方法"><a href="#默认钩子方法" class="headerlink" title="默认钩子方法"></a>默认钩子方法</h3><p>一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。显然，这种默认钩子方法在缺省适配模式里面已经见过了，一个缺省适配模式讲的是一个类为一个接口提供一个默认的空实现，从而使得缺省适配类的子类不必像实现接口那样必须给出所有方法的实现，因为通常一个具体类并不需要所有的方法。</p>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>命名规则是设计师之间赖以沟通的管道之一，使用恰当的命名规则可以帮助不同设计师之间的沟通。</p>
<p>钩子方法的名字应当以do开始，这是熟悉设计模式的Java开发人员的标准做法。在上面的例子中，钩子方法hookMethod()应当以do开头；在HttpServlet类中，也遵从这一命名规则，如doGet()、doPost()等方法。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>考虑一个计算存款利息的例子。假设系统需要支持两种存款账号，即货币市场(Money Market)账号和定期存款(Certificate of Deposite)账号。这两种账号的存款利息是不同的，因此，在计算一个存户的存款利息额时，必须区分两种不同的账号类型。</p>
<p>这个系统的总行为应当是计算出利息，这也就决定了作为一个模板方法模式的顶级逻辑应当是利息计算。由于利息计算涉及到两个步骤:一个基本方法给出账号种类，另一个基本方法给出利息百分比。这两个基本方法构成具体逻辑，因为账号的类型不同，所以具体逻辑会有所不同。</p>
<p>显然，系统需要一个抽象角色给出顶级行为的实现，而将两个作为细节步骤的基本方法留给具体子类实现。由于需要考虑的账号有两种:一是货币市场账号，二是定期存款账号。系统的类结构如下图所示。<br><img src="/2017/10/28/设计模式-模板方法模式/download1.png" alt="download1.png" title=""></p>
<p>源代码<br>抽象模板角色类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 模板方法，计算利息数额</div><div class="line">     * <span class="doctag">@return</span>    返回利息数额</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> <span class="title">calculateInterest</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">double</span> interestRate = doCalculateInterestRate();</div><div class="line">        String accountType = doCalculateAccountType();</div><div class="line">        <span class="keyword">double</span> amount = calculateAmount(accountType);</div><div class="line">        <span class="keyword">return</span> amount * interestRate;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 基本方法留给子类实现</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">doCalculateAccountType</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 基本方法留给子类实现</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">doCalculateInterestRate</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 基本方法，已经实现</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">calculateAmount</span><span class="params">(String accountType)</span></span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 省略相关的业务逻辑</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="number">7243.00</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体模板角色类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoneyMarketAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doCalculateAccountType</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="string">"Money Market"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">doCalculateInterestRate</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="number">0.045</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDAccount</span> <span class="keyword">extends</span> <span class="title">Account</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doCalculateAccountType</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Certificate of Deposite"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">doCalculateInterestRate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0.06</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端类<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Account account = <span class="keyword">new</span> MoneyMarketAccount();</div><div class="line">        System.out.println(<span class="string">"货币市场账号的利息数额为:"</span> + account.calculateInterest());</div><div class="line">        account = <span class="keyword">new</span> CDAccount();</div><div class="line">        System.out.println(<span class="string">"定期账号的利息数额为:"</span> + account.calculateInterest());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="模板方法模式在Servlet中的应用"><a href="#模板方法模式在Servlet中的应用" class="headerlink" title="模板方法模式在Servlet中的应用"></a>模板方法模式在Servlet中的应用</h2><p>使用过Servlet的人都清楚，除了要在web.xml做相应的配置外，还需继承一个叫HttpServlet的抽象类。HttpService类提供了一个service()方法，这个方法调用七个do方法中的一个或几个，完成对客户端调用的响应。这些do方法需要由HttpServlet的具体子类提供，因此这是典型的模板方法模式。下面是service()方法的源代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">    String method = req.getMethod();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</div><div class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</div><div class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// servlet doesn't support if-modified-since, no reason</span></div><div class="line">            <span class="comment">// to go through further expensive logic</span></div><div class="line">            doGet(req, resp);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</div><div class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</div><div class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></div><div class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></div><div class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></div><div class="line">                maybeSetLastModified(resp, lastModified);</div><div class="line">                doGet(req, resp);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</div><div class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</div><div class="line">        maybeSetLastModified(resp, lastModified);</div><div class="line">        doHead(req, resp);</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</div><div class="line">        doPost(req, resp);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</div><div class="line">        doPut(req, resp);        </div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</div><div class="line">        doDelete(req, resp);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</div><div class="line">        doOptions(req,resp);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</div><div class="line">        doTrace(req,resp);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="comment">// Note that this means NO servlet supports whatever</span></div><div class="line">        <span class="comment">// method was requested, anywhere on this server.</span></div><div class="line">        <span class="comment">//</span></div><div class="line"></div><div class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</div><div class="line">        Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</div><div class="line">        errArgs[<span class="number">0</span>] = method;</div><div class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</div><div class="line">        </div><div class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，这个service()方法也可以被子类置换掉。<br>下面给出一个简单的Servlet例子:<br><img src="/2017/10/28/设计模式-模板方法模式/download2.png" alt="download2.png" title=""><br>从上面的类图可以看出，TestServlet类是HttpServlet类的子类，并且置换掉了父类的两个方法:doGet()和doPost()。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">        </div><div class="line">        System.out.println(<span class="string">"using the GET method"</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">            <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">            </div><div class="line">        System.out.println(<span class="string">"using the POST method"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的例子可以看出这是一个典型的模板方法模式。</p>
<p>HttpServlet担任抽象模板角色<br>模板方法:由service()方法担任。<br>基本方法:由doPost()、doGet()等方法担任。</p>
<p>TestServlet担任具体模板角色<br>TestServlet置换掉了父类HttpServlet中七个基本方法中的其中两个，分别是doGet()和doPost()。</p>
<p>ref: <a href="http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/05/14/2495235.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>DB-数据库事务的四大特性以及事务的隔离级别</title>
    <url>/2017/10/16/DB-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<p>本篇讲诉数据库中事务的四大特性（ACID），并且将会详细地说明事务的隔离级别</p>
<a id="more"></a>
<p>如果一个数据库声称支持事务的操作，那么该数据库必须要具备以下四个特性</p>
<h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</p>
<p>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
<p>即要达到这么一种效果:对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
<p>例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<h2 id="事务隔离性问题"><a href="#事务隔离性问题" class="headerlink" title="事务隔离性问题"></a>事务隔离性问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。<br>当一个事务正在多次修改某个数据，而在这个事务中这多次的修改都还未提交，这时一个并发的事务来访问该数据，就会造成两个事务得到的数据不一致。例如:用户A向用户B转账100元，对应SQL命令如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">update account set money=money+100 where name=’B’;  (此时A通知B)</div><div class="line">update account set money=money - 100 where name=’A’;</div></pre></td></tr></table></figure></p>
<p>当只执行第一条SQL时，A通知B查看账户，B发现确实钱已到账（此时即发生了脏读），而之后无论第二条SQL是否执行，只要该事务不提交，则所有操作都将回滚，那么当B以后再次查看账户时就会发现钱其实并没有转。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</p>
<p>例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。</p>
<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了……</p>
<h3 id="虚读-幻读"><a href="#虚读-幻读" class="headerlink" title="虚读(幻读)"></a>虚读(幻读)</h3><p>幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</p>
<p>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）</p>
<h2 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h2><p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p>
<ol>
<li>Serializable (串行化):可避免脏读、不可重复读、幻读的发生。<br>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</li>
<li>Repeatable read (可重复读):可避免脏读、不可重复读的发生。<br>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题:幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</li>
<li>Read committed (读已提交):可避免脏读的发生。<br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义:一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</li>
<li>Read uncommitted (读未提交):最低级别，任何情况都无法保证。<br>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）</li>
</ol>
<p>以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像Serializable这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。在MySQL数据库中默认的隔离级别为Repeatable read (可重复读)。</p>
<p>在MySQL数据库中，支持上面四种隔离级别，默认的为Repeatable read (可重复读)；而在Oracle数据库中，只支持Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。<br>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示:<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611194432965.png" alt="201611194432965.png" title=""></p>
<h2 id="Mysql-与隔离级别"><a href="#Mysql-与隔离级别" class="headerlink" title="Mysql 与隔离级别"></a>Mysql 与隔离级别</h2><p>在MySQL数据库中查看当前事务的隔离级别:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">select @@tx_isolation;</div></pre></td></tr></table></figure></p>
<p>在MySQL数据库中设置事务的隔离 级别:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">set  [glogal | session]  transaction isolation level 隔离级别名称;</div><div class="line">or</div><div class="line">set tx_isolation=’隔离级别名称;’</div></pre></td></tr></table></figure></p>
<p>如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段:<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/787876-20160313202333460-377269897.png" alt="787876-20160313202333460-377269897.png" title=""><br>在JDBC中设置隔离级别的部分代码:<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/787876-20160313202355694-2106931487.png" alt="787876-20160313202355694-2106931487.png" title=""></p>
<p>后记:隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。</p>
<h2 id="测试Mysql的隔离级别"><a href="#测试Mysql的隔离级别" class="headerlink" title="测试Mysql的隔离级别"></a>测试Mysql的隔离级别</h2><p>下面，将利用MySQL的客户端程序，我们分别来测试一下这几种隔离级别。<br>测试数据库为demo，表为test；表结构:<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611194605622.png" alt="201611194605622.png" title=""><br>两个命令行客户端分别为A，B；不断改变A的隔离级别，在B端修改数据。</p>
<h3 id="将A的隔离级别设置为read-uncommitted-未提交读"><a href="#将A的隔离级别设置为read-uncommitted-未提交读" class="headerlink" title="将A的隔离级别设置为read uncommitted(未提交读)"></a>将A的隔离级别设置为read uncommitted(未提交读)</h3><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611194759917.png" alt="201611194759917.png" title="">
<p>A:启动事务，此时数据为初始状态<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611194632720.png" alt="201611194632720.png" title=""><br>B:启动事务，更新数据，但不提交<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611194653408.png" alt="201611194653408.png" title=""><br>A:再次读取数据，发现数据已经被修改了，这就是所谓的“脏读”<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611194718643.png" alt="201611194718643.png" title=""><br>B:回滚事务<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195241916.png" alt="201611195241916.png" title=""><br>A:再次读数据，发现数据变回初始状态<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195308274.png" alt="201611195308274.png" title=""><br>经过上面的实验可以得出结论，事务B更新了一条记录，但是没有提交，此时事务A可以查询出未提交记录。造成脏读现象。未提交读是最低的隔离级别。</p>
<h3 id="将客户端A的事务隔离级别设置为read-committed-已提交读"><a href="#将客户端A的事务隔离级别设置为read-committed-已提交读" class="headerlink" title="将客户端A的事务隔离级别设置为read committed(已提交读)"></a>将客户端A的事务隔离级别设置为read committed(已提交读)</h3><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195344953.png" alt="201611195344953.png" title="">
<p>A:启动事务，此时数据为初始状态<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195411881.png" alt="201611195411881.png" title=""><br>B:启动事务，更新数据，但不提交<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195435775.png" alt="201611195435775.png" title=""><br>A:再次读数据，发现数据未被修改<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195456816.png" alt="201611195456816.png" title=""><br>B:提交事务<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195517603.png" alt="201611195517603.png" title=""><br>A:再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195540774.png" alt="201611195540774.png" title=""><br>经过上面的实验可以得出结论，已提交读隔离级别解决了脏读的问题，但是出现了不可重复读的问题，即事务A在两次查询的数据不一致，因为在两次查询之间事务B更新了一条数据。已提交读只允许读取已提交的记录，但不要求可重复读。</p>
<h3 id="将A的隔离级别设置为repeatable-read-可重复读"><a href="#将A的隔离级别设置为repeatable-read-可重复读" class="headerlink" title="将A的隔离级别设置为repeatable read(可重复读)"></a>将A的隔离级别设置为repeatable read(可重复读)</h3><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195605770.png" alt="201611195605770.png" title="">
<p>A:启动事务，此时数据为初始状态<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195637644.png" alt="201611195637644.png" title=""><br>B:启动事务，更新数据，但不提交<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195714478.png" alt="201611195714478.png" title=""><br>A:再次读取数据，发现数据未被修改<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195736005.png" alt="201611195736005.png" title=""><br>B:提交事务<br>A:再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195821243.png" alt="201611195821243.png" title=""><br>B:插入一条新的数据，并提交<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195856395.png" alt="201611195856395.png" title=""><br>A:再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195918521.png" alt="201611195918521.png" title=""><br>A:提交本次事务，再次读取数据，发现读取正常了<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/201611195942907.png" alt="201611195942907.png" title=""><br>由以上的实验可以得出结论，可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务部的更新该记录。但该事务不要求与其他事务可串行化。例如，当一个事务可以找到由一个已提交事务更新的记录，但是可能产生幻读问题(注意是可能，因为数据库对隔离级别的实现有所差别)。像以上的实验，就没有出现数据幻读的问题。</p>
<h3 id="将A的隔离级别设置为可串行化-Serializable"><a href="#将A的隔离级别设置为可串行化-Serializable" class="headerlink" title="将A的隔离级别设置为可串行化(Serializable)"></a>将A的隔离级别设置为可串行化(Serializable)</h3><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/2016111100001382.png" alt="2016111100001382.png" title="">
<p>A:启动事务，此时数据为初始状态<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/2016111100031903.png" alt="2016111100031903.png" title=""><br>B:发现B此时进入了等待状态，原因是因为A的事务尚未提交，只能等待（此时，B可能会发生等待超时）<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/2016111100056502.png" alt="2016111100056502.png" title=""><br>A:提交事务<br>B:发现插入成功<br><img src="/2017/10/16/DB-数据库事务的四大特性以及事务的隔离级别/2016111100135047.png" alt="2016111100135047.png" title=""><br>serializable完全锁定字段，若一个事务来查询同一份数据就必须等待，直到前一个事务完成并解除锁定为止。是完整的隔离级别，会锁定对应的数据表格，因而会有效率的问题。</p>
<p>ref:<br><a href="http://www.cnblogs.com/fjdingsd/p/5273008.html" target="_blank" rel="external">http://www.cnblogs.com/fjdingsd/p/5273008.html</a><br><a href="http://www.jb51.net/article/96179.htm" target="_blank" rel="external">http://www.jb51.net/article/96179.htm</a></p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-接口和抽象类</title>
    <url>/2017/10/13/Java-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    <content><![CDATA[<p>在Java中,可以通过两种形式来体现OOP的抽象:接口和抽象类。这两者有太多相似的地方,又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用,但是实际则不然。</p>
<a id="more"></a>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在了解抽象类之前,先来了解一下抽象方法。抽象方法是一种特殊的方法:它只有声明,而没有具体的实现。抽象方法的声明格式为:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法,则称这个类为抽象类,抽象类必须在类前用abstract关键字修饰。<strong>因为抽象类中含有无具体实现的方法,所以不能用抽象类创建对象</strong></p>
<p>下面要注意一个问题:在《JAVA编程思想》一书中,将抽象类定义为“包含抽象方法的类”,但是后面发现如果一个类不包含抽象方法,只是用abstract修饰的话也是抽象类。<strong>也就是说抽象类不一定必须含有抽象方法</strong>。个人觉得这个属于钻牛角尖的问题吧,因为如果一个抽象类不包含任何抽象方法,为何还要设计为抽象类？所以暂且记住这个概念吧,不必去深究为什么。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[<span class="keyword">public</span>] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这里可以看出,抽象类就是为了继承而存在的,如果你定义了一个抽象类,却不去继承它,那么等于白白创建了这个抽象类,因为你不能用它来做任何事情。对于一个父类,如果它的某个方法在父类中实现出来没有任何意义,必须根据子类的实际需求来进行不同的实现,那么就可以将这个方法声明为abstract方法,此时这个类也就成为abstract类了。</p>
<p>包含抽象方法的类称为抽象类,但并不意味着抽象类中只能有抽象方法,它和普通类一样,同样可以拥有成员变量和普通的成员方法。注意,抽象类和普通类的主要有三点区别:</p>
<ol>
<li>抽象方法必须为public或者protected（因为如果为private,则不能被子类继承,子类便无法实现该方法）,缺省情况下默认为public。</li>
<li>抽象类不能用来创建对象；</li>
<li>如果一个类继承于一个抽象类,则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法,则必须将子类也定义为为abstract类。</li>
</ol>
<p>在其他方面,抽象类和普通的类并没有区别。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口,英文称作interface,在软件工程中,接口泛指供别人调用的方法或者函数。从这里,我们可以体会到Java语言设计者的初衷,它是<strong>对行为的抽象</strong>。在Java中,定一个接口的形式如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">[<span class="keyword">public</span>] <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span> </span>&#123;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口中可以含有 变量和方法。但是要注意,接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量,用private修饰会报编译错误）,而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字,比如private、protected、static、 final等修饰会报编译错误）,并且接口中所有的方法不能有具体的实现,也就是说,接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别,接口是一种极度抽象的类型,它比抽象类更加“抽象”,并且一般情况下不在接口中定义变量。</p>
<p>要让一个类遵循某组特地的接口需要使用implements关键字,具体格式如下:<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">class ClassName implements Interface1,Interface2,[....]&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出,允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口,就必须实现该接口中的所有方法。对于遵循某个接口的抽象类,可以不实现该接口中的抽象方法。</p>
<h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><h3 id="语法层面上的区别"><a href="#语法层面上的区别" class="headerlink" title="语法层面上的区别"></a>语法层面上的区别</h3><ol>
<li>抽象类可以提供成员方法的实现细节,而接口中只能存在public abstract 方法；</li>
<li>抽象类中的成员变量可以是各种类型的,而接口中的成员变量只能是public static final类型的；</li>
<li>接口中不能含有静态代码块以及静态方法,而抽象类可以有静态代码块和静态方法；</li>
<li>一个类只能继承一个抽象类,而一个类却可以实现多个接口。</li>
</ol>
<h3 id="设计层面上的区别"><a href="#设计层面上的区别" class="headerlink" title="设计层面上的区别"></a>设计层面上的区别</h3><ol>
<li><p><strong>抽象类是对一种事物的抽象,即对类抽象,而接口是对行为的抽象</strong>。抽象类是对整个类整体进行抽象,包括属性、行为,但是接口却是对类局部（行为）进行抽象。举个简单的例子,飞机和鸟是不同类的事物,但是它们都有一个共性,就是都会飞。那么在设计的时候,可以将飞机设计为一个类Airplane,将鸟设计为一个类Bird,但是不能将 飞行 这个特性也设计为类,因此它只是一个行为特性,并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly,包含方法fly( ),然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机,比如战斗机、民用飞机等直接继承Airplane即可,对于鸟也是类似的,不同种类的鸟直接继承Bird类即可。从这里可以看出,继承是一个 “是不是”的关系,而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类,则子类必定是抽象类的种类,而接口实现则是有没有、具备不具备的关系,比如鸟是否能飞（或者是否具备飞行这个特点）,能飞行则可以实现这个接口,不能飞行就不实现这个接口。</p>
</li>
<li><p><strong>设计层面不同,抽象类作为很多子类的父类,它是一种模板式设计。而接口是一种行为规范,它是一种辐射式设计</strong>。什么是模板式设计？最简单例子,大家都用过ppt里面的模板,如果用模板A设计了ppt B和ppt C,ppt B和ppt C公共的部分就是模板A了,如果它们的公共部分需要改动,则只需要改动模板A就可以了,不需要重新对ppt B和ppt C进行改动。而辐射式设计,比如某个电梯都装了某种报警器,一旦要更新报警器,就必须全部更新。也就是说对于抽象类,如果需要添加新的方法,可以直接在抽象类中添加具体的实现,子类可以不进行变更；而对于接口则不行,如果接口进行了变更,则所有实现这个接口的类都必须进行相应的改动。</p>
</li>
</ol>
<p>下面看一个网上流传最广泛的例子:门和警报的例子:门都有open( )和close( )两个动作,此时我们可以定义通过抽象类和接口来定义这个抽象概念:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>or<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是现在如果我们需要门具有报警alarm( )的功能,那么该如何实现？下面提供两种思路:</p>
<ol>
<li>将这三个功能都放在抽象类里面,但是这样一来所有继承于这个抽象类的子类都具备了报警功能,但是有的门并不一定具备报警功能；</li>
<li>将这三个功能都放在接口里面,需要用到报警功能的类就需要实现这个接口中的open( )和close( ),也许这个类根本就不具备open( )和close( )这两个功能,比如火灾报警器。</li>
</ol>
<p>从这里可以看出, Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为,open()和close()属于门本身固有的行为特性,而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口,包含alarm()行为,Door设计为单独的一个抽象类,包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alram</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oepn</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//....</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//....</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//....</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ref: <a href="http://www.cnblogs.com/dolphin0520/p/3811437.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3811437.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-ACID和隔离级别</title>
    <url>/2017/10/13/Mysql-ACID%E5%92%8C%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<p>面试问烂的 MySQL 四种隔离级别，看完吊打面试官</p>
<a id="more"></a>
<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。</p>
<p>事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。另外，这篇分布式事务不理解？一次给你讲清楚！推荐大家阅读。</p>
<h2 id="事务的-ACID"><a href="#事务的-ACID" class="headerlink" title="事务的 ACID"></a>事务的 ACID</h2><p>事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。</p>
<ul>
<li>原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做</li>
<li>一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。</li>
<li>隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。</li>
<li>持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。</li>
</ul>
<h2 id="Mysql的四种隔离级别"><a href="#Mysql的四种隔离级别" class="headerlink" title="Mysql的四种隔离级别"></a>Mysql的四种隔离级别</h2><p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。另外，这篇<a href="http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247487861&amp;idx=1&amp;sn=1e041eb56eaec737f95af0b3e65ac0e8&amp;chksm=eb539443dc241d55bdbcee140ab8b33182bcf9768f21a13ba4b03fcccf331ca1eb757ba6b90e&amp;scene=21#wechat_redirect" target="_blank" rel="external">分布式事务不理解？一次给你讲清楚！</a>推荐大家阅读</p>
<h3 id="Read-Uncommitted（读取未提交内容）"><a href="#Read-Uncommitted（读取未提交内容）" class="headerlink" title="Read Uncommitted（读取未提交内容）"></a>Read Uncommitted（读取未提交内容）</h3><p>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>
<h3 id="Read-Committed（读取提交内容）"><a href="#Read-Committed（读取提交内容）" class="headerlink" title="Read Committed（读取提交内容）"></a>Read Committed（读取提交内容）</h3><p>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>
<h3 id="Repeatable-Read（可重读）"><a href="#Repeatable-Read（可重读）" class="headerlink" title="Repeatable Read（可重读）"></a>Repeatable Read（可重读）</h3><p>这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>
<h3 id="Serializable（可串行化）"><a href="#Serializable（可串行化）" class="headerlink" title="Serializable（可串行化）"></a>Serializable（可串行化）</h3><p>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>
<p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：</p>
<ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就有几列数据是未查询出来的，如果此时插入和另外一个事务插入的数据，就会报错。</li>
</ul>
<p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：<br><img src="WX201904261119272x.png" alt="WX201904261119272x.png"></p>
<h2 id="测试Mysql的隔离级别"><a href="#测试Mysql的隔离级别" class="headerlink" title="测试Mysql的隔离级别"></a>测试Mysql的隔离级别</h2><p>下面，将利用MySQL的客户端程序，我们分别来测试一下这几种隔离级别。</p>
<p>测试数据库为demo，表为test；表结构：<br><img src="WX20190426-1121462x.png" alt="WX20190426-1121462x.png"></p>
<p>两个命令行客户端分别为A，B；不断改变A的隔离级别，在B端修改数据。</p>
<h3 id="将A的隔离级别设置为read-uncommitted-未提交读"><a href="#将A的隔离级别设置为read-uncommitted-未提交读" class="headerlink" title="将A的隔离级别设置为read uncommitted(未提交读)"></a>将A的隔离级别设置为read uncommitted(未提交读)</h3><p><img src="WX20190426-1123422x.png" alt="WX20190426-1123422x.png"></p>
<p>A：启动事务，此时数据为初始状态</p>
<p><img src="WX20190426-1125022x.png" alt="WX20190426-1125022x.png"></p>
<p>B：启动事务，更新数据，但不提交</p>
<p><img src="WX20190426-1125482x.png" alt="WX20190426-1125482x.png"></p>
<p>A：再次读取数据，发现数据已经被修改了，这就是所谓的“脏读”</p>
<p><img src="WX20190426-1126292x.png" alt="WX20190426-1126292x.png"></p>
<p>B：回滚事务<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt;rollback</div></pre></td></tr></table></figure></p>
<p>A：再次读数据，发现数据变回初始状态</p>
<p><img src="WX20190426-1128172x.png" alt="WX20190426-1128172x.png"></p>
<p>经过上面的实验可以得出结论，事务B更新了一条记录，但是没有提交，此时事务A可以查询出未提交记录。造成脏读现象。未提交读是最低的隔离级别。</p>
<h3 id="将客户端A的事务隔离级别设置为read-committed-已提交读"><a href="#将客户端A的事务隔离级别设置为read-committed-已提交读" class="headerlink" title="将客户端A的事务隔离级别设置为read committed(已提交读"></a>将客户端A的事务隔离级别设置为read committed(已提交读</h3><p><img src="WX20190426-1133572x.png" alt="WX20190426-1133572x.png"></p>
<p>A：启动事务，此时数据为初始状态<br><img src="WX20190426-1129502x.png" alt="WX20190426-1129502x.png"></p>
<p>B：启动事务，更新数据，但不提交<br><img src="WX20190426-1130432x.png" alt="WX20190426-1130432x.png"></p>
<p>A：再次读数据，发现数据未被修改<br><img src="WX20190426-1131222x.png" alt="WX20190426-1131222x.png"></p>
<p>B：提交事务</p>
<p>A：再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”<br><img src="WX20190426-1132202x.png" alt="WX20190426-1132202x.png"></p>
<p>经过上面的实验可以得出结论，已提交读隔离级别解决了脏读的问题，但是出现了不可重复读的问题，即事务A在两次查询的数据不一致，因为在两次查询之间事务B更新了一条数据。已提交读只允许读取已提交的记录，但不要求可重复读。</p>
<h3 id="将A的隔离级别设置为repeatable-read-可重复读"><a href="#将A的隔离级别设置为repeatable-read-可重复读" class="headerlink" title="将A的隔离级别设置为repeatable read(可重复读)"></a>将A的隔离级别设置为repeatable read(可重复读)</h3><p><img src="WX20190426-1134422x.png" alt="WX20190426-1134422x.png"></p>
<p>A：启动事务，此时数据为初始状态</p>
<p><img src="WX20190426-1135192x.png" alt="WX20190426-1135192x.png"></p>
<p>B：启动事务，更新数据，但不提交<br><img src="WX20190426-1135552x.png" alt="WX20190426-1135552x.png"></p>
<p>A：再次读取数据，发现数据未被修改</p>
<p>B：提交事务</p>
<p>A：再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了<br><img src="WX20190426-1137072x.png" alt="WX20190426-1137072x.png"></p>
<p>B：插入一条新的数据，并提交<br><img src="WX20190426-1137522x.png" alt="WX20190426-1137522x.png"></p>
<p>A：再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”</p>
<p><img src="WX20190426-1138372x.png" alt="WX20190426-1138372x.png"></p>
<p>A：提交本次事务，再次读取数据，发现读取正常了<br><img src="WX20190426-1139252x.png" alt="WX20190426-1139252x.png"></p>
<p>由以上的实验可以得出结论，可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务部的更新该记录。但该事务不要求与其他事务可串行化。例如，当一个事务可以找到由一个已提交事务更新的记录，但是可能产生幻读问题(注意是可能，因为数据库对隔离级别的实现有所差别)。像以上的实验，就没有出现数据幻读的问题。</p>
<h3 id="将A的隔离级别设置为可串行化-Serializable"><a href="#将A的隔离级别设置为可串行化-Serializable" class="headerlink" title="将A的隔离级别设置为可串行化(Serializable)"></a>将A的隔离级别设置为可串行化(Serializable)</h3><p><img src="WX20190426-1140282x.png" alt="WX20190426-1140282x.png"></p>
<p>A：启动事务，此时数据为初始状态<br><img src="WX20190426-1141172x.png" alt="WX20190426-1141172x.png"></p>
<p>B：发现B此时进入了等待状态，原因是因为A的事务尚未提交，只能等待（此时，B可能会发生等待超时）<br><img src="WX20190426-1141562x.png" alt="WX20190426-1141562x.png"></p>
<p>A：提交事务</p>
<p>B：发现插入成功</p>
<p>serializable完全锁定字段，若一个事务来查询同一份数据就必须等待，直到前一个事务完成并解除锁定为止。是完整的隔离级别，会锁定对应的数据表格，因而会有效率的问题。</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/gkfzOtYWWhMgMgcRB32BoA" target="_blank" rel="external">https://mp.weixin.qq.com/s/gkfzOtYWWhMgMgcRB32BoA</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-InnoDB的多版本并发控制MVCC</title>
    <url>/2017/10/13/Mysql-InnoDB%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6MVCC/</url>
    <content><![CDATA[<p>MVCC（Multi-Version Concurrency Control）即多版本并发控制。<br>MySQL的大多数事务型（如InnoDB,Falcon等）存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，他们一般都同时实现了MVCC。当前不仅仅是MySQL,其它数据库系统（如Oracle,PostgreSQL）也都实现了MVCC。值得注意的是MVCC并没有一个统一的实现标准，所以不同的数据库，不同的存储引擎的实现都不尽相同。</p>
<a id="more"></a>
<h2 id="MVCC优缺点"><a href="#MVCC优缺点" class="headerlink" title="MVCC优缺点"></a>MVCC优缺点</h2><p>MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。</p>
<h2 id="MVCC的实现原理"><a href="#MVCC的实现原理" class="headerlink" title="MVCC的实现原理"></a>MVCC的实现原理</h2><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>为了便于理解MVCC的实现原理，这里简单介绍一下undo log的工作过程</p>
<p>在不考虑redo log 的情况下利用undo log工作的简化过程为：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">动作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">开始事务</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">记录数据行数据快照到undo log</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">更新数据</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">将undo log写到磁盘</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">将数据写到磁盘</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">提交事务</td>
</tr>
</tbody>
</table>
<p>1）为了保证数据的持久性数据要在事务提交之前持久化<br>2）undo log的持久化必须在在数据持久化之前，这样才能保证系统崩溃时，可以用undo log来回滚事务</p>
<h3 id="Innodb中的隐藏列"><a href="#Innodb中的隐藏列" class="headerlink" title="Innodb中的隐藏列"></a>Innodb中的隐藏列</h3><p>Innodb通过undo log保存了已更改行的旧版本的信息的快照。<br>InnoDB的内部实现中为每一行数据增加了三个隐藏列(事务ID, 回滚指针, 隐藏的ID)用于实现MVCC。</p>
<table>
<thead>
<tr>
<th style="text-align:left">列名</th>
<th style="text-align:left">长度(字节)</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DB_TRX_ID</td>
<td style="text-align:left">6</td>
<td style="text-align:left">插入或更新行的最后一个事务的事务标识符。（删除视为更新，将其标记为已删除）</td>
</tr>
<tr>
<td style="text-align:left">DB_ROLL_PTR</td>
<td style="text-align:left">7</td>
<td style="text-align:left">写入回滚段的撤消日志记录（若行已更新，则撤消日志记录包含在更新行之前重建行内容所需的信息）</td>
</tr>
<tr>
<td style="text-align:left">DB_ROW_ID</td>
<td style="text-align:left">6</td>
<td style="text-align:left">行标识（隐藏单调自增id）</td>
</tr>
</tbody>
</table>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>|数据列    |..    |DB_ROW_ID    |DB_TRX_ID    |DB_ROLL_PTR|</p>
<h2 id="MVCC工作过程"><a href="#MVCC工作过程" class="headerlink" title="MVCC工作过程"></a>MVCC工作过程</h2><p>MVCC只在READ COMMITED 和 REPEATABLE READ 两个隔离级别下工作。READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE 则会对所有读取的行都加锁</p>
<h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><p>InnoDB 会根据两个条件来检查每行记录：</p>
<ul>
<li>InnoDB只查找版本(DB_TRX_ID)早于当前事务版本的数据行（行的系统版本号&lt;=事务的系统版本号,这样可以确保数据行要么是在开始之前已经存在了，要么是事务自身插入或修改过的）</li>
<li>行的删除版本号(DB_ROLL_PTR)要么未定义（未更新过），要么大于当前事务版本号（在当前事务开始之后更新的）。这样可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ul>
<h3 id="NSERT"><a href="#NSERT" class="headerlink" title="NSERT"></a>NSERT</h3><p>InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p>
<h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>InnoDB为删除的每一行保存当前的系统版本号作为行删除标识</p>
<h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识</p>
<h2 id="MVCC实现方式"><a href="#MVCC实现方式" class="headerlink" title="MVCC实现方式"></a>MVCC实现方式</h2><h3 id="1-Innodb的事务相关概念"><a href="#1-Innodb的事务相关概念" class="headerlink" title="1. Innodb的事务相关概念"></a>1. Innodb的事务相关概念</h3><p>为了支持事务，Innbodb引入了下面几个概念：</p>
<p>redo log:<br>redo log就是保存执行的SQL语句到一个指定的Log文件，当Mysql执行recovery时重新执行redo log记录的SQL操作即可。当客户端执行每条SQL（更新语句）时，redo log会被首先写入log buffer；当客户端执行COMMIT命令时，log buffer中的内容会被视情况刷新到磁盘。redo log在磁盘上作为一个独立的文件存在，即Innodb的log文件。</p>
<p>undo log:<br>与redo log相反，undo log是为回滚而用，具体内容就是copy事务前的数据库内容（行）到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。</p>
<p>rollback segment:<br>回滚段这个概念来自Oracle的事物模型，在Innodb中，undo log被划分为多个段，具体某行的undo log就保存在某个段中，称为回滚段。可以认为undo log和回滚段是同一意思。</p>
<p>锁:<br>Innodb提供了基于行的锁，如果行的数量非常大，则在高并发下锁的数量也可能会比较大，据Innodb文档说，Innodb对锁进行了空间有效优化，即使并发量高也不会导致内存耗尽。</p>
<p>对行的锁有分两种：排他锁、共享锁。共享锁针对读，排他锁针对写，完全等同读写锁的概念。如果某个事务在更新某行（排他锁），则其他事物无论是读还是写本行都必须等待；如果某个事物读某行（共享锁），则其他读的事物无需等待，而写事物则需等待。通过共享锁，保证了多读之间的无等待性，但是锁的应用又依赖Mysql的事务隔离级别。</p>
<p>隔离级别:<br>隔离级别用来限制事务直接的交互程度，目前有几个工业标准：</p>
<ul>
<li>READ_UNCOMMITTED：脏读</li>
<li>READ_COMMITTED：读提交</li>
<li>REPEATABLE_READ：重复读</li>
<li>SERIALIZABLE：串行化</li>
</ul>
<p>Innodb对四种类型都支持，脏读和串行化应用场景不多，读提交、重复读用的比较广泛，后面会介绍其实现方式。</p>
<p>下面演示下事务对某行记录的更新过程：</p>
<ol>
<li>初始数据行<br><img src="44474267_1.gif" alt="44474267_1.gif"></li>
</ol>
<p>F1～F6是某行列的名字，1～6是其对应的数据。后面三个隐含字段分别对应该行的事务号和回滚指针，假如这条数据是刚INSERT的，可以认为ID为1，其他两个字段为空。</p>
<ol>
<li>事务1更改该行的各字段的值<br><img src="44474267_2.gif" alt="44474267_2.gif"></li>
</ol>
<p>当事务1更改该行的值时，会进行如下操作：<br>用排他锁锁定该行<br>记录redo log<br>把该行修改前的值Copy到undo log，即上图中下面的行<br>修改当前行的值，填写事务编号，使回滚指针指向undo log中的修改前的行</p>
<ol>
<li>事务2修改该行的值<br><img src="44474267_3.gif" alt="44474267_3.gif"><br>与事务1相同，此时undo log，中有有两行记录，并且通过回滚指针连在一起。</li>
</ol>
<p>因此，如果undo log一直不删除，则会通过当前记录的回滚指针回溯到该行创建时的初始内容，所幸的时在Innodb中存在purge线程，它会查询那些比现在最老的活动事务还早的undo log，并删除它们，从而保证undo log文件不至于无限增长。</p>
<ol>
<li><p>事务提交<br>当事务正常提交时Innbod只需要更改事务状态为COMMIT即可，不需做其他额外的工作，而Rollback则稍微复杂点，需要根据当前回滚指针从undo log中找出事务修改前的版本，并恢复。如果事务影响的行非常多，回滚则可能会变的效率不高，根据经验值没事务行数在1000～10000之间，Innodb效率还是非常高的。很显然，Innodb是一个COMMIT效率比Rollback高的存储引擎。据说，Postgress的实现恰好与此相反。</p>
</li>
<li><p>Insert Undo log</p>
</li>
</ol>
<p>上述过程确切地说是描述了UPDATE的事务过程，其实undo log分insert和update undo log，因为insert时，原始的数据并不存在，所以回滚时把insert undo log丢弃即可，而update undo log则必须遵守上述过程。</p>
<ol>
<li>事务级别</li>
</ol>
<p>众所周知地是更新（update、insert、delete）是一个事务过程，在Innodb中，查询也是一个事务，只读事务。当读写事务并发访问同一行数据时，能读到什么样的内容则依赖事务级别：</p>
<p>READ_UNCOMMITTED<br>读未提交时，读事务直接读取主记录，无论更新事务是否完成</p>
<p>READ_COMMITTED<br>读提交时，读事务每次都读取undo log中最近的版本，因此两次对同一字段的读可能读到不同的数据（幻读），但能保证每次都读到最新的数据。</p>
<p>REPEATABLE_READ<br>每次都读取指定的版本，这样保证不会产生幻读，但可能读不到最新的数据</p>
<p>SERIALIZABLE<br>锁表，读写相互阻塞，使用较少</p>
<p>读事务一般有SELECT语句触发，在Innodb中保证其非阻塞，但带FOR UPDATE的SELECT除外，带FOR UPDATE的SELECT会对行加排他锁，等待更新事务完成后读取其最新内容。就整个Innodb的设计目标来说，就是提供高效的、非阻塞的查询操作。</p>
<ol>
<li>MVCC</li>
</ol>
<p>上述更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，undo log中的行就是MVCC中的多版本，这个可能与我们所理解的MVCC有较大的出入，一般我们认为MVCC有下面几个特点：</p>
<p>每行数据都存在一个版本，每次数据更新时都更新该版本<br>修改时Copy出当前版本随意修改，个事务之间无干扰<br>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）<br>就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道。。。，而Innodb的实现方式是：<br>事务以排他锁的形式修改原始数据<br>把修改前的数据存放于undo log，通过回滚指针与主数据关联<br>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）<br>二者最本质的区别是，当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？ </p>
<p>Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。</p>
<p>比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。</p>
<p>理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。</p>
<ol>
<li>总结<br>也不是说MVCC就无处可用，对一些一致性要求不高的场景和对单一数据的操作的场景还是可以发挥作用的，比如多个事务同时更改用户在线数，如果某个事务更新失败则重新计算后重试，直至成功。这样使用MVCC会极大地提高并发数，并消除线程锁。</li>
</ol>
<p>ref:<br><a href="https://www.jianshu.com/p/a3d49f7507ff" target="_blank" rel="external">https://www.jianshu.com/p/a3d49f7507ff</a><br><a href="http://www.360doc.com/content/14/0821/09/12904276_403505950.shtml" target="_blank" rel="external">http://www.360doc.com/content/14/0821/09/12904276_403505950.shtml</a><br>参考资料<br>《高性能MYSQL》</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-图解5种join连接和实例</title>
    <url>/2017/10/13/Mysql-%E5%9B%BE%E8%A7%A35%E7%A7%8Djoin%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>Join 连接在日常开发用得比较多，但大家都搞清楚了它们的使用区别吗？？一文带你上车~~</p>
<a id="more"></a>
<h2 id="内连接-inner-join"><a href="#内连接-inner-join" class="headerlink" title="内连接 inner join"></a>内连接 inner join</h2><p>内连接是基于连接谓词将俩张表（如A和B）的列组合到一起产生新的结果表，在表中存在至少一个匹配时，INNER JOIN 关键字返回行。<br><img src="WX20190426-115417@2x.png" alt="WX20190426-115417@2x.png"></p>
<p>下面是一个简单的使用案例<br><img src="WX20190426-115530@2x.png" alt="WX20190426-115530@2x.png"></p>
<p>以下是运行代码及结果<br><img src="WX20190426-115604@2x.png" alt="WX20190426-115604@2x.png"></p>
<h2 id="左外连接-left-join"><a href="#左外连接-left-join" class="headerlink" title="左外连接 left join"></a>左外连接 left join</h2><p>左外连接Left join关键字会从左表那里返回所有的行，即使是在右表中没有匹配到的行 </p>
<p><img src="WX20190426-115711@2x.png" alt="WX20190426-115711@2x.png"><br><img src="WX20190426-115744@2x.png" alt="WX20190426-115744@2x.png"><br><img src="WX20190426-115810@2x.png" alt="WX20190426-115810@2x.png"></p>
<h2 id="右外连接-right-join"><a href="#右外连接-right-join" class="headerlink" title="右外连接 right join"></a>右外连接 right join</h2><p>右外连接关键字Right join会从右表那里返回所有的行，即使是在左表中没有匹配到的行 </p>
<p><img src="WX20190426-115902@2x.png" alt="WX20190426-115902@2x.png"><br><img src="WX20190426-115924@2x.png" alt="WX20190426-115924@2x.png"><br><img src="WX20190426-115947@2x.png" alt="WX20190426-115947@2x.png"></p>
<h2 id="全连接-full-join"><a href="#全连接-full-join" class="headerlink" title="全连接 full join"></a>全连接 full join</h2><p>全连接的关键字Full join，只要其中某个表中存在匹配，Full join 就会返回行 </p>
<p><img src="WX20190426-120027@2x.png" alt="WX20190426-120027@2x.png"><br><img src="WX20190426-120048@2x.png" alt="WX20190426-120048@2x.png"><br><img src="WX20190426-120113@2x.png" alt="WX20190426-120113@2x.png"></p>
<p>注意一点 mysql中是不支持Full join 的但是orcal等数据库是支持的。<br>如果在mysql要使用Full join就会报以下错误<br><img src="WX20190426-120150@2x.png" alt="WX20190426-120150@2x.png"><br>解决办法：同时使用左连接和右连接 </p>
<p>以下是一个简单的例子<br><img src="WX20190426-120232@2x.png" alt="WX20190426-120232@2x.png"></p>
<h2 id="交叉连接-cross-join"><a href="#交叉连接-cross-join" class="headerlink" title="交叉连接 cross join"></a>交叉连接 cross join</h2><p>交叉连接一般使用的比较少，交叉连接又称笛卡尔连接或者叉乘连接，如果，A和B是俩个集合，他们的交叉连接就是A*B </p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247485697&amp;idx=1&amp;sn=aa41e25d02a92d0d83a597074f6d579c&amp;chksm=eb538c37dc240521dd10df0498404a37fb81c61aef665efcae142831ca7b7bbfadfcdb53ff4e&amp;scene=21#wechat_redirect" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247485697&amp;idx=1&amp;sn=aa41e25d02a92d0d83a597074f6d579c&amp;chksm=eb538c37dc240521dd10df0498404a37fb81c61aef665efcae142831ca7b7bbfadfcdb53ff4e&amp;scene=21#wechat_redirect</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-索引</title>
    <url>/2017/10/13/Mysql-%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<p>一直是想知道一条SQL语句是怎么被执行的,它执行的顺序是怎样的<br>本文将从MySQL总体架构—&gt;查询执行流程—&gt;语句执行顺序来探讨一下其中的知识</p>
<a id="more"></a>
<h2 id="索引类型（按用途非严格划分）"><a href="#索引类型（按用途非严格划分）" class="headerlink" title="索引类型（按用途非严格划分）"></a>索引类型（按用途非严格划分）</h2><ul>
<li>普通索引，这是最基本的索引，无任何限制</li>
<li>唯一索引，与普通索引类似，索引列值必须唯一，允许NULL值</li>
<li>全文索引，基于词干方式创建索引，多用于BLOB数据类型</li>
<li>单列索引，仅基于一列创建的索引</li>
<li>多列索引，基于多列创建的索引，列顺序非常重要</li>
<li>空间索引，用作地理数据存储</li>
<li>主键索引，是一种特殊的唯一索引，不允许有NULL值，通常在建表时创建。</li>
</ul>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul>
<li>大大减少了服务器需要扫描的数据量</li>
<li>可以帮助服务器避免排序或减少使用临时表排序</li>
<li>索引可以随机I/O变为顺序I/O</li>
</ul>
<h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ul>
<li>需要占用磁盘空间，因此冗余低效的索引将占用大量的磁盘空间</li>
<li>降低DML性能，对于数据的任意增删改都需要调整对应的索引，甚至出现索引分裂</li>
<li>索引会产生相应的碎片，产生维护开销</li>
</ul>
<h2 id="索引失效的情形"><a href="#索引失效的情形" class="headerlink" title="索引失效的情形"></a>索引失效的情形</h2><ul>
<li>请表上的数据行超出表总记录数30%，变成全表扫描</li>
<li>谓词上的索引列上存在NULL值</li>
<li>谓词上的索引列条件使用函数</li>
<li>谓词上的索引列条件进行了相关运算</li>
<li>负向查询<code>（not  , not in, not like, &lt;&gt;, != ,!&gt;,!&lt;  ）</code>不会使用索引</li>
<li>复合索引中，第一个索引列使用范围查询–只能用到部份或无法使用索引</li>
<li>复合索引中，第一个查询条件不是最左索引列</li>
<li>模糊查询条件列最左以通配符%开始</li>
<li>内存表（HEAP表）使用HASH索引时，使用范围检索或者ORDER BY</li>
<li>表关联字段类型不一样（包括某些长度不一样，但像varchar(10)与char(10)则可以，MYSQL经过内部优化处理）</li>
<li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li>
<li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li>
<li>如果条件中有or(并且其中有or的条件是不带索引的)，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li>
<li>在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER BY操作方面也没什么作用</li>
</ul>
<p>ps: 如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0/1”或“Y/N”等值，就没有必要为它创建一个索引。</p>
<p>疑问: <a href="http://www.cnblogs.com/jyk/archive/2010/04/10/1708945.html" target="_blank" rel="external">http://www.cnblogs.com/jyk/archive/2010/04/10/1708945.html</a><br><a href="http://www.cnblogs.com/yuerdongni/p/4255395.html" target="_blank" rel="external">http://www.cnblogs.com/yuerdongni/p/4255395.html</a></p>
<p>补充: <a href="http://blog.sina.com.cn/s/blog_6e322ce7010101i7.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_6e322ce7010101i7.html</a><br><a href="https://www.2cto.com/database/201208/145888.html" target="_blank" rel="external">https://www.2cto.com/database/201208/145888.html</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-explain命令</title>
    <url>/2017/10/13/Mysql-explain%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>mysql查询优化的方法有很多种，explain是工作当中用的比较多的一种检查方式。explain翻译即解释，就是看mysql语句的查询解释计划，从解释计划我们能很清楚的看到解释的语句有没有合理用到索引，扫描了多少行数，有没有触及全表扫描、用到临时表等影响慢查询的原因。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">explain select * from user ...</div></pre></td></tr></table></figure>
<p>执行后会出现解释计划的表格，意义可参考下面的参数，针对这些解释计划，我们可以作为相对应的优化。<br><img src="WX20190426-120735@2x.png" alt="WX20190426-120735@2x.png"></p>
<p>id    mysql查询标识符，即序号</p>
<p>select_type    查询类型</p>
<ul>
<li>simple：即简单select 查询，不包含union及子查询；</li>
<li>primary：最外层的 select 查询；</li>
<li>union：表示此查询是 union 的第二或随后的查询；</li>
<li>dependent union：union 中的第二个或后面的查询语句, 取决于外面的查询；</li>
<li>union result：union的结果；</li>
<li>subquery：子查询中的第一个select；</li>
<li>dependent subquery：子查询中的第一个select，取决于外面的查询，即子查询依</li>
</ul>
<p>table    所有查询到的表。</p>
<p>type    联接类型，比较重要的项，从这一项可以看出是否高效的重要依据, 性能从好到坏依次如下：</p>
<ul>
<li>system：表中只有一条数据，这是一个特殊的const 类型；</li>
<li>const：针对主键或唯一索引的等值查询扫描，最多只返回一行数据，const 查询速度非常快，因为它仅仅读取一次即可；</li>
<li>eq_ref：此类型通常出现在多表的 join 查询，表示对于前表的每一个结果,都只能匹配到后表的一行结果，并且查询的比较操作通常是＝, 查询效率较高；</li>
<li>ref：此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询；</li>
<li>fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引；</li>
<li>ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多；</li>
<li>unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值；</li>
<li>index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重；</li>
<li>index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and,or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range；</li>
<li>range：表示使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN操作中，此时输出的 ref 字段为 NULL并且key_len字段是此次查询中使用到的索引的最长的那个；</li>
<li>index：全表扫描，只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序，但是开销仍然非常大，这种情况时, Extra 字段会显示 Using index；</li>
<li>all：性能最差的情况，使用了全表扫描，系统必须避免出现这种情况。</li>
</ul>
<p>possible_keys    可能用到的索引。</p>
<p>key    真正用到的索引。</p>
<p>key_len    使用了索引字节的长度。</p>
<p>ref     显示索引的哪一列被使用了。</p>
<p>rows    扫描了多少行数，也是性能评估的重要依据。</p>
<p>extra 额度信息，常见的有以下几种</p>
<ul>
<li>Distinct：一旦找到了与行相联合匹配的行就不再搜索了；</li>
<li>Using filesort：使用了文件排序，性能非常慢，需要优化。</li>
<li>Using index：查询使用到了索引，列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候。</li>
<li>Using temporary：使用了临时表排序，性能非常慢，需要优化。</li>
<li>Using where：表示使用了where进行查询，不是很重要。</li>
<li>ALL：这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，需要优化。</li>
</ul>
<p>具体的对执行计划解释可以参考msyql官网：</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/explain-output.html</a></p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247483766&amp;idx=1&amp;sn=ee4fb7bf004f28046d10ffced085da42&amp;chksm=eb538440dc240d561259e71abe556c09658993c397ee204d5029c9cb5d30475f9d621a58bd0b&amp;scene=21#wechat_redirect" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247483766&amp;idx=1&amp;sn=ee4fb7bf004f28046d10ffced085da42&amp;chksm=eb538440dc240d561259e71abe556c09658993c397ee204d5029c9cb5d30475f9d621a58bd0b&amp;scene=21#wechat_redirect</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-SQL解析顺序</title>
    <url>/2017/10/12/Mysql-SQL%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>一直是想知道一条SQL语句是怎么被执行的,它执行的顺序是怎样的<br>本文将从MySQL总体架构—&gt;查询执行流程—&gt;语句执行顺序来探讨一下其中的知识</p>
<a id="more"></a>
<h2 id="MySQL架构总览"><a href="#MySQL架构总览" class="headerlink" title="MySQL架构总览"></a>MySQL架构总览</h2><p>下图根据参考书籍中一图为原本,再在其上添加上了自己的理解。<br><img src="/2017/10/12/Mysql-SQL解析顺序/701942-20151210224128402-1287669438.png" alt="701942-20151210224128402-1287669438.png" title=""><br>从上图中我们可以看到,整个架构分为两层,上层是MySQLD的被称为的‘SQL Layer’,下层是各种各样对上提供接口的存储引擎,被称为‘Storage Engine Layer’。其它各个模块和组件,从名字上就可以简单了解到它们的作用,这里就不再累述了。</p>
<h2 id="查询执行流程"><a href="#查询执行流程" class="headerlink" title="查询执行流程"></a>查询执行流程</h2><p>下面再向前走一些,容我根据自己的认识说一下查询执行的流程是怎样的:</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ol>
<li>客户端发起一条Query请求,监听客户端的‘连接管理模块’接收请求</li>
<li>将请求转发到‘连接进/线程模块’</li>
<li>调用‘用户模块’来进行授权检查</li>
<li>通过检查后,‘连接进/线程模块’从‘线程连接池’中取出空闲的被缓存的连接线程和客户端请求对接,如果失败则创建一个新的连接请求</li>
</ol>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ol>
<li>先查询缓存,检查Query语句是否完全匹配,接着再检查是否具有权限,都成功则直接取数据返回</li>
<li>上一步有失败则转交给‘命令解析器’,经过词法分析,语法分析后生成解析树</li>
<li>接下来是预处理阶段,处理解析器无法解决的语义,检查权限等,生成新的解析树</li>
<li>再转交给对应的模块处理</li>
<li>如果是SELECT查询还会经由‘查询优化器’做大量的优化,生成执行计划</li>
<li>模块收到请求后,通过‘访问控制模块’检查所连接的用户是否有访问目标表和目标字段的权限</li>
<li>有则调用‘表管理模块’,先是查看table cache中是否存在,有则直接对应的表和获取锁,否则重新打开表文件</li>
<li>根据表的meta数据,获取表的存储引擎类型等信息,通过接口调用对应的存储引擎处理</li>
<li>上述过程中产生数据变化的时候,若打开日志功能,则会记录到相应二进制日志文件中</li>
</ol>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ol>
<li>Query请求完成后,将结果集返回给‘连接进/线程模块’</li>
<li>返回的也可以是相应的状态标识,如成功或失败等</li>
<li>‘连接进/线程模块’进行后续的清理工作,并继续等待请求或断开与客户端的连接</li>
</ol>
<img src="/2017/10/12/Mysql-SQL解析顺序/701942-20151210224221011-1559007674.png" alt="701942-20151210224221011-1559007674.png" title="">
<h2 id="SQL解析顺序"><a href="#SQL解析顺序" class="headerlink" title="SQL解析顺序"></a>SQL解析顺序</h2><p>首先看一下示例语句<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT DISTINCT</div><div class="line">    &lt; select_list &gt;</div><div class="line">FROM</div><div class="line">    &lt; left_table &gt; &lt; join_type &gt;</div><div class="line">JOIN &lt; right_table &gt; ON &lt; join_condition &gt;</div><div class="line">WHERE</div><div class="line">    &lt; where_condition &gt;</div><div class="line">GROUP BY</div><div class="line">    &lt; group_by_list &gt;</div><div class="line">HAVING</div><div class="line">    &lt; having_condition &gt;</div><div class="line">ORDER BY</div><div class="line">    &lt; order_by_condition &gt;</div><div class="line">LIMIT &lt; limit_number &gt;</div></pre></td></tr></table></figure></p>
<p>然而它的执行顺序是这样的<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">FROM &lt;left_table&gt;</div><div class="line">ON &lt;join_condition&gt;</div><div class="line">&lt;join_type&gt; JOIN &lt;right_table&gt;</div><div class="line">WHERE &lt;where_condition&gt;</div><div class="line">GROUP BY &lt;group_by_list&gt;</div><div class="line">HAVING &lt;having_condition&gt;</div><div class="line">SELECT </div><div class="line">DISTINCT &lt;select_list&gt;</div><div class="line">ORDER BY &lt;order_by_condition&gt;</div><div class="line">LIMIT &lt;limit_number&gt;</div></pre></td></tr></table></figure></p>
<p>一步步来看看其中的细节吧</p>
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1.创建测试数据库<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">create database testQuery</div></pre></td></tr></table></figure></p>
<p>2.创建测试表<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE table1</div><div class="line">(</div><div class="line">    uid VARCHAR(10) NOT NULL,</div><div class="line">    name VARCHAR(10) NOT NULL,</div><div class="line">    PRIMARY KEY(uid)</div><div class="line">)ENGINE=INNODB DEFAULT CHARSET=UTF8;</div><div class="line"></div><div class="line">CREATE TABLE table2</div><div class="line">(</div><div class="line">    oid INT NOT NULL auto_increment,</div><div class="line">    uid VARCHAR(10),</div><div class="line">    PRIMARY KEY(oid)</div><div class="line">)ENGINE=INNODB DEFAULT CHARSET=UTF8;</div></pre></td></tr></table></figure></p>
<p>3.插入数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">INSERT INTO table1(uid,name) VALUES(&apos;aaa&apos;,&apos;mike&apos;),(&apos;bbb&apos;,&apos;jack&apos;),(&apos;ccc&apos;,&apos;mike&apos;),(&apos;ddd&apos;,&apos;mike&apos;);</div><div class="line">INSERT INTO table2(uid) VALUES(&apos;aaa&apos;),(&apos;aaa&apos;),(&apos;bbb&apos;),(&apos;bbb&apos;),(&apos;bbb&apos;),(&apos;ccc&apos;),(NULL);</div></pre></td></tr></table></figure></p>
<p>4.最后想要的结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT</div><div class="line">    a.uid,</div><div class="line">    count(b.oid) AS total</div><div class="line">FROM</div><div class="line">    table1 AS a</div><div class="line">LEFT JOIN table2 AS b ON a.uid = b.uid</div><div class="line">WHERE</div><div class="line">    a. NAME = &apos;mike&apos;</div><div class="line">GROUP BY</div><div class="line">    a.uid</div><div class="line">HAVING</div><div class="line">    count(b.oid) &lt; 2</div><div class="line">ORDER BY</div><div class="line">    total DESC</div><div class="line">LIMIT 1;</div></pre></td></tr></table></figure></p>
<h3 id="SQL解析"><a href="#SQL解析" class="headerlink" title="SQL解析"></a>SQL解析</h3><p>1.FROM<br>当涉及多个表的时候,左边表的输出会作为右边表的输入,之后会生成一个虚拟表VT1。<br>(1-J1)笛卡尔积<br>计算两个相关联表的笛卡尔积(CROSS JOIN) ,生成虚拟表VT1-J1。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; select * from table1,table2;</div><div class="line">+-----+------+-----+------+</div><div class="line">| uid | name | oid | uid  |</div><div class="line">+-----+------+-----+------+</div><div class="line">| aaa | mike |   1 | aaa  |</div><div class="line">| bbb | jack |   1 | aaa  |</div><div class="line">| ccc | mike |   1 | aaa  |</div><div class="line">| ddd | mike |   1 | aaa  |</div><div class="line">| aaa | mike |   2 | aaa  |</div><div class="line">| bbb | jack |   2 | aaa  |</div><div class="line">| ccc | mike |   2 | aaa  |</div><div class="line">| ddd | mike |   2 | aaa  |</div><div class="line">| aaa | mike |   3 | bbb  |</div><div class="line">| bbb | jack |   3 | bbb  |</div><div class="line">| ccc | mike |   3 | bbb  |</div><div class="line">| ddd | mike |   3 | bbb  |</div><div class="line">| aaa | mike |   4 | bbb  |</div><div class="line">| bbb | jack |   4 | bbb  |</div><div class="line">| ccc | mike |   4 | bbb  |</div><div class="line">| ddd | mike |   4 | bbb  |</div><div class="line">| aaa | mike |   5 | bbb  |</div><div class="line">| bbb | jack |   5 | bbb  |</div><div class="line">| ccc | mike |   5 | bbb  |</div><div class="line">| ddd | mike |   5 | bbb  |</div><div class="line">| aaa | mike |   6 | ccc  |</div><div class="line">| bbb | jack |   6 | ccc  |</div><div class="line">| ccc | mike |   6 | ccc  |</div><div class="line">| ddd | mike |   6 | ccc  |</div><div class="line">| aaa | mike |   7 | NULL |</div><div class="line">| bbb | jack |   7 | NULL |</div><div class="line">| ccc | mike |   7 | NULL |</div><div class="line">| ddd | mike |   7 | NULL |</div><div class="line">+-----+------+-----+------+</div><div class="line">rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>(1-J2)ON过滤<br>基于虚拟表VT1-J1这一个虚拟表进行过滤,过滤出所有满足ON 谓词条件的列,生成虚拟表VT1-J2。<br>注意:这里因为语法限制,使用了’WHERE’代替,从中读者也可以感受到两者之间微妙的关系；<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT</div><div class="line">    -&gt; *</div><div class="line">    -&gt; FROM</div><div class="line">    -&gt; table1,</div><div class="line">    -&gt; table2</div><div class="line">    -&gt; WHERE</div><div class="line">    -&gt; table1.uid = table2.uid</div><div class="line">    -&gt; ;</div><div class="line">+-----+------+-----+------+</div><div class="line">| uid | name | oid | uid  |</div><div class="line">+-----+------+-----+------+</div><div class="line">| aaa | mike |   1 | aaa  |</div><div class="line">| aaa | mike |   2 | aaa  |</div><div class="line">| bbb | jack |   3 | bbb  |</div><div class="line">| bbb | jack |   4 | bbb  |</div><div class="line">| bbb | jack |   5 | bbb  |</div><div class="line">| ccc | mike |   6 | ccc  |</div><div class="line">+-----+------+-----+------+</div><div class="line">rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>(1-J3)添加外部列<br>如果使用了外连接(LEFT,RIGHT,FULL),主表(保留表)中的不符合ON条件的列也会被加入到VT1-J2中,作为外部行,生成虚拟表VT1-J3。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT</div><div class="line">    -&gt; *</div><div class="line">    -&gt; FROM</div><div class="line">    -&gt; table1 AS a</div><div class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid;</div><div class="line">+-----+------+------+------+</div><div class="line">| uid | name | oid  | uid  |</div><div class="line">+-----+------+------+------+</div><div class="line">| aaa | mike |    1 | aaa  |</div><div class="line">| aaa | mike |    2 | aaa  |</div><div class="line">| bbb | jack |    3 | bbb  |</div><div class="line">| bbb | jack |    4 | bbb  |</div><div class="line">| bbb | jack |    5 | bbb  |</div><div class="line">| ccc | mike |    6 | ccc  |</div><div class="line">| ddd | mike | NULL | NULL |</div><div class="line">+-----+------+------+------+</div><div class="line">rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>SQL JOINS’的解释图<br><img src="/2017/10/12/Mysql-SQL解析顺序/701942-20151210224510246-264811072.png" alt="701942-20151210224510246-264811072.png" title=""></p>
<p>2.WHERE<br>对VT1过程中生成的临时表进行过滤,满足WHERE子句的列被插入到VT2表中。<br>注意:<br>此时因为分组,不能使用聚合运算；也不能使用SELECT中创建的别名；<br>与ON的区别:<br>如果有外部列,ON针对过滤的是关联表,主表(保留表)会返回所有的列；<br>如果没有添加外部列,两者的效果是一样的；<br>应用:<br>对主表的过滤应该放在WHERE；<br>对于关联表,先条件查询后连接则用ON,先连接后条件查询则用WHERE；<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT</div><div class="line">    -&gt; *</div><div class="line">    -&gt; FROM</div><div class="line">    -&gt; table1 AS a</div><div class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid</div><div class="line">    -&gt; WHERE</div><div class="line">    -&gt; a. NAME = &apos;mike&apos;;</div><div class="line">+-----+------+------+------+</div><div class="line">| uid | name | oid  | uid  |</div><div class="line">+-----+------+------+------+</div><div class="line">| aaa | mike |    1 | aaa  |</div><div class="line">| aaa | mike |    2 | aaa  |</div><div class="line">| ccc | mike |    6 | ccc  |</div><div class="line">| ddd | mike | NULL | NULL |</div><div class="line">+-----+------+------+------+</div><div class="line">rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>3.GROUP BY<br>这个子句会把VT2中生成的表按照GROUP BY中的列进行分组。生成VT3表。<br>注意:<br>其后处理过程的语句,如SELECT,HAVING,所用到的列必须包含在GROUP BY中,对于没有出现的,得用聚合函数；<br>原因:<br>GROUP BY改变了对表的引用,将其转换为新的引用方式,能够对其进行下一级逻辑操作的列会减少；<br>我的理解是:<br>根据分组字段,将具有相同分组字段的记录归并成一条记录,因为每一个分组只能返回一条记录,除非是被过滤掉了,而不在分组字段里面的字段可能会有多个值,多个值是无法放进一条记录的,所以必须通过聚合函数将这些具有多值的列转换成单值；<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT</div><div class="line">    -&gt; *</div><div class="line">    -&gt; FROM</div><div class="line">    -&gt; table1 AS a</div><div class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid</div><div class="line">    -&gt; WHERE</div><div class="line">    -&gt; a. NAME = &apos;mike&apos;</div><div class="line">    -&gt; GROUP BY</div><div class="line">    -&gt; a.uid;</div><div class="line">+-----+------+------+------+</div><div class="line">| uid | name | oid  | uid  |</div><div class="line">+-----+------+------+------+</div><div class="line">| aaa | mike |    1 | aaa  |</div><div class="line">| ccc | mike |    6 | ccc  |</div><div class="line">| ddd | mike | NULL | NULL |</div><div class="line">+-----+------+------+------+</div><div class="line">rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>4.HAVING<br>这个子句对VT3表中的不同的组进行过滤,只作用于分组后的数据,满足HAVING条件的子句被加入到VT4表中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT</div><div class="line">    -&gt; *</div><div class="line">    -&gt; FROM</div><div class="line">    -&gt; table1 AS a</div><div class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid</div><div class="line">    -&gt; WHERE</div><div class="line">    -&gt; a. NAME = &apos;mike&apos;</div><div class="line">    -&gt; GROUP BY</div><div class="line">    -&gt; a.uid</div><div class="line">    -&gt; HAVING</div><div class="line">    -&gt; count(b.oid) &lt; 2;</div><div class="line">+-----+------+------+------+</div><div class="line">| uid | name | oid  | uid  |</div><div class="line">+-----+------+------+------+</div><div class="line">| ccc | mike |    6 | ccc  |</div><div class="line">| ddd | mike | NULL | NULL |</div><div class="line">+-----+------+------+------+</div><div class="line">rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>5.SELECT<br>这个子句对SELECT子句中的元素进行处理,生成VT5表。<br>(5-J1)计算表达式 计算SELECT 子句中的表达式,生成VT5-J1<br>(5-J2)DISTINCT<br>寻找VT5-1中的重复列,并删掉,生成VT5-J2<br>如果在查询中指定了DISTINCT子句,则会创建一张内存临时表(如果内存放不下,就需要存放在硬盘了)。这张临时表的表结构和上一步产生的虚拟表VT5是一样的,不同的是对进行DISTINCT操作的列增加了一个唯一索引,以此来除重复数据。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT</div><div class="line">    -&gt; a.uid,</div><div class="line">    -&gt; count(b.oid) AS total</div><div class="line">    -&gt; FROM</div><div class="line">    -&gt; table1 AS a</div><div class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid</div><div class="line">    -&gt; WHERE</div><div class="line">    -&gt; a. NAME = &apos;mike&apos;</div><div class="line">    -&gt; GROUP BY</div><div class="line">    -&gt; a.uid</div><div class="line">    -&gt; HAVING</div><div class="line">    -&gt; count(b.oid) &lt; 2;</div><div class="line">+-----+-------+</div><div class="line">| uid | total |</div><div class="line">+-----+-------+</div><div class="line">| ccc |     1 |</div><div class="line">| ddd |     0 |</div><div class="line">+-----+-------+</div><div class="line">rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>6.ORDER BY<br>从VT5-J2中的表中,根据ORDER BY 子句的条件对结果进行排序,生成VT6表。<br>注意:<br>唯一可使用SELECT中别名的地方；<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT</div><div class="line">    -&gt; a.uid,</div><div class="line">    -&gt; count(b.oid) AS total</div><div class="line">    -&gt; FROM</div><div class="line">    -&gt; table1 AS a</div><div class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid</div><div class="line">    -&gt; WHERE</div><div class="line">    -&gt; a. NAME = &apos;mike&apos;</div><div class="line">    -&gt; GROUP BY</div><div class="line">    -&gt; a.uid</div><div class="line">    -&gt; HAVING</div><div class="line">    -&gt; count(b.oid) &lt; 2</div><div class="line">    -&gt; ORDER BY</div><div class="line">    -&gt; total DESC;</div><div class="line">+-----+-------+</div><div class="line">| uid | total |</div><div class="line">+-----+-------+</div><div class="line">| ccc |     1 |</div><div class="line">| ddd |     0 |</div><div class="line">+-----+-------+</div><div class="line">rows in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<p>7.LIMIT<br>LIMIT子句从上一步得到的VT6虚拟表中选出从指定位置开始的指定行数据。<br>注意:<br>offset和rows的正负带来的影响；<br>当偏移量很大时效率是很低的,可以这么做:<br>采用子查询的方式优化,在子查询里先从索引获取到最大id,然后倒序排,再取N行结果集<br>采用INNER JOIN优化,JOIN子句里也优先从索引获取ID列表,然后直接关联查询获得最终结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mysql&gt; SELECT</div><div class="line">    -&gt; a.uid,</div><div class="line">    -&gt; count(b.oid) AS total</div><div class="line">    -&gt; FROM</div><div class="line">    -&gt; table1 AS a</div><div class="line">    -&gt; LEFT JOIN table2 AS b ON a.uid = b.uid</div><div class="line">    -&gt; WHERE</div><div class="line">    -&gt; a. NAME = &apos;mike&apos;</div><div class="line">    -&gt; GROUP BY</div><div class="line">    -&gt; a.uid</div><div class="line">    -&gt; HAVING</div><div class="line">    -&gt; count(b.oid) &lt; 2</div><div class="line">    -&gt; ORDER BY</div><div class="line">    -&gt; total DESC</div><div class="line">    -&gt; LIMIT 1;</div><div class="line">+-----+-------+</div><div class="line">| uid | total |</div><div class="line">+-----+-------+</div><div class="line">| ccc |     1 |</div><div class="line">+-----+-------+</div><div class="line">row in set (0.00 sec)</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="/2017/10/12/Mysql-SQL解析顺序/701942-20151210224616246-320415795.png" alt="701942-20151210224616246-320415795.png" title="">
<p>ref:<br>《MySQL性能调优与架构实践》<br>《MySQL技术内幕:SQL编程》<br><a href="http://www.cnblogs.com/annsshadow/p/5037667.html" target="_blank" rel="external">http://www.cnblogs.com/annsshadow/p/5037667.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Annotation实现原理</title>
    <url>/2017/10/09/Java-Annotation%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>注解Annotation实现原理与自定义注解例子</p>
<a id="more"></a>
<h2 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h2><p>对于很多初次接触的开发者来说应该都有这个疑问？Annontation是Java5开始引入的新特征，中文名称叫注解。它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。为程序的元素（类、方法、成员变量）加上更直观更明了的说明，这些说明信息是与程序的业务逻辑无关，并且供指定的工具或框架使用。Annontation像一种修饰符一样，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中。<br>Java注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。包含在 java.lang.annotation 包中</p>
<h2 id="注解的用处"><a href="#注解的用处" class="headerlink" title="注解的用处"></a>注解的用处</h2><ol>
<li>生成文档。这是最常见的，也是java 最早提供的注解。常用的有@param @return 等</li>
<li>跟踪代码依赖性，实现替代配置文件功能。比如Dagger 2 依赖注入，未来java 开发，将大量注解配置，具有很大用处;</li>
<li>在编译时进行格式检查。如@override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出</li>
</ol>
<h2 id="注解的原理"><a href="#注解的原理" class="headerlink" title="注解的原理"></a>注解的原理</h2><p>注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>java.lang.annotation 提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）：</p>
<ul>
<li>@Documented – 注解是否将包含在JavaDoc中</li>
<li>@Retention – 什么时候使用该注解</li>
<li>@Target – 注解用于什么地方</li>
<li>@Inherited – 是否允许子类继承该注解</li>
</ul>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>定义该注解的生命周期</p>
<ul>
<li>RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码。@Override, @SuppressWarnings都属于这类注解。</li>
<li>RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式</li>
<li>RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式</li>
</ul>
<h3 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h3><p>表示该注解用于什么地方。默认值为任何元素，表示该注解用于什么地方。可用的ElementType 参数包括</p>
<ul>
<li>ElementType.CONSTRUCTOR: 用于描述构造器</li>
<li>ElementType.FIELD: 成员变量、对象、属性（包括enum实例）</li>
<li>ElementType.LOCAL_VARIABLE: 用于描述局部变量</li>
<li>ElementType.METHOD: 用于描述方法</li>
<li>ElementType.PACKAGE: 用于描述包</li>
<li>ElementType.PARAMETER: 用于描述参数</li>
<li>ElementType.TYPE: 用于描述类、接口(包括注解类型) 或enum声明</li>
</ul>
<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>一个简单的Annotations 标记注解，表示是否将注解信息添加在java 文档</p>
<h3 id="Inherited-–-定义该注释和子类的关系"><a href="#Inherited-–-定义该注释和子类的关系" class="headerlink" title="@Inherited – 定义该注释和子类的关系"></a>@Inherited – 定义该注释和子类的关系</h3><p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的annotation 类型被用于一个class，则这个annotation 将被用于该class 的子类</p>
<h2 id="常见标准的Annotation"><a href="#常见标准的Annotation" class="headerlink" title="常见标准的Annotation"></a>常见标准的Annotation</h2><ol>
<li>Override<br>java.lang.Override 是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java 编译器将以一个编译错误来警示。</li>
<li>Deprecated<br>Deprecated 也是一种标记类型注解。当一个类型或者类型成员使用@Deprecated 修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。</li>
<li>SuppressWarnings<br>SuppressWarning 不是一个标记类型注解。它有一个类型为String[] 的成员，这个成员的值为被禁止的警告名。对于javac 编译器来讲，被-Xlint 选项有效的警告名也同样对@SuppressWarings 有效，同时编译器忽略掉无法识别的警告名。<br>　　@SuppressWarnings(“unchecked”)</li>
</ol>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>自定义注解类编写的一些规则:</p>
<ol>
<li>Annotation 型定义为@interface, 所有的Annotation 会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口.</li>
<li>参数成员只能用public 或默认(default) 这两个访问权修饰</li>
<li>参数成员只能用基本类型byte、short、char、int、long、float、double、boolean八种基本数据类型和String、Enum、Class、annotations等数据类型，以及这一些类型的数组.</li>
<li>要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation 对象，因为你除此之外没有别的获取注解对象的方法</li>
<li>注解也可以没有定义成员, 不过这样注解就没啥用了<br>PS:自定义注解需要使用到元注解</li>
</ol>
<h2 id="自定义注解实例"><a href="#自定义注解实例" class="headerlink" title="自定义注解实例"></a>自定义注解实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import java.lang.annotation.Documented;</div><div class="line">import java.lang.annotation.Retention;</div><div class="line">import java.lang.annotation.Target;</div><div class="line">import static java.lang.annotation.ElementType.FIELD;</div><div class="line">import static java.lang.annotation.RetentionPolicy.RUNTIME;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 水果名称注解</div><div class="line"> */</div><div class="line">@Target(FIELD)</div><div class="line">@Retention(RUNTIME)</div><div class="line">@Documented</div><div class="line">public @interface FruitName &#123;</div><div class="line">    String value() default &quot;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import java.lang.annotation.Documented;</div><div class="line">import java.lang.annotation.Retention;</div><div class="line">import java.lang.annotation.Target;</div><div class="line">import static java.lang.annotation.ElementType.FIELD;</div><div class="line">import static java.lang.annotation.RetentionPolicy.RUNTIME;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 水果颜色注解</div><div class="line"> */</div><div class="line">@Target(FIELD)</div><div class="line">@Retention(RUNTIME)</div><div class="line">@Documented</div><div class="line">public @interface FruitColor &#123;</div><div class="line">    /**</div><div class="line">     * 颜色枚举</div><div class="line">     */</div><div class="line">    public enum Color&#123; BLUE,RED,GREEN&#125;;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 颜色属性</div><div class="line">     */</div><div class="line">    Color fruitColor() default Color.GREEN;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import java.lang.annotation.Documented;</div><div class="line">import java.lang.annotation.Retention;</div><div class="line">import java.lang.annotation.Target;</div><div class="line">import static java.lang.annotation.ElementType.FIELD;</div><div class="line">import static java.lang.annotation.RetentionPolicy.RUNTIME;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * 水果供应者注解</div><div class="line"> */</div><div class="line">@Target(FIELD)</div><div class="line">@Retention(RUNTIME)</div><div class="line">@Documented</div><div class="line">public @interface FruitProvider &#123;</div><div class="line">    /**</div><div class="line">     * 供应商编号</div><div class="line">     */</div><div class="line">    public int id() default -1;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 供应商名称</div><div class="line">     */</div><div class="line">    public String name() default &quot;&quot;;</div><div class="line">    </div><div class="line">    /**</div><div class="line">     * 供应商地址</div><div class="line">     */</div><div class="line">    public String address() default &quot;&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import java.lang.reflect.Field;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 注解处理器</div><div class="line"> */</div><div class="line">public class FruitInfoUtil &#123;</div><div class="line">    public static void getFruitInfo(Class&lt;?&gt; clazz)&#123;</div><div class="line">        </div><div class="line">        String strFruitName=&quot; 水果名称：&quot;;</div><div class="line">        String strFruitColor=&quot; 水果颜色：&quot;;</div><div class="line">        String strFruitProvicer=&quot;供应商信息：&quot;;</div><div class="line">        </div><div class="line">        Field[] fields = clazz.getDeclaredFields();</div><div class="line">        </div><div class="line">        for(Field field :fields)&#123;</div><div class="line">            if(field.isAnnotationPresent(FruitName.class))&#123;</div><div class="line">                FruitName fruitName = (FruitName) field.getAnnotation(FruitName.class);</div><div class="line">                strFruitName=strFruitName+fruitName.value();</div><div class="line">                System.out.println(strFruitName);</div><div class="line">            &#125;</div><div class="line">            else if(field.isAnnotationPresent(FruitColor.class))&#123;</div><div class="line">                FruitColor fruitColor= (FruitColor) field.getAnnotation(FruitColor.class);</div><div class="line">                strFruitColor=strFruitColor+fruitColor.fruitColor().toString();</div><div class="line">                System.out.println(strFruitColor);</div><div class="line">            &#125;</div><div class="line">            else if(field.isAnnotationPresent(FruitProvider.class))&#123;</div><div class="line">                FruitProvider fruitProvider= (FruitProvider) field.getAnnotation(FruitProvider.class);</div><div class="line">                strFruitProvicer=&quot; 供应商编号：&quot;+fruitProvider.id()+&quot; 供应商名称：&quot;+fruitProvider.name()+&quot; 供应商地址：&quot;+fruitProvider.address();</div><div class="line">                System.out.println(strFruitProvicer);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import test.FruitColor.Color;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 注解使用</div><div class="line"> */</div><div class="line">public class Apple &#123;</div><div class="line">    </div><div class="line">    @FruitName(&quot;Apple&quot;)</div><div class="line">    private String appleName;</div><div class="line">    </div><div class="line">    @FruitColor(fruitColor=Color.RED)</div><div class="line">    private String appleColor;</div><div class="line">    </div><div class="line">    @FruitProvider(id=1,name=&quot;陕西红富士集团&quot;,address=&quot;陕西省西安市延安路89号红富士大厦&quot;)</div><div class="line">    private String appleProvider;</div><div class="line">    </div><div class="line">    public void setAppleColor(String appleColor) &#123;</div><div class="line">        this.appleColor = appleColor;</div><div class="line">    &#125;</div><div class="line">    public String getAppleColor() &#123;</div><div class="line">        return appleColor;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setAppleName(String appleName) &#123;</div><div class="line">        this.appleName = appleName;</div><div class="line">    &#125;</div><div class="line">    public String getAppleName() &#123;</div><div class="line">        return appleName;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void setAppleProvider(String appleProvider) &#123;</div><div class="line">        this.appleProvider = appleProvider;</div><div class="line">    &#125;</div><div class="line">    public String getAppleProvider() &#123;</div><div class="line">        return appleProvider;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void displayName()&#123;</div><div class="line">        System.out.println(&quot;水果的名字是：苹果&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 输出结果</div><div class="line"> */</div><div class="line">public class FruitRun &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        FruitInfoUtil.getFruitInfo(Apple.class);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">水果名称：Apple</div><div class="line">水果颜色：RED</div><div class="line">供应商编号：1 供应商名称：陕西红富士集团 供应商地址：陕西省西安市延安路89号红富士大厦</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>//TODO 更好的文章推荐 <a href="https://www.jianshu.com/p/28edf5352b63?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="external">https://www.jianshu.com/p/28edf5352b63?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>
<p>ref: <a href="https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html" target="_blank" rel="external">https://www.cnblogs.com/acm-bingzi/p/javaAnnotation.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-FutureTask</title>
    <url>/2017/10/09/Java-FutureTask/</url>
    <content><![CDATA[<p>深入学习 FutureTask</p>
<a id="more"></a>
<h2 id="第一部分-What"><a href="#第一部分-What" class="headerlink" title="第一部分:What"></a>第一部分:What</h2><p>在Java中一般通过继承Thread类或者实现Runnable接口这两种方式来创建多线程,但是这两种方式都有个缺陷,就是不能在执行完成后获取执行的结果,因此Java 1.5之后提供了Callable和Future接口,通过它们就可以在任务执行完毕之后得到任务的执行结果。本文会简要的介绍使用方法,然后会从源代码角度分析下具体的实现原理。<br>本文以Java 1.7的代码进行分析。</p>
<h2 id="第二部分-How"><a href="#第二部分-How" class="headerlink" title="第二部分:How"></a>第二部分:How</h2><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><p>对于需要执行的任务需要实现Callable接口,Callable接口定义如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Computes a result, or throws an exception if unable to do so.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> computed result</div><div class="line">     * <span class="doctag">@throws</span> Exception if unable to compute a result</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到Callable是个泛型接口,泛型V就是要call()方法返回的类型。Callable接口和Runnable接口很像,都可以被另外一个线程执行,但是正如前面所说的,Runnable不会返回数据也不能抛出异常。</p>
<h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p>Future接口代表异步计算的结果,通过Future接口提供的方法可以查看异步计算是否执行完成,或者等待执行结果并获取执行结果,同时还可以取消执行。Future接口的定义如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>cancel():cancel()方法用来取消异步任务的执行。如果异步任务已经完成或者已经被取消,或者由于某些原因不能取消,则会返回false。如果任务还没有被执行,则会返回true并且异步任务不会被执行。如果任务已经开始执行了但是还没有执行完成,若mayInterruptIfRunning为true,则会立即中断执行任务的线程并返回true,若mayInterruptIfRunning为false,则会返回true且不会中断任务执行线程。</li>
<li>isCanceled():判断任务是否被取消,如果任务在结束(正常执行结束或者执行异常结束)前被取消则返回true,否则返回false。</li>
<li>isDone():判断任务是否已经完成,如果完成则返回true,否则返回false。需要注意的是:任务执行过程中发生异常、任务被取消也属于任务已完成,也会返回true。</li>
<li>get():获取任务执行结果,如果任务还没完成则会阻塞等待直到任务执行完成。如果任务被取消则会抛出CancellationException异常,如果任务执行过程发生异常则会抛出ExecutionException异常,如果阻塞等待过程中被中断则会抛出InterruptedException异常。</li>
<li>get(long timeout,Timeunit unit):带超时时间的get()版本,如果阻塞等待过程中超时则会抛出TimeoutException异常。</li>
</ul>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>Future只是一个接口,不能直接用来创建对象,FutureTask是Future的实现类,<br>FutureTask的继承图如下:<br><img src="/2017/10/09/Java-FutureTask/728ad60436305482476012b9ac99c699.png" alt="728ad60436305482476012b9ac99c699.png" title=""><br>可以看到,FutureTask实现了RunnableFuture接口,则RunnableFuture接口继承了Runnable接口和Future接口,所以FutureTask既能当做一个Runnable直接被Thread执行,也能作为Future用来得到Callable的计算结果。</p>
<p>FutureTask一般配合ExecutorService来使用,也可以直接通过Thread来使用。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">package</span> com.beautyboss.slogen.callback;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.concurrent.*;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallDemo</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</div><div class="line"> </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 第一种方式:Future + ExecutorService</div><div class="line">         * Task task = new Task();</div><div class="line">         * ExecutorService service = Executors.newCachedThreadPool();</div><div class="line">         * Future&lt;Integer&gt; future = service.submit(task1);</div><div class="line">         * service.shutdown();</div><div class="line">         */</div><div class="line"> </div><div class="line"> </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 第二种方式: FutureTask + ExecutorService</div><div class="line">         * ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">         * Task task = new Task();</div><div class="line">         * FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</div><div class="line">         * executor.submit(futureTask);</div><div class="line">         * executor.shutdown();</div><div class="line">         */</div><div class="line"> </div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 第三种方式:FutureTask + Thread</div><div class="line">         */</div><div class="line"> </div><div class="line">        <span class="comment">// 2. 新建FutureTask,需要一个实现了Callable接口的类的实例作为构造函数参数</span></div><div class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Task());</div><div class="line">        <span class="comment">// 3. 新建Thread对象并启动</span></div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</div><div class="line">        thread.setName(<span class="string">"Task thread"</span>);</div><div class="line">        thread.start();</div><div class="line"> </div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        System.out.println(<span class="string">"Thread ["</span> + Thread.currentThread().getName() + <span class="string">"] is running"</span>);</div><div class="line"> </div><div class="line">        <span class="comment">// 4. 调用isDone()判断任务是否结束</span></div><div class="line">        <span class="keyword">if</span>(!futureTask.isDone()) &#123;</div><div class="line">            System.out.println(<span class="string">"Task is not done"</span>);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(<span class="number">2000</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 5. 调用get()方法获取任务结果,如果任务没有执行完成则阻塞等待</span></div><div class="line">            result = futureTask.get();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        System.out.println(<span class="string">"result is "</span> + result);</div><div class="line"> </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="comment">// 1. 继承Callable接口,实现call()方法,泛型参数为要返回的类型</span></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span>  <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line"> </div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Thread ["</span> + Thread.currentThread().getName() + <span class="string">"] is running"</span>);</div><div class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;++i) &#123;</div><div class="line">                result += i;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            Thread.sleep(<span class="number">3000</span>);</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="第三部分-Why"><a href="#第三部分-Why" class="headerlink" title="第三部分:Why"></a>第三部分:Why</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>先从FutureTask的构造函数看起,FutureTask有两个构造函数,其中一个如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="keyword">this</span>.callable = callable;</div><div class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个构造函数会把传入的Callable变量保存在this.callable字段中,该字段定义为private Callable<v> callable;用来保存底层的调用,在被执行完成以后会指向null,接着会初始化state字段为NEW。state字段用来保存FutureTask内部的任务执行状态,一共有7中状态,每种状态及其对应的值如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</div></pre></td></tr></table></figure></v></p>
<p>其中需要注意的是state是volatile类型的,也就是说只要有任何一个线程修改了这个变量,那么其他所有的线程都会知道最新的值。</p>
<p>为了后面更好的分析FutureTask的实现,这里有必要解释下各个状态。</p>
<ul>
<li>NEW:表示是个新的任务或者还没被执行完的任务。这是初始状态。</li>
<li>COMPLETING:任务已经执行完成或者执行任务的时候发生异常,但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果,如果发生异常,则用来保存异常原因)的时候,状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短,属于中间状态。</li>
<li>NORMAL:任务已经执行完成并且任务执行结果已经保存到outcome字段,状态会从COMPLETING转换到NORMAL。这是一个最终态。</li>
<li>EXCEPTIONAL:任务执行发生异常并且异常原因已经保存到outcome字段中后,状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。</li>
<li>CANCELLED:任务还没开始执行或者已经开始执行但是还没有执行完成的时候,用户调用了cancel(false)方法取消任务且不中断任务执行线程,这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。</li>
<li>INTERRUPTING: 任务还没开始执行或者已经执行但是还没有执行完成的时候,用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前,状态会从NEW转化为INTERRUPTING。这是一个中间状态。</li>
<li>INTERRUPTED:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。</li>
</ul>
<p>有一点需要注意的是,所有值大于COMPLETING的状态都表示任务已经执行完成(任务正常执行完成,任务执行异常或者任务被取消)。</p>
<p>各个状态之间的可能转换关系如下图所示:<br><img src="/2017/10/09/Java-FutureTask/815ce1e16f6e67713e34c51046a91e3f.png" alt="815ce1e16f6e67713e34c51046a91e3f.png" title=""></p>
<p>另外一个构造函数如下,<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</div><div class="line">        <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个构造函数会把传入的Runnable封装成一个Callable对象保存在callable字段中,同时如果任务执行成功的话就会返回传入的result。这种情况下如果不需要返回值的话可以传入一个null。</p>
<p>顺带看下Executors.callable()这个方法,这个方法的功能是把Runnable转换成Callable,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到这里采用的是适配器模式,调用RunnableAdapter<t>(task, result)方法来适配,实现如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">final</span> Runnable task;</div><div class="line">    <span class="keyword">final</span> T result;</div><div class="line">    RunnableAdapter(Runnable task, T result) &#123;</div><div class="line">        <span class="keyword">this</span>.task = task;</div><div class="line">        <span class="keyword">this</span>.result = result;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        task.run();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></t></p>
<p>这个适配器很简单,就是简单的实现了Callable接口,在call()实现中调用Runnable.run()方法,然后把传入的result作为任务的结果返回。</p>
<p>在new了一个FutureTask对象之后,接下来就是在另一个线程中执行这个Task,无论是通过直接new一个Thread还是通过线程池,执行的都是run()方法,接下来就看看run()方法的实现。</p>
<h3 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h3><p>run()方法实现如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 1. 状态如果不是NEW,说明任务或者已经执行过,或者已经被取消,直接返回</span></div><div class="line">    <span class="comment">// 2. 状态如果是NEW,则尝试把当前执行线程保存在runner字段中</span></div><div class="line">    <span class="comment">// 如果赋值失败则直接返回</span></div><div class="line">    <span class="keyword">if</span> (state != NEW ||</div><div class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</div><div class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</div><div class="line">            V result;</div><div class="line">            <span class="keyword">boolean</span> ran;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 3. 执行任务</span></div><div class="line">                result = c.call();</div><div class="line">                ran = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                result = <span class="keyword">null</span>;</div><div class="line">                ran = <span class="keyword">false</span>;</div><div class="line">                <span class="comment">// 4. 任务异常</span></div><div class="line">                setException(ex);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (ran)</div><div class="line">                <span class="comment">// 4. 任务正常执行完毕</span></div><div class="line">                set(result);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// runner must be non-null until state is settled to</span></div><div class="line">        <span class="comment">// prevent concurrent calls to run()</span></div><div class="line">        runner = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></div><div class="line">        <span class="comment">// leaked interrupts</span></div><div class="line">        <span class="keyword">int</span> s = state;</div><div class="line">        <span class="comment">// 5. 如果任务被中断,执行中断处理</span></div><div class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</div><div class="line">            handlePossibleCancellationInterrupt(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>run()方法首先会</p>
<ol>
<li>判断当前任务的state是否等于NEW,如果不为NEW则说明任务或者已经执行过,或者已经被取消,直接返回。</li>
<li>如果状态为NEW则接着会通过unsafe类把任务执行线程引用CAS的保存在runner字段中,如果保存失败,则直接返回。</li>
<li>执行任务。</li>
<li>如果任务执行发生异常,则调用setException()方法保存异常信息。<br>setException()方法如下:<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</div><div class="line">        outcome = t;</div><div class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></div><div class="line">        finishCompletion();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在setException()方法中</p>
<ul>
<li>首先会CAS的把当前的状态从NEW变更为COMPLETING状态。</li>
<li>把异常原因保存在outcome字段中,outcome字段用来保存任务执行结果或者异常原因。</li>
<li>CAS的把当前任务状态从COMPLETING变更为EXCEPTIONAL。这个状态转换对应着上图中的二。</li>
<li>调用finishCompletion()。关于这个方法后面在分析。</li>
</ul>
<ol>
<li>如果任务成功执行则调用set()方法设置执行结果,该方法实现如下:<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</div><div class="line">        outcome = v;</div><div class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></div><div class="line">        finishCompletion();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个方法跟上面分析的setException()差不多,</p>
<ul>
<li>首先会CAS的把当前的状态从NEW变更为COMPLETING状态。</li>
<li>把任务执行结果保存在outcome字段中。</li>
<li>CAS的把当前任务状态从COMPLETING变更为NORMAL。这个状态转换对应着上图中的一。</li>
<li>调用finishCompletion()。</li>
</ul>
<p>发起任务线程跟执行任务线程通常情况下都不会是同一个线程,在任务执行线程执行任务的时候,任务发起线程可以查看任务执行状态、获取任务执行结果、取消任务等等操作,接下来分析下这些操作。</p>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>任务发起线程可以调用get()方法来获取任务执行结果,如果此时任务已经执行完毕则会直接返回任务结果,如果任务还没执行完毕,则调用方会阻塞直到任务执行结束返回结果为止。get()方法实现如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">    <span class="keyword">int</span> s = state;</div><div class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</div><div class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    <span class="keyword">return</span> report(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>get()方法实现比较简单,会</p>
<ol>
<li>判断任务当前的state &lt;= COMPLETING是否成立。前面分析过,COMPLETING状态是任务是否执行完成的临界状态。</li>
<li>如果成立,表明任务还没有结束(这里的结束包括任务正常执行完毕,任务执行异常,任务被取消),则会调用awaitDone()进行阻塞等待。</li>
<li>如果不成立表明任务已经结束,调用report()返回结果。</li>
</ol>
<h3 id="awaitDone"><a href="#awaitDone" class="headerlink" title="awaitDone()"></a>awaitDone()</h3><p>当调用get()获取任务结果但是任务还没执行完成的时候,调用线程会调用awaitDone()方法进行阻塞等待,该方法定义如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="comment">// 计算等待截止时间</span></div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</div><div class="line">    WaitNode q = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="comment">// 1. 判断阻塞线程是否被中断,如果被中断则在等待队</span></div><div class="line">        <span class="comment">// 列中删除该节点并抛出InterruptedException异常</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">            removeWaiter(q);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">// 2. 获取当前状态,如果状态大于COMPLETING</span></div><div class="line">        <span class="comment">// 说明任务已经结束(要么正常结束,要么异常结束,要么被取消)</span></div><div class="line">        <span class="comment">// 则把thread显示置空,并返回结果</span></div><div class="line">        <span class="keyword">int</span> s = state;</div><div class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</div><div class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</div><div class="line">                q.thread = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">return</span> s;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 3. 如果状态处于中间状态COMPLETING</span></div><div class="line">        <span class="comment">// 表示任务已经结束但是任务执行线程还没来得及给outcome赋值</span></div><div class="line">        <span class="comment">// 这个时候让出执行权让其他线程优先执行</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></div><div class="line">            Thread.yield();</div><div class="line">        <span class="comment">// 4. 如果等待节点为空,则构造一个等待节点</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</div><div class="line">            q = <span class="keyword">new</span> WaitNode();</div><div class="line">        <span class="comment">// 5. 如果还没有入队列,则把当前节点加入waiters首节点并替换原来waiters</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</div><div class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</div><div class="line">                    q.next = waiters, q);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</div><div class="line">            <span class="comment">// 如果需要等待特定时间,则先计算要等待的时间</span></div><div class="line">            <span class="comment">// 如果已经超时,则删除对应节点并返回对应的状态</span></div><div class="line">            nanos = deadline - System.nanoTime();</div><div class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</div><div class="line">                removeWaiter(q);</div><div class="line">                <span class="keyword">return</span> state;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 6. 阻塞等待特定时间</span></div><div class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="comment">// 6. 阻塞等待直到被其他线程唤醒</span></div><div class="line">            LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>awaitDone()中有个死循环,每一次循环都会</p>
<ol>
<li>判断调用get()的线程是否被其他线程中断,如果是的话则在等待队列中删除对应节点然后抛出InterruptedException异常。</li>
<li>获取任务当前状态,如果当前任务状态大于COMPLETING则表示任务执行完成,则把thread字段置null并返回结果。</li>
<li>如果任务处于COMPLETING状态,则表示任务已经处理完成(正常执行完成或者执行出现异常),但是执行结果或者异常原因还没有保存到outcome字段中。这个时候调用线程让出执行权让其他线程优先执行。</li>
<li>如果等待节点为空,则构造一个等待节点WaitNode。</li>
<li>如果第四步中新建的节点还没如队列,则CAS的把该节点加入waiters队列的首节点。</li>
<li>阻塞等待。</li>
</ol>
<p>假设当前state=NEW且waiters为NULL,也就是说还没有任何一个线程调用get()获取执行结果,这个时候有两个线程threadA和threadB先后调用get()来获取执行结果。再假设这两个线程在加入阻塞队列进行阻塞等待之前任务都没有执行完成且threadA和threadB都没有被中断的情况下(因为如果threadA和threadB在进行阻塞等待结果之前任务就执行完成或线程本身被中断的话,awaitDone()就执行结束返回了),执行过程是这样的,以threadA为例:</p>
<ol>
<li>第一轮for循环,执行的逻辑是q == null,所以这时候会新建一个节点q。第一轮循环结束。</li>
<li>第二轮for循环,执行的逻辑是!queue,这个时候会把第一轮循环中生成的节点的netx指针指向waiters,然后CAS的把节点q替换waiters。也就是把新生成的节点添加到waiters链表的首节点。如果替换成功,queued=true。第二轮循环结束。</li>
<li>第三轮for循环,进行阻塞等待。要么阻塞特定时间,要么一直阻塞知道被其他线程唤醒。</li>
</ol>
<p>在threadA和threadB都阻塞等待之后的waiters结果如图<br><img src="/2017/10/09/Java-FutureTask/92f6bbb0d4800bc528b2dacc1116e0d4.png" alt="92f6bbb0d4800bc528b2dacc1116e0d4.png" title=""></p>
<h3 id="cancel-boolean"><a href="#cancel-boolean" class="headerlink" title="cancel(boolean)"></a>cancel(boolean)</h3><p>用户可以调用cancel(boolean)方法取消任务的执行,cancel()实现如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</div><div class="line">    <span class="comment">// 1. 如果任务已经结束,则直接返回false</span></div><div class="line">    <span class="keyword">if</span> (state != NEW)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 2. 如果需要中断任务执行线程</span></div><div class="line">    <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</div><div class="line">        <span class="comment">// 2.1. 把任务状态从NEW转化到INTERRUPTING</span></div><div class="line">        <span class="keyword">if</span> (!UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, INTERRUPTING))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Thread t = runner;</div><div class="line">        <span class="comment">// 2.2. 中断任务执行线程</span></div><div class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>)</div><div class="line">            t.interrupt();</div><div class="line">        <span class="comment">// 2.3. 修改状态为INTERRUPTED</span></div><div class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED); <span class="comment">// final state</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 3. 如果不需要中断任务执行线程,则直接把状态从NEW转化为CANCELLED</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, CANCELLED))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="comment">// 4. </span></div><div class="line">    finishCompletion();</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>cancel()方法会做下面几件事:</p>
<ol>
<li>判断任务当前执行状态,如果任务状态不为NEW,则说明任务或者已经执行完成,或者执行异常,不能被取消,直接返回false表示执行失败。</li>
<li>判断需要中断任务执行线程,则</li>
</ol>
<ul>
<li>把任务状态从NEW转化到INTERRUPTING。这是个中间状态。</li>
<li>中断任务执行线程。</li>
<li>修改任务状态为INTERRUPTED。这个转换过程对应上图中的四。</li>
</ul>
<ol>
<li>如果不需要中断任务执行线程,直接把任务状态从NEW转化为CANCELLED。如果转化失败则返回false表示取消失败。这个转换过程对应上图中的四。</li>
<li>调用finishCompletion()。</li>
</ol>
<h3 id="finishCompletion"><a href="#finishCompletion" class="headerlink" title="finishCompletion()"></a>finishCompletion()</h3><p>根据前面的分析,不管是任务执行异常还是任务正常执行完毕,或者取消任务,最后都会调用finishCompletion()方法,该方法实现如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></div><div class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</div><div class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                Thread t = q.thread;</div><div class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">                    q.thread = <span class="keyword">null</span>;</div><div class="line">                    LockSupport.unpark(t);</div><div class="line">                &#125;</div><div class="line">                WaitNode next = q.next;</div><div class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></div><div class="line">                q = next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    done();</div><div class="line"> </div><div class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法的实现比较简单,依次遍历waiters链表,唤醒节点中的线程,然后把callable置空。<br>被唤醒的线程会各自从awaitDone()方法中的LockSupport.park()阻塞中返回,然后会进行新一轮的循环。在新一轮的循环中会返回执行结果(或者更确切的说是返回任务的状态)。</p>
<h3 id="report"><a href="#report" class="headerlink" title="report()"></a>report()</h3><p>report()方法用在get()方法中,作用是把不同的任务状态映射成任务执行结果。实现如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</div><div class="line">    Object x = outcome;</div><div class="line">    <span class="comment">// 1. 任务正常执行完成,返回任务执行结果</span></div><div class="line">    <span class="keyword">if</span> (s == NORMAL)</div><div class="line">        <span class="keyword">return</span> (V)x;</div><div class="line">    <span class="comment">// 2. 任务被取消,抛出CancellationException异常</span></div><div class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</div><div class="line">    <span class="comment">// 3. 其他状态,抛出执行异常ExecutionException</span></div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>映射关系如下图所示:<br><img src="/2017/10/09/Java-FutureTask/137a6979a224d067b7b401ec072ca00f.png" alt="137a6979a224d067b7b401ec072ca00f.png" title=""><br>如果任务处于NEW、COMPLETING和INTERRUPTING这三种状态的时候是执行不到report()方法的,所以没必要对这三种状态进行转换。</p>
<h3 id="get-long-TimeUnit"><a href="#get-long-TimeUnit" class="headerlink" title="get(long,TimeUnit)"></a>get(long,TimeUnit)</h3><p>带超时等待的获取任务结果,实现如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;</div><div class="line">    <span class="keyword">if</span> (unit == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> s = state;</div><div class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING &amp;&amp;</div><div class="line">        <span class="comment">// 如果awaitDone()超时返回之后任务还没结束,则抛出异常</span></div><div class="line">        (s = awaitDone(<span class="keyword">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</div><div class="line">    <span class="keyword">return</span> report(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>跟get()不同点在于get(long,TimeUnit)会在awaitDone()超时返回之后抛出TimeoutException异常。</p>
<h3 id="isCancelled-和isDone"><a href="#isCancelled-和isDone" class="headerlink" title="isCancelled()和isDone()"></a>isCancelled()和isDone()</h3><p>这两个方法分别用来判断任务是否被取消和任务是否执行完成,实现都比较简单,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> state &gt;= CANCELLED;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> state != NEW;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结下,其实FutureTask的实现还是比较简单的,当用户实现Callable()接口定义好任务之后,把任务交给其他线程进行执行。FutureTask内部维护一个任务状态,任何操作都是围绕着这个状态进行,并随时更新任务状态。任务发起者调用get()获取执行结果的时候,如果任务还没有执行完毕,则会把自己放入阻塞队列中然后进行阻塞等待。当任务执行完成之后,任务执行线程会依次唤醒阻塞等待的线程。调用cancel()取消任务的时候也只是简单的修改任务状态,如果需要中断任务执行线程的话则调用Thread.interrupt()中断任务执行线程。</p>
<h2 id="第四部分-Other"><a href="#第四部分-Other" class="headerlink" title="第四部分:Other"></a>第四部分:Other</h2><p>有个值得关注的问题就是当任务还在执行的时候用户调用cancel(true)方法能否真正让任务停止执行呢？<br>在前面的分析中我们直到,当调用cancel(true)方法的时候,实际执行还是Thread.interrupt()方法,而interrupt()方法只是设置中断标志位,如果被中断的线程处于sleep()、wait()或者join()逻辑中则会抛出InterruptedException异常。</p>
<p>因此结论是:cancel(true)并不一定能够停止正在执行的异步任务。</p>
<p>ref: <a href="http://www.importnew.com/25286.html" target="_blank" rel="external">http://www.importnew.com/25286.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>FutureTask</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat-部署静态文件</title>
    <url>/2017/10/09/Tomcat-%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>在 tomcat 部署静态文件</p>
<a id="more"></a>
<p>可以把文件直接放到webapps下面。当只是运行一个项目的时候,这种方法还好,但是当你涉及到两个以上项目的时候,就麻烦了。设定虚拟目录的方法,下面详细介绍。</p>
<p>配置虚拟目录也有两种方法,直接介绍我现在用的这种,直接在servler.xml里修改,毕竟经过了实践可用的,首先找到Tomcat下的conf文件夹下的server.xml</p>
<p>编辑server.xml,可以看到Host标签,默认就有一个,一个Host代表一个站点,找到Host结束标签,我们在这里配置虚拟路径</p>
<p>在的上面添加<code>&lt;Context path=&quot;&quot; docBase=&quot;&quot; reloadable=&quot;&quot; debug=&quot;&quot; crossContext=&quot;&quot;/&gt;</code>,这里属性值都没有填写,下面填写属性值。<br>要填写属性值,我们要知道什么意思,对待知识就得不甚解。所以我这步没有直接填东西,填完你可能就直接似懂非懂的去用了。</p>
<p>Context指上下文,相信当你看到这步的时候,你一定没少接触过这个词。不赘述<br>path指虚拟目录,与浏览器访问的路径相关,如果直接是path=”/“,访问就是<a href="http://localhost:8080/XX.jsp,如果为空串,也是一样,如果加了项目名,访问路径也要加,如path=&quot;/home&quot;,访问就是http://localhost:8080/home/XX.jsp" target="_blank" rel="external">http://localhost:8080/XX.jsp,如果为空串,也是一样,如果加了项目名,访问路径也要加,如path=&quot;/home&quot;,访问就是http://localhost:8080/home/XX.jsp</a><br>docBase指实际存在路径,一般在硬盘里。如果我们的文件home直接放在了E盘下,那docBase=“E:\home”<br>reloadable指有文件更新时,是否重新加载,一般设置为true,设置为true后,不需重新启动,就能验证我们的改动,不过修改了java文件后,可以重新编译需要一小会,在IDE下的控制台里可以看见输出,一般没有输出滚动出来的时候,就可以了。这三个一般经常设置。</p>
<p>debug指等级,一般设置为debug=“0”,提供最少的信息。设不设置无大影响。<br>crossContext指是否可以互相使用上下文环境。这个我也是查了很久,一般不使用。网上搜到一个两个应用共享session的,有兴趣的同学可以看下。</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-IO</title>
    <url>/2017/10/09/Java-IO/</url>
    <content><![CDATA[<p>Java IO 是一套Java用来读写数据(输入和输出)的API。大部分程序都要处理一些输入,并由输入产生一些输出。Java为此提供了java.io包。</p>
<p>如果你浏览下java.io包,会对其中各样的类选择感到迷惑。这些类的作用都是什么？对于某个任务该选择哪个类？怎样创建你自己的类做插件？这个手册的目的就是给你介绍这些类是如何组织的,以及怎样使用他们,因此你就不会疑惑需要时怎样选取合适的类,或者是否有一个满足你需求的类已经存在了。</p>
<a id="more"></a>
<h2 id="Java-io-包的范围"><a href="#Java-io-包的范围" class="headerlink" title="Java.io 包的范围"></a>Java.io 包的范围</h2><p>java.io 包并没有涵盖所有输入输出类型。例如,并不包含GUI或者网页上的输入输出,这些输入和输出在其它地方都涉及,比如Swing工程中的JFC (Java Foundation Classes) 类,或者J2EE里的Servlet和HTTP包。<br>Java.io 包主要涉及文件,网络数据流,内存缓冲等的输入输出。</p>
<h2 id="更多的Java-IO工具-提示等"><a href="#更多的Java-IO工具-提示等" class="headerlink" title="更多的Java IO工具,提示等"></a>更多的Java IO工具,提示等</h2><p>这个手册也被称为” <a href="http://tutorials.jenkov.com/java-howto/index.html" target="_blank" rel="external">Java How To’s and Utilities</a> ”,包含一些Java IO的工具,例如替换流数据中的字符串,使用缓冲来反复处理流数据。</p>
<h2 id="此Java-IO-手册的范围"><a href="#此Java-IO-手册的范围" class="headerlink" title="此Java IO 手册的范围"></a>此Java IO 手册的范围</h2><p>这个手册开始部分会给你一个Java IO API 工作的概览,以及你该怎样使用这些他们,接着会介绍包括所有Java IO API 的核心类。<br>这个手册不只是一个API的列表,这样的列表你可以从Sun公司的官方Java文档获得。事实上,每篇文档都是对一个类的简要介绍,设计它的目的以及一些实用的例子。换句话说,这些内容你在Sun公司的官方文档上是找不到的。</p>
<h2 id="Java-IO-概述"><a href="#Java-IO-概述" class="headerlink" title="Java IO 概述"></a>Java IO 概述</h2><p>在这一小节,我会试着给出Java IO(java.io)包下所有类的概述。更具体地说,我会根据类的用途对类进行分组。这个分组将会使你在未来的工作中,进行类的用途判定时,或者是为某个特定用途选择类时变得更加容易。</p>
<h3 id="输入和输出-–-数据源和目标媒介"><a href="#输入和输出-–-数据源和目标媒介" class="headerlink" title="输入和输出 – 数据源和目标媒介"></a>输入和输出 – 数据源和目标媒介</h3><p>术语“输入”和“输出”有时候会有一点让人疑惑。一个应用程序的输入往往是另外一个应用程序的输出。那么OutputStream流到底是一个输出到目的地的流呢,还是一个产生输出的流？InputStream流到底会不会输出它的数据给读取数据的程序呢？就我个人而言,在第一天学习Java IO的时候我就感觉到了一丝疑惑。(校对注:输入流可以理解为向内存输入,输出流可以理解为从内存输出)</p>
<p>为了消除这个疑惑,我试着给输入和输出起一些不一样的别名,让它们从概念上与数据的来源和数据的流向相联系。</p>
<p>Java的IO包主要关注的是从原始数据源的读取以及输出原始数据到目标媒介。以下是最典型的数据源和目标媒介:</p>
<ul>
<li>文件</li>
<li>管道</li>
<li>网络连接</li>
<li>内存缓存</li>
<li>System.in, System.out, System.error(注:Java标准输入、输出、错误输出)</li>
</ul>
<p>下面这张图描绘了一个程序从数据源读取数据,然后将数据输出到其他媒介的原理:<br><img src="/2017/10/09/Java-IO/无标题1.png" alt="无标题1.png" title=""></p>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>在Java IO中,流是一个核心的概念。流从概念上来说是一个连续的数据流。你既可以从流中读取数据,也可以往流中写数据。流与数据源或者数据流向的媒介相关联。在Java IO中流既可以是字节流(以字节为单位进行读写),也可以是字符流(以字符为单位进行读写)。</p>
<h3 id="类InputStream-OutputStream-Reader-和Writer"><a href="#类InputStream-OutputStream-Reader-和Writer" class="headerlink" title="类InputStream, OutputStream, Reader 和Writer"></a>类InputStream, OutputStream, Reader 和Writer</h3><p>一个程序需要InputStream或者Reader从数据源读取数据,需要OutputStream或者Writer将数据写入到目标媒介中。以下的图说明了这一点:<br><img src="/2017/10/09/Java-IO/无标题2.png" alt="无标题2.png" title=""><br>InputStream和Reader与数据源相关联,OutputStream和writer与目标媒介相关联。</p>
<p>Java IO中包含了许多InputStream、OutputStream、Reader、Writer的子类。这样设计的原因是让每一个类都负责不同的功能。这也就是为什么IO包中有这么多不同的类的缘故。各类用途汇总如下:</p>
<ul>
<li>文件访问</li>
<li>网络访问</li>
<li>内存缓存访问</li>
<li>线程内部通信(管道)</li>
<li>缓冲</li>
<li>过滤</li>
<li>解析</li>
<li>读写文本 (Readers / Writers)</li>
<li>读写基本类型数据 (long, int etc.)</li>
<li>读写对象</li>
</ul>
<p>当通读过Java IO类的源代码之后,我们很容易就能了解这些用途。这些用途或多或少让我们更加容易地理解,不同的类用于针对不同业务场景。</p>
<h3 id="Java-IO类概述表"><a href="#Java-IO类概述表" class="headerlink" title="Java IO类概述表"></a>Java IO类概述表</h3><p>已经讨论了数据源、目标媒介、输入、输出和各类不同用途的Java IO类,接下来是一张通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途划分的大部分Java IO类的表格。<br><img src="/2017/10/09/Java-IO/QQ截图20141020174145.png" alt="QQ截图20141020174145.png" title=""></p>
<h2 id="Java-IO-文件"><a href="#Java-IO-文件" class="headerlink" title="Java IO: 文件"></a>Java IO: 文件</h2><p>在Java应用程序中,文件是一种常用的数据源或者存储数据的媒介。所以这一小节将会对Java中文件的使用做一个简短的概述。这篇文章不会对每一个技术细节都做出解释,而是会针对文件存取的方法提供给你一些必要的知识点。在之后的文章中,将会更加详细地描述这些方法或者类,包括方法示例等等。</p>
<h3 id="通过Java-IO读文件"><a href="#通过Java-IO读文件" class="headerlink" title="通过Java IO读文件"></a>通过Java IO读文件</h3><p>如果你需要在不同端之间读取文件,你可以根据该文件是二进制文件还是文本文件来选择使用FileInputStream或者FileReader。这两个类允许你从文件开始到文件末尾一次读取一个字节或者字符,或者将读取到的字节写入到字节数组或者字符数组。你不必一次性读取整个文件,相反你可以按顺序地读取文件中的字节和字符。</p>
<p>如果你需要跳跃式地读取文件其中的某些部分,可以使用RandomAccessFile。</p>
<h3 id="通过Java-IO写文件"><a href="#通过Java-IO写文件" class="headerlink" title="通过Java IO写文件"></a>通过Java IO写文件</h3><p>如果你需要在不同端之间进行文件的写入,你可以根据你要写入的数据是二进制型数据还是字符型数据选用FileOutputStream或者FileWriter。你可以一次写入一个字节或者字符到文件中,也可以直接写入一个字节数组或者字符数据。数据按照写入的顺序存储在文件当中。</p>
<h3 id="通过Java-IO随机存取文件"><a href="#通过Java-IO随机存取文件" class="headerlink" title="通过Java IO随机存取文件"></a>通过Java IO随机存取文件</h3><p>正如我所提到的,你可以通过RandomAccessFile对文件进行随机存取。</p>
<p>随机存取并不意味着你可以在真正随机的位置进行读写操作,它只是意味着你可以跳过文件中某些部分进行操作,并且支持同时读写,不要求特定的存取顺序。这使得RandomAccessFile可以覆盖一个文件的某些部分、或者追加内容到它的末尾、或者删除它的某些内容,当然它也可以从文件的任何位置开始读取文件</p>
<h3 id="文件和目录信息的获取"><a href="#文件和目录信息的获取" class="headerlink" title="文件和目录信息的获取"></a>文件和目录信息的获取</h3><p>有时候你可能需要读取文件的信息而不是文件的内容,举个例子,如果你需要知道文件的大小和文件的属性。对于目录来说也是一样的,比如你需要获取某个目录下的文件列表。通过File类可以获取文件和目录的信息。</p>
<h2 id="Java-IO-管道"><a href="#Java-IO-管道" class="headerlink" title="Java IO: 管道"></a>Java IO: 管道</h2><p>Java IO中的管道为运行在同一个JVM中的两个线程提供了通信的能力。所以管道也可以作为数据源以及目标媒介。</p>
<p>你不能利用管道与不同的JVM中的线程通信(不同的进程)。在概念上,Java的管道不同于Unix/Linux系统中的管道。在Unix/Linux中,运行在不同地址空间的两个进程可以通过管道通信。在Java中,通信的双方应该是运行在同一进程中的不同线程。</p>
<h3 id="通过Java-IO创建管道"><a href="#通过Java-IO创建管道" class="headerlink" title="通过Java IO创建管道"></a>通过Java IO创建管道</h3><p>可以通过Java IO中的PipedOutputStream和PipedInputStream创建管道。一个PipedInputStream流应该和一个PipedOutputStream流相关联。一个线程通过PipedOutputStream写入的数据可以被另一个线程通过相关联的PipedInputStream读取出来。</p>
<h3 id="Java-IO管道示例"><a href="#Java-IO管道示例" class="headerlink" title="Java IO管道示例"></a>Java IO管道示例</h3><p>这是一个如何将PipedInputStream和PipedOutputStream关联起来的简单例子:<br><img src="/2017/10/09/Java-IO/1.png" alt="1.png" title=""><br>注:本例忽略了流的关闭。请在处理流的过程中,务必保证关闭流,或者使用jdk7引入的try-resources代替显示地调用close方法的方式。</p>
<p>你也可以使用两个管道共有的connect()方法使之相关联。PipedInputStream和PipedOutputStream都拥有一个可以互相关联的connect()方法。</p>
<h3 id="管道和线程"><a href="#管道和线程" class="headerlink" title="管道和线程"></a>管道和线程</h3><p>请记得,当使用两个相关联的管道流时,务必将它们分配给不同的线程。read()方法和write()方法调用时会导致流阻塞,这意味着如果你尝试在一个线程中同时进行读和写,可能会导致线程死锁。</p>
<h3 id="管道的替代"><a href="#管道的替代" class="headerlink" title="管道的替代"></a>管道的替代</h3><p>除了管道之外,一个JVM中不同线程之间还有许多通信的方式。实际上,线程在大多数情况下会传递完整的对象信息而非原始的字节数据。但是,如果你需要在线程之间传递字节数据,Java IO的管道是一个不错的选择。</p>
<h3 id="Java-IO-网络"><a href="#Java-IO-网络" class="headerlink" title="Java IO: 网络"></a>Java IO: 网络</h3><p>Java中网络的内容或多或少的超出了Java IO的范畴。关于Java网络更多的是在我的<a href="http://ifeve.com/java-network/" target="_blank" rel="external">Java网络教程</a>中探讨。但是既然网络是一个常见的数据来源以及数据流目的地,并且因为你使用Java IO的API通过网络连接进行通信,所以本文将简要的涉及网络应用。</p>
<p>当两个进程之间建立了网络连接之后,他们通信的方式如同操作文件一样:利用InputStream读取数据,利用OutputStream写入数据。换句话来说,Java网络API用来在不同进程之间建立网络连接,而Java IO则用来在建立了连接之后的进程之间交换数据。</p>
<p>基本上意味着如果你有一份能够对文件进行写入某些数据的代码,那么这些数据也可以很容易地写入到网络连接中去。你所需要做的仅仅只是在代码中利用OutputStream替代FileOutputStream进行数据的写入。因为FileOutputStream是OutputStream的子类,所以这么做并没有什么问题.<br>实际上对于文件的读操作也类似,一个具有读取文件数据功能的组件,同样可以轻松读取网络连接中的数据。只需要保证读取数据的组件是基于InputStream而非FileInputStream即可。<br>这是一份简单的代码示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\myfile.txt"</span>);</div><div class="line">        process(inputStream);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="comment">//do something with the InputStream</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个例子中,process()方法并不关心InputStream参数的输入流,是来自于文件还是网络(例子只展示了输入流来自文件的版本)。process()方法只会对InputStream进行操作。</p>
<h2 id="Java-IO-字节和字符数组"><a href="#Java-IO-字节和字符数组" class="headerlink" title="Java IO: 字节和字符数组"></a>Java IO: 字节和字符数组</h2><p>内容列表</p>
<ul>
<li>从InputStream或者Reader中读入数组</li>
<li>从OutputStream或者Writer中写数组</li>
</ul>
<p>在java中常用字节和字符数组在应用中临时存储数据。而这些数组又是通常的数据读取来源或者写入目的地。如果你需要在程序运行时需要大量读取文件里的内容,那么你也可以把一个文件加载到数组中。当然你可以通过直接指定索引来读取这些数组。但如果设计成为从InputStream或者Reader,而不是从数组中读取某些数据的话,你会用什么组件呢？</p>
<h3 id="从-InputStream-或-Reader中读取数组"><a href="#从-InputStream-或-Reader中读取数组" class="headerlink" title="从 InputStream 或 Reader中读取数组"></a>从 InputStream 或 Reader中读取数组</h3><p>用ByteArrayInputStream或者CharArrayReader封装字节或者字符数组从数组中读取数据。通过这种方式字节和字符就可以以数组的形式读出了。<br>样例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"></div><div class="line"><span class="comment">//把数据写入字节数组...</span></div><div class="line">InputStream input = <span class="keyword">new</span> ByteArrayInputStream(bytes);</div><div class="line"></div><div class="line"><span class="comment">//读取第一个字节</span></div><div class="line"><span class="keyword">int</span> data = input.read();</div><div class="line"></div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//操作数据</span></div><div class="line"></div><div class="line">    <span class="comment">//读下一个字节</span></div><div class="line">    data = input.read();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以同样的方式也可以用于读取字符数组,只要把字符数组封装在CharArrayReader上就行了。</p>
<h3 id="通过-OutputStream-或者-Writer写数组"><a href="#通过-OutputStream-或者-Writer写数组" class="headerlink" title="通过 OutputStream 或者 Writer写数组"></a>通过 OutputStream 或者 Writer写数组</h3><p>同样,也可以把数据写到ByteArrayOutputStream或者CharArrayWriter中。你只需要创建ByteArrayOutputStream或者CharArrayWriter,把数据写入,就像写其它的流一样。当所有的数据都写进去了以后,只要调用toByteArray()或者toCharArray,所有写入的数据就会以数组的形式返回。</p>
<p>样例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line"></div><div class="line">output.write(<span class="string">"This text is converted to bytes"</span>.toBytes(<span class="string">"UTF-8"</span>));</div><div class="line"></div><div class="line"><span class="keyword">byte</span>[] bytes = output.toByteArray();</div></pre></td></tr></table></figure></p>
<p>写字符数组也和此例子类似。只要把字符数组封装在CharArrayWriter上就可以了。</p>
<h2 id="Java-IO-System-in-System-out-System-err"><a href="#Java-IO-System-in-System-out-System-err" class="headerlink" title="Java IO: System.in, System.out, System.err"></a>Java IO: System.in, System.out, System.err</h2><p>System.in, System.out, System.err这3个流同样是常见的数据来源和数据流目的地。使用最多的可能是在控制台程序里利用System.out将输出打印到控制台上。</p>
<p>JVM启动的时候通过Java运行时初始化这3个流,所以你不需要初始化它们(尽管你可以在运行时替换掉它们)。</p>
<h3 id="System-in"><a href="#System-in" class="headerlink" title="System.in"></a>System.in</h3><p>System.in是一个典型的连接控制台程序和键盘输入的InputStream流。通常当数据通过命令行参数或者配置文件传递给命令行Java程序的时候,System.in并不是很常用。图形界面程序通过界面传递参数给程序,这是一块单独的Java IO输入机制。</p>
<h3 id="System-out"><a href="#System-out" class="headerlink" title="System.out"></a>System.out</h3><p>System.out是一个PrintStream流。System.out一般会把你写到其中的数据输出到控制台上。System.out通常仅用在类似命令行工具的控制台程序上。System.out也经常用于打印程序的调试信息(尽管它可能并不是获取程序调试信息的最佳方式)。</p>
<h3 id="System-err"><a href="#System-err" class="headerlink" title="System.err"></a>System.err</h3><p>System.err是一个PrintStream流。System.err与System.out的运行方式类似,但它更多的是用于打印错误文本。一些类似Eclipse的程序,为了让错误信息更加显眼,会将错误信息以红色文本的形式通过System.err输出到控制台上。</p>
<h3 id="System-out和System-err的简单例子"><a href="#System-out和System-err的简单例子" class="headerlink" title="System.out和System.err的简单例子:"></a>System.out和System.err的简单例子:</h3><p>这是一个System.out和System.err结合使用的简单示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\..."</span>);</div><div class="line">    System.out.println(<span class="string">"File opened..."</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    System.err.println(<span class="string">"File opening failed:"</span>);</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="替换系统流"><a href="#替换系统流" class="headerlink" title="替换系统流"></a>替换系统流</h3><p>尽管System.in, System.out, System.err这3个流是java.lang.System类中的静态成员(译者注:这3个变量均为final static常量),并且已经预先在JVM启动的时候初始化完成,你依然可以更改它们。只需要把一个新的InputStream设置给System.in或者一个新的OutputStream设置给System.out或者System.err,之后的数据都将会在新的流中进行读取、写入。</p>
<p>可以使用System.setIn(), System.setOut(), System.setErr()方法设置新的系统流(译者注:这三个方法均为静态方法,内部调用了本地native方法重新设置系统流)。例子如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\system.out.txt"</span>);</div><div class="line">PrintStream printOut = <span class="keyword">new</span> PrintStream(output);</div><div class="line">System.setOut(printOut);</div></pre></td></tr></table></figure></p>
<p>现在所有的System.out都将重定向到”c:\data\system.out.txt”文件中。请记住,务必在JVM关闭之前冲刷System.out(译者注:调用flush()),确保System.out把数据输出到了文件中。</p>
<h2 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO: 流"></a>Java IO: 流</h2><p>Java IO流是既可以从中读取,也可以写入到其中的数据流。正如这个系列教程之前提到过的,流通常会与数据源、数据流向目的地相关联,比如文件、网络等等。</p>
<p>流和数组不一样,不能通过索引读写数据。在流中,你也不能像数组那样前后移动读取数据,除非使用<a href="http://tutorials.jenkov.com/java-io/randomaccessfile.html" target="_blank" rel="external">RandomAccessFile</a> 处理文件。流仅仅只是一个连续的数据流。</p>
<p>某些类似<a href="http://tutorials.jenkov.com/java-io/pushbackinputstream.html" target="_blank" rel="external">PushbackInputStream</a> 流的实现允许你将数据重新推回到流中,以便重新读取。然而你只能把有限的数据推回流中,并且你不能像操作数组那样随意读取数据。流中的数据只能够顺序访问。</p>
<p>Java IO流通常是基于字节或者基于字符的。字节流通常以“stream”命名,比如InputStream和OutputStream。除了<a href="http://tutorials.jenkov.com/java-io/datainputstream.html" target="_blank" rel="external">DataInputStream</a> 和<a href="http://tutorials.jenkov.com/java-io/dataoutputstream.html" target="_blank" rel="external">DataOutputStream</a> 还能够读写int, long, float和double类型的值以外,其他流在一个操作时间内只能读取或者写入一个原始字节。</p>
<p>字符流通常以“Reader”或者“Writer”命名。字符流能够读写字符(比如Latin1或者Unicode字符)。可以浏览<a href="http://tutorials.jenkov.com/java-io/readers-writers.html" target="_blank" rel="external">Java Readers and Writers</a>获取更多关于字符流输入输出的信息。</p>
<h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>java.io.InputStream类是所有Java IO输入流的基类。如果你正在开发一个从流中读取数据的组件,请尝试用InputStream替代任何它的子类(比如FileInputStream)进行开发。这么做能够让你的代码兼容任何类型而非某种确定类型的输入流。</p>
<p>然而仅仅依靠InputStream并不总是可行。如果你需要将读过的数据推回到流中,你必须使用PushbackInputStream,这意味着你的流变量只能是这个类型,否则在代码中就不能调用PushbackInputStream的unread()方法。</p>
<p>通常使用输入流中的read()方法读取数据。read()方法返回一个整数,代表了读取到的字节的内容(译者注:0 ~ 255)。当达到流末尾没有更多数据可以读取的时候,read()方法返回-1。</p>
<p>这是一个简单的示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-file.txt"</span>);</div><div class="line"><span class="keyword">int</span> data = input.read(); </div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</div><div class="line">        data = input.read();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><p>java.io.OutputStream是Java IO中所有输出流的基类。如果你正在开发一个能够将数据写入流中的组件,请尝试使用OutputStream替代它的所有子类。</p>
<p>这是一个简单的示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-file.txt"</span>);</div><div class="line">output.write(<span class="string">"Hello World"</span>.getBytes());</div><div class="line">output.close();</div></pre></td></tr></table></figure></p>
<h3 id="组合流"><a href="#组合流" class="headerlink" title="组合流"></a>组合流</h3><p>你可以将流整合起来以便实现更高级的输入和输出操作。比如,一次读取一个字节是很慢的,所以可以从磁盘中一次读取一大块数据,然后从读到的数据块中获取字节。为了实现缓冲,可以把InputStream包装到BufferedInputStream中。代码示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream input = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-file.txt"</span>));</div></pre></td></tr></table></figure>
<p>缓冲同样可以应用到OutputStream中。你可以实现将大块数据批量地写入到磁盘(或者相应的流)中,这个功能由BufferedOutputStream实现。</p>
<p>缓冲只是通过流整合实现的其中一个效果。你可以把InputStream包装到PushbackInputStream中,之后可以将读取过的数据推回到流中重新读取,在解析过程中有时候这样做很方便。或者,你可以将两个InputStream整合成一个<a href="http://tutorials.jenkov.com/java-io/sequenceinputstream.html" target="_blank" rel="external">SequenceInputStream</a>。</p>
<p>将不同的流整合到一个链中,可以实现更多种高级操作。通过编写包装了标准流的类,可以实现你想要的效果和过滤器。</p>
<h2 id="Java-IO-Input-Parsing"><a href="#Java-IO-Input-Parsing" class="headerlink" title="Java IO: Input Parsing"></a>Java IO: Input Parsing</h2><p>Some of the classes in the Java IO API are designed to help you parse input. These classes are:</p>
<ul>
<li><a href="http://tutorials.jenkov.com/java-io/pushbackinputstream.html" target="_blank" rel="external">PusbackInputStream</a></li>
<li><a href="http://tutorials.jenkov.com/java-io/pushbackreader.html" target="_blank" rel="external">PusbackReader</a></li>
<li><a href="http://tutorials.jenkov.com/java-io/streamtokenizer.html" target="_blank" rel="external">StreamTokenizer</a></li>
<li><a href="http://tutorials.jenkov.com/java-io/pushbackreader.html" target="_blank" rel="external">PushbackReader</a></li>
<li><a href="http://tutorials.jenkov.com/java-io/linenumberreader.html" target="_blank" rel="external">LineNumberReader</a></li>
</ul>
<p>It is not the purpose of this text to give you a complete course in parsing of data. The purpose was rather to give you above quick list of classes related to parsing of input data.</p>
<p>If you have to parse data you will often end up writing your own classes that use some of the classes in this list. I know I did when I wrote the parser for the Butterfly Container Script. I used the PushbackInputStream at the core of my parser, because sometimes I needed to read ahead a character or two, to determine what the character at hand meant.</p>
<p>I have a real life example that uses the PushbackReader in my article about <a href="http://tutorials.jenkov.com/java-howto/replace-strings-in-streams-arrays-files.html" target="_blank" rel="external">Replace Strings in Streams, Arrays, Files</a> tutorial. The example creates a TokenReplacingReader which can replace tokens of the format ${tokenName} in data read from an underlying Reader with values of your own choosing. The user of the TokenReplacingReader cannot see that this replacement takes place.</p>
<h2 id="Java-IO-Reader-And-Writer"><a href="#Java-IO-Reader-And-Writer" class="headerlink" title="Java IO: Reader And Writer"></a>Java IO: Reader And Writer</h2><p>Java IO的Reader和Writer除了基于字符之外,其他方面都与InputStream和OutputStream非常类似。他们被用于读写文本。InputStream和OutputStream是基于字节的</p>
<h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p>Reader类是Java IO中所有Reader的基类。子类包括BufferedReader,PushbackReader,InputStreamReader,StringReader和其他Reader。</p>
<p>这是一个简单的Java IO Reader的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\myfile.txt"</span>);</div><div class="line"><span class="keyword">int</span> data = reader.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">char</span> dataChar = (<span class="keyword">char</span>) data;</div><div class="line">    data = reader.read();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>请注意,InputStream的read()方法返回一个字节,意味着这个返回值的范围在0到255之间(当达到流末尾时,返回-1),Reader的read()方法返回一个字符,意味着这个返回值的范围在0到65535之间(当达到流末尾时,同样返回-1)。这并不意味着Reade只会从数据源中一次读取2个字节,Reader会根据文本的编码,一次读取一个或者多个字节。</p>
<p>你通常会使用Reader的子类,而不会直接使用Reader。Reader的子类包括InputStreamReader,CharArrayReader,FileReader等等。可以查看Java IO概述浏览完整的Reader表格。</p>
<h3 id="整合Reader与InputStream"><a href="#整合Reader与InputStream" class="headerlink" title="整合Reader与InputStream"></a>整合Reader与InputStream</h3><p>一个Reader可以和一个InputStream相结合。如果你有一个InputStream输入流,并且想从其中读取字符,可以把这个InputStream包装到InputStreamReader中。把InputStream传递到InputStreamReader的构造函数中:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(inputStream);</div></pre></td></tr></table></figure></p>
<p>在构造函数中可以指定解码方式。更多内容请参阅InputStreamReader。</p>
<h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><p>Writer类是Java IO中所有Writer的基类。子类包括BufferedWriter和PrintWriter等等。这是一个Java IO Writer的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\file-output.txt"</span>); </div><div class="line">writer.write(<span class="string">"Hello World Writer"</span>); </div><div class="line">writer.close();</div></pre></td></tr></table></figure></p>
<p>同样,你最好使用Writer的子类,不需要直接使用Writer,因为子类的实现更加明确,更能表现你的意图。常用子类包括OutputStreamWriter,CharArrayWriter,FileWriter等。Writer的write(int c)方法,会将传入参数的低16位写入到Writer中,忽略高16位的数据。</p>
<h3 id="整合Writer和OutputStream"><a href="#整合Writer和OutputStream" class="headerlink" title="整合Writer和OutputStream"></a>整合Writer和OutputStream</h3><p>与Reader和InputStream类似,一个Writer可以和一个OutputStream相结合。把OutputStream包装到OutputStreamWriter中,所有写入到OutputStreamWriter的字符都将会传递给OutputStream。这是一个OutputStreamWriter的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Writer writer = <span class="keyword">new</span> OutputStreamWriter(outputStream);</div></pre></td></tr></table></figure></p>
<h3 id="整合Reader和Writer"><a href="#整合Reader和Writer" class="headerlink" title="整合Reader和Writer"></a>整合Reader和Writer</h3><p>和字节流一样,Reader和Writer可以相互结合实现更多更有趣的IO,工作原理和把Reader与InputStream或者Writer与OutputStream相结合类似。举个栗子,可以通过将Reader包装到BufferedReader、Writer包装到BufferedWriter中实现缓冲。以下是例子:<br>Reader reader = new BufferedReader(new FileReader(…));<br>Writer writer = new BufferedWriter(new FileWriter(…));</p>
<h2 id="Java-IO-并发IO"><a href="#Java-IO-并发IO" class="headerlink" title="Java IO: 并发IO"></a>Java IO: 并发IO</h2><p>有时候你可能需要并发地处理输入和输出。换句话说,你可能有超过一个线程处理输入和产生输出。比如,你有一个程序需要处理磁盘上的大量文件,这个任务可以通过并发操作提高性能。又比如,你有一个web服务器或者聊天服务器,接收许多连接和请求,这些任务都可以通过并发获得性能的提升。</p>
<p>如果你需要并发处理IO,这里有几个问题可能需要注意一下:</p>
<p>在同一时刻不能有多个线程同时从InputStream或者Reader中读取数据,也不能同时往OutputStream或者Writer里写数据。你没有办法保证每个线程读取多少数据,以及多个线程写数据时的顺序。</p>
<p>如果线程之间能够保证操作的顺序,它们可以使用同一个stream、reader、writer。比如,你有一个线程判断当前的输入流来自哪种类型的请求,然后将流数据传递给其他合适的线程做后续处理。当有序存取流、reader、writer时,这种做法是可行的。请注意,在线程之间传递流数据的代码应当是同步的。</p>
<p>注意:在Java NIO中,你可以让一个线程读写多个“channel”。比如,你有很多网络连接处于开启状态,但是每个连接中都只有少量数据,类似于聊天服务器,可以让一个线程监视多个频道(连接)。Java NIO是另一个话题了,会后续教程中介绍。</p>
<h2 id="Java-IO-异常处理"><a href="#Java-IO-异常处理" class="headerlink" title="Java IO: 异常处理"></a>Java IO: 异常处理</h2><p>流与Reader和Writer在结束使用的时候,需要正确地关闭它们。通过调用close()方法可以达到这一点。不过这需要一些思考。请看下边的代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</div><div class="line"><span class="keyword">int</span> data = input.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//do something with data...  </span></div><div class="line">    doSomethingWithData(data);</div><div class="line">    data = input.read();</div><div class="line">&#125;</div><div class="line">input.close();</div></pre></td></tr></table></figure></p>
<p>第一眼看这段代码时,可能觉得没什么问题。可是如果在调用doSomethingWithData()方法时出现了异常,会发生什么呢？没错,这个InputStream对象就不会被关闭。</p>
<p>为了避免异常造成流无法被关闭,我们可以把代码重写成这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream input = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</div><div class="line">    <span class="keyword">int</span> data = input.read();</div><div class="line">    <span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//do something with data...</span></div><div class="line">        doSomethingWithData(data);</div><div class="line">        data = input.read();</div><div class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">    <span class="comment">//do something with e... log, perhaps rethrow etc.</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span>(input != <span class="keyword">null</span>)</div><div class="line">        input.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意到这里把InputStream的关闭代码放到了finally块中,无论在try-catch块中发生了什么,finally内的代码始终会被执行,所以这个InputStream总是会被关闭。</p>
<p>但是如果close()方法抛出了异常,告诉你流已经被关闭过了呢？为了解决这个难题,你也需要把close()方法写在try-catch内部,就像这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>)</div><div class="line">            input.close();</div><div class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</div><div class="line">        <span class="comment">//do something, or ignore.</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段解决了InputStream(或者OutputStream)流关闭的问题的代码,确实是有一些不优雅,尽管能够正确处理异常。如果你的代码中重复地遍布了这段丑陋的异常处理代码,这不是很好的一个解决方案。如果一个匆忙的家伙贪图方便忽略了异常处理呢？</p>
<p>此外,想象一下某个异常最先从doSomethingWithData方法内抛出。第一个catch会捕获到异常,然后在finally里程序会尝试关闭InputStream。但是如果还有异常从close()方法内抛出呢？这两个异常中得哪个异常应当往调用栈上传播呢？</p>
<p>幸运的是,有一个办法能够解决这个问题。这个解决方案称作“异常处理模板”。创建一个正确关闭流的模板,能够在代码中做到一次编写,重复使用,既优雅又简单。详情参见<a href="http://tutorials.jenkov.com/java-exception-handling/exception-handling-templates.html" target="_blank" rel="external">Java异常处理模板</a>。</p>
<h3 id="Java7中IO的异常处理"><a href="#Java7中IO的异常处理" class="headerlink" title="Java7中IO的异常处理"></a>Java7中IO的异常处理</h3><p>从Java7开始,一种新的被称作“try-with-resource”的异常处理机制被引入进来。这种机制旨在解决针对InputStream和OutputStream这类在使用完毕之后需要关闭的资源的异常处理。可以浏览<a href="http://tutorials.jenkov.com/java-exception-handling/try-with-resources.html" target="_blank" rel="external">Try with Resource in Java 7</a>获得更多信息。</p>
<h2 id="Java-IO-InputStream"><a href="#Java-IO-InputStream" class="headerlink" title="Java IO: InputStream"></a>Java IO: InputStream</h2><p>InputStream类是Java IO API中所有输入流的基类。InputStream子类包括FileInputStream,BufferedInputStream,PushbackInputStream等等。参考Java IO概述这一小节底部的表格,可以浏览完整的InputStream子类的列表。</p>
<h3 id="Java-InputStream例子"><a href="#Java-InputStream例子" class="headerlink" title="Java InputStream例子"></a>Java InputStream例子</h3><p>InputStream用于读取基于字节的数据,一次读取一个字节,这是一个InputStream的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream inputstream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</div><div class="line"><span class="keyword">int</span> data = inputstream.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123; </div><div class="line">    <span class="comment">//do something with data...  </span></div><div class="line">    doSomethingWithData(data);   </div><div class="line">    data = inputstream.read();</div><div class="line">&#125;</div><div class="line">inputstream.close();</div></pre></td></tr></table></figure></p>
<p>这个例子创建了FileInputStream实例。FileInputStream是InputStream的子类,所以可以把FileInputStream实例赋值给InputStream变量。</p>
<p>注意:为了清晰,代码忽略了一些必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p>
<p>从Java7开始,你可以使用“try-with-resource”结构确保InputStream在结束使用之后关闭,链接指向了一篇关于“try-with-resource”是如何工作的文章,这里只是一个简单的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span>( InputStream inputstream = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>) ) &#123;</div><div class="line">    <span class="keyword">int</span> data = inputstream.read();</div><div class="line">    <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</div><div class="line">        System.out.print((<span class="keyword">char</span>) data);</div><div class="line">        data = inputstream.read();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当执行线程退出try语句块的时候,InputStream变量会被关闭。</p>
<h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><p>read()方法返回从InputStream流内读取到的一个字节内容(译者注:0~255),例子如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> data = inputstream.read();</div></pre></td></tr></table></figure></p>
<p>你可以把返回的int类型转化成char类型:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">char</span> aChar = (<span class="keyword">char</span>) data;</div></pre></td></tr></table></figure></p>
<p>InputStream的子类可能会包含read()方法的替代方法。比如,DataInputStream允许你利用readBoolean(),readDouble()等方法读取Java基本类型变量int,long,float,double和boolean。</p>
<h3 id="流末尾"><a href="#流末尾" class="headerlink" title="流末尾"></a>流末尾</h3><p>如果read()方法返回-1,意味着程序已经读到了流的末尾,此时流内已经没有多余的数据可供读取了。-1是一个int类型,不是byte或者char类型,这是不一样的。</p>
<p>当达到流末尾时,你就可以关闭流了。</p>
<h3 id="read-byte"><a href="#read-byte" class="headerlink" title="read(byte[])"></a>read(byte[])</h3><p>InputStream包含了2个从InputStream中读取数据并将数据存储到缓冲数组中的read()方法,他们分别是:</p>
<ul>
<li>int read(byte[])</li>
<li>int read(byte, int offset, int length)</li>
</ul>
<p>一次性读取一个字节数组的方式,比一次性读取一个字节的方式快的多,所以,尽可能使用这两个方法代替read()方法。</p>
<p>read(byte[])方法会尝试读取与给定字节数组容量一样大的字节数,返回值说明了已经读取过的字节数。如果InputStream内可读的数据不足以填满字节数组,那么数组剩余的部分将包含本次读取之前的数据。记得检查有多少数据实际被写入到了字节数组中。</p>
<p>read(byte, int offset, int length)方法同样将数据读取到字节数组中,不同的是,该方法从数组的offset位置开始,并且最多将length个字节写入到数组中。同样地,read(byte, int offset, int length)方法返回一个int变量,告诉你已经有多少字节已经被写入到字节数组中,所以请记得在读取数据前检查上一次调用read(byte, int offset, int length)的返回值。</p>
<p>这两个方法都会在读取到达到流末尾时返回-1。</p>
<p>这是一个使用InputStream的read(byte[])的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream inputstream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</div><div class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line"><span class="keyword">int</span> bytesRead = inputstream.read(data);</div><div class="line"><span class="keyword">while</span>(bytesRead != -<span class="number">1</span>) &#123;</div><div class="line">    doSomethingWithData(data, bytesRead);</div><div class="line">    bytesRead = inputstream.read(data);</div><div class="line">&#125;</div><div class="line">inputstream.close();</div></pre></td></tr></table></figure></p>
<p>在代码中,首先创建了一个字节数组。然后声明一个叫做bytesRead的存储每次调用read(byte[])返回值的int变量,并且将第一次调用read(byte[])得到的返回值赋值给它。</p>
<p>在while循环内部,把字节数组和已读取字节数作为参数传递给doSomethingWithData方法然后执行调用。在循环的末尾,再次将数据写入到字节数组中。</p>
<p>你不需要想象出read(byte, int offset, int length)替代read(byte[])的场景,几乎可以在使用read(byte, int offset, int length)的任何地方使用read(byte[])。</p>
<h3 id="输入流和数据源"><a href="#输入流和数据源" class="headerlink" title="输入流和数据源"></a>输入流和数据源</h3><p>一个输入流往往会和数据源联系起来,比如文件,网络连接,管道等,更多细节已经在Java IO概述文章中介绍过了。</p>
<h2 id="Java-IO-OutputStream"><a href="#Java-IO-OutputStream" class="headerlink" title="Java IO: OutputStream"></a>Java IO: OutputStream</h2><p>OutputStream类是Java IO API中所有输出流的基类。子类包括BufferedOutputStream,FileOutputStream等等。参考Java IO概述这一小节底部的表格,可以浏览完整的子类的列表。</p>
<h3 id="输出流和目标媒介"><a href="#输出流和目标媒介" class="headerlink" title="输出流和目标媒介"></a>输出流和目标媒介</h3><p>输出流往往和某些数据的目标媒介相关联,比如文件,网络连接,管道等。更多细节请参考Java IO概述。当写入到输出流的数据逐渐输出完毕时,目标媒介是所有数据的归属地。</p>
<h3 id="write-byte"><a href="#write-byte" class="headerlink" title="write(byte)"></a>write(byte)</h3><p>write(byte)方法用于把单个字节写入到输出流中。OutputStream的write(byte)方法将一个包含了待写入数据的int变量作为参数进行写入。只有int类型的第一个字节会被写入,其余位会被忽略。(译者注:写入低8位,忽略高24位)。</p>
<p>OutputStream的子类可能会包含write()方法的替代方法。比如,DataOutputStream允许你利用writeBoolean(),writeDouble()等方法将基本类型int,long,float,double,boolean等变量写入。</p>
<p>这是一个OutputStream的write()方法例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>);</div><div class="line"><span class="keyword">while</span>(hasMoreData()) &#123;</div><div class="line">    <span class="keyword">int</span> data = getMoreData();</div><div class="line">    output.write(data);</div><div class="line">&#125;</div><div class="line">output.close();</div></pre></td></tr></table></figure></p>
<p>这个例子首先创建了待写入的FileOutputStream。在进入while循环之后,循环的判断条件是hasMoreData()方法的返回值。hasMoreData()方法的实现不予展示,请把这个函数理解为:当有剩余可写数据时,返回true,否则返回false。</p>
<p>请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p>
<h3 id="write-byte-1"><a href="#write-byte-1" class="headerlink" title="write(byte[])"></a>write(byte[])</h3><p>OutputStream同样包含了将字节数据中全部或者部分数据写入到输出流中的方法,分别是write(byte[])和write(byte[], int offset, int length)。</p>
<p>write(byte[])把字节数组中所有数据写入到输出流中。</p>
<p>write(byte[], int offset, int length)把字节数据中从offset位置开始,length个字节的数据写入到输出流。</p>
<h3 id="flush"><a href="#flush" class="headerlink" title="flush()"></a>flush()</h3><p>OutputStream的flush()方法将所有写入到OutputStream的数据冲刷到相应的目标媒介中。比如,如果输出流是FileOutputStream,那么写入到其中的数据可能并没有真正写入到磁盘中。即使所有数据都写入到了FileOutputStream,这些数据还是有可能保留在内存的缓冲区中。通过调用flush()方法,可以把缓冲区内的数据刷新到磁盘(或者网络,以及其他任何形式的目标媒介)中。</p>
<h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>当你结束数据写入时,需要关闭OutputStream。通过调用close()可以达到这一点。因为OutputStream的各种write()方法可能会抛出IO异常,所以你需要把调用close()的关闭操作方在finally块中执行。这是一个OutputStream调用close()的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OutputStream output = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>);</div><div class="line">    <span class="keyword">while</span>(hasMoreData()) &#123;</div><div class="line">        <span class="keyword">int</span> data = getMoreData();</div><div class="line">        output.write(data);</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="keyword">if</span>(output != <span class="keyword">null</span>) &#123;</div><div class="line">        output.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个例子在finally块中调用close()方法。虽然这种方式可以确保OutputStream关闭,但却不是一个完美的异常处理方案。我在Java IO异常处理这文章中更加详细地探讨了IO的异常处理。</p>
<h2 id="Java-IO-FileInputStream"><a href="#Java-IO-FileInputStream" class="headerlink" title="Java IO: FileInputStream"></a>Java IO: FileInputStream</h2><p>FileInputStream可以以字节流的形式读取文件内容。FileInputStream是InputStream的子类,这意味着你可以把FileInputStream当做InputStream使用(FileInputStream与InputStream的行为类似)。</p>
<p>这是一个FileInputStream的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</div><div class="line"><span class="keyword">int</span> data = input.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//do something with data...</span></div><div class="line">    doSomethingWithData(data);</div><div class="line">    data = input.read();</div><div class="line">&#125;</div><div class="line">input.close();</div></pre></td></tr></table></figure></p>
<p>请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p>
<p>FileInputStream的read()方法返回读取到的包含一个字节内容的int变量(译者注:0~255)。如果read()方法返回-1,意味着程序已经读到了流的末尾,此时流内已经没有多余的数据可供读取了,你可以关闭流。-1是一个int类型,不是byte类型,这是不一样的。</p>
<p>FileInputStream也有其他的构造函数,允许你通过不同的方式读取文件。请参考<a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="external">官方文档</a>查阅更多信息。</p>
<p>其中一个FileInputStream构造函数取一个File对象替代String对象作为参数。这里是一个使用该构造函数的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-text.txt"</span>);</div><div class="line">InputStream input = <span class="keyword">new</span> FileInputStream(file);</div></pre></td></tr></table></figure></p>
<p>至于你该采用参数是String对象还是File对象的构造函数,取决于你当前是否已经拥有一个File对象,也取决于你是否要在打开FileOutputStream之前通过File对象执行某些检查(比如检查文件是否存在)。</p>
<h2 id="Java-IO-FileOutputStream"><a href="#Java-IO-FileOutputStream" class="headerlink" title="Java IO: FileOutputStream"></a>Java IO: FileOutputStream</h2><p>FileOutputStream可以往文件里写入字节流,它是OutputStream的子类,所以你可以像使用OutputStream那样使用FileOutputStream。</p>
<p>这是一个FileOutputStream的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>);</div><div class="line"><span class="keyword">while</span>(moreData) &#123;</div><div class="line">    <span class="keyword">int</span> data = getMoreData();</div><div class="line">    output.write(data);</div><div class="line">&#125;</div><div class="line">output.close();</div></pre></td></tr></table></figure></p>
<p>请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p>
<p>FileOutputStream的write()方法取一个包含了待写入字节(译者注:低8位数据)的int变量作为参数进行写入。</p>
<p>FileOutputStream也有其他的构造函数,允许你通过不同的方式写入文件。请参考<a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="external">官方文档</a>查阅更多信息。</p>
<h3 id="文件内容的覆盖Override-VS追加Appending"><a href="#文件内容的覆盖Override-VS追加Appending" class="headerlink" title="文件内容的覆盖Override VS追加Appending"></a>文件内容的覆盖Override VS追加Appending</h3><p>当你创建了一个指向已存在文件的FileOutputStream,你可以选择覆盖整个文件,或者在文件末尾追加内容。通过使用不同的构造函数可以实现不同的目的。</p>
<p>其中一个构造函数取文件名作为参数,会覆盖任何此文件名指向的文件。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>);</div></pre></td></tr></table></figure></p>
<p>另外一个构造函数取2个参数:文件名和一个布尔值,布尔值表明你是否需要覆盖文件。这是构造函数的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>, <span class="keyword">true</span>); <span class="comment">//appends to file</span></div><div class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>, <span class="keyword">false</span>); <span class="comment">//overwrites file</span></div></pre></td></tr></table></figure></p>
<h3 id="写入字节数组"><a href="#写入字节数组" class="headerlink" title="写入字节数组"></a>写入字节数组</h3><p>既然FileOutputStream是OutputStream的子类,所以你也可以往FileOutputStream中写入字节数组,而不需要每次都只写入一个字节。可以参考我的OutputStream教程查阅更多关于写入字节数组的信息。</p>
<h3 id="flush-1"><a href="#flush-1" class="headerlink" title="flush()"></a>flush()</h3><p>当你往FileOutputStream里写数据的时候,这些数据有可能会缓存在内存中。在之后的某个时间,比如,每次都只有X份数据可写,或者FileOutputStream关闭的时候,才会真正地写入磁盘。当FileOutputStream没被关闭,而你又想确保写入到FileOutputStream中的数据写入到磁盘中,可以调用flush()方法,该方法可以保证所有写入到FileOutputStream的数据全部写入到磁盘中。</p>
<h2 id="Java-IO-RandomAccessFile"><a href="#Java-IO-RandomAccessFile" class="headerlink" title="Java IO: RandomAccessFile"></a>Java IO: RandomAccessFile</h2><p>RandomAccessFile允许你来回读写文件,也可以替换文件中的某些部分。FileInputStream和FileOutputStream没有这样的功能。</p>
<h3 id="创建一个RandomAccessFile"><a href="#创建一个RandomAccessFile" class="headerlink" title="创建一个RandomAccessFile"></a>创建一个RandomAccessFile</h3><p>在使用RandomAccessFile之前,必须初始化它。这是例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</div></pre></td></tr></table></figure></p>
<p>请注意构造函数的第二个参数:“rw”,表明你以读写方式打开文件。请查阅Java文档获知你需要以何种方式构造RandomAccessFile。</p>
<h3 id="在RandomAccessFile中来回读写"><a href="#在RandomAccessFile中来回读写" class="headerlink" title="在RandomAccessFile中来回读写"></a>在RandomAccessFile中来回读写</h3><p>在RandomAccessFile的某个位置读写之前,必须把文件指针指向该位置。通过seek()方法可以达到这一目标。可以通过调用getFilePointer()获得当前文件指针的位置。例子如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">file.seek(<span class="number">200</span>);</div><div class="line"><span class="keyword">long</span> pointer = file.getFilePointer();</div><div class="line">file.close();</div></pre></td></tr></table></figure></p>
<h3 id="读取RandomAccessFile"><a href="#读取RandomAccessFile" class="headerlink" title="读取RandomAccessFile"></a>读取RandomAccessFile</h3><p>RandomAccessFile中的任何一个read()方法都可以读取RandomAccessFile的数据。例子如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</div><div class="line"><span class="keyword">int</span> aByte = file.read();</div><div class="line">file.close();</div></pre></td></tr></table></figure></p>
<p>read()方法返回当前RandomAccessFile实例的文件指针指向的位置中包含的字节内容。Java文档中遗漏了一点:read()方法在读取完一个字节之后,会自动把指针移动到下一个可读字节。这意味着使用者在调用完read()方法之后不需要手动移动文件指针。</p>
<h3 id="写入RandomAccessFile"><a href="#写入RandomAccessFile" class="headerlink" title="写入RandomAccessFile"></a>写入RandomAccessFile</h3><p>RandomAccessFile中的任何一个write()方法都可以往RandomAccessFile中写入数据。例子如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">file.write(<span class="string">"Hello World"</span>.getBytes());</div><div class="line">file.close();</div></pre></td></tr></table></figure></p>
<p>与read()方法类似,write()方法在调用结束之后自动移动文件指针,所以你不需要频繁地把指针移动到下一个将要写入数据的位置。</p>
<h3 id="RandomAccessFile异常处理"><a href="#RandomAccessFile异常处理" class="headerlink" title="RandomAccessFile异常处理"></a>RandomAccessFile异常处理</h3><p>为了本篇内容清晰,暂时忽略RandomAccessFile异常处理的内容。RandomAccessFile与其他流一样,在使用完毕之后必须关闭。想要了解更多信息,请参考Java IO异常处理。</p>
<h2 id="Java-IO-File"><a href="#Java-IO-File" class="headerlink" title="Java IO: File"></a>Java IO: File</h2><p>Java IO API中的FIle类可以让你访问底层文件系统,通过File类,你可以做到以下几点:</p>
<ul>
<li>检测文件是否存在</li>
<li>读取文件长度</li>
<li>重命名或移动文件</li>
<li>删除文件</li>
<li>检测某个路径是文件还是目录</li>
<li>读取目录中的文件列表</li>
</ul>
<p>请注意:File只能访问文件以及文件系统的元数据。如果你想读写文件内容,需要使用FileInputStream、FileOutputStream或者RandomAccessFile。如果你正在使用Java NIO,并且想使用完整的NIO解决方案,你会使用到java.nio.FileChannel(否则你也可以使用File)。</p>
<p>实例化一个java.io.File对象<br>在使用File之前,必须拥有一个File对象,这是实例化的代码例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-file.txt"</span>);</div></pre></td></tr></table></figure></p>
<p>很简单,对吗？File类同样拥有多种不同实例化方式的构造函数。</p>
<h3 id="检测文件是否存在"><a href="#检测文件是否存在" class="headerlink" title="检测文件是否存在"></a>检测文件是否存在</h3><p>当你获得一个File对象之后,可以检测相应的文件是否存在。当文件不存在的时候,构造函数并不会执行失败。你已经准备好创建一个File了,对吧？</p>
<p>通过调用exists()方法,可以检测文件是否存在,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-file.txt"</span>);</div><div class="line"><span class="keyword">boolean</span> fileExists = file.exists();</div></pre></td></tr></table></figure></p>
<h3 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h3><p>通过调用length()可以获得文件的字节长度,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-file.txt"</span>);</div><div class="line"><span class="keyword">long</span> length = file.length();</div></pre></td></tr></table></figure></p>
<h3 id="重命名或移动文件"><a href="#重命名或移动文件" class="headerlink" title="重命名或移动文件"></a>重命名或移动文件</h3><p>通过调用File类中的renameTo()方法可以重命名(或者移动)文件,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-file.txt"</span>);</div><div class="line"><span class="keyword">boolean</span> success = file.renameTo(<span class="keyword">new</span> File(<span class="string">"c:\\data\\new-file.txt"</span>));</div></pre></td></tr></table></figure></p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>通过调用delete()方法可以删除文件,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-file.txt"</span>);</div><div class="line"><span class="keyword">boolean</span> success = file.delete();</div></pre></td></tr></table></figure></p>
<p>delete()方法与rename()方法一样,返回布尔值表明是否成功删除文件,同样也会有相同的操作失败原因。</p>
<h3 id="检测某个路径是文件还是目录"><a href="#检测某个路径是文件还是目录" class="headerlink" title="检测某个路径是文件还是目录"></a>检测某个路径是文件还是目录</h3><p>File对象既可以指向一个文件,也可以指向一个目录。可以通过调用isDirectory()方法,可以判断当前File对象指向的是文件还是目录。当方法返回值是true时,File指向的是目录,否则指向的是文件,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data"</span>);</div><div class="line"><span class="keyword">boolean</span> isDirectory = file.isDirectory();</div></pre></td></tr></table></figure></p>
<h3 id="读取目录中的文件列表"><a href="#读取目录中的文件列表" class="headerlink" title="读取目录中的文件列表"></a>读取目录中的文件列表</h3><p>你可以通过调用list()或者listFiles()方法获取一个目录中的所有文件列表。list()方法返回当前File对象指向的目录中所有文件与子目录的字符串名称(译者注:不会返回子目录下的文件及其子目录名称)。listFiles()方法返回当前File对象指向的目录中所有文件与子目录相关联的File对象(译者注:与list()方法类似,不会返回子目录下的文件及其子目录)。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data"</span>);</div><div class="line">String[] fileNames = file.list();</div><div class="line">File[] files = file.listFiles();</div></pre></td></tr></table></figure></p>
<h2 id="Java-IO-PipedInputStream"><a href="#Java-IO-PipedInputStream" class="headerlink" title="Java IO: PipedInputStream"></a>Java IO: PipedInputStream</h2><p>PipedInputStream可以从管道中读取字节流数据,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream input = <span class="keyword">new</span> PipedInputStream(pipedOutputStream);</div><div class="line"><span class="keyword">int</span> data = input.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//do something with data...</span></div><div class="line">    doSomethingWithData(data);</div><div class="line">    data = input.read();</div><div class="line">&#125;</div><div class="line">input.close();</div></pre></td></tr></table></figure></p>
<p>请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p>
<p>PipedInputStream的read()方法返回读取到的包含一个字节内容的int变量(译者注:0~255)。如果read()方法返回-1,意味着程序已经读到了流的末尾,此时流内已经没有多余的数据可供读取了,你可以关闭流。-1是一个int类型,不是byte类型,这是不一样的。</p>
<h3 id="Java-IO管道"><a href="#Java-IO管道" class="headerlink" title="Java IO管道"></a>Java IO管道</h3><p>正如你所看到的例子那样,一个PipedInputStream需要与一个PipedOutputStream相关联,当这两种流联系起来时,就形成了一条管道。要想更多地了解Java IO中的管道,请参考Java IO管道。</p>
<h2 id="Java-IO-PipedOutputStream"><a href="#Java-IO-PipedOutputStream" class="headerlink" title="Java IO: PipedOutputStream"></a>Java IO: PipedOutputStream</h2><p>PipedOutputStream可以往管道里写入读取字节流数据,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OutputStream output = <span class="keyword">new</span> PipedOutputStream(pipedInputStream);</div><div class="line"><span class="keyword">while</span>(moreData) &#123;</div><div class="line">    <span class="keyword">int</span> data = getMoreData();</div><div class="line">    output.write(data);</div><div class="line">&#125;</div><div class="line">output.close();</div></pre></td></tr></table></figure></p>
<p>请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p>
<p>PipedOutputStream的write()方法取一个包含了待写入字节的int类型变量作为参数进行写入。</p>
<h3 id="Java-IO管道-1"><a href="#Java-IO管道-1" class="headerlink" title="Java IO管道"></a>Java IO管道</h3><p>一个PipedOutputStream总是需要与一个PipedInputStream相关联。当这两种流联系起来时,它们就形成了一条管道。要想更多地了解Java IO中的管道,请参考Java IO管道。</p>
<h2 id="Java-IO-ByteArray和Filter"><a href="#Java-IO-ByteArray和Filter" class="headerlink" title="Java IO: ByteArray和Filter"></a>Java IO: ByteArray和Filter</h2><p>本小节会简要概括Java IO中字节数组与过滤器的输入输出流,主要涉及以下4个类型的流:ByteArrayInputStream,ByteArrayOutputStream,FilterInputStream,FilterOutputStream。请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p>
<h3 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h3><p>ByteArrayInputStream允许你从字节数组中读取字节流数据,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">byte</span>[] bytes = ... <span class="comment">//get byte array from somewhere.</span></div><div class="line">InputStream input = <span class="keyword">new</span> ByteArrayInputStream(bytes);</div><div class="line"><span class="keyword">int</span> data = input.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//do something with data</span></div><div class="line">    data = input.read();</div><div class="line">&#125;</div><div class="line">input.close();</div></pre></td></tr></table></figure></p>
<p>如果数据存储在数组中,ByteArrayInputStream可以很方便地读取数据。如果你有一个InputStream变量,又想从数组中读取数据呢？很简单,只需要把字节数组传递给ByteArrayInputStream的构造函数,在把这个ByteArrayInputStream赋值给InputStream变量就可以了(译者注:InputStream是所有字节输入流流的基类,Reader是所有字符输入流的基类,OutputStream与Writer同理)。</p>
<h3 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h3><p>ByteArrayOutputStream允许你以数组的形式获取写入到该输出流中的数据,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line"><span class="comment">//write data to output stream</span></div><div class="line"><span class="keyword">byte</span>[] bytes = output.toByteArray();</div></pre></td></tr></table></figure></p>
<h3 id="FilterInputStream"><a href="#FilterInputStream" class="headerlink" title="FilterInputStream"></a>FilterInputStream</h3><p>FilterInputStream是实现自定义过滤输入流的基类,基本上它仅仅只是覆盖了InputStream中的所有方法。</p>
<p>就我自己而言,我没发现这个类明显的用途。除了构造函数取一个InputStream变量作为参数之外,我没看到FilterInputStream任何对InputStream新增或者修改的地方。如果你选择继承FilterInputStream实现自定义的类,同样也可以直接继承自InputStream从而避免额外的类层级结构。</p>
<h3 id="FilterOutputStream"><a href="#FilterOutputStream" class="headerlink" title="FilterOutputStream"></a>FilterOutputStream</h3><p>内容同FilterInputStream,不再赘述。</p>
<h2 id="Java-IO-序列化与ObjectInputStream、ObjectOutputStream"><a href="#Java-IO-序列化与ObjectInputStream、ObjectOutputStream" class="headerlink" title="Java IO: 序列化与ObjectInputStream、ObjectOutputStream"></a>Java IO: 序列化与ObjectInputStream、ObjectOutputStream</h2><p>本小节会简要概括Java IO中的序列化以及涉及到的流,主要包括ObjectInputStream和ObjectOutputStream。</p>
<h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>如果你希望类能够序列化和反序列化,必须实现Serializable接口,就像所展示的ObjectInputStream和ObjectOutputStream例子一样。</p>
<p>对象序列化本身就是一个主题。Java IO系列教程主要关注流、reader和writer,所以我不会深入探讨对象序列化的细节。</p>
<h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p>ObjectInputStream能够让你从输入流中读取Java对象,而不需要每次读取一个字节。你可以把InputStream包装到ObjectInputStream中,然后就可以从中读取对象了。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"object.data"</span>));</div><div class="line">MyClass object = (MyClass) input.readObject(); <span class="comment">//etc.</span></div><div class="line">input.close();</div></pre></td></tr></table></figure></p>
<p>在这个例子中,你读取的对象必须是MyClass的一个实例,并且必须事先通过ObjectOutputStream序列化到“object.data”文件中。(译者注:ObjectInputStream和ObjectOutputStream还有许多read和write方法,比如readInt、writeLong等等,详细信息请查看官方文档)</p>
<p>在你序列化和反序列化一个对象之前,该对象的类必须实现了java.io.Serializable接口。</p>
<h3 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h3><p>ObjectOutputStream能够让你把对象写入到输出流中,而不需要每次写入一个字节。你可以把OutputStream包装到ObjectOutputStream中,然后就可以把对象写入到该输出流中了。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"object.data"</span>));</div><div class="line">MyClass object = <span class="keyword">new</span> MyClass();  output.writeObject(object); <span class="comment">//etc.</span></div><div class="line">output.close();</div></pre></td></tr></table></figure></p>
<p>例子中序列化的对象object现在可以从ObjectInputStream中读取了。</p>
<p>同样,在你序列化和反序列化一个对象之前,该对象的类必须实现了java.io.Serializable接口。</p>
<h2 id="Java-IO-Reader和Writer"><a href="#Java-IO-Reader和Writer" class="headerlink" title="Java IO: Reader和Writer"></a>Java IO: Reader和Writer</h2><h3 id="Reader-1"><a href="#Reader-1" class="headerlink" title="Reader"></a>Reader</h3><p>Reader是Java IO中所有Reader的基类。Reader与InputStream类似,不同点在于,Reader基于字符而非基于字节。换句话说,Reader用于读取文本,而InputStream用于读取原始字节。</p>
<p>请记住,Java内部使用UTF8编码表示字符串。输入流中一个字节可能并不等同于一个UTF8字符。如果你从输入流中以字节为单位读取UTF8编码的文本,并且尝试将读取到的字节转换成字符,你可能会得不到预期的结果。</p>
<p>read()方法返回一个包含了读取到的字符内容的int类型变量(译者注:0~65535)。如果方法返回-1,表明Reader中已经没有剩余可读取字符,此时可以关闭Reader。-1是一个int类型,不是byte或者char类型,这是不一样的。</p>
<p>你通常会使用Reader的子类,而不会直接使用Reader。Reader的子类包括InputStreamReader,CharArrayReader,FileReader等等。可以查看Java IO概述浏览完整的Reader表格。</p>
<p>Reader通常与文件、字符数组、网络等数据源相关联,Java IO概述中同样说明了这一点。</p>
<p>###Writer</p>
<p>Writer是Java IO中所有Writer的基类。与Reader和InputStream的关系类似,Writer基于字符而非基于字节,Writer用于写入文本,OutputStream用于写入字节。</p>
<p>同样,你最好使用Writer的子类,不需要直接使用Writer,因为子类的实现更加明确,更能表现你的意图。常用子类包括OutputStreamWriter,CharArrayWriter,FileWriter等。</p>
<p>Writer的write(int c)方法,会将传入参数的低16位写入到Writer中,忽略高16位的数据。</p>
<h2 id="Java-IO-InputStreamReader和OutputStreamWriter"><a href="#Java-IO-InputStreamReader和OutputStreamWriter" class="headerlink" title="Java IO: InputStreamReader和OutputStreamWriter"></a>Java IO: InputStreamReader和OutputStreamWriter</h2><p>本章节将简要介绍InputStreamReader和OutputStreamWriter。细心的读者可能会发现,在之前的文章中,IO中的类要么以Stream结尾,要么以Reader或者Writer结尾,那这两个同时以字节流和字符流的类名后缀结尾的类是什么用途呢？简单来说,这两个类把字节流转换成字符流,中间做了数据的转换,类似适配器模式的思想</p>
<h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>InputStreamReader会包含一个InputStream,从而可以将该输入字节流转换成字符流,代码例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input.txt"</span>);</div><div class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(inputStream);</div><div class="line"><span class="keyword">int</span> data = reader.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">char</span> theChar = (<span class="keyword">char</span>) data;</div><div class="line">    data = reader.read();</div><div class="line">&#125;</div><div class="line">reader.close();</div></pre></td></tr></table></figure></p>
<p>注意:为了清晰,代码忽略了一些必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p>
<p>read()方法返回一个包含了读取到的字符内容的int类型变量(译者注:0~65535)。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> data = reader.read();</div></pre></td></tr></table></figure></p>
<p>你可以把返回的int值转换成char变量,就像这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">char</span> aChar = (<span class="keyword">char</span>) data; <span class="comment">//译者注:这里不会造成数据丢失,因为返回的int类型变量data只有低16位有数据,高16位没有数据</span></div></pre></td></tr></table></figure></p>
<p>如果方法返回-1,表明Reader中已经没有剩余可读取字符,此时可以关闭Reader。-1是一个int类型,不是byte或者char类型,这是不一样的。</p>
<p>InputStreamReader同样拥有其他可选的构造函数,能够让你指定将底层字节流解释成何种编码的字符流。例子如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input.txt"</span>);</div><div class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"UTF-8"</span>);</div></pre></td></tr></table></figure></p>
<p>注意构造函数的第二个参数,此时该InputStreamReader会将输入的字节流转换成UTF8字符流。</p>
<h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><p>OutputStreamWriter会包含一个OutputStream,从而可以将该输出字节流转换成字符流,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output.txt"</span>);</div><div class="line">Writer writer = <span class="keyword">new</span> OutputStreamWriter(outputStream);</div><div class="line">writer.write(<span class="string">"Hello World"</span>);</div><div class="line">writer.close();</div></pre></td></tr></table></figure></p>
<p>OutputStreamWriter同样拥有将输出字节流转换成指定编码的字符流的构造函数。</p>
<h2 id="Java-IO-FileReader和FileWriter"><a href="#Java-IO-FileReader和FileWriter" class="headerlink" title="Java IO: FileReader和FileWriter"></a>Java IO: FileReader和FileWriter</h2><p>本章节将简要介绍FileReader和FileWriter。与FileInputStream和FileOutputStream类似,FileReader与FileWriter用于处理文件内容。</p>
<p>FileReader<br>原文链接</p>
<p>FileReader能够以字符流的形式读取文件内容。除了读取的单位不同之外(译者注:FileReader读取字符,FileInputStream读取字节),FileReader与FileInputStream并无太大差异,也就是说,FileReader用于读取文本。根据不同的编码方案,一个字符可能会相当于一个或者多个字节。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input-text.txt"</span>);</div><div class="line"><span class="keyword">int</span> data = reader.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//do something with data...</span></div><div class="line">    doSomethingWithData(data);</div><div class="line">    data = reader.read();</div><div class="line">&#125;</div><div class="line">reader.close();</div></pre></td></tr></table></figure></p>
<p>注意:为了清晰,代码忽略了一些必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p>
<p>read()方法返回一个包含了读取到的字符内容的int类型变量(译者注:0~65535)。如果方法返回-1,表明FileReader中已经没有剩余可读取字符,此时可以关闭FileReader。-1是一个int类型,不是byte或者char类型,这是不一样的。</p>
<p>FileReader拥有其他可选的构造函数,能够让你使用不同的方式读取文件,更多内容请查看官方文档。</p>
<p>FileReader会假设你想使用你所使用的JVM的版本的默认编码处理字节流,但是这通常不是你想要的,你可以手动设置编码方案。</p>
<p>如果你想明确指定一种编码方案,利用InputStreamReader配合FileInputStream来替代FileReader(译者注:FileReader没有可以指定编码的构造函数)。InputStreamReader可以让你设置编码处理从底层文件中读取的字节。</p>
<h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><p>FileWriter能够把数据以字符流的形式写入文件。同样是处理文件,FileWriter处理字符,FileOutputStream处理字节。根据不同的编码方案,一个字符可能会相当于一个或者多个字节。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output.txt"</span>);</div><div class="line"><span class="keyword">while</span>(moreData) &#123;</div><div class="line">    String data = getMoreData();</div><div class="line">    write.write(data);</div><div class="line">&#125;</div><div class="line">writer.close();</div></pre></td></tr></table></figure></p>
<p>处理文件都会碰到的一个问题是,当前写入的数据是覆盖原文件内容还是追加到文件末尾。当你创建一个FileWriter之后,你可以通过使用不同构造函数实现你的不同目的。</p>
<p>以下的构造函数取文件名作为参数,将会新写入的内容将会覆盖该文件:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output.txt"</span>);</div></pre></td></tr></table></figure></p>
<p>以下的构造函数取文件名和一个布尔变量作为参数,布尔值表明你是想追加还是覆盖该文件。例子如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output.txt"</span>, <span class="keyword">true</span>); <span class="comment">//appends to file</span></div><div class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output.txt"</span>, <span class="keyword">false</span>); <span class="comment">//overwrites file</span></div></pre></td></tr></table></figure></p>
<p>同样,FileWriter不能指定编码,可以通过OutputStreamWriter配合FileOutputStream替代FileWriter。</p>
<h2 id="Java-IO-字符流的Buffered和Filter"><a href="#Java-IO-字符流的Buffered和Filter" class="headerlink" title="Java IO: 字符流的Buffered和Filter"></a>Java IO: 字符流的Buffered和Filter</h2><p>本章节将简要介绍缓冲与过滤相关的reader和writer,主要涉及BufferedReader、BufferedWriter、FilterReader、FilterWriter。</p>
<h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>BufferedReader能为字符输入流提供缓冲区,可以提高许多IO处理的速度。你可以一次读取一大块的数据,而不需要每次从网络或者磁盘中一次读取一个字节。特别是在访问大量磁盘数据时,缓冲通常会让IO快上许多。</p>
<p>BufferedReader和BufferedInputStream的主要区别在于,BufferedReader操作字符,而BufferedInputStream操作原始字节。只需要把Reader包装到BufferedReader中,就可以为Reader添加缓冲区(译者注:默认缓冲区大小为8192字节,即8KB)。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Reader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input-file.txt"</span>));</div></pre></td></tr></table></figure>
<p>你也可以通过传递构造函数的第二个参数,指定缓冲区大小,代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Reader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input-file.txt"</span>), <span class="number">8</span> * <span class="number">1024</span>);</div></pre></td></tr></table></figure>
<p>这个例子设置了8KB的缓冲区。最好把缓冲区大小设置成1024字节的整数倍,这样能更高效地利用内置缓冲区的磁盘。</p>
<p>除了能够为输入流提供缓冲区以外,其余方面BufferedReader基本与Reader类似。BufferedReader还有一个额外readLine()方法,可以方便地一次性读取一整行字符。</p>
<h3 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h3><p>与BufferedReader类似,BufferedWriter可以为输出流提供缓冲区。可以构造一个使用默认大小缓冲区的BufferedWriter(译者注:默认缓冲区大小8 * 1024B),代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Writer writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output-file.txt"</span>));</div></pre></td></tr></table></figure>
<p>也可以手动设置缓冲区大小,代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Writer writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output-file.txt"</span>), <span class="number">8</span> * <span class="number">1024</span>);</div></pre></td></tr></table></figure>
<p>为了更好地使用内置缓冲区的磁盘,同样建议把缓冲区大小设置成1024的整数倍。除了能够为输出流提供缓冲区以外,其余方面BufferedWriter基本与Writer类似。类似地,BufferedWriter也提供了writeLine()方法,能够把一行字符写入到底层的字符输出流中。值得注意是,你需要手动flush()方法确保写入到此输出流的数据真正写入到磁盘或者网络中。</p>
<h3 id="FilterReader"><a href="#FilterReader" class="headerlink" title="FilterReader"></a>FilterReader</h3><p>与FilterInputStream类似,FilterReader是实现自定义过滤输入字符流的基类,基本上它仅仅只是简单覆盖了Reader中的所有方法。</p>
<p>就我自己而言,我没发现这个类明显的用途。除了构造函数取一个Reader变量作为参数之外,我没看到FilterReader任何对Reader新增或者修改的地方。如果你选择继承FilterReader实现自定义的类,同样也可以直接继承自Reader从而避免额外的类层级结构。</p>
<h3 id="FilterWriter"><a href="#FilterWriter" class="headerlink" title="FilterWriter"></a>FilterWriter</h3><p>内容同FilterReader,不再赘述。</p>
<h2 id="Java-IO-字符流的Piped和CharArray"><a href="#Java-IO-字符流的Piped和CharArray" class="headerlink" title="Java IO: 字符流的Piped和CharArray"></a>Java IO: 字符流的Piped和CharArray</h2><p>本章节将简要介绍管道与字符数组相关的reader和writer,主要涉及PipedReader、PipedWriter、CharArrayReader、CharArrayWriter。</p>
<h3 id="PipedReader"><a href="#PipedReader" class="headerlink" title="PipedReader"></a>PipedReader</h3><p>PipedReader能够从管道中读取字符流。与PipedInputStream类似,不同的是PipedReader读取的是字符而非字节。换句话说,PipedReader用于读取管道中的文本。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Reader reader = <span class="keyword">new</span> PipedReader(pipedWriter);</div><div class="line"><span class="keyword">int</span> data = reader.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//do something with data...</span></div><div class="line">    doSomethingWithData(data);</div><div class="line">    data = reader.read();</div><div class="line">&#125;</div><div class="line">reader.close();</div></pre></td></tr></table></figure></p>
<p>注意:为了清晰,代码忽略了一些必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p>
<p>read()方法返回一个包含了读取到的字符内容的int类型变量(译者注:0~65535)。如果方法返回-1,表明PipedReader中已经没有剩余可读取字符,此时可以关闭PipedReader。-1是一个int类型,不是byte或者char类型,这是不一样的。</p>
<p>正如你所看到的例子那样,一个PipedReader需要与一个PipedWriter相关联,当这两种流联系起来时,就形成了一条管道。要想更多地了解Java IO中的管道,请参考Java IO管道。</p>
<h3 id="PipedWriter"><a href="#PipedWriter" class="headerlink" title="PipedWriter"></a>PipedWriter</h3><p>PipedWriter能够往管道中写入字符流。与PipedOutputStream类似,不同的是PipedWriter处理的是字符而非字节,PipedWriter用于写入文本数据。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PipedWriter writer = <span class="keyword">new</span> PipedWriter(pipedReader);</div><div class="line"><span class="keyword">while</span>(moreData()) &#123;</div><div class="line">    <span class="keyword">int</span> data = getMoreData();</div><div class="line">    writer.write(data);</div><div class="line">&#125;</div><div class="line">writer.close();</div></pre></td></tr></table></figure></p>
<p>PipedWriter的write()方法取一个包含了待写入字节的int类型变量作为参数进行写入,同时也有采用字符串、字符数组作为参数的write()方法。</p>
<h3 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h3><p>CharArrayReader能够让你从字符数组中读取字符流。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">char</span>[] chars = ... <span class="comment">//get char array from somewhere.</span></div><div class="line">Reader reader = <span class="keyword">new</span> CharArrayReader(chars);</div><div class="line"><span class="keyword">int</span> data = reader.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//do something with data</span></div><div class="line">    data = reader.read();</div><div class="line">&#125;</div><div class="line">reader.close();</div></pre></td></tr></table></figure></p>
<p>如果数据的存储媒介是字符数组,CharArrayReader可以很方便的读取到你想要的数据。CharArrayReader会包含一个字符数组,然后将字符数组转换成字符流。(译者注:CharArrayReader有2个构造函数,一个是CharArrayReader(char[] buf),将整个字符数组创建成一个字符流。另外一个是CharArrayReader(char[] buf, int offset, int length),把buf从offset开始,length个字符创建成一个字符流。更多细节请参考Java官方文档)</p>
<h3 id="CharArrayWriter"><a href="#CharArrayWriter" class="headerlink" title="CharArrayWriter"></a>CharArrayWriter</h3><p>CharArrayWriter能够把字符写入到字符输出流writer中,并且能够将写入的字符转换成字符数组。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter();</div><div class="line"><span class="comment">//write characters to writer.</span></div><div class="line"><span class="keyword">char</span>[] chars = writer.toCharArray();</div></pre></td></tr></table></figure>
<p>当你需要以字符数组的形式访问写入到writer中的字符流数据时,CharArrayWriter是个不错的选择。</p>
<h2 id="Java-IO-其他字节流"><a href="#Java-IO-其他字节流" class="headerlink" title="Java IO: 其他字节流"></a>Java IO: 其他字节流</h2><p>本小节会简要概括Java IO中的PushbackInputStream,SequenceInputStream,PrintStream, PushbackReader,LineNumberReader,StreamTokenizer,PrintWriter,StringReader,StringWriter。其中,最常用的是PrintStream,System.out和System.err都是PrintStream类型的变量,请查看Java IO: System.in, System.out, System.err浏览更多关于System.out和System.err的信息。</p>
<h3 id="PushbackInputStream"><a href="#PushbackInputStream" class="headerlink" title="PushbackInputStream"></a>PushbackInputStream</h3><p>PushbackInputStream用于解析InputStream内的数据。有时候你需要提前知道接下来将要读取到的字节内容,才能判断用何种方式进行数据解析。PushBackInputStream允许你这么做,你可以把读取到的字节重新推回到InputStream中,以便再次通过read()读取。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PushbackInputStream input = <span class="keyword">new</span> PushbackInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input.txt"</span>));</div><div class="line"><span class="keyword">int</span> data = input.read();</div><div class="line">input.unread(data);</div></pre></td></tr></table></figure></p>
<p>可以通过PushBackInputStream的构造函数设置推回缓冲区的大小,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PushbackInputStream input = <span class="keyword">new</span> PushbackInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input.txt"</span>), <span class="number">8</span>);</div></pre></td></tr></table></figure></p>
<p>这个例子设置了8个字节的缓冲区,意味着你最多可以重新读取8个字节的数据。</p>
<h3 id="PushbackReader"><a href="#PushbackReader" class="headerlink" title="PushbackReader"></a>PushbackReader</h3><p>PushbackReader与PushbackInputStream类似,唯一不同的是PushbackReader处理字符,PushbackInputStream处理字节。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PushbackReader reader = <span class="keyword">new</span> PushbackReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input.txt"</span>));</div><div class="line"><span class="keyword">int</span> data = reader.read();</div><div class="line">reader.unread(data);</div></pre></td></tr></table></figure></p>
<p>同样可以设置缓冲区大小,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PushbackReader reader = <span class="keyword">new</span> PushbackReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input.txt"</span>), <span class="number">8</span>);</div></pre></td></tr></table></figure></p>
<h3 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a>SequenceInputStream</h3><p>SequenceInputStream把一个或者多个InputStream整合起来,形成一个逻辑连贯的输入流。当读取SequenceInputStream时,会先从第一个输入流中读取,完成之后再从第二个输入流读取,以此推类。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream input1 = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\file1.txt"</span>);</div><div class="line">InputStream input2 = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\file2.txt"</span>);</div><div class="line">InputStream combined = <span class="keyword">new</span> SequenceInputStream(input1, input2);</div></pre></td></tr></table></figure>
<p>通过SequenceInputStream,例子中的2个InputStream使用起来就如同只有一个InputStream一样(译者注:SequenceInputStream的read()方法会在读取到当前流末尾时,关闭流,并把当前流指向逻辑链中的下一个流,最后返回新的当前流的read()值)。</p>
<h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><p>PrintStream允许你把格式化数据写入到底层OutputStream中。比如,写入格式化成文本的int,long以及其他原始数据类型到输出流中,而非它们的字节数据。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">PrintStream output = <span class="keyword">new</span> PrintStream(outputStream);</div><div class="line">output.print(<span class="keyword">true</span>);</div><div class="line">output.print((<span class="keyword">int</span>) <span class="number">123</span>);</div><div class="line">output.print((<span class="keyword">float</span>) <span class="number">123.456</span>);</div><div class="line">output.printf(Locale.UK, <span class="string">"Text + data: %1$"</span>, <span class="number">123</span>);</div><div class="line">output.close();</div></pre></td></tr></table></figure></p>
<p>PrintStream包含2个强大的函数,分别是format()和printf()(这两个函数几乎做了一样的事情,但是C程序员会更熟悉printf())。</p>
<p>译者注:其中一个printf()函数实现如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String format, Object ... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> format(format, args);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h3><p>与PrintStream类似,PrintWriter可以把格式化后的数据写入到底层writer中。由于内容相似,不再赘述。</p>
<p>值得一提的是,PrintWriter有更多种构造函数供使用者选择,除了可以输出到文件、Writer以外,还可以输出到OutputStream中(译者注:PrintStream只能把数据输出到文件和OutputStream)。</p>
<h3 id="LineNumberReader"><a href="#LineNumberReader" class="headerlink" title="LineNumberReader"></a>LineNumberReader</h3><p>LineNumberReader是记录了已读取数据行号的BufferedReader。默认情况下,行号从0开始,当LineNumberReader读取到行终止符时,行号会递增(译者注:换行\n,回车\r,或者换行回车\n\r都是行终止符)。</p>
<p>你可以通过getLineNumber()方法获取当前行号,通过setLineNumber()方法设置当前行数(译者注:setLineNumber()仅仅改变LineNumberReader内的记录行号的变量值,不会改变当前流的读取位置。流的读取依然是顺序进行,意味着你不能通过setLineNumber()实现流的跳跃读取)。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">LineNumberReader reader = <span class="keyword">new</span> LineNumberReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input.txt"</span>));</div><div class="line"><span class="keyword">int</span> data = reader.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</div><div class="line">    <span class="keyword">char</span> dataChar = (<span class="keyword">char</span>) data;</div><div class="line">    data = reader.read();</div><div class="line">    <span class="keyword">int</span> lineNumber = reader.getLineNumber();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果解析的文本有错误,LineNumberReader可以很方便地定位问题。当你把错误报告给用户时,如果能够同时把出错的行号提供给用户,用户就能迅速发现并且解决问题。</p>
<h3 id="StreamTokenizer"><a href="#StreamTokenizer" class="headerlink" title="StreamTokenizer"></a>StreamTokenizer</h3><p>StreamTokenizer(译者注:请注意不是StringTokenizer)可以把输入流(译者注:InputStream和Reader。通过InputStream构造StreamTokenizer的构造函数已经在JDK1.1版本过时,推荐将InputStream转化成Reader,再利用此Reader构造StringTokenizer)分解成一系列符号。比如,句子”Mary had a little lamb”的每个单词都是一个单独的符号。</p>
<p>当你解析文件或者计算机语言时,为了进一步的处理,需要将解析的数据分解成符号。通常这个过程也称作分词。</p>
<p>通过循环调用nextToken()可以遍历底层输入流的所有符号。在每次调用nextToken()之后,StreamTokenizer有一些变量可以帮助我们获取读取到的符号的类型和值。这些变量是:</p>
<p>ttype 读取到的符号的类型(字符,数字,或者行结尾符)</p>
<p>sval 如果读取到的符号是字符串类型,该变量的值就是读取到的字符串的值</p>
<p>nval 如果读取到的符号是数字类型,该变量的值就是读取到的数字的值</p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">StreamTokenizer tokenizer = <span class="keyword">new</span> StreamTokenizer(<span class="keyword">new</span> StringReader(<span class="string">"Mary had 1 little lamb..."</span>));</div><div class="line"><span class="keyword">while</span>(tokenizer.nextToken() != StreamTokenizer.TT_EOF)&#123;</div><div class="line">    <span class="keyword">if</span>(tokenizer.ttype == StreamTokenizer.TT_WORD) &#123;</div><div class="line">        System.out.println(tokenizer.sval);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tokenizer.ttype == StreamTokenizer.TT_NUMBER) &#123;</div><div class="line">        System.out.println(tokenizer.nval);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tokenizer.ttype == StreamTokenizer.TT_EOL) &#123;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>译者注:TT_EOF表示流末尾,TT_EOL表示行末尾。</p>
<p>StreamTokenizer可以识别标示符,数字,引用的字符串,和多种注释类型。你也可以指定何种字符解释成空格、注释的开始以及结束等。在StreamTokenizer开始解析之前,所有的功能都可以进行配置。请查阅官方文档获取更多信息。</p>
<h3 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h3><p>StringReader能够将原始字符串转换成Reader,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Reader reader = <span class="keyword">new</span> StringReader(<span class="string">"input string..."</span>);</div><div class="line"><span class="keyword">int</span> data = reader.read();</div><div class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</div><div class="line">    <span class="comment">//do something with data...</span></div><div class="line">    doSomethingWithData(data);</div><div class="line">    data = reader.read();</div><div class="line">&#125;</div><div class="line">reader.close();</div></pre></td></tr></table></figure></p>
<h3 id="StringWriter"><a href="#StringWriter" class="headerlink" title="StringWriter"></a>StringWriter</h3><p>StringWriter能够以字符串的形式从Writer中获取写入到其中数据,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">StringWriter writer = <span class="keyword">new</span> StringWriter();</div><div class="line"><span class="comment">//write characters to writer.</span></div><div class="line">String data = writer.toString();</div><div class="line">StringBuffer dataBuffer = writer.getBuffer();</div></pre></td></tr></table></figure></p>
<p>toString()方法能够获取StringWriter中的字符串数据。</p>
<p>getBuffer()方法能够获取StringWriter内部构造字符串时所使用的StringBuffer对象。</p>
<p>ref:<br><a href="http://tutorials.jenkov.com/java-io/index.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-io/index.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-NIO</title>
    <url>/2017/10/09/Java-NIO/</url>
    <content><![CDATA[<p>Java NIO(New IO)是一个可以替代标准Java IO API的IO API(从Java 1.4开始),Java NIO提供了与标准IO不同的IO工作方式。</p>
<p><strong>Java NIO: Channels and Buffers(通道和缓冲区)</strong></p>
<p>标准的IO基于字节流和字符流进行操作的,而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作,数据总是从通道读取到缓冲区中,或者从缓冲区写入到通道中。</p>
<p><strong>Java NIO: Non-blocking IO(非阻塞IO)</strong></p>
<p>Java NIO可以让你非阻塞的使用IO,例如:当线程从通道读取数据到缓冲区时,线程还是可以进行其他事情。当数据被写入到缓冲区时,线程可以继续处理它。从缓冲区写入通道也类似。</p>
<p><strong>Java NIO: Selectors(选择器)</strong></p>
<p>Java NIO引入了选择器的概念,选择器用于监听多个通道的事件(比如:连接打开,数据到达)。因此,单个的线程可以监听多个数据通道。</p>
<a id="more"></a>
<h2 id="Java-NIO-概述"><a href="#Java-NIO-概述" class="headerlink" title="Java NIO 概述"></a>Java NIO 概述</h2><p>Java NIO 由以下几个核心部分组成:</p>
<ul>
<li>Channels</li>
<li>Buffers</li>
<li>Selectors</li>
</ul>
<p>虽然Java NIO 中除此之外还有很多类和组件,但在我看来,Channel,Buffer 和 Selector 构成了核心的API。其它组件,如Pipe和FileLock,只不过是与三个核心组件共同使用的工具类。因此,在概述中我将集中在这三个组件上。其它组件会在单独的章节中讲到。</p>
<h3 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h3><p>基本上,所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中,也可以从Buffer 写到Channel中。这里有个图示:<br><img src="/2017/10/09/Java-NIO/overview-channels-buffers1.png" alt="overview-channels-buffers1.png" title=""></p>
<p>Channel和Buffer有好几种类型。下面是JAVA NIO中的一些主要Channel的实现:</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
</ul>
<p>正如你所看到的,这些通道涵盖了UDP 和 TCP 网络IO,以及文件IO。</p>
<p>与这些类一起的有一些有趣的接口,但为简单起见,我尽量在概述中不提到它们。本教程其它章节与它们相关的地方我会进行解释。</p>
<p>以下是Java NIO里关键的Buffer实现:</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>这些Buffer覆盖了你能通过IO发送的基本数据类型:byte, short, int, long, float, double 和 char。</p>
<p>Java NIO 还有个 MappedByteBuffer,用于表示内存映射文件, 我也不打算在概述中说明。</p>
<h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接(通道),但每个连接的流量都很低,使用Selector就会很方便。例如,在一个聊天服务器中。</p>
<p>这是在一个单线程中使用一个Selector处理3个Channel的图示:<br><img src="/2017/10/09/Java-NIO/overview-selectors.png" alt="overview-selectors.png" title=""><br>要使用Selector,得向Selector注册Channel,然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回,线程就可以处理这些事件,事件的例子有如新连接进来,数据接收等。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Java NIO的通道类似流,但又有些不同:</p>
<ul>
<li>既可以从通道中读取数据,又可以写数据到通道。但流的读写通常是单向的。</li>
<li>通道可以异步地读写。</li>
<li>通道中的数据总是要先读到一个Buffer,或者总是要从一个Buffer中写入。</li>
</ul>
<p>正如上面所说,从通道读取数据到缓冲区,从缓冲区写入数据到通道。如下图所示:<br><img src="/2017/10/09/Java-NIO/overview-channels-buffers.png" alt="overview-channels-buffers.png" title=""></p>
<h3 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a>Channel的实现</h3><p>这些是Java NIO中最重要的通道的实现:</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel</li>
<li>FileChannel 从文件中读写数据。</li>
</ul>
<p>DatagramChannel 能通过UDP读写网络中的数据。</p>
<p>SocketChannel 能通过TCP读写网络中的数据。</p>
<p>ServerSocketChannel可以监听新进来的TCP连接,像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</p>
<h3 id="基本的-Channel-示例"><a href="#基本的-Channel-示例" class="headerlink" title="基本的 Channel 示例"></a>基本的 Channel 示例</h3><p>下面是一个使用FileChannel读取数据到Buffer中的示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">FileChannel inChannel = aFile.getChannel();</div><div class="line"></div><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line"></div><div class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</div><div class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</div><div class="line">    System.out.println(<span class="string">"Read "</span> + bytesRead);</div><div class="line">    buf.flip();</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(buf.hasRemaining())&#123;</div><div class="line">        System.out.print((<span class="keyword">char</span>) buf.get());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    buf.clear();</div><div class="line">    bytesRead = inChannel.read(buf);</div><div class="line">&#125;</div><div class="line">aFile.close();</div></pre></td></tr></table></figure></p>
<p>注意 buf.flip() 的调用,首先读取数据到Buffer,然后反转Buffer,接着再从Buffer中读取数据。下一节会深入讲解Buffer的更多细节。</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Java NIO中的Buffer用于和NIO通道进行交互。如你所知,数据是从通道读入缓冲区,从缓冲区写入到通道中的。</p>
<p>缓冲区本质上是一块可以写入数据,然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象,并提供了一组方法,用来方便的访问该块内存。</p>
<h3 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a>Buffer的基本用法</h3><p>使用Buffer读写数据一般遵循以下四个步骤:</p>
<ol>
<li>写入数据到Buffer</li>
<li>调用flip()方法</li>
<li>从Buffer中读取数据</li>
<li>调用clear()方法或者compact()方法</li>
</ol>
<p>当向buffer写入数据时,buffer会记录下写了多少数据。一旦要读取数据,需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下,可以读取之前写入到buffer的所有数据。</p>
<p>一旦读完了所有的数据,就需要清空缓冲区,让它可以再次被写入。有两种方式能清空缓冲区:调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处,新写入的数据将放到缓冲区未读数据的后面。</p>
<p>下面是一个使用Buffer的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">FileChannel inChannel = aFile.getChannel();</div><div class="line"></div><div class="line"><span class="comment">//create buffer with capacity of 48 bytes</span></div><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line"></div><div class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></div><div class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</div><div class="line"></div><div class="line">  buf.flip();  <span class="comment">//make buffer ready for read</span></div><div class="line"></div><div class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</div><div class="line">      System.out.print((<span class="keyword">char</span>) buf.get()); <span class="comment">// read 1 byte at a time</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  buf.clear(); <span class="comment">//make buffer ready for writing</span></div><div class="line">  bytesRead = inChannel.read(buf);</div><div class="line">&#125;</div><div class="line">aFile.close();</div></pre></td></tr></table></figure></p>
<h3 id="Buffer的capacity-position和limit"><a href="#Buffer的capacity-position和limit" class="headerlink" title="Buffer的capacity,position和limit"></a>Buffer的capacity,position和limit</h3><p>缓冲区本质上是一块可以写入数据,然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象,并提供了一组方法,用来方便的访问该块内存。</p>
<p>为了理解Buffer的工作原理,需要熟悉它的三个属性:</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式,capacity的含义总是一样的。</p>
<p>这里有一个关于capacity,position和limit在读写模式中的说明,详细的解释在插图后面。<br><img src="/2017/10/09/Java-NIO/buffers-modes.png" alt="buffers-modes.png" title=""></p>
<h4 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h4><p>作为一个内存块,Buffer有一个固定的大小值,也叫“capacity”.你只能往里写capacity个byte、long,char等类型。一旦Buffer满了,需要将其清空(通过读数据或者清除数据)才能继续写数据往里写数据。</p>
<h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p>当你写数据到Buffer中时,position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后, position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p>
<p>当读取数据时,也是从某个特定位置读。当将Buffer从写模式切换到读模式,position会被重置为0. 当从Buffer的position处读取数据时,position向前移动到下一个可读的位置。</p>
<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>在写模式下,Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下,limit等于Buffer的capacity。</p>
<p>当切换Buffer到读模式时, limit表示你最多能读到多少数据。因此,当切换Buffer到读模式时,limit会被设置成写模式下的position值。换句话说,你能读到之前写入的所有数据(limit被设置成已写数据的数量,这个值在写模式下就是position)</p>
<h3 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h3><p>Java NIO 有以下Buffer类型</p>
<ul>
<li>ByteBuffer</li>
<li>MappedByteBuffer</li>
<li>CharBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>ShortBuffer</li>
</ul>
<p>如你所见,这些Buffer类型代表了不同的数据类型。换句话说,就是可以通过char,short,int,long,float 或 double类型来操作缓冲区中的字节。</p>
<p>MappedByteBuffer 有些特别,在涉及它的专门章节中再讲。</p>
<h3 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h3><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div></pre></td></tr></table></figure>
<p>这是分配一个可存储1024个字符的CharBuffer:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CharBuffer buf = CharBuffer.allocate(<span class="number">1024</span>);</div></pre></td></tr></table></figure></p>
<h3 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h3><p>写数据到Buffer有两种方式:</p>
<ul>
<li>从Channel写到Buffer。</li>
<li>通过Buffer的put()方法写到Buffer里。</li>
</ul>
<p>从Channel写到Buffer的例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></div></pre></td></tr></table></figure>
<p>通过put方法写Buffer的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">buf.put(<span class="number">127</span>);</div></pre></td></tr></table></figure></p>
<p>put方法有很多版本,允许你以不同的方式把数据写入到Buffer中。例如, 写到一个指定的位置,或者把一个字节数组写入到Buffer。 更多Buffer实现的细节参考JavaDoc。</p>
<h3 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h3><p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0,并将limit设置成之前position的值。</p>
<p>换句话说,position现在用于标记读的位置,limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等。</p>
<h3 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h3><p>从Buffer中读取数据有两种方式:</p>
<ul>
<li>从Buffer读取数据到Channel。</li>
<li>使用get()方法从Buffer中读取数据。</li>
</ul>
<p>从Buffer读取数据到Channel的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//read from buffer into channel.</span></div><div class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</div></pre></td></tr></table></figure></p>
<p>使用get()方法从Buffer中读取数据的例子<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">byte</span> aByte = buf.get();</div></pre></td></tr></table></figure></p>
<p>get方法有很多版本,允许你以不同的方式从Buffer中读取数据。例如,从指定position读取,或者从Buffer中读取数据到字节数组。更多Buffer实现的细节参考JavaDoc。</p>
<h3 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h3><p>Buffer.rewind()将position设回0,所以你可以重读Buffer中的所有数据。limit保持不变,仍然表示能从Buffer中读取多少个元素(byte、char等)。</p>
<h3 id="clear-与compact-方法"><a href="#clear-与compact-方法" class="headerlink" title="clear()与compact()方法"></a>clear()与compact()方法</h3><p>一旦读完Buffer中的数据,需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。</p>
<p>如果调用的是clear()方法,position将被设回0,limit被设置成 capacity的值。换句话说,Buffer 被清空了。Buffer中的数据并未清除,只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p>
<p>如果Buffer中有一些未读的数据,调用clear()方法,数据将“被遗忘”,意味着不再有任何标记会告诉你哪些数据被读过,哪些还没有。</p>
<p>如果Buffer中仍有未读的数据,且后续还需要这些数据,但是此时想要先先写些数据,那么使用compact()方法。</p>
<p>compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样,设置成capacity。现在Buffer准备好写数据了,但是不会覆盖未读的数据。</p>
<h3 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h3><p>通过调用Buffer.mark()方法,可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">buffer.mark();</div><div class="line"><span class="comment">//call buffer.get() a couple of times, e.g. during parsing.</span></div><div class="line">buffer.reset();  <span class="comment">//set position back to mark.</span></div></pre></td></tr></table></figure></p>
<h3 id="equals-与compareTo-方法"><a href="#equals-与compareTo-方法" class="headerlink" title="equals()与compareTo()方法"></a>equals()与compareTo()方法</h3><p>可以使用equals()和compareTo()方法比较两个Buffer。</p>
<h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>当满足下列条件时,表示两个Buffer相等:</p>
<ol>
<li>有相同的类型(byte、char、int等)。</li>
<li>Buffer中剩余的byte、char等的个数相等。</li>
<li>Buffer中所有剩余的byte、char等都相同。</li>
</ol>
<p>如你所见,equals只是比较Buffer的一部分,不是每一个在它里面的元素都比较。实际上,它只比较Buffer中的剩余元素。</p>
<h4 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h4><p>compareTo()方法比较两个Buffer的剩余元素(byte、char等), 如果满足下列条件,则认为一个Buffer“小于”另一个Buffer:</p>
<ol>
<li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li>
<li>所有元素都相等,但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li>
</ol>
<p>(译注:剩余元素是从 position到limit之间的元素)</p>
<h2 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h2><p>Java NIO开始支持scatter/gather,scatter/gather用于描述从Channel(译者注:Channel在中文经常翻译为通道)中读取或者写入到Channel的操作。<br>分散(scatter)从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此,Channel将从Channel中读取的数据“分散(scatter)”到多个Buffer中。<br>聚集(gather)写入Channel是指在写操作时将多个buffer的数据写入同一个Channel,因此,Channel 将多个Buffer中的数据“聚集(gather)”后发送到Channel。</p>
<p>scatter / gather经常用于需要将传输的数据分开处理的场合,例如传输一个由消息头和消息体组成的消息,你可能会将消息体和消息头分散到不同的buffer中,这样你可以方便的处理消息头和消息体。</p>
<h3 id="Scattering-Reads"><a href="#Scattering-Reads" class="headerlink" title="Scattering Reads"></a>Scattering Reads</h3><p>Scattering Reads是指数据从一个channel读取到多个buffer中。如下图描述:<br><img src="/2017/10/09/Java-NIO/scatter.png" alt="scatter.png" title=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</div><div class="line"></div><div class="line">channel.read(bufferArray);</div></pre></td></tr></table></figure>
<p>注意buffer首先被插入到数组,然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer,当一个buffer被写满后,channel紧接着向另一个buffer中写。</p>
<p>Scattering Reads在移动下一个buffer前,必须填满当前的buffer,这也意味着它不适用于动态消息(译者注:消息大小不固定)。换句话说,如果存在消息头和消息体,消息头必须完成填充(例如 128byte),Scattering Reads才能正常工作。</p>
<h3 id="Gathering-Writes"><a href="#Gathering-Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h3><p>Gathering Writes是指数据从多个buffer写入到同一个channel。如下图描述:<br><img src="/2017/10/09/Java-NIO/gather.png" alt="gather.png" title=""><br>代码示例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</div><div class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line"><span class="comment">//write data into buffers</span></div><div class="line"></div><div class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</div><div class="line"></div><div class="line">channel.write(bufferArray);</div></pre></td></tr></table></figure></p>
<p>buffers数组是write()方法的入参,write()方法会按照buffer在数组中的顺序,将数据写入到channel,注意只有position和limit之间的数据才会被写入。因此,如果一个buffer的容量为128byte,但是仅仅包含58byte的数据,那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反,Gathering Writes能较好的处理动态消息。</p>
<h2 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h2><p>在Java NIO中,如果两个通道中有一个是FileChannel,那你可以直接将数据从一个channel(译者注:channel中文常译作通道)传输到另外一个channel。</p>
<h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h3><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中(译者注:这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中)。下面是一个简单的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">FileChannel      fromChannel = fromFile.getChannel();</div><div class="line"></div><div class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">FileChannel      toChannel = toFile.getChannel();</div><div class="line"></div><div class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</div><div class="line"><span class="keyword">long</span> count = fromChannel.size();</div><div class="line"></div><div class="line">toChannel.transferFrom(position, count, fromChannel);</div></pre></td></tr></table></figure></p>
<p>方法的输入参数position表示从position处开始向目标文件写入数据,count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节,则所传输的字节数要小于请求的字节数。<br>此外要注意,在SoketChannel的实现中,SocketChannel只会传输此刻准备好的数据(可能不足count字节)。因此,SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p>
<h3 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h3><p>transferTo()方法将数据从FileChannel传输到其他的channel中。下面是一个简单的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">FileChannel      fromChannel = fromFile.getChannel();</div><div class="line"></div><div class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">FileChannel      toChannel = toFile.getChannel();</div><div class="line"></div><div class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</div><div class="line"><span class="keyword">long</span> count = fromChannel.size();</div><div class="line"></div><div class="line">fromChannel.transferTo(position, count, toChannel);</div></pre></td></tr></table></figure></p>
<p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外,其他的都一样。<br>上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。</p>
<h2 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h2><p>Selector(选择器)是Java NIO中能够检测一到多个NIO通道,并能够知晓通道是否为诸如读写事件做好准备的组件。这样,一个单独的线程可以管理多个channel,从而管理多个网络连接。</p>
<h3 id="为什么使用Selector"><a href="#为什么使用Selector" class="headerlink" title="为什么使用Selector?"></a>为什么使用Selector?</h3><p>仅用单个线程来处理多个Channels的好处是,只需要更少的线程来处理通道。事实上,可以只用一个线程处理所有的通道。对于操作系统来说,线程之间上下文切换的开销很大,而且每个线程都要占用系统的一些资源(如内存)。因此,使用的线程越少越好。</p>
<p>但是,需要记住,现代的操作系统和CPU在多任务方面表现的越来越好,所以多线程的开销随着时间的推移,变得越来越小了。实际上,如果一个CPU有多个内核,不使用多任务可能是在浪费CPU能力。不管怎么说,关于那种设计的讨论应该放在另一篇不同的文章中。在这里,只要知道使用Selector能够处理多个通道就足够了。</p>
<p>下面是单线程使用一个Selector处理3个channel的示例图:<br><img src="/2017/10/09/Java-NIO/overview-selectors.png" alt="overview-selectors.png" title=""></p>
<h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>通过调用Selector.open()方法创建一个Selector,如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Selector selector = Selector.open();</div></pre></td></tr></table></figure></p>
<h3 id="向Selector注册通道"><a href="#向Selector注册通道" class="headerlink" title="向Selector注册通道"></a>向Selector注册通道</h3><p>为了将Channel和Selector配合使用,必须将channel注册到selector上。通过SelectableChannel.register()方法来实现,如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">SelectionKey key = channel.register(selector,</div><div class="line">	Selectionkey.OP_READ);</div></pre></td></tr></table></figure></p>
<p>与Selector一起使用时,Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用,因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p>
<p>注意register()方法的第二个参数。这是一个“interest集合”,意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件:</p>
<ol>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ol>
<p>通道触发了一个事件意思是该事件已经就绪。所以,某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p>
<p>这四种事件用SelectionKey的四个常量来表示:</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>如果你对不止一种事件感兴趣,那么可以用“位或”操作符将常量连接起来,如下:</p>
<p>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;<br>在下面还会继续提到interest集合。</p>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>在上一小节中,当向Selector注册Channel时,register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性:</p>
<ul>
<li>interest集合</li>
<li>ready集合</li>
<li>Channel</li>
<li>Selector</li>
<li>附加的对象(可选)</li>
</ul>
<p>下面我会描述这些属性。</p>
<h4 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h4><p>就像向Selector注册通道一节中所描述的,interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合,像这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</div><div class="line"></div><div class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</div><div class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</div><div class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</div><div class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</div></pre></td></tr></table></figure></p>
<p>可以看到,用“位与”操作interest 集合和给定的SelectionKey常量,可以确定某个确定的事件是否在interest 集合中。</p>
<h4 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h4><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后,你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</div></pre></td></tr></table></figure></p>
<p>可以用像检测interest集合那样的方法,来检测channel中什么事件或操作已经就绪。但是,也可以使用以下四个方法,它们都会返回一个布尔类型:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">selectionKey.isAcceptable();</div><div class="line">selectionKey.isConnectable();</div><div class="line">selectionKey.isReadable();</div><div class="line">selectionKey.isWritable();</div></pre></td></tr></table></figure></p>
<h4 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h4><p>从SelectionKey访问Channel和Selector很简单。如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Channel  channel  = selectionKey.channel();</div><div class="line">Selector selector = selectionKey.selector();</div></pre></td></tr></table></figure></p>
<h4 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h4><p>可以将一个对象或者更多信息附着到SelectionKey上,这样就能方便的识别某个给定的通道。例如,可以附加 与通道一起使用的Buffer,或是包含聚集数据的某个对象。使用方法如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">selectionKey.attach(theObject);</div><div class="line">Object attachedObj = selectionKey.attachment();</div></pre></td></tr></table></figure></p>
<p>还可以在用register()方法向Selector注册Channel的时候附加对象。如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</div></pre></td></tr></table></figure></p>
<h3 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h3><p>一旦向Selector注册了一或多个通道,就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件(如连接、接受、读或写)已经准备就绪的那些通道。换句话说,如果你对“读就绪”的通道感兴趣,select()方法会返回读事件已经就绪的那些通道。</p>
<p>下面是select()方法:</p>
<ul>
<li>int select()</li>
<li>int select(long timeout)</li>
<li>int selectNow()</li>
</ul>
<p>select()阻塞到至少有一个通道在你注册的事件上就绪了。</p>
<p>select(long timeout)和select()一样,除了最长会阻塞timeout毫秒(参数)。</p>
<p>selectNow()不会阻塞,不管什么通道就绪都立刻返回(译者注:此方法执行非阻塞的选择操作。如果自从前一次选择操作后,没有通道变成可选择的,则此方法直接返回零。)。</p>
<p>select()方法返回的int值表示有多少通道已经就绪。亦即,自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法,因为有一个通道变成就绪状态,返回了1,若再次调用select()方法,如果另一个通道就绪了,它会再次返回1。如果对第一个就绪的channel没有做任何操作,现在就有两个就绪的通道,但在每次select()方法调用之间,只有一个通道就绪了。</p>
<h4 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h4><p>一旦调用了select()方法,并且返回值表明有一个或更多个通道就绪了,然后可以通过调用selector的selectedKeys()方法,访问“已选择键集(selected key set)”中的就绪通道。如下所示:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Set selectedKeys = selector.selectedKeys();</div></pre></td></tr></table></figure></p>
<p>当像Selector注册Channel时,Channel.register()方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p>
<p>可以遍历这个已选择的键集合来访问就绪的通道。如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Set selectedKeys = selector.selectedKeys();</div><div class="line">Iterator keyIterator = selectedKeys.iterator();</div><div class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</div><div class="line">    SelectionKey key = keyIterator.next();</div><div class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</div><div class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</div><div class="line">        <span class="comment">// a connection was established with a remote server.</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line">        <span class="comment">// a channel is ready for reading</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</div><div class="line">        <span class="comment">// a channel is ready for writing</span></div><div class="line">    &#125;</div><div class="line">    keyIterator.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个循环遍历已选择键集中的每个键,并检测各个键所对应的通道的就绪事件。</p>
<p>注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时,Selector会再次将其放入已选择键集中。</p>
<p>SelectionKey.channel()方法返回的通道需要转型成你要处理的类型,如ServerSocketChannel或SocketChannel等。</p>
<h3 id="wakeUp"><a href="#wakeUp" class="headerlink" title="wakeUp()"></a>wakeUp()</h3><p>某个线程调用select()方法后阻塞了,即使没有通道已经就绪,也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p>
<p>如果有其它线程调用了wakeup()方法,但当前没有线程阻塞在select()方法上,下个调用select()方法的线程会立即“醒来(wake up)”。</p>
<h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>用完Selector后调用其close()方法会关闭该Selector,且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p>
<p>完整的示例</p>
<p>这里有一个完整的示例,打开一个Selector,注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件(接受,连接,读,写)是否就绪。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Selector selector = Selector.open();</div><div class="line">channel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">  <span class="keyword">int</span> readyChannels = selector.select();</div><div class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">  Set selectedKeys = selector.selectedKeys();</div><div class="line">  Iterator keyIterator = selectedKeys.iterator();</div><div class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</div><div class="line">    SelectionKey key = keyIterator.next();</div><div class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</div><div class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</div><div class="line">        <span class="comment">// a connection was established with a remote server.</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</div><div class="line">        <span class="comment">// a channel is ready for reading</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</div><div class="line">        <span class="comment">// a channel is ready for writing</span></div><div class="line">    &#125;</div><div class="line">    keyIterator.remove();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。</p>
<p>FileChannel无法设置为非阻塞模式,它总是运行在阻塞模式下。</p>
<h3 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h3><p>在使用FileChannel之前,必须先打开它。但是,我们无法直接打开一个FileChannel,需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</div><div class="line">FileChannel inChannel = aFile.getChannel();</div></pre></td></tr></table></figure></p>
<h3 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h3><p>调用多个read()方法之一从FileChannel中读取数据。如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</div></pre></td></tr></table></figure></p>
<p>首先,分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。</p>
<p>然后,调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1,表示到了文件末尾。</p>
<h3 id="向FileChannel写数据"><a href="#向FileChannel写数据" class="headerlink" title="向FileChannel写数据"></a>向FileChannel写数据</h3><p>使用FileChannel.write()方法向FileChannel写数据,该方法的参数是一个Buffer。如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</div><div class="line"></div><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line">buf.clear();</div><div class="line">buf.put(newData.getBytes());</div><div class="line"></div><div class="line">buf.flip();</div><div class="line"></div><div class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</div><div class="line">	channel.write(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节,因此需要重复调用write()方法,直到Buffer中已经没有尚未写入通道的字节。</p>
<h3 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h3><p>用完FileChannel后必须将其关闭。如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">channel.close();</div></pre></td></tr></table></figure></p>
<h3 id="FileChannel的position方法"><a href="#FileChannel的position方法" class="headerlink" title="FileChannel的position方法"></a>FileChannel的position方法</h3><p>有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。</p>
<p>也可以通过调用position(long pos)方法设置FileChannel的当前位置。</p>
<p>这里有两个例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">long</span> pos = channel.position();</div><div class="line">channel.position(pos +<span class="number">123</span>);</div></pre></td></tr></table></figure></p>
<p>如果将位置设置在文件结束符之后,然后试图从文件通道中读取数据,读方法将返回-1 —— 文件结束标志。</p>
<p>如果将位置设置在文件结束符之后,然后向通道中写数据,文件将撑大到当前位置并写入数据。这可能导致“文件空洞”,磁盘上物理文件中写入的数据间有空隙。</p>
<h3 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h3><p>FileChannel实例的size()方法将返回该实例所关联文件的大小。如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">long</span> fileSize = channel.size();</div></pre></td></tr></table></figure></p>
<h3 id="FileChannel的truncate方法"><a href="#FileChannel的truncate方法" class="headerlink" title="FileChannel的truncate方法"></a>FileChannel的truncate方法</h3><p>可以使用FileChannel.truncate()方法截取一个文件。截取文件时,文件将中指定长度后面的部分将被删除。如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">channel.truncate(<span class="number">1024</span>);</div></pre></td></tr></table></figure></p>
<p>这个例子截取文件的前1024个字节。</p>
<h3 id="FileChannel的force方法"><a href="#FileChannel的force方法" class="headerlink" title="FileChannel的force方法"></a>FileChannel的force方法</h3><p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑,操作系统会将数据缓存在内存中,所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点,需要调用force()方法。</p>
<p>force()方法有一个boolean类型的参数,指明是否同时将文件元数据(权限信息等)写到磁盘上。</p>
<p>下面的例子同时将文件数据和元数据强制写到磁盘上:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">channel.force(<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel:</p>
<ol>
<li>打开一个SocketChannel并连接到互联网上的某台服务器。</li>
<li>一个新连接到达ServerSocketChannel时,会创建一个SocketChannel。</li>
</ol>
<h3 id="打开-SocketChannel"><a href="#打开-SocketChannel" class="headerlink" title="打开 SocketChannel"></a>打开 SocketChannel</h3><p>下面是SocketChannel的打开方式:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">SocketChannel socketChannel = SocketChannel.open();</div><div class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</div></pre></td></tr></table></figure></p>
<h3 id="关闭-SocketChannel"><a href="#关闭-SocketChannel" class="headerlink" title="关闭 SocketChannel"></a>关闭 SocketChannel</h3><p>当用完SocketChannel之后调用SocketChannel.close()关闭SocketChannel:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">socketChannel.close();</div></pre></td></tr></table></figure></p>
<h3 id="从-SocketChannel-读取数据"><a href="#从-SocketChannel-读取数据" class="headerlink" title="从 SocketChannel 读取数据"></a>从 SocketChannel 读取数据</h3><p>要从SocketChannel中读取数据,调用一个read()的方法之一。以下是例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line"><span class="keyword">int</span> bytesRead = socketChannel.read(buf);</div></pre></td></tr></table></figure></p>
<p>首先,分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。</p>
<p>然后,调用SocketChannel.read()。该方法将数据从SocketChannel 读到Buffer中。read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1,表示已经读到了流的末尾(连接关闭了)。</p>
<h3 id="写入-SocketChannel"><a href="#写入-SocketChannel" class="headerlink" title="写入 SocketChannel"></a>写入 SocketChannel</h3><p>写数据到SocketChannel用的是SocketChannel.write()方法,该方法以一个Buffer作为参数。示例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</div><div class="line"></div><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line">buf.clear();</div><div class="line">buf.put(newData.getBytes());</div><div class="line"></div><div class="line">buf.flip();</div><div class="line"></div><div class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</div><div class="line">    channel.write(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意SocketChannel.write()方法的调用是在一个while循环中的。Write()方法无法保证能写多少字节到SocketChannel。所以,我们重复调用write()直到Buffer没有要写的字节为止。</p>
<h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>可以设置 SocketChannel 为非阻塞模式(non-blocking mode).设置之后,就可以在异步模式下调用connect(), read() 和write()了。</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>如果SocketChannel在非阻塞模式下,此时调用connect(),该方法可能在连接建立之前就返回了。为了确定连接是否建立,可以调用finishConnect()的方法。像这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</div><div class="line"></div><div class="line"><span class="keyword">while</span>(! socketChannel.finishConnect() )&#123;</div><div class="line">    <span class="comment">//wait, or do something else...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h4><p>非阻塞模式下,write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。前面已经有例子了,这里就不赘述了。</p>
<h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值,它会告诉你读取了多少字节。</p>
<h3 id="非阻塞模式与选择器"><a href="#非阻塞模式与选择器" class="headerlink" title="非阻塞模式与选择器"></a>非阻塞模式与选择器</h3><p>非阻塞模式与选择器搭配会工作的更好,通过将一或多个SocketChannel注册到Selector,可以询问选择器哪个通道已经准备好了读取,写入等。Selector与SocketChannel的搭配使用会在后面详讲。</p>
<h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。ServerSocketChannel类在 java.nio.channels包中。</p>
<p>这里有个例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div><div class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</div><div class="line">    <span class="comment">//do something with socketChannel...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="打开-ServerSocketChannel"><a href="#打开-ServerSocketChannel" class="headerlink" title="打开 ServerSocketChannel"></a>打开 ServerSocketChannel</h3><p>通过调用 ServerSocketChannel.open() 方法来打开ServerSocketChannel.如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div></pre></td></tr></table></figure></p>
<h3 id="关闭-ServerSocketChannel"><a href="#关闭-ServerSocketChannel" class="headerlink" title="关闭 ServerSocketChannel"></a>关闭 ServerSocketChannel</h3><p>通过调用ServerSocketChannel.close() 方法来关闭ServerSocketChannel. 如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">serverSocketChannel.close();</div></pre></td></tr></table></figure></p>
<h3 id="监听新进来的连接"><a href="#监听新进来的连接" class="headerlink" title="监听新进来的连接"></a>监听新进来的连接</h3><p>通过 ServerSocketChannel.accept() 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。</p>
<p>通常不会仅仅只监听一个连接,在while循环中调用 accept()方法. 如下面的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</div><div class="line">    <span class="comment">//do something with socketChannel...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然,也可以在while循环中使用除了true以外的其它退出准则。</p>
<h3 id="非阻塞模式-1"><a href="#非阻塞模式-1" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下,accept() 方法会立刻返回,如果还没有新进来的连接,返回的将是null。 因此,需要检查返回的SocketChannel是否是null.如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div><div class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</div><div class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</div><div class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="comment">//do something with socketChannel...</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="非阻塞式服务器"><a href="#非阻塞式服务器" class="headerlink" title="非阻塞式服务器"></a>非阻塞式服务器</h2><p>即使你知道Java NIO 非阻塞的工作特性(如Selector,Channel,Buffer等组件),但是想要设计一个非阻塞的服务器仍然是一件很困难的事。非阻塞式服务器相较于阻塞式来说要多上许多挑战。本文将会讨论非阻塞式服务器的主要几个难题,并针对这些难题给出一些可能的解决方案。</p>
<p>本文的设计思路想法都是基于Java NIO的。但是我相信如果某些语言中也有像Selector之类的组件的话,文中的想法也能用于该语言。据我所知,类似的组件底层操作系统会提供,所以对你来说也可以根据其中的思想运用在其他语言上。</p>
<h3 id="非阻塞式服务器–-GitHub-仓库"><a href="#非阻塞式服务器–-GitHub-仓库" class="headerlink" title="非阻塞式服务器– GitHub 仓库"></a>非阻塞式服务器– GitHub 仓库</h3><p>我已经创建了一些简单的这些思想的概念验证呈现在这篇教程中,并且为了让你可以看到,我把源码放到了github资源库上了。这里是GitHub资源库地址:<br><a href="https://github.com/jjenkov/java-nio-server" target="_blank" rel="external">https://github.com/jjenkov/java-nio-server</a></p>
<h3 id="非阻塞式IO管道-Pipelines"><a href="#非阻塞式IO管道-Pipelines" class="headerlink" title="非阻塞式IO管道(Pipelines)"></a>非阻塞式IO管道(Pipelines)</h3><p>一个非阻塞式IO管道是由各个处理非阻塞式IO组件组成的链。其中包括读/写IO。下图就是一个简单的非阻塞式IO管道组成:<br><img src="/2017/10/09/Java-NIO/non-blocking-server-1.png" alt="non-blocking-server-1.png" title=""><br>一个组件使用 Selector 监控 Channel 什么时候有可读数据。然后这个组件读取输入并且根据输入生成相应的输出。最后输出将会再次写入到一个Channel中。</p>
<p>一个非阻塞式IO管道不需要将读数据和写数据都包含,有一些管道可能只会读数据,另一些可能只会写数据。</p>
<p>上图仅显示了一个单一的组件。一个非阻塞式IO管道可能拥有超过一个以上的组件去处理输入数据。一个非阻塞式管道的长度是由他的所要完成的任务决定。</p>
<p>一个非阻塞IO管道可能同时读取多个Channel里的数据。举个例子:从多个SocketChannel管道读取数据。</p>
<p>其实上图的控制流程还是太简单了。这里是组件从Selector开始从Channel中读取数据,而不是Channel将数据推送给Selector进入组件中,即便上图画的就是这样。</p>
<h3 id="非阻塞式vs-阻塞式管道"><a href="#非阻塞式vs-阻塞式管道" class="headerlink" title="非阻塞式vs. 阻塞式管道"></a>非阻塞式vs. 阻塞式管道</h3><p>非阻塞和阻塞IO管道两者之间最大的区别在于他们如何从底层Channel(Socket或者file)读取数据。</p>
<p>IO管道通常从流中读取数据(来自socket或者file)并且将这些数据拆分为一系列连贯的消息。这和使用tokenizer(这里估计是解析器之类的意思)将数据流解析为token(这里应该是数据包的意思)类似。相反你只是将数据流分解为更大的消息体。我将拆分数据流成消息这一组件称为“消息读取器”(Message Reader)下面是Message Reader拆分流为消息的示意图:<br><img src="/2017/10/09/Java-NIO/non-blocking-server-2.png" alt="non-blocking-server-2.png" title=""><br>一个阻塞IO管道可以使用类似InputStream的接口每次一个字节地从底层Channel读取数据,并且这个接口阻塞直到有数据可以读取。这就是阻塞式Message Reader的实现过程。</p>
<p>使用阻塞式IO接口简化了Message Reader的实现。阻塞式Message Reader从不用处理在流没有数据可读的情况,或者它只读取流中的部分数据并且对于消息的恢复也要延迟处理的情况。</p>
<p>同样,阻塞式Message Writer(一个将数据写入流中组件)也从不用处理只有部分数据被写入和写入消息要延迟恢复的情况。</p>
<h4 id="阻塞式IO管道的缺陷"><a href="#阻塞式IO管道的缺陷" class="headerlink" title="阻塞式IO管道的缺陷"></a>阻塞式IO管道的缺陷</h4><p>虽然阻塞式Message Reader容易实现,但是也有一个不幸的缺点:每一个要分解成消息的流都需要一个独立的线程。必须要这样做的理由是每一个流的IO接口会阻塞,直到它有数据读取。这就意味着一个单独的线程是无法尝试从一个没有数据的流中读取数据转去读另一个流。一旦一个线程尝试从一个流中读取数据,那么这个线程将会阻塞直到有数据可以读取。</p>
<p>如果IO管道是必须要处理大量并发链接服务器的一部分的话,那么服务器就需要为每一个链接维护一个线程。对于任何时间都只有几百条并发链接的服务器这确实不是什么问题。但是如果服务器拥有百万级别的并发链接量,这种设计方式就没有良好收放。每个线程都会占用栈32bit-64bit的内存。所以一百万个线程占用的内存将会达到1TB！不过在此之前服务器将会把所有的内存用以处理传经来的消息(例如:分配给消息处理期间使用对象的内存)</p>
<p>为了将线程数量降下来,许多服务器使用了服务器维持线程池(例如:常用线程为100)的设计,从而一次一个地从入站链接(inbound connections)地读取。入站链接保存在一个队列中,线程按照进入队列的顺序处理入站链接。这一设计如下图所示:(译者注:Tomcat就是这样的)<br><img src="/2017/10/09/Java-NIO/non-blocking-server-3.png" alt="non-blocking-server-3.png" title=""><br>然而,这一设计需要入站链接合理地发送数据。如果入站链接长时间不活跃,那么大量的不活跃链接实际上就造成了线程池中所有线程阻塞。这意味着服务器响应变慢甚至是没有反应。</p>
<p>一些服务器尝试通过弹性控制线程池的核心线程数量这一设计减轻这一问题。例如,如果线程池线程不足时,线程池可能开启更多的线程处理请求。这一方案意味着需要大量的长时链接才能使服务器不响应。但是记住,对于并发线程数任然是有一个上限的。因此,这一方案仍然无法很好地解决一百万个长时链接。</p>
<h3 id="基础非阻塞式IO管道设计"><a href="#基础非阻塞式IO管道设计" class="headerlink" title="基础非阻塞式IO管道设计"></a>基础非阻塞式IO管道设计</h3><p>一个非阻塞式IO管道可以使用一个单独的线程向多个流读取数据。这需要流可以被切换到非阻塞模式。在非阻塞模式下,当你读取流信息时可能会返回0个字节或更多字节的信息。如果流中没有数据可读就返回0字节,如果流中有数据可读就返回1+字节。</p>
<p>为了避免检查没有可读数据的流我们可以使用 Java NIO Selector. 一个或多个SelectableChannel 实例可以同时被一个Selector注册。<strong>当你调用Selector的select()或者 selectNow() 方法它只会返回有数据读取的SelectableChannel的实例</strong>. 下图是该设计的示意图:<br><img src="/2017/10/09/Java-NIO/non-blocking-server-4.png" alt="non-blocking-server-4.png" title=""></p>
<h3 id="读取部分消息"><a href="#读取部分消息" class="headerlink" title="读取部分消息"></a>读取部分消息</h3><p>当我们从一个SelectableChannel读取一个数据包时,我们不知道这个数据包相比于源文件是否有丢失或者重复数据(原文是:When we read a block of data from a SelectableChannel we do not know if that data block contains less or more than a message)。一个数据包可能的情况有:缺失数据(比原有消息的数据少)、与原有一致、比原来的消息的数据更多(例如:是原来的1.5或者2.5倍)。数据包可能出现的情况如下图所示:<br><img src="/2017/10/09/Java-NIO/non-blocking-server-5.png" alt="non-blocking-server-5.png" title=""><br>在处理类似上面这样部分信息时,有两个问题:</p>
<ul>
<li>判断你是否能在数据包中获取完整的消息。</li>
<li>在其余消息到达之前如何处理已到达的部分消息。</li>
</ul>
<p>判断消息的完整性需要消息读取器(Message Reader)在数据包中寻找是否存在至少一个完整消息体的数据。如果一个数据包包含一个或多个完整消息体,这些消息就能够被发送到管道进行处理。寻找完整消息体这一处理可能会重复多次,因此这一操作应该尽可能的快。</p>
<p>判断消息完整性和存储部分消息都是消息读取器(Message Reader)的责任。为了避免混合来自不同Channel的消息,我们将对每一个Channel使用一个Message Reader。设计如下图所示:<br><img src="/2017/10/09/Java-NIO/non-blocking-server-6.png" alt="non-blocking-server-6.png" title=""><br>在从Selector得到可从中读取数据的Channel实例之后, 与该Channel相关联的Message Reader读取数据并尝试将他们分解为消息。这样读出的任何完整消息可以被传到读取通道(read pipeline)任何需要处理这些消息的组件中。</p>
<p>一个Message Reader一定满足特定的协议。Message Reader需要知道它尝试读取的消息的消息格式。如果我们的服务器可以通过协议来复用,那它需要有能够插入Message Reader实现的功能 – 可能通过接收一个Message Reader工厂作为配置参数。</p>
<h3 id="存储部分消息"><a href="#存储部分消息" class="headerlink" title="存储部分消息"></a>存储部分消息</h3><p>现在我们已经确定Message Reader有责任存储部分消息,直到收到完整的消息,我们需要弄清楚这些部分消息的存储应该如何实现。</p>
<p>有两个设计因素我们要考虑:</p>
<ul>
<li>我们想尽可能少地复制消息数据。复制越多,性能越低。</li>
<li>我们希望将完整的消息存储在连续的字节序列中,使解析消息更容易。</li>
</ul>
<h4 id="每个Message-Reader的缓冲区"><a href="#每个Message-Reader的缓冲区" class="headerlink" title="每个Message Reader的缓冲区"></a>每个Message Reader的缓冲区</h4><p>很显然部分消息需要存储某些缓冲区中。简单的实现方式可以是每一个Message Reader内部简单地有一个缓冲区。但是这个缓冲区应该多大？它要大到足够储存最大允许储存消息。因此,如果最大允许储存消息是1MB,那么Message Reader内部缓冲区将至少需要1MB。</p>
<p>当我们的链接达到百万数量级,每个链接都使用1MB并没有什么作用。1,000,000 * 1MB仍然是1TB的内存！那如果最大的消息是16MB甚至是128MB呢？</p>
<h4 id="大小可调的缓冲区"><a href="#大小可调的缓冲区" class="headerlink" title="大小可调的缓冲区"></a>大小可调的缓冲区</h4><p>另一个选择是在Message Reader内部实现一个大小可调的缓冲区。大小可调的缓冲区开始的时候很小,如果它获取的消息过大,那缓冲区会扩大。这样每一条链接就不一定需要如1MB的缓冲区。每条链接的缓冲区只要需要足够储存下一条消息的内存就行了。</p>
<p>有几个可实现可调大小缓冲区的方法。它们都各自有自己的优缺点,所以接下来的部分我将逐个讨论。</p>
<p><strong>通过复制调整大小</strong></p>
<p>实现可调大小缓冲区的第一种方式是从一个大小(例如:4KB)的缓冲区开始。如果4KB的缓冲区装不下一个消息,则会分配一个更大的缓冲区(如:8KB),并将大小为4KB的缓冲区数据复制到这个更大的缓冲区中去。</p>
<p>通过复制实现大小可调缓冲区的优点在于消息的所有数据被保存在一个连续的字节数组中,这就使得消息的解析更加容易。它的缺点就是在复制更大消息的时候会导致大量的数据。</p>
<p>为了减少消息的复制,你可以分析流进你系统的消息的大小,并找出尽量减少复制量的缓冲区的大小。例如,你可能看到大多数消息都小于4KB,这是因为它们都仅包含很小的 request/responses。这意味着缓冲区的初始值应该设为4KB。</p>
<p>然后你可能有一个消息大于4KB,这通常是因为它里面包含一个文件。你可能注意到大多数流进系统的文件都是小于128KB的。这样第二个缓冲区的大小设置为128KB就较为合理。</p>
<p>最后你可能会发现一旦消息超过128KB之后,消息的大小就没有什么固定的模式,因此缓冲区最终的大小可能就是最大消息的大小。</p>
<p>根据流经系统的消息大小,上面三种缓冲区大小可以减少数据的复制。小于4KB的消息将不会复制。对于一百万个并发链接其结果是:1,000,000 * 4KB = 4GB,对于目前大多数服务器还是有可能的。介于4KB – 128KB的消息将只会复制一次,并且只有4KB的数据复制进128KB的缓冲区中。介于128KB至最大消息大小的消息将会复制两次。第一次复制4KB,第二次复制128KB,所以最大的消息总共复制了132KB。假设没有那么多超过128KB大小的消息那还是可以接受的。</p>
<p>一旦消息处理完毕,那么分配的内存将会被清空。这样在同一链接接收到的下一条消息将会再次从最小缓冲区大小开始算。这样做的必要性是确保了不同连接间内存的有效共享。所有的连接很有可能在同一时间并不需要打的缓冲区。</p>
<p>我有一篇介绍如何实现这样支持可调整大小的数组的内存缓冲区的完整文章:</p>
<p>Resizable Arrays(<a href="http://tutorials.jenkov.com/java-performance/resizable-array.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-performance/resizable-array.html</a>)</p>
<p>文章包含一个GitHub仓库连接,其中的代码演示了是如何实现的。</p>
<p><strong>通过追加调整大小</strong></p>
<p>调整缓冲区大小的另一种方法是使缓冲区由多个数组组成。当你需要调整缓冲区大小时,你只需要另一个字节数组并将数据写进去就行了。</p>
<p>这里有两种方法扩张一个缓冲区。一个方法是分配单独的字节数组,并将这些数组保存在一个列表中。另一个方法是分配较大的共享字节数组的片段,然后保留分配给缓冲区的片段的列表。就个人而言,我觉得片段的方式会好些,但是差别不大。</p>
<p>通过追加单独的数组或片段来扩展缓冲区的优点在于写入过程中不需要复制数据。所有的数据可以直接从socket (Channel)复制到一个数组或片段中。</p>
<p>以这种方式扩展缓冲区的缺点是在于数据不是存储在单独且连续的数组中。这将使得消息的解析更困难,因为解析器需要同时查找每个单独数组的结尾处和所有数组的结尾处。由于你需要在写入的数据中查找消息的结尾,所以该模型并不容易使用。</p>
<h3 id="TLV编码消息"><a href="#TLV编码消息" class="headerlink" title="TLV编码消息"></a>TLV编码消息</h3><p>一些协议消息格式是使用TLV格式(类型(Type)、长度(Length)、值(Value))编码。这意味着当消息到达时,消息的总长度被存储在消息的开头。这一方式你可以立即知道应该对整个消息分配多大的内存。</p>
<p>TLV编码使得内存管理变得更加容易。你可以立即知道要分配多大的内存给这个消息。只有部分在结束时使用的缓冲区才会使得内存浪费。</p>
<p>TLV编码的一个缺点是你要在消息的所有数据到达之前就分配好这个消息需要的所有内存。一些慢连接可能因此分配完你所有可用内存,从而使得你的服务器无法响应。</p>
<p>此问题的解决方法是使用包含多个TLV字段的消息格式。因此,服务器是为每个字段分配内存而不是为整个消息分配内存,并且是字段到达之后再分配内存。然而,一个大消息中的一个大字段在你的内存管理有同样的影响。</p>
<p>另外一个方案就是对于还未到达的信息设置超时时间,例如10-15秒。当恰好有许多大消息到达服务器时,这个方案能够使得你的服务器可以恢复,但是仍然会造成服务器一段时间无法响应。另外,恶意的DoS(Denial of Service拒绝服务)攻击仍然可以分配完你服务器的所有内存。</p>
<p>TLV编码存在许多不同的形式。实际使用的字节数、自定字段的类型和长度都依赖于每一个TLV编码。TLV编码首先放置字段的长度、然后是类型、然后是值(一个LTV编码)。 虽然字段的顺序不同,但它仍然是TLV的一种。</p>
<p>TLV编码使内存管理更容易这一事实,其实是HTTP 1.1是如此可怕的协议的原因之一。 这是他们试图在HTTP 2.0中修复数据的问题之一,数据在LTV编码帧中传输。 这也是为什么我们使用TLV编码的VStack.co project 设计了我们自己的网络协议。</p>
<h3 id="写部分数据"><a href="#写部分数据" class="headerlink" title="写部分数据"></a>写部分数据</h3><p>在非阻塞IO管道中写数据仍然是一个挑战。当你调用一个处于非阻塞式Channel对象的write(ByteBuffer)方法时,ByteBuffer写入多少数据是无法保证的。write(ByteBuffer)方法会返回写入的字节数,因此可以跟踪写入的字节数。这就是挑战:跟踪部分写入的消息,以便最终可以发送一条消息的所有字节。</p>
<p>为了管理部分消息写入Channel,我们将创建一个消息写入器(Message Writer)。就像Message Reader一样,每一个要写入消息的Channel我们都需要一个Message Writer。在每个Message Writer中,我们跟踪正在写入的消息的字节数。</p>
<p>如果达到的消息量超过Message Writer可直接写入Channel的消息量,消息就需要在Message Writer排队。然后Message Writer尽快地将消息写入到Channel中。</p>
<p>下图是部分消息如何写入的设计图:<br><img src="/2017/10/09/Java-NIO/non-blocking-server-8.png" alt="non-blocking-server-8.png" title=""></p>
<p>为了使Message Writer能够尽快发送数据,Message Writer需要能够不时被调用,这样就能发送更多的消息。</p>
<p>如果你又大量的连接那你将需要大量的Message Writer实例。检查Message Writer实例(如:一百万个)看写任何数据时是否缓慢。 首先,许多Message Writer实例都没有任何消息要发送,我们并不想检查那些Message Writer实例。其次,并不是所有的Channel实例都可以准备好写入数据。 我们不想浪费时间尝试将数据写入无法接受任何数据的Channel。</p>
<p>为了检查Channel是否准备好进行写入,您可以使用Selector注册Channel。然而我们并不想将所有的Channel实例注册到Selector中去。想象一下,如果你有1,000,000个连接且其中大多是空闲的,并且所有的连接已经与Selector注册。然后当你调用select()时,这些Channel实例的大部分将被写入就绪(它们大都是空闲的,记得吗？)然后你必须检查所有这些连接的Message Writer,以查看他们是否有任何数据要写入。</p>
<p>为了避免检查所有消息的Message Writer实例和所有不可能被写入任何信息的Channel实例,我们使用这两步的方法:</p>
<ul>
<li>当一个消息被写入Message Writer,Message Writer向Selector注册其相关Channel(如果尚未注册)。</li>
<li>当你的服务器有时间时,它检查Selector以查看哪些注册的Channel实例已准备好进行写入。 对于每个写就绪Channel,请求其关联的Message Writer将数据写入Channel。 如果Message Writer将其所有消息写入其Channel,则Channel将再次从Selector注册。</li>
</ul>
<p>这两个小步骤确保了有消息写入的Channel实际上已经被Selector注册了。</p>
<h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p>正如你所见,一个非阻塞式服务器需要时不时检查输入的消息来判断是否有任何的新的完整的消息发送过来。服务器可能会在一个或多个完整消息发来之前就检查了多次。检查一次是不够的。</p>
<p>同样,一个非阻塞式服务器需要时不时检查是否有任何数据需要写入。如果有,服务器需要检查是否有任何相应的连接准备好将该数据写入它们。只有在第一次排队消息时才检查是不够的,因为消息可能被部分写入。</p>
<p>所有这些非阻塞服务器最终都需要定期执行的三个“管道”(pipelines)::</p>
<p>读取管道(The read pipeline),用于检查是否有新数据从开放连接进来的。<br>处理管道(The process pipeline),用于所有任何完整消息。<br>写入管道(The write pipeline),用于检查是否可以将任何传出的消息写入任何打开的连接。<br>这三条管道在循环中重复执行。你可能可以稍微优化执行。例如,如果没有排队的消息可以跳过写入管道。 或者,如果我们没有收到新的,完整的消息,也许您可以跳过流程管道。</p>
<p>以下是说明完整服务器循环的图:</p>
<img src="/2017/10/09/Java-NIO/non-blocking-server-9.png" alt="non-blocking-server-9.png" title="">
<p>如果仍然发现这有点复杂,请记住查看GitHub资料库:<a href="https://github.com/jjenkov/java-nio-server" target="_blank" rel="external">https://github.com/jjenkov/java-nio-server</a></p>
<p>也许看到正在执行的代码可能会帮助你了解如何实现这一点。</p>
<h3 id="服务器线程模型"><a href="#服务器线程模型" class="headerlink" title="服务器线程模型"></a>服务器线程模型</h3><p>GitHub资源库里面的非阻塞式服务器实现使用了两个线程的线程模式。第一个线程用来接收来自ServerSocketChannel的传入连接。第二个线程处理接受的连接,意思是读取消息,处理消息并将响应写回连接。这两个线程模型的图解如下:<br><img src="/2017/10/09/Java-NIO/non-blocking-server-10.png" alt="non-blocking-server-10.png" title=""><br>上一节中说到的服务器循环处理是由处理线程(Processor Thread)执行。</p>
<h2 id="Java-NIO-DatagramChannel"><a href="#Java-NIO-DatagramChannel" class="headerlink" title="Java NIO DatagramChannel"></a>Java NIO DatagramChannel</h2><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议,所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p>
<h3 id="打开-DatagramChannel"><a href="#打开-DatagramChannel" class="headerlink" title="打开 DatagramChannel"></a>打开 DatagramChannel</h3><p>下面是 DatagramChannel 的打开方式:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">DatagramChannel channel = DatagramChannel.open();</div><div class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</div></pre></td></tr></table></figure></p>
<p>这个例子打开的 DatagramChannel可以在UDP端口9999上接收数据包。</p>
<h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><p>通过receive()方法从DatagramChannel接收数据,如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line">buf.clear();</div><div class="line">channel.receive(buf);</div></pre></td></tr></table></figure></p>
<p>receive()方法会将接收到的数据包内容复制到指定的Buffer. 如果Buffer容不下收到的数据,多出的数据将被丢弃。</p>
<h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>通过send()方法从DatagramChannel发送数据,如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</div><div class="line"></div><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line">buf.clear();</div><div class="line">buf.put(newData.getBytes());</div><div class="line">buf.flip();</div><div class="line"></div><div class="line"><span class="keyword">int</span> bytesSent = channel.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>));</div></pre></td></tr></table></figure></p>
<p>这个例子发送一串字符到”jenkov.com”服务器的UDP端口80。 因为服务端并没有监控这个端口,所以什么也不会发生。也不会通知你发出的数据包是否已收到,因为UDP在数据传送方面没有任何保证。</p>
<h3 id="连接到特定的地址"><a href="#连接到特定的地址" class="headerlink" title="连接到特定的地址"></a>连接到特定的地址</h3><p>可以将DatagramChannel“连接”到网络中的特定地址的。由于UDP是无连接的,连接到特定地址并不会像TCP通道那样创建一个真正的连接。而是锁住DatagramChannel ,让其只能从特定地址收发数据。</p>
<p>这里有个例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>));</div></pre></td></tr></table></figure></p>
<p>当连接后,也可以使用read()和write()方法,就像在用传统的通道一样。只是在数据传送方面没有任何保证。这里有几个例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> bytesRead = channel.read(buf);</div><div class="line"><span class="keyword">int</span> bytesWritten = channel.write(but);</div></pre></td></tr></table></figure></p>
<h2 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h2><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道,从source通道读取。</p>
<p>这里是Pipe原理的图示:<br><img src="/2017/10/09/Java-NIO/pipe.bmp" alt="pipe.bmp" title=""></p>
<h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><p>通过Pipe.open()方法打开管道。例如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pipe pipe = Pipe.open();</div></pre></td></tr></table></figure></p>
<h3 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a>向管道写数据</h3><p>要向管道写数据,需要访问sink通道。像这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</div></pre></td></tr></table></figure></p>
<p>通过调用SinkChannel的write()方法,将数据写入SinkChannel,像这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</div><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line">buf.clear();</div><div class="line">buf.put(newData.getBytes());</div><div class="line"></div><div class="line">buf.flip();</div><div class="line"></div><div class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</div><div class="line">    sinkChannel.write(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h3><p>从读取管道的数据,需要访问source通道,像这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Pipe.SourceChannel sourceChannel = pipe.source();</div></pre></td></tr></table></figure></p>
<p>调用source通道的read()方法来读取数据,像这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line"><span class="keyword">int</span> bytesRead = sourceChannel.read(buf);</div></pre></td></tr></table></figure></p>
<p>read()方法返回的int值会告诉我们多少字节被读进了缓冲区。</p>
<h2 id="Java-NIO与IO"><a href="#Java-NIO与IO" class="headerlink" title="Java NIO与IO"></a>Java NIO与IO</h2><p>当学习了Java NIO和IO的API后,一个问题马上涌入脑海:</p>
<p>我应该何时使用IO,何时使用NIO呢？在本文中,我会尽量清晰地解析Java NIO和IO的差异、它们的使用场景,以及它们如何影响您的代码设计。</p>
<h3 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h3><p>下表总结了Java NIO和IO之间的主要差别,我会更详细地描述表中每部分的差异。</p>
<table>
<thead>
<tr>
<th style="text-align:left">IO</th>
<th style="text-align:left">NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">面向流</td>
<td style="text-align:left">面向缓冲</td>
</tr>
<tr>
<td style="text-align:left">阻塞IO</td>
<td style="text-align:left">非阻塞IO</td>
</tr>
<tr>
<td style="text-align:left">无</td>
<td style="text-align:left">选择器</td>
</tr>
</tbody>
</table>
<h4 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a>面向流与面向缓冲</h4><p>Java NIO和IO之间第一个最大的区别是,IO是面向流的,NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节,直至读取所有字节,它们没有被缓存在任何地方。此外,它不能前后移动流中的数据。如果需要前后移动从流中读取的数据,需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区,需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是,还需要检查是否该缓冲区中包含所有您需要处理的数据。而且,需确保当更多的数据读入缓冲区时,不要覆盖缓冲区里尚未处理的数据。</p>
<h4 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h4><p>Java IO的各种流是阻塞的。这意味着,当一个线程调用read() 或 write()时,该线程被阻塞,直到有一些数据被读取,或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式,使一个线程从某通道发送请求读取数据,但是它仅能得到目前可用的数据,如果目前没有数据可用时,就什么都不会获取。而不是保持线程阻塞,所以直至数据变的可以读取之前,该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道,但不需要等待它完全写入,这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作,所以一个单独的线程现在可以管理多个输入和输出通道(channel)。</p>
<h4 id="选择器-Selectors"><a href="#选择器-Selectors" class="headerlink" title="选择器(Selectors)"></a>选择器(Selectors)</h4><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道,你可以注册多个通道使用一个选择器,然后使用一个单独的线程来“选择”通道:这些通道里已经有可以处理的输入,或者选择已准备写入的通道。这种选择机制,使得一个单独的线程很容易来管理多个通道。</p>
<h3 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a>NIO和IO如何影响应用程序的设计</h3><p>无论您选择IO或NIO工具箱,可能会影响您应用程序设计的以下几个方面:</p>
<ol>
<li>对NIO或IO类的API调用。</li>
<li>数据处理。</li>
<li>用来处理数据的线程数。</li>
</ol>
<h3 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h3><p>当然,使用NIO的API调用时看起来与使用IO时有所不同,但这并不意外,因为并不是仅从一个InputStream逐字节读取,而是数据必须先读入缓冲区再处理。</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>使用纯粹的NIO设计相较IO设计,数据处理也受到影响。</p>
<p>在IO设计中,我们从InputStream或 Reader逐字节读取数据。假设你正在处理一基于行的文本数据流,例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Name: Anna</div><div class="line">Age: 25</div><div class="line">Email: anna@mailserver.com</div><div class="line">Phone: 1234567890</div></pre></td></tr></table></figure></p>
<p>该文本行的流可以这样处理:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">InputStream input = ... ; <span class="comment">// get the InputStream from the client socket</span></div><div class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input));</div><div class="line"></div><div class="line">String nameLine   = reader.readLine();</div><div class="line">String ageLine    = reader.readLine();</div><div class="line">String emailLine  = reader.readLine();</div><div class="line">String phoneLine  = reader.readLine();</div></pre></td></tr></table></figure></p>
<p>请注意处理状态由程序执行多久决定。换句话说,一旦reader.readLine()方法返回,你就知道肯定文本行就已读完, readline()阻塞直到整行读完,这就是原因。你也知道此行包含名称；同样,第二个readline()调用返回的时候,你知道这行包含年龄等。 正如你可以看到,该处理程序仅在有新数据读入时运行,并知道每步的数据是什么。一旦正在运行的线程已处理过读入的某些数据,该线程不会再回退数据(大多如此)。下图也说明了这条原则:<br><img src="/2017/10/09/Java-NIO/nio-vs-io-1.png" alt="nio-vs-io-1.png" title=""><br>(Java IO: 从一个阻塞的流中读数据) 而一个NIO的实现会有所不同,下面是一个简单的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</div></pre></td></tr></table></figure></p>
<p>注意第二行,从通道读取字节到ByteBuffer。当这个方法调用返回时,你不知道你所需的所有数据是否在缓冲区内。你所知道的是,该缓冲区包含一些字节,这使得处理有点困难。<br>假设第一次 read(buffer)调用后,读入缓冲区的数据只有半行,例如,“Name:An”,你能处理数据吗？显然不能,需要等待,直到整行数据读入缓存,在此之前,对数据的任何处理毫无意义。</p>
<p>所以,你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了,你不知道。发现的方法只能查看缓冲区中的数据。其结果是,在你知道所有数据都在缓冲区里之前,你必须检查几次缓冲区的数据。这不仅效率低下,而且可以使程序设计方案杂乱不堪。例如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</div><div class="line"></div><div class="line"><span class="keyword">while</span>(! bufferFull(bytesRead) ) &#123;</div><div class="line">    bytesRead = inChannel.read(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>bufferFull()方法必须跟踪有多少数据读入缓冲区,并返回真或假,这取决于缓冲区是否已满。换句话说,如果缓冲区准备好被处理,那么表示缓冲区满了。</p>
<p>bufferFull()方法扫描缓冲区,但必须保持在bufferFull()方法被调用之前状态相同。如果没有,下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的,但却是需要注意的又一问题。</p>
<p>如果缓冲区已满,它可以被处理。如果它不满,并且在你的实际案例中有意义,你或许能处理其中的部分数据。但是许多情况下并非如此。下图展示了“缓冲区数据循环就绪”:<br><img src="/2017/10/09/Java-NIO/nio-vs-io-2.png" alt="nio-vs-io-2.png" title=""><br>Java NIO:从一个通道里读数据,直到所有的数据都读到缓冲区里.</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>NIO可让您只使用一个(或几个)单线程管理多个通道(网络连接或文件),但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。</p>
<p>如果需要管理同时打开的成千上万个连接,这些连接每次只是发送少量的数据,例如聊天服务器,实现NIO的服务器可能是一个优势。同样,如果你需要维持许多打开的连接到其他计算机上,如P2P网络中,使用一个单独的线程来管理你所有出站连接,可能是一个优势。一个线程多个连接的设计方案如下图所示:<br><img src="/2017/10/09/Java-NIO/nio-vs-io-3.png" alt="nio-vs-io-3.png" title=""><br>Java NIO: 单线程管理多个连接</p>
<p>如果你有少量的连接使用非常高的带宽,一次发送大量的数据,也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计:<br><img src="/2017/10/09/Java-NIO/nio-vs-io-4.png" alt="nio-vs-io-4.png" title=""><br>Java IO: 一个典型的IO服务器设计- 一个连接通过一个线程处理.</p>
<p>未完待续…</p>
<p>ref:<br><a href="http://ifeve.com/java-nio-all/" target="_blank" rel="external">http://ifeve.com/java-nio-all/</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer-basis-AND-OR-exclusiveOR</title>
    <url>/2017/10/01/Computer-basis-AND-OR-exclusiveOR/</url>
    <content><![CDATA[<p> 与、或、异或运算</p>
<a id="more"></a>
<h2 id="与运算（-amp-）"><a href="#与运算（-amp-）" class="headerlink" title="与运算（&amp;）"></a>与运算（&amp;）</h2><p>参加运算的两个数据，按二进制位进行“与”运算。</p>
<p>运算规则：0&amp;0=0;   0&amp;1=0;    1&amp;0=0;     1&amp;1=1;<br>       即：两位同时为“1”，结果才为“1”，否则为0</p>
<p>例如：3&amp;5  即 0000 0011 &amp; 0000 0101 = 0000 0001   因此，3&amp;5的值得1。<br>例如：9&amp;5  即 0000 1001 (9的二进制补码)&amp;00000101 (5的二进制补码) =00000001 (1的二进制补码)可见9&amp;5=1。</p>
<h2 id="或运算（-）"><a href="#或运算（-）" class="headerlink" title="或运算（|）"></a>或运算（|）</h2><p>参加运算的两个对象，按二进制位进行“或”运算。</p>
<p>运算规则：0|0=0；   0|1=1；   1|0=1；    1|1=1；<br> 　　即 ：参加运算的两个对象只要有一个为1，其值为1。</p>
<p>例如:3|5　即 0000 0011 | 0000 0101 = 0000 0111   因此，3|5的值得7。　<br>例如：9|5可写算式如下： 00001001|00000101 =00001101 (十进制为13)可见9|5=13</p>
<h2 id="异或运算（-）"><a href="#异或运算（-）" class="headerlink" title="异或运算（^）"></a>异或运算（^）</h2><p>参加运算的两个数据，按二进制位进行“异或”运算。</p>
<p>运算规则：0^0=0；   0^1=1；   1^0=1；   1^1=0；<br>　　即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</p>
<p>例如：9^5可写成算式如下： 00001001^00000101=00001100 (十进制为12)可见9^5=12  </p>
<p>ref:<br><a href="https://www.cnblogs.com/wisdom-jie/p/7732940.html" target="_blank" rel="external">https://www.cnblogs.com/wisdom-jie/p/7732940.html</a></p>
]]></content>
      <categories>
        <category>Computer-basis</category>
      </categories>
      <tags>
        <tag>Computer-basis</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-基本原理及快速入门</title>
    <url>/2017/10/01/Docker-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>几张图帮你理解 docker 基本原理及快速入门</p>
<a id="more"></a>
<h2 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>Docker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。<br>Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。<br>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处，可见容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件层面实现。<br><img src="virtualization.png" alt="virtualization.png"><br><img src="docker.png" alt="docker.png"></p>
<h2 id="为什么用docker"><a href="#为什么用docker" class="headerlink" title="为什么用docker"></a>为什么用docker</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<p>Docker 在如下几个方面具有较大的优势：</p>
<ul>
<li><p>更快速的交付和部署<br>  Docker在整个开发周期都可以完美的辅助你实现快速交付。Docker允许开发者在装有应用和服务本地容器做开发。可以直接集成到可持续开发流程中。</p>
<p>  例如：开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。</p>
</li>
<li><p>高效的部署和扩容<br>  Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。</p>
<p>  Docker的兼容性和轻量特性可以很轻松的实现负载的动态管理。你可以快速扩容或方便的下线的你的应用和服务，这种速度趋近实时。</p>
</li>
<li><p>更高的资源利用率<br>  Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。</p>
</li>
<li><p>更简单的管理<br>  使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</p>
</li>
</ul>
<h2 id="Docker引擎"><a href="#Docker引擎" class="headerlink" title="Docker引擎"></a>Docker引擎</h2><p>docker引擎是一个c/s结构的应用，主要组件见下图：<br><img src="engine-components-flow.png" alt="engine-components-flow.png"></p>
<ul>
<li>Server是一个常驻进程</li>
<li>REST API 实现了client和server间的交互协议</li>
<li>CLI 实现容器和镜像的管理，为用户提供统一的操作界面</li>
</ul>
<h2 id="Docker构架"><a href="#Docker构架" class="headerlink" title="Docker构架"></a>Docker构架</h2><p>Docker使用C/S架构，Client 通过接口与Server进程通信实现容器的构建，运行和发布。client和server可以运行在同一台机器，也可以通过跨主机实现远程通信。<br><img src="architecture.jpg" alt="architecture.jpg"></p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><p>镜像(image)<br>  Docker 镜像（Image）就是一个只读的模板。例如：一个镜像可以包含一个完整的操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p>
<p>  镜像（Image）就是一堆只读层（read-only layer）的统一视角，也许这个定义有些难以理解，看看下面这张图：<br><img src="image_ufs.png" alt="image_ufs.png"></p>
<p>  右边我们看到了多个只读层，它们重叠在一起。除了最下面一层，其它层都会有一个指针指向下一层。这些层是Docker内部的实现细节，并且能够在docker宿主机的文件系统上访问到。统一文件系统（Union File System）技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统。</p>
</li>
</ul>
<ul>
<li><p>仓库(repository)<br>  仓库（Repository）是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
<p>  仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。国内的公开仓库包括 时速云 、网易云 等，可以提供大陆用户更稳定快速的访问。当然，用户也可以在本地网络内创建一个私有仓库。</p>
<p>  当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了。</p>
<p>  Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p>
</li>
<li><p>容器(container)<br>  Docker 利用容器（Container）来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p>
<p>  容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。<br><img src="container-ufs.png" alt="container-ufs.png"></p>
</li>
</ul>
<p>一个运行态容器被定义为一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程。下面这张图片展示了一个运行中的容器。<br><img src="container-running.png" alt="container-running.png"><br>正是文件系统隔离技术使得Docker成为了一个非常有潜力的虚拟化技术。一个容器中的进程可能会对文件进行修改、删除、创建，这些改变都将作用于可读写层。</p>
<h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker pull</div></pre></td></tr></table></figure>
<p>从仓库获取所需要的镜像。</p>
<p>使用示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker pull centos:centos6</div></pre></td></tr></table></figure></p>
<p>实际上相当于 docker pull registry.hub.docker.com/centos:centos6<br>命令，即从注册服务器 registry.hub.docker.com 中的 centos 仓库来下载标记为 centos6 的镜像。<br>有时候官方仓库注册服务器下载较慢，可以从其他仓库下载。 从其它仓库下载时需要指定完整的仓库注册服务器地址。</p>
<h3 id="查看镜像列表"><a href="#查看镜像列表" class="headerlink" title="查看镜像列表"></a>查看镜像列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker images</div></pre></td></tr></table></figure>
<p>列出了所有顶层（top-level）镜像。实际上，在这里我们没有办法区分一个镜像和一个只读层，所以我们<br>提出了top-level镜像。只有创建容器时使用的镜像或者是直接pull下来的镜像能被称为顶层（top-level）<br>镜像，并且每一个顶层镜像下面都隐藏了多个镜像层。</p>
<p>使用示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ docker images</div><div class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">centos                   centos6             6a77ab6655b9        8 weeks ago         194.6 MB</div><div class="line">ubuntu                   latest              2fa927b5cdd3        9 weeks ago         122 MB</div></pre></td></tr></table></figure></p>
<p>在列出信息中，可以看到几个字段信息</p>
<ul>
<li>来自于哪个仓库，比如 ubuntu</li>
<li>镜像的标记，比如 14.04</li>
<li>它的 ID 号（唯一）</li>
<li>创建时间</li>
<li>镜像大小</li>
</ul>
<h3 id="利用-Dockerfile-来创建镜像"><a href="#利用-Dockerfile-来创建镜像" class="headerlink" title="利用 Dockerfile 来创建镜像"></a>利用 Dockerfile 来创建镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker build</div></pre></td></tr></table></figure>
<p>使用 docker commit 来扩展一个镜像比较简单，但是不方便在一个团队中分享。我们可以使用<br>docker build 来创建一个新的镜像。为此，首先需要创建一个 Dockerfile，包含一些如何创建镜像的<br>指令。新建一个目录和一个 Dockerfile。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">mkdir hainiu</div><div class="line">cd hainiu</div><div class="line">touch Dockerfile</div></pre></td></tr></table></figure></p>
<p>Dockerfile 中每一条指令都创建镜像的一层，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">FROM centos:centos6</div><div class="line">MAINTAINER sandywei &lt;sandy@hainiu.tech&gt;</div><div class="line"># move all configuration files into container</div><div class="line"></div><div class="line">RUN yum install -y httpd</div><div class="line">EXPOSE 80</div><div class="line">CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;service httpd start;bash&quot;]</div></pre></td></tr></table></figure></p>
<p>Dockerfile 基本的语法是</p>
<ul>
<li>使用#来注释</li>
<li>FROM 指令告诉 Docker 使用哪个镜像作为基础</li>
<li>接着是维护者的信息</li>
<li>RUN开头的指令会在创建中运行，比如安装一个软件包，在这里使用yum来安装了一些软件</li>
<li>更详细的语法说明请参考 <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="external">Dockerfile</a></li>
</ul>
<p>编写完成 Dockerfile 后可以使用 docker build 来生成镜像。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ docker build -t hainiu/httpd:1.0 .</div><div class="line"></div><div class="line">Sending build context to Docker daemon 2.048 kB</div><div class="line">Step 1 : FROM centos:centos6</div><div class="line"> ---&gt; 6a77ab6655b9</div><div class="line">Step 2 : MAINTAINER sandywei &lt;sandy@hainiu.tech&gt;</div><div class="line"> ---&gt; Running in 1b26493518a7</div><div class="line"> ---&gt; 8877ee5f7432</div><div class="line">Removing intermediate container 1b26493518a7</div><div class="line">Step 3 : RUN yum install -y httpd</div><div class="line"> ---&gt; Running in fe5b6f1ef888</div><div class="line"></div><div class="line"> .....</div><div class="line"></div><div class="line"> Step 5 : CMD sh -c service httpd start</div><div class="line"> ---&gt; Running in b2b94c1601c2</div><div class="line"> ---&gt; 5f9aa91b0c9e</div><div class="line">Removing intermediate container b2b94c1601c2</div><div class="line">Successfully built 5f9aa91b0c9e</div></pre></td></tr></table></figure></p>
<p>其中 -t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），<br>也可以替换为一个具体的 Dockerfile 的路径。注意一个镜像不能超过 127 层。</p>
<p>用docker images 查看镜像列表<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ docker images</div><div class="line">REPOSITORY                 TAG               IMAGE ID            CREATED             SIZE</div><div class="line">hainiu/httpd               1.0               5f9aa91b0c9e        3 minutes ago       292.4 MB</div><div class="line">centos                   centos6             6a77ab6655b9        8 weeks ago         194.6 MB</div><div class="line">ubuntu                   latest              2fa927b5cdd3        9 weeks ago         122 MB</div></pre></td></tr></table></figure></p>
<p>细心的朋友可以看到最后一层的ID（5f9aa91b0c9e）和 image id 是一样的</p>
<h3 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker push</div></pre></td></tr></table></figure>
<p>用户可以通过 docker push 命令，把自己创建的镜像上传到仓库中来共享。例如，用户在 Docker Hub 上完成注册后，可以推送自己的镜像到仓库中。</p>
<p>运行实例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ docker push hainiu/httpd:1.0</div></pre></td></tr></table></figure></p>
<h3 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker create &lt;image-id&gt;</div></pre></td></tr></table></figure>
<p>docker create 命令为指定的镜像（image）添加了一个可读写层，构成了一个新的容器。注意，这个容器并没有运行。</p>
<p>docker create 命令提供了许多参数选项可以指定名字，硬件资源，网络配置等等。</p>
<p>运行示例：</p>
<p>创建一个centos的容器，可以使用仓库＋标签的名字确定image，也可以使用image－id指定image。返回容器id<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">＃查看本地images列表</div><div class="line">$ docker images</div><div class="line"></div><div class="line">＃用仓库＋标签</div><div class="line">$ docker create -it --name centos6_container centos:centos6</div><div class="line"></div><div class="line">＃使用image－id</div><div class="line">$ docker create -it --name centos6_container 6a77ab6655b9 bash</div><div class="line">b3cd0b47fe3db0115037c5e9cf776914bd46944d1ac63c0b753a9df6944c7a67</div><div class="line"></div><div class="line">#可以使用 docker ps查看一件存在的容器列表,不加参数默认只显示当前运行的容器</div><div class="line">$ docker ps -a</div></pre></td></tr></table></figure></p>
<p>可以使用 -v 参数将本地目录挂载到容器中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ docker create -it --name centos6_container -v /src/webapp:/opt/webapp centos:centos6</div></pre></td></tr></table></figure></p>
<p>这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，如果目录不存在 Docker 会自动为你创建它。</p>
<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker start &lt;container-id&gt;</div></pre></td></tr></table></figure>
<p>Docker start命令为容器文件系统创建了一个进程隔离空间。注意，每一个容器只能够有一个进程隔离空间。</p>
<p>运行实例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#通过名字启动</div><div class="line">$ docker start -i centos6_container</div><div class="line"></div><div class="line">＃通过容器ID启动</div><div class="line">$ docker start -i b3cd0b47fe3d</div></pre></td></tr></table></figure></p>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker exec &lt;container-id&gt;</div></pre></td></tr></table></figure>
<p>在当前容器中执行新命令，如果增加 -it参数运行bash 就和登录到容器效果一样的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker exec -it centos6_container bash</div></pre></td></tr></table></figure></p>
<h3 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker stop &lt;container-id&gt;</div></pre></td></tr></table></figure>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker rm &lt;container-id&gt;</div></pre></td></tr></table></figure>
<h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker run &lt;image-id&gt;</div></pre></td></tr></table></figure>
<p>docker run就是docker create和docker start两个命令的组合,支持参数也是一致的，如果指定容器<br>名字是，容器已经存在会报错,可以增加 –rm 参数实现容器退出时自动删除。</p>
<p>运行示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker create -it --rm --name centos6_container centos:centos6</div></pre></td></tr></table></figure></p>
<h3 id="查看容器列表"><a href="#查看容器列表" class="headerlink" title="查看容器列表"></a>查看容器列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker ps</div></pre></td></tr></table></figure>
<p>docker ps 命令会列出所有运行中的容器。这隐藏了非运行态容器的存在，如果想要找出这些容器，增加 -a 参数。</p>
<h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker rmi &lt;image-id&gt;</div></pre></td></tr></table></figure>
<p>删除构成镜像的一个只读层。你只能够使用docker rmi来移除最顶层（top level layer）<br>（也可以说是镜像），你也可以使用-f参数来强制删除中间的只读层。</p>
<h3 id="commit容器"><a href="#commit容器" class="headerlink" title="commit容器"></a>commit容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker commit &lt;container-id&gt;</div></pre></td></tr></table></figure>
<p>将容器的可读写层转换为一个只读层，这样就把一个容器转换成了不可变的镜像。</p>
<h3 id="镜像保存"><a href="#镜像保存" class="headerlink" title="镜像保存"></a>镜像保存</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker save &lt;image-id&gt;</div></pre></td></tr></table></figure>
<p>创建一个镜像的压缩文件，这个文件能够在另外一个主机的Docker上使用。和export命令不同，这个命令<br>为每一个层都保存了它们的元数据。这个命令只能对镜像生效。</p>
<p>使用示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#保存centos镜像到centos_images.tar 文件</div><div class="line">$ docker save  -o centos_images.tar centos:centos6</div><div class="line"></div><div class="line">＃或者直接重定向</div><div class="line">$ docker save  -o centos_images.tar centos:centos6 &gt; centos_images.tar</div></pre></td></tr></table></figure></p>
<h3 id="容器导出"><a href="#容器导出" class="headerlink" title="容器导出"></a>容器导出</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker export &lt;container-id&gt;</div></pre></td></tr></table></figure>
<p>创建一个tar文件，并且移除了元数据和不必要的层，将多个层整合成了一个层，只保存了当前统一视角看到<br>的内容。expoxt后的容器再import到Docker中，只有一个容器当前状态的镜像；而save后的镜像则不同，<br>它能够看到这个镜像的历史镜像。</p>
<h3 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">docker inspect &lt;container-id&gt; or &lt;image-id&gt;</div></pre></td></tr></table></figure>
<p>docker inspect命令会提取出容器或者镜像最顶层的元数据</p>
<p>ref:<br><a href="https://www.cnblogs.com/SzeCheng/p/6822905.html" target="_blank" rel="external">https://www.cnblogs.com/SzeCheng/p/6822905.html</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-安装</title>
    <url>/2017/10/01/Docker-%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>本文环境 Ubuntu 16.04 LTS</p>
<a id="more"></a>
<h2 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h2><p>Docker 要求 Ubuntu 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的 Ubuntu 版本是否支持 Docker。</p>
<p>通过 uname -r 命令查看你当前的内核版本<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">runoob@runoob:~$ uname -r</div></pre></td></tr></table></figure></p>
<h2 id="使用脚本安装-Docker"><a href="#使用脚本安装-Docker" class="headerlink" title="使用脚本安装 Docker"></a>使用脚本安装 Docker</h2><h3 id="获取最新版本的-Docker-安装包"><a href="#获取最新版本的-Docker-安装包" class="headerlink" title="获取最新版本的 Docker 安装包"></a>获取最新版本的 Docker 安装包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">runoob@runoob:~$ wget -qO- https://get.docker.com/ | sh</div></pre></td></tr></table></figure>
<p>如果上述资源不可用, 可以尝试国内资源<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">curl -sSL https://get.daocloud.io/docker | sh</div></pre></td></tr></table></figure></p>
<p>安装体验版或测试版，体验最新Docker。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">curl -sSL https://get.daocloud.io/docker-experimental | sh</div><div class="line">curl -sSL https://get.daocloud.io/docker-test | sh</div></pre></td></tr></table></figure></p>
<p>安装完成后有个提示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> If you would like to use Docker as a non-root user, you should now consider</div><div class="line"> adding your user to the &quot;docker&quot; group with something like:</div><div class="line"></div><div class="line"> sudo usermod -aG docker runoob</div><div class="line">Remember that you will have to log out and back in for this to take effect!</div></pre></td></tr></table></figure></p>
<p>当要以非root用户可以直接运行docker时，需要执行 sudo usermod -aG docker runoob 命令，然后重新登陆，否则会有如下报错</p>
<h3 id="离线安装-Docker"><a href="#离线安装-Docker" class="headerlink" title="离线安装 Docker"></a>离线安装 Docker</h3><p>根据自己的操作系统在下载列表中下载相应的 Docker 离线包，然后在终端中运行下面的命令安装 Docker。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tar -zxvf docker-offline-17.09.1-ce-&lt;operating-system&gt;.tar.gz</div><div class="line">cd docker-offline-17.09.1-ce-&lt;operating-system&gt;</div><div class="line">sudo chmod +x install.sh</div><div class="line">sudo bash install.sh</div></pre></td></tr></table></figure></p>
<h3 id="卸载Docker"><a href="#卸载Docker" class="headerlink" title="卸载Docker"></a>卸载Docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo apt-get remove docker docker-engine</div></pre></td></tr></table></figure>
<p>卸载Docker后,/var/lib/docker/目录下会保留原Docker的镜像,网络,存储卷等文件. 如果需要全新安装Docker,需要删除/var/lib/docker/目录</p>
<h3 id="启动docker-后台服务"><a href="#启动docker-后台服务" class="headerlink" title="启动docker 后台服务"></a>启动docker 后台服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">runoob@runoob:~$ sudo service docker start</div></pre></td></tr></table></figure>
<h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。" target="_blank" rel="external">http://hub-mirror.c.163.com。</a></p>
<p>新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。</p>
<p>请在该配置文件中加入（没有该文件的话，请先建一个）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ref:<br><a href="http://get.daocloud.io/#install-docker" target="_blank" rel="external">http://get.daocloud.io/#install-docker</a><br><a href="https://download.daocloud.io/Docker_Mirror/Docker" target="_blank" rel="external">https://download.daocloud.io/Docker_Mirror/Docker</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-regularExpression</title>
    <url>/2017/10/01/Java-regularExpression/</url>
    <content><![CDATA[<p>Java 正则表达</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>正则表达式通常用于两种功能：验证和搜索/替换。用于验证时，通常需要在前后分别加上^和$，以匹配整个待验证字符串。<br>java正则表达式通过java.util.regex包下的Pattern类与Matcher类实现。</p>
<ul>
<li>java.util.regex.Pattern 模式类：用来表示一个编译过的正则表达式</li>
<li>java.util.regex.Matcher 匹配类：用模式匹配一个字符串所得到的结果</li>
</ul>
<p>字符串的正则表达式必须首先被编译为Pattern的实例。然后，可将得到的模式用于创建 Matcher 对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">String str = &quot;abc123&quot;;</div><div class="line">String regex = &quot;^[a-z]+[0-9]*&quot;;</div><div class="line">Pattern p = Pattern.compile(regex);</div><div class="line">Matcher matcher = p.matcher(str);</div></pre></td></tr></table></figure>
<h2 id="Pattern类"><a href="#Pattern类" class="headerlink" title="Pattern类"></a>Pattern类</h2><p>pattern 对象是一个正则表达式的编译表示，要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。<br>public static Pattern compile(String regex, int flags);静态方法可以指定pattern对象的编译模式，常见模式：</p>
<ul>
<li>CASE<em>INSENSITIVE：大小写不敏感
</em>- MULTILINE：多行模式<br>_ LITERAL：模式字面值分析</li>
</ul>
<h2 id="Matcher类"><a href="#Matcher类" class="headerlink" title="Matcher类"></a>Matcher类</h2><p>Matcher类提供如下三个匹配操作方法,三个方法均返回boolean类型,当匹配到时返回true,没匹配到则返回false</p>
<ul>
<li>matches 方法尝试将整个输入序列与该模式匹配</li>
<li>lookingAt 尝试将输入序列从头开始与该模式匹配</li>
<li>find 方法扫描输入序列以查找与该模式匹配的下一个子序列。</li>
</ul>
<p>下面分别用示例分别解释每种方法：</p>
<h3 id="matcher-matches-方法"><a href="#matcher-matches-方法" class="headerlink" title="matcher.matches()方法"></a>matcher.matches()方法</h3><p>对整个字符串进行匹配,只有整个字符串都匹配了才返回true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(&quot;\\d+&quot;);</div><div class="line">Matcher m=p.matcher(&quot;22bb23&quot;);</div><div class="line">m.matches();//返回false,因为bb不能被\d+匹配, 导致整个字符串匹配未成功.</div></pre></td></tr></table></figure>
<h3 id="matcher-lookingAt-方法"><a href="#matcher-lookingAt-方法" class="headerlink" title="matcher.lookingAt()方法"></a>matcher.lookingAt()方法</h3><p>对前面的字符串进行匹配,只有匹配到的字符串在最前面才返回true</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(&quot;\\d+&quot;);</div><div class="line">Matcher m=p.matcher(&quot;22bb23&quot;);</div><div class="line">m.lookingAt();//返回true,因为\d+匹配到了前面的22Matcher</div><div class="line">m2=p.matcher(&quot;aa2223&quot;);</div><div class="line">m2.lookingAt();//返回false,因为\d+不能匹配前面的aa</div></pre></td></tr></table></figure>
<p>##*# matcher.find()方法<br>对字符串进行匹配,匹配到的字符串可以在任何位置，另外find可以传入参数i表示匹配的起始位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(&quot;\\d+&quot;);</div><div class="line">Matcher m=p.matcher(&quot;22bb23&quot;);</div><div class="line">m.find();//返回true </div><div class="line">Matcher m2=p.matcher(&quot;aa2223&quot;);</div><div class="line">m2.find();//返回true </div><div class="line">Matcher m4=p.matcher(&quot;aabb&quot;);</div><div class="line">m4.find();//返回false</div></pre></td></tr></table></figure>
<p>在使用完上述三个方法以后，就可以使用.Mathcer.start()/ Matcher.end()/ Matcher.group()方法获取更详细的信息。</p>
<p>start()返回匹配到的子字符串在字符串中的索引位置<br>end()返回匹配到的子字符串的最后一个字符在字符串中的索引位置，最后一个字符的下标加1<br>group()返回匹配到的子字符串 （带参数表示第几组）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Pattern p=Pattern.compile(&quot;\\d+&quot;);</div><div class="line">Matcher m2= p.matcher(&quot;aa2223ddd&quot;);</div><div class="line">m2.find();//使用之后才能使用后面几个方法</div><div class="line">m2.start();//2  匹配到“2223”</div><div class="line">m2.end();//6</div><div class="line">m2.group();//&quot;2223&quot;</div></pre></td></tr></table></figure>
<h2 id="组的概念"><a href="#组的概念" class="headerlink" title="组的概念"></a>组的概念</h2><p>组是用括号划分的正则表达式，可以通过编号来引用组。组号从0开始，有几对小括号就表示有几个组，并且组可以嵌套。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">A((B)C)(D)E正则式中有四组：组0是ABCDE，组1是BC，组2是B；组3是C，组4是D。（顺序从最左边括号开始计算,第0组默认是全部字符串）</div></pre></td></tr></table></figure>
<p>start(),end(),group()均有一个重载方法它们是start(int i),end(int i),group(int i)专用于分组操作,Mathcer类还有一个groupCount()用于返回有多少组.<br>注意，只有使用了前面三个检测方法返回true后才可以使用上述三个详细方法，否则会引发一个IllegalStateException。</p>
<h2 id="替换操作"><a href="#替换操作" class="headerlink" title="替换操作"></a>替换操作</h2><p>常用替换方法如下：</p>
<ul>
<li>replaceFirst(String replacement)将字符串里，第一个与模式相匹配的子串替换成replacement</li>
<li>replaceAll(String replacement)，将输入字符串里所有与模式相匹配的子串全部替换成replacement。</li>
<li>appendReplacement(StringBuffer sb, String replacement) 将当前匹配子串替换为指定字符串，并且将替换后的子串以及其之前到上次匹配子串之后的字符串段添加到一个 StringBuffer 对象里</li>
<li>appendTail(StringBuffer sb) 方法则将最后一次匹配工作后剩余的字符串添加到一个 StringBuffer 对象里。</li>
</ul>
<h3 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">String regex = &quot;\\w(\\d\\d)(\\w+)&quot;;</div><div class="line">String candidate = &quot;x99SuperJava x98SuperJava&quot;;</div><div class="line">while(m.find)&#123;</div><div class="line">    int gc = matcher.groupCount();</div><div class="line">    for (int i = 0; i &lt;= gc; i++) &#123;    </div><div class="line">        System.out.println(&quot;group: &quot; + i + &quot;: &quot; + matcher.group(i));</div><div class="line">    &#125;</div><div class="line">    //从当前位置开始匹配，找到一个匹配的子串，将移动下次匹配的位置。</div><div class="line"></div><div class="line">    //或者以下方式, 个人觉得方便, 如果不需要知道具体 group 的话</div><div class="line">    System.out.println(matcher.group());</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意调用matches、lookAt、find进行匹配以后，无论成功失败，第二次匹配的位置都会改变，matcher.reset()可以重置会起始位置。</p>
<h2 id="在正则特殊性"><a href="#在正则特殊性" class="headerlink" title="\在正则特殊性"></a>\在正则特殊性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">根据 Java Language Specification 的要求，Java 源代码的字符串中的反斜线被解释为 Unicode 转义或其他字符转义。因此必须在字符串字面值中使用两个反斜线，表示正则表达式受到保护，不被 Java 字节码编译器解释。</div></pre></td></tr></table></figure>
<p>在正则表达式中有两类在java中使用需要\ \ 进行特殊保护处理（两个\ \目的就是消除其在字面值中的转义作用，转换为普通的\）</p>
<p>_- 一类是如\w(括下划线的任何单词字符)、\s（匹配任何空白字符）本身规定中含有\，其在java中写法就是“\ \w”</p>
<ul>
<li>第二类自身是正则表达式的特殊字符比如？. * () 这类特殊字符如果想用其本身代表的含义需要用\ 进行转义（正则表达式中的规定和java字符串中字母值中转义重叠，所以为了消除字面量中的转义用两个\ \将其转换为普通的\），其在java中使用“\ ?”如果没有转义\则会当做特殊字符处理（java编译期间会校验\后面是否可以字面值转义）</li>
<li>最后最特殊的\本身也是特殊字符，在java正则里面需要”\ \ \ \”才能展示</li>
</ul>
<p>ref:<br><a href="https://www.jianshu.com/p/07375050ae93" target="_blank" rel="external">https://www.jianshu.com/p/07375050ae93</a></p>
<p>java正则表达式语法参考<br><a href="http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_blank" rel="external">http://docs.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html</a><br><a href="http://josh-persistence.iteye.com/blog/1881270" target="_blank" rel="external">http://josh-persistence.iteye.com/blog/1881270</a><br><a href="http://blog.jobbole.com/63398/" target="_blank" rel="external">http://blog.jobbole.com/63398/</a><br>参考博客<br><a href="http://a52071453.iteye.com/blog/1693040" target="_blank" rel="external">http://a52071453.iteye.com/blog/1693040</a><br><a href="http://josh-persistence.iteye.com/blog/1881270" target="_blank" rel="external">http://josh-persistence.iteye.com/blog/1881270</a><br><a href="http://www.voidcn.com/blog/zhoumingsong123/article/p-4417764.html" target="_blank" rel="external">http://www.voidcn.com/blog/zhoumingsong123/article/p-4417764.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>regularExpression</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Mint-reset-panel</title>
    <url>/2017/10/01/Linux-Mint-reset-panel/</url>
    <content><![CDATA[<p>here is the tutorial for resetting your panel menu in Linux Mint</p>
<a id="more"></a>
<p>so what you all have to do are :</p>
<ol>
<li><p>Open up your terminal (ctrl+alt+t)</p>
</li>
<li><p>Run the following command in the terminal:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gsettings reset-recursively org.cinnamon (THIS IS FOR CINNAMON)</div><div class="line">gsettings reset-recursively org.mate.panel (THIS IS FOR MATE)</div></pre></td></tr></table></figure>
</li>
<li><p>Hit Enter</p>
</li>
<li>Taraa!!! you should have your panel back to their default again.</li>
</ol>
<p>NOTE :</p>
<ul>
<li>you may login out and login in again to get them work again, in some cases you need to reboot your system.</li>
<li>tested and worked on my MATE Dekstop Envir</li>
</ul>
<p>ref:<br><a href="https://community.linuxmint.com/tutorial/view/2195" target="_blank" rel="external">https://community.linuxmint.com/tutorial/view/2195</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Pycharm-创建Flask项目</title>
    <url>/2017/10/01/Pycharm-%E5%88%9B%E5%BB%BAFlask%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>Pycharm 创建Flask项目</p>
<a id="more"></a>
<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p><img src="001.jpg" alt="001.jpg"><br>如图, 1处填写项目名, 2处填写venv环境</p>
<h2 id="确认虚拟环境"><a href="#确认虚拟环境" class="headerlink" title="确认虚拟环境"></a>确认虚拟环境</h2><p><img src="001.jpg" alt="001.jpg"><br>在Terminal中，先检查是否为（venv）的虚拟环境标识</p>
<h2 id="创建依赖更新文件"><a href="#创建依赖更新文件" class="headerlink" title="创建依赖更新文件"></a>创建依赖更新文件</h2><p>再虚拟环境的命令行下输入pip freeze &gt; requirements.txt，请确保每次更新包依赖后重新更新此文件，即重新执行本命令。</p>
<h2 id="安装Flask"><a href="#安装Flask" class="headerlink" title="安装Flask"></a>安装Flask</h2><p>在Terminal 下输入<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pip install flask</div></pre></td></tr></table></figure></p>
<p>ps: 在每次更新包依赖时记得更新依赖文件</p>
<h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><p><img src="003.jpg" alt="003.jpg"><br>Flask 项目有4个顶级文件夹：</p>
<ul>
<li>app ——(本例中是 jbox）Flask 程序保存在此文件夹中</li>
<li>migrations ——包含数据库迁移脚本（安装了 flask-migrate 后自动生成）</li>
<li>tests ——单元测试放在此文件夹下</li>
<li>venv ——Python 虚拟环境</li>
</ul>
<p>同时还有一些文件：</p>
<ul>
<li>requirements.txt —— 列出了所有的依赖包，以便于在其他电脑中重新生成相同的环境</li>
<li>config.py 存储配置</li>
<li>manage.py 启动程序或者其他任务</li>
<li>gun.conf Gunicorn 配置文件</li>
</ul>
<h2 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">##config.py</div><div class="line"></div><div class="line">import os</div><div class="line"></div><div class="line">basedir = os.path.abspath(os.path.dirname(__file__))</div><div class="line"></div><div class="line"></div><div class="line">class Config:</div><div class="line">    SECRET_KEY = os.environ.get(&apos;SECRET_KEY&apos;) or &apos;hard to guess string&apos;</div><div class="line">    SQLALCHEMY_COMMIT_ON_TEARDOWN = True</div><div class="line">    FLASKY_MAIL_SUBJECT_PREFIX = &apos;[Flasky]&apos;</div><div class="line">    FLASKY_MAIL_SENDER = &apos;Flasky Admin &lt;flasky&gt;@example.com&apos;</div><div class="line">    FLASKY_ADMIN = os.environ.get(&apos;FLASKY_ADMIN&apos;)</div><div class="line"></div><div class="line">    @staticmethod</div><div class="line">    def init_app(app):</div><div class="line">        pass</div><div class="line"></div><div class="line"></div><div class="line"># 开发环境配置</div><div class="line">class DevelopmentConfig(Config):</div><div class="line">    DEBUG = True</div><div class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;DEV_DATABASE_URL&apos;) or \</div><div class="line">                              &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-dev.sqlite&apos;)</div><div class="line">    SQLALCHEMY_TRACK_MODIFICATIONS = True</div><div class="line"></div><div class="line"></div><div class="line"># 测试环境配置</div><div class="line">class TestingConfig(Config):</div><div class="line">    TESTING = True</div><div class="line">    WTF_CSRF_ENABLED = False</div><div class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;TEST_DATABASE_URL&apos;) or \</div><div class="line">                              &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data-test.sqlite&apos;)</div><div class="line">    SQLALCHEMY_TRACK_MODIFICATIONS = True</div><div class="line"></div><div class="line"></div><div class="line"># 生产环境配置</div><div class="line">class ProductionConfig(Config):</div><div class="line">    SQLALCHEMY_DATABASE_URI = os.environ.get(&apos;DATABASE_URL&apos;) or \</div><div class="line">                              &apos;sqlite:///&apos; + os.path.join(basedir, &apos;data.sqlite&apos;)</div><div class="line">    SQLALCHEMY_TRACK_MODIFICATIONS = True</div><div class="line"></div><div class="line"></div><div class="line">config = &#123;</div><div class="line">    &apos;development&apos;: DevelopmentConfig,</div><div class="line">    &apos;testing&apos;: TestingConfig,</div><div class="line">    &apos;prodection&apos;: ProductionConfig,</div><div class="line"></div><div class="line">    &apos;default&apos;: DevelopmentConfig</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>config 顾名思义，保存了一些配置变量。SQLALCHEMY_DATABASE_URI 变量在不同的配置中被赋予了不同的值，这样就可以在不同的环境中切换数据库。如果是远程数据库则从环境变量中读取 URL，否则在本地路径中创建。</p>
<p>接下来创建一个 app 文件夹，并在此文件夹中创建一个 <code>__init__.py</code> 文件（init 前后都有两个下划线）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">##app/__init__.py</div><div class="line"># coding=utf-8</div><div class="line">from flask import Flask</div><div class="line">from flask_sqlalchemy import SQLAlchemy</div><div class="line">from config import config</div><div class="line"></div><div class="line">db = SQLAlchemy()</div><div class="line"></div><div class="line"></div><div class="line">def create_app(config_name):</div><div class="line">    app = Flask(__name__)</div><div class="line">    app.config.from_object(config[config_name])</div><div class="line">    config[config_name].init_app(app)</div><div class="line"></div><div class="line">    db.init_app(app)</div><div class="line"></div><div class="line">    # 注册蓝本</div><div class="line">    # 增加auth蓝本</div><div class="line">    from .main import main as main_blueprint</div><div class="line">    app.register_blueprint(main_blueprint)</div><div class="line"></div><div class="line">    # 附加路由和自定义的错误页面</div><div class="line">    return app</div></pre></td></tr></table></figure></p>
<p>create_app() 就是程序的工厂函数，参数就是配置类的名字，即 config.py，其中保存的配置可以使用 from_object() 方法导入。</p>
<p>接下来要解释两个重要的概念——路由和视图函数。客户端把请求发给 Web 服务器，Web 服务器再把请求发给 Flask 程序实例，Flask 程序实例需要知道每个 URL 请求要运行哪些代码，所以保存了一个 URL 到 Python 函数的映射关系。处理 URL 和函数之间关系的程序称为路由，这个函数称为视图函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">from flask import render_template, jsonify</div><div class="line"># 导入蓝本 main</div><div class="line">from . import main</div><div class="line"></div><div class="line"></div><div class="line">@main.route(&apos;/&apos;)</div><div class="line">def index():</div><div class="line">    print(&quot;aaa&quot;)</div><div class="line">    return jsonify(&#123;&quot;Index&quot;: &quot;xxx&quot;&#125;)</div><div class="line"></div><div class="line"></div><div class="line">@main.route(&apos;/hello&apos;)</div><div class="line">def hello():</div><div class="line">    print(&quot;aaa&quot;)</div><div class="line">    return jsonify(&#123;&quot;Hello&quot;: &quot;xxx&quot;&#125;)</div></pre></td></tr></table></figure>
<p>这里使用 app.route 修饰器来定义路由，app 指 Flask 程序实例对象，后面可以看到使用蓝本管理路由后，由蓝本实例对象来取代 app。Flask 使用蓝本来定义路由，在蓝本中定义的路由处于休眠状态，直到蓝本注册到程序上后，路由真正成为程序的一部分。蓝本通常使用结构化的方式保存在包的多个模块中。接下来在 app 文件夹下创建一个子文件夹 main，并在 main 中创建 <strong>init</strong>.py（如果使用 PyCharm，这里有个快捷方式，右键点击 app 文件夹，在菜单中选择 new -&gt; Python Package，在弹出的对话框中填写包名然后确认即可）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">##app/main/__ init__.py</div><div class="line"></div><div class="line"># coding=utf-8</div><div class="line">from flask import Flask</div><div class="line">from flask_sqlalchemy import SQLAlchemy</div><div class="line">from config import config</div><div class="line"></div><div class="line">db = SQLAlchemy()</div><div class="line"></div><div class="line"></div><div class="line">def create_app(config_name):</div><div class="line">    app = Flask(__name__)</div><div class="line">    app.config.from_object(config[config_name])</div><div class="line">    config[config_name].init_app(app)</div><div class="line"></div><div class="line">    db.init_app(app)</div><div class="line"></div><div class="line">    # 注册蓝本</div><div class="line">    # 增加auth蓝本</div><div class="line">    from .main import main as main_blueprint</div><div class="line">    app.register_blueprint(main_blueprint)</div><div class="line"></div><div class="line">    # 附加路由和自定义的错误页面</div><div class="line">    return app</div></pre></td></tr></table></figure>
<p>现在接着来定义 errors.py:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">##app/main/errors.py</div><div class="line"></div><div class="line">from flask import render_template</div><div class="line">from . import main</div><div class="line"></div><div class="line"></div><div class="line">@main.app_errorhandler(404)</div><div class="line">def page_not_found(e):</div><div class="line">    return render_template(&apos;404.html&apos;), 404</div></pre></td></tr></table></figure>
<p>最后创建启动脚本 manage.py：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">##manage.py</div><div class="line"></div><div class="line">import os</div><div class="line">from flask_migrate import Migrate, MigrateCommand</div><div class="line">from flask_script import Manager, Shell</div><div class="line">from app import create_app, db</div><div class="line"></div><div class="line">app = create_app(os.getenv(&apos;FLASK_CONFIG&apos;) or &apos;default&apos;)</div><div class="line">manager = Manager(app)</div><div class="line">migrate = Migrate(app, db)</div><div class="line"></div><div class="line"></div><div class="line">def make_shell_context():</div><div class="line">    return dict(app=app, db=db)</div><div class="line"></div><div class="line"></div><div class="line">manager.add_command(&quot;shell&quot;, Shell(make_context=make_shell_context))</div><div class="line">manager.add_command(&quot;db&quot;, MigrateCommand)</div><div class="line"></div><div class="line"></div><div class="line">@manager.command</div><div class="line">def test():</div><div class="line">    &quot;&quot;&quot;run the unit tests.&quot;&quot;&quot;</div><div class="line">    import unittest</div><div class="line">    tests = unittest.TestLoader().discover(&apos;tests&apos;)</div><div class="line">    unittest.TextTestRunner(verbosity=2).run(tests)</div><div class="line"></div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    manager.run()</div></pre></td></tr></table></figure>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>现在就来启动我们的程序，在命令行中进入 TestProject 目录，然后执行如下命令即可运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">python manage.py runserver</div></pre></td></tr></table></figure></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><img src="004.jpg" alt="004.jpg"></p>
<p>ref:<br><a href="https://www.jianshu.com/p/cc90a14856c5" target="_blank" rel="external">https://www.jianshu.com/p/cc90a14856c5</a><br><a href="https://www.jianshu.com/p/9352b191f059" target="_blank" rel="external">https://www.jianshu.com/p/9352b191f059</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>IDE</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-Qpython-what</title>
    <url>/2017/10/01/Python-Qpython-what/</url>
    <content><![CDATA[<p>Qpython 可用于在安卓端开发编辑python脚本,结合SL4A,它可以使你的Android设备运行Python脚本或项目</p>
<a id="more"></a>
<h2 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h2><p><a href="http://www.qpython.com/" target="_blank" rel="external">http://www.qpython.com/</a></p>
<h2 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h2><p><a href="https://github.com/qpython-android/qpython3/releases" target="_blank" rel="external">https://github.com/qpython-android/qpython3/releases</a></p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="http://www.qpython.org/zhindex.html" target="_blank" rel="external">http://www.qpython.org/zhindex.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-Ctags</title>
    <url>/2017/10/01/Vim-Ctags/</url>
    <content><![CDATA[<p>Ctags 在windows 下安装</p>
<a id="more"></a>
<p>下载 <a href="http://ctags.sourceforge.net/" target="_blank" rel="external">Exuberant Ctags</a></p>
<p>下载一个支持windows的版本的，只要拷贝出ctags.exe这个文件就可以，把它放在$(home)\vim71下（也就是在vim的安装目录下找到.exe这样的文件所在的文件目录下）</p>
<p>特别重要的地方：<br>编辑_vimrc，在里面加入以下两句：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">set tags=tags; </div><div class="line">set autochdir</div></pre></td></tr></table></figure></p>
<p>注意第一个命令里的分号是必不可少的。这个命令让vim首先在当前目录里寻找tags文件，如果没有找到tags文件，或者没有找到对应的目标，就到父目录中查找，一直向上递归。因为tags文件中记录的路径总是相对于tags文件所在的路径，所以要使用第二个设置项来改变vim的当前目录。</p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
        <tag>Ctags</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-Python支持</title>
    <url>/2017/10/01/Vim-Python%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p>Vim 集成 Python 编程环境时, 需要 Python 支持, 但有的环境并不支持 python2, 而支持 python3, 所以需要配置 Vim 进行支持</p>
<a id="more"></a>
<ol>
<li>Ctrl+Alt+T 打开命令终端，输入: vim –version |grep python 查看vim是否支持python<img src="/2017/10/01/Vim-Python支持/20161029201019726.png" alt="20161029201019726.png" title="">
我这个vim只支持python3，不支持python</li>
<li>安装py2包，在命令终端下输入: sudo apt-get install vim-nox-py2</li>
<li>可以再次用vim –version|grep python 查看此时vim是否支持python，若支持到此为止，若不支持，请执行第四步。 </li>
<li>在命令终端输入:sudo update-alternatives –config vim<img src="/2017/10/01/Vim-Python支持/20161029201825239.png" alt="20161029201825239.png" title="">
我这里是第三项属于python，第二项属于python3，故想打开哪一项支持就输入它的编号就可以了（0，1，2，3）。</li>
<li>想知道Vim中使用的Python版本，你可以在编辑器中运行: python import sys; print(sys.version)</li>
</ol>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Bug-模板</title>
    <url>/2017/09/30/Bug-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>平时记录一些开发中遇到的Bug, 既可以供以后遇到相似问题时再使用解决思路, 也可从Bug中学习知识</p>
<a id="more"></a>
<p>TEMPLATE:</p>
<p>【日期】：2004-08-17 </p>
<p>【问题】：当解码 Q.931 信令时无限循环 </p>
<p>【原因】：当在Q.931信令中发现一个未知的元素id时，我们试图通过读取它的长度来跳过它，并且将位置指针迁移几个字节。但是，在这个例子中的长度是零，导致我们反复跳过相同的元素id。 </p>
<p>【怎么发现的】：在解码一个 Ethereal 从 Nortel 追踪到的安装信息时发现了这个问题。他们的信息是 1016 字节长度（包含大量快速启动元素），但我们的 MSG_MAX_LEN 是 1000。通常我们会收到一条来自 common/Communication.cxx 的信息，但现在，当直接输入需要解析的数据时，数组末端内存访问越界，其恰好是 0，暴露了这个问题。 </p>
<p>为了找到它，我仅仅在 9931 解码中添加一些打印输出。但很幸运数据恰好是零。 </p>
<p>【修复】：如果长度是零，设置为 1。这方式总是行得通。 </p>
<p>【在哪些文件修改了】：<br>callh/q931_msg.cxx<br>callh/q931_msg.cxx </p>
<p>【我导致的】：是的 </p>
<p>【解决Bug的时间】：1小时 </p>
<p>【教训】：信任收到信息中获得的数据。不仅仅是产生大量可能导致问题的数据。显示长度为 0 也同样不好。</p>
]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-LinkedList的局限</title>
    <url>/2017/09/29/Java-LinkedList%E7%9A%84%E5%B1%80%E9%99%90/</url>
    <content><![CDATA[<p>java.util.LinkedList是双向链表,这个大家都知道,比如Java的基础面试题喜欢问ArrayList和LinkedList的区别,在什么场景下用。<br>大家都会说LinkedList随机增删多的场景比较合适,而ArrayList的随机访问多的场景比较合适。<br>更进一步,我有时候会问,LinkedList.remove(Object)方法的时间复杂度是什么？有的人回答对了,有的人回答错了。回答错的应该是没有读过源码。<br>理论上说,双向链表的删除的时间复杂度是O(1),你只需要将要删除的节点的前节点和后节点相连,然后将要删除的节点的前节点和后节点置为null即可,</p>
<a id="more"></a>
<p>先看看删除操作<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Unlinks non-null node x.</div><div class="line"> */</div><div class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert x != null;</span></div><div class="line">    <span class="keyword">final</span> E element = x.item;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</div><div class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">        first = next;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        prev.next = next;</div><div class="line">        x.prev = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</div><div class="line">        last = prev;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        next.prev = prev;</div><div class="line">        x.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    x.item = <span class="keyword">null</span>;</div><div class="line">    size--;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> element;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个操作的时间复杂度可以认为是O(1)级别的。但是LinkedList的实现是一个通用的数据结构,因此没有暴露内部的节点 Node 对象,remove(Object)传入的Object其实是节点存储的value,这里还需要一个查找过程:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</div><div class="line">                unlink(x);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 查找节点 Node</span></div><div class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</div><div class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</div><div class="line">                unlink(x);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因此,显然,LinkedList.remove(Object)方法的时间复杂度是O(n)+O(1),结果仍然是O(n)的时间复杂度,而非推测的O(1)复杂度。最坏情况下要删除的元素是最后一个,你都要比较 N-1 次才能找到要删除的元素。</p>
<p>既然如此,说LinkedList适合随机删减有个前提,链表的大小不能太大,如果链表元素非常多,调用remove(Object)去删除一个元素的效率肯定有影响,一个简单测试,插入100万数据,随机删除1000个元素:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">	<span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">	<span class="keyword">final</span> <span class="keyword">int</span> count = <span class="number">1000000</span>;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">		list.add(i);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">final</span> Random rand = <span class="keyword">new</span> Random();</div><div class="line">	<span class="keyword">long</span> start = System.nanoTime();</div><div class="line">	<span class="comment">// remove(Object) 耗时 3.196757626</span></div><div class="line">	<span class="comment">/*for (int i = 0; i &lt; 1000; i++) &#123;</span></div><div class="line">		//这里要强制转型为Integer,否则调用的是remove(int)</div><div class="line">		list.remove((Integer) rand.nextInt(count));</div><div class="line">	&#125;*/</div><div class="line"></div><div class="line">	<span class="comment">// remove(int) 耗时 1.182296505</span></div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</div><div class="line">           <span class="comment">// 随机数范围要递减,防止数组越界</span></div><div class="line">		list.remove(rand.nextInt(list.size() - <span class="number">1</span>));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	System.out.println((System.nanoTime() - start) / Math.pow(<span class="number">10</span>, <span class="number">9</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在我的机器上耗时近 3.19 秒,删除1000个元素耗时 3.19 秒,耗时很长？注意到上面的注释,产生的随机数强制转为Integer对象,否则调用的是 remove(int)方法,而非remove(Object)。如果我们调用remove(int)根据索引来删除,换成remove(int)效率提高不少,这是因为 remove(int)的实现很有技巧,它首先判断索引位置在链表的前半部分还是后半部分,如果是前半部分则从head往前查找,如果在后半部分,则从 head往后查找（LinkedList的实现是一个环）:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    checkElementIndex(index);</div><div class="line">    <span class="keyword">return</span> unlink(node(index));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">    <span class="comment">// size &gt;&gt; 1 判断索引位置是前半部分还是后半部分</span></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最坏情况下要删除的节点在中点左右,查找的次数仍然达到n/2次,但是注意到这里没有比较的开销,并且比remove(Object)最坏情况下n次查找还是好很多。</p>
<p>总结下,LinkedList的两个remove方法,remove(Object)和remove(int)的时间复杂度都是O(n),在链表元素很多并且没有索引可用的情况下,LinkedList也并不适合做随机增删元素。在对性能特别敏感的场景下,还是需要自己实现专用的双向链表结构,真正实现 O(1)级别的随机增删。更进一步,jdk5引入的ConcurrentLinkedQueue是一个非阻塞的线程安全的双向队列实现,同样有本文提到的问题,有兴趣可以测试一下在大量元素情况下的并发随机增删,效率跟自己实现的特定类型的线程安全的链表差距是惊人的。</p>
<p>题外,ArrayList比LinkedList更不适合随机增删的原因是多了一个数组移动的动作,假设你删除的元素在m,那么除了要查找m次之外,还需要往前移动 n-m-1 个元素。</p>
<p>ref:<br><a href="http://jm.taobao.org/2010/09/16/322/" target="_blank" rel="external">http://jm.taobao.org/2010/09/16/322/</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>linklist</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Thread-线程池的分析和使用</title>
    <url>/2017/09/29/Java-Thread-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>合理利用线程池能够带来三个好处:</p>
<ol>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时,任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源,如果无限制的创建,不仅会消耗系统资源,还会降低系统的稳定性,使用线程池可以进行统一的分配,调优和监控。但是要做到合理的利用线程池,必须对其原理了如指掌。</li>
</ol>
<a id="more"></a>
<h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过ThreadPoolExecutor来创建一个线程池<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, </div><div class="line">                    maximumPoolSize, </div><div class="line">                    keepAliveTime, </div><div class="line">                    milliseconds,</div><div class="line">                    runnableTaskQueue, </div><div class="line">                    threadFactory,</div><div class="line">                    handler);</div></pre></td></tr></table></figure></p>
<p>创建一个线程池需要输入几个参数:</p>
<ul>
<li>corePoolSize(线程池的基本大小):当提交一个任务到线程池时,线程池会创建一个线程来执行任务,即使其他空闲的基本线程能够执行新任务也会创建线程,等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法,线程池会提前创建并启动所有基本线程。</li>
<li><p>runnableTaskQueue(任务队列):用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p>
<ul>
<li>ArrayBlockingQueue:是一个基于数组结构的有界阻塞队列,此队列按 FIFO(先进先出)原则对元素进行排序。</li>
<li>LinkedBlockingQueue:一个基于链表结构的阻塞队列,此队列按FIFO (先进先出) 排序元素,吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue:一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作,否则插入操作一直处于阻塞状态,吞吐量通常要高于LinkedBlockingQueue,静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue:一个具有优先级得无限阻塞队列。</li>
</ul>
</li>
<li><p>maximumPoolSize(线程池最大大小):线程池允许创建的最大线程数。如果队列满了,并且已创建的线程数小于最大线程数,则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</p>
</li>
<li>ThreadFactory:用于设置创建线程的工厂,可以通过线程工厂给每个创建出来的线程设置更有意义的名字,Debug和定位问题时非常又帮助。</li>
<li><p>RejectedExecutionHandler(饱和策略):当队列和线程池都满了,说明线程池处于饱和状态,那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy,表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。</p>
<ul>
<li>AbortPolicy:直接抛出异常。</li>
<li>CallerRunsPolicy:只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy:丢弃队列里最近的一个任务,并执行当前任务。</li>
<li>DiscardPolicy:不处理,丢弃掉。</li>
<li>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li>
</ul>
</li>
<li><p>keepAliveTime(线程活动保持时间):线程池的工作线程空闲后,保持存活的时间。所以如果任务很多,并且每个任务执行的时间比较短,可以调大这个时间,提高线程的利用率。</p>
</li>
<li>TimeUnit(线程活动保持时间的单位):可选的单位有天(DAYS),小时(HOURS),分钟(MINUTES),毫秒(MILLISECONDS),微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</li>
</ul>
<h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>我们可以使用execute提交的任务,但是execute方法没有返回值,所以无法判断任务知否被线程池执行成功。通过以下代码可知execute方法输入的任务是一个Runnable类的实例。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="comment">// TODO Auto-generated method stub  </span></div><div class="line">    &#125;  </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们也可以使用submit 方法来提交任务,它会返回一个future,那么我们可以通过这个future来判断任务是否执行成功,通过future的get方法来获取返回值,get方法会阻塞住直到任务完成,而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回,这时有可能任务没有执行完。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">     Object s = future.get();</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    <span class="comment">// 处理中断异常</span></div><div class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">    <span class="comment">// 处理无法执行任务异常</span></div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    <span class="comment">// 关闭线程池</span></div><div class="line">    executor.shutdown();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p>我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池,它们的原理是遍历线程池中的工作线程,然后逐个调用线程的interrupt方法来中断线程,所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别,shutdownNow首先将线程池的状态设置成STOP,然后尝试停止所有的正在执行或暂停任务的线程,并返回等待执行任务的列表,而shutdown只是将线程池的状态设置成SHUTDOWN状态,然后中断所有没有正在执行任务的线程。</p>
<p>只要调用了这两个关闭方法的其中一个,isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功,这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池,应该由提交到线程池的任务特性决定,通常调用shutdown来关闭线程池,如果任务不一定要执行完,则可以调用shutdownNow。</p>
<h2 id="线程池的分析"><a href="#线程池的分析" class="headerlink" title="线程池的分析"></a>线程池的分析</h2><p>流程分析:线程池的主要工作流程如下图:<br><img src="/2017/09/29/Java-Thread-线程池的分析和使用/threadpool.jpg" alt="threadpool.jpg" title=""></p>
<p>从上图我们可以看出,当提交一个新任务到线程池时,线程池的处理流程如下:</p>
<ol>
<li>首先线程池判断基本线程池是否已满？没满,创建一个工作线程来执行任务。满了,则进入下个流程。</li>
<li>其次线程池判断工作队列是否已满？没满,则将新提交的任务存储在工作队列里。满了,则进入下个流程。</li>
<li>最后线程池判断整个线程池是否已满？没满,则创建一个新的工作线程来执行任务,满了,则交给饱和策略来处理这个任务。</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>上面的流程分析让我们很直观的了解了线程池的工作原理,让我们再通过源代码来看看是如何实现的。线程池执行任务的方法如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">//如果线程数小于基本线程数,则创建线程并执行当前任务 </span></div><div class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</div><div class="line">        <span class="comment">//如线程数大于等于基本线程数或线程创建失败,则将当前任务放到工作队列中。</span></div><div class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</div><div class="line">                      ensureQueuedTaskHandled(command);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果线程池不处于运行中或任务无法放入队列,并且当前线程数量小于最大允许的线程数量,则创建一个线程执行任务。</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</div><div class="line">            <span class="comment">//抛出RejectedExecutionException异常</span></div><div class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h3><p>线程池创建线程时,会将线程封装成工作线程Worker,Worker在执行完任务后,还会无限循环获取工作队列里的任务来执行。我们可以从Worker的run方法里看到这点:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Runnable task = firstTask;</div><div class="line">        firstTask = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">             runTask(task);</div><div class="line">             task = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">         workerDone(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="合理的配置线程池"><a href="#合理的配置线程池" class="headerlink" title="合理的配置线程池"></a>合理的配置线程池</h2><p>要想合理的配置线程池,就必须首先分析任务特性,可以从以下几个角度来进行分析:</p>
<ul>
<li>任务的性质:CPU密集型任务,IO密集型任务和混合型任务。</li>
<li>任务的优先级:高,中和低。</li>
<li>任务的执行时间:长,中和短。</li>
<li>任务的依赖性:是否依赖其他系统资源,如数据库连接。</li>
</ul>
<p>任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程,如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务,则配置尽可能多的线程,如2*Ncpu。混合型的任务,如果可以拆分,则将其拆分成一个CPU密集型任务和一个IO密集型任务,只要这两个任务执行的时间相差不是太大,那么分解后执行的吞吐率要高于串行执行的吞吐率,如果这两个任务执行时间相差太大,则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行,需要注意的是如果一直有优先级高的任务提交到队列里,那么优先级低的任务可能永远不能执行。</p>
<p>执行时间不同的任务可以交给不同规模的线程池来处理,或者也可以使用优先级队列,让执行时间短的任务先执行。</p>
<p>依赖数据库连接池的任务,因为线程提交SQL后需要等待数据库返回结果,如果等待的时间越长CPU空闲时间就越长,那么线程数应该设置越大,这样才能更好的利用CPU。</p>
<p>建议使用有界队列,有界队列能增加系统的稳定性和预警能力,可以根据需要设大一点,比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了,不断的抛出抛弃任务的异常,通过排查发现是数据库出现了问题,导致执行SQL变得非常缓慢,因为后台任务线程池里的任务全是需要向数据库查询和插入数据的,所以导致线程池里的工作线程全部阻塞住,任务积压在线程池里。如果当时我们设置成无界队列,线程池的队列就会越来越多,有可能会撑满内存,导致整个系统不可用,而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的,而我们使用不同规模的线程池跑不同类型的任务,但是出现这样问题时也会影响到其他任务。</p>
<h2 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h2><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p>
<ul>
<li>taskCount:线程池需要执行的任务数量。</li>
<li>completedTaskCount:线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li>
<li>largestPoolSize:线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小,则表示线程池曾经满了。</li>
<li>getPoolSize:线程池的线程数量。如果线程池不销毁的话,池里的线程不会自动销毁,所以这个大小只增不减</li>
<li>getActiveCount:获取活动的线程数。</li>
</ul>
<p>通过扩展线程池进行监控。通过继承线程池并重写线程池的beforeExecute,afterExecute和terminated方法,我们可以在任务执行前,执行后和线程池关闭前干一些事情。如监控任务的平均执行时间,最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java并发编程实战。<br>JDK1.6源码</p>
<p>ref:<br><a href="http://www.infoq.com/cn/articles/java-threadPool" target="_blank" rel="external">http://www.infoq.com/cn/articles/java-threadPool</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask-PyCharm-HelloWorld</title>
    <url>/2017/09/28/Flask-PyCharm-HelloWorld/</url>
    <content><![CDATA[<p>今天讲讲使用Pycharm写一个Hello World</p>
<a id="more"></a>
<h2 id="创建Flask项目"><a href="#创建Flask项目" class="headerlink" title="创建Flask项目"></a>创建Flask项目</h2><img src="/2017/09/28/Flask-PyCharm-HelloWorld/1147362-20170502132217961-192322010.png" alt="1147362-20170502132217961-192322010.png" title="">
<p>点击创建虚拟环境<br><img src="/2017/09/28/Flask-PyCharm-HelloWorld/1147362-20170502132322507-1468734691.png" alt="1147362-20170502132322507-1468734691.png" title=""><br>输入venv名字，选择存放路径<br><img src="/2017/09/28/Flask-PyCharm-HelloWorld/1147362-20170502132335148-1111821164.png" alt="1147362-20170502132335148-1111821164.png" title=""><br>ps: venv 不宜放在项目目录, 这样pycharm 不能自动生成项目代码<br>注意提示内容，点击Create创建项目<br><img src="/2017/09/28/Flask-PyCharm-HelloWorld/1147362-20170502132422226-101963808.png" alt="1147362-20170502132422226-101963808.png" title=""></p>
<h2 id="敲击代码写Hello-World"><a href="#敲击代码写Hello-World" class="headerlink" title="敲击代码写Hello World"></a>敲击代码写Hello World</h2><p>你以为还要自己写代码吗？天真，Pycharm早就给你做好模板了哈哈，就差运行了<br><img src="/2017/09/28/Flask-PyCharm-HelloWorld/1147362-20170502132711773-1966944999.png" alt="1147362-20170502132711773-1966944999.png" title=""><br>运行项目<br><img src="/2017/09/28/Flask-PyCharm-HelloWorld/1147362-20170502133147476-374044575.png" alt="1147362-20170502133147476-374044575.png" title=""><br>查看结果<br><img src="/2017/09/28/Flask-PyCharm-HelloWorld/1147362-20170502133311820-360688493.png" alt="1147362-20170502133311820-360688493.png" title=""></p>
<p>ref: <a href="https://www.cnblogs.com/wongbingming/p/6795725.html" target="_blank" rel="external">https://www.cnblogs.com/wongbingming/p/6795725.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-m参数</title>
    <url>/2017/09/28/Python-m%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>python xxx.py和python -m xxx.py有什么区别?</p>
<a id="more"></a>
<h2 id="m-作用"><a href="#m-作用" class="headerlink" title="-m 作用"></a>-m 作用</h2><p>python -m xxx.py 作用是把 xxx.py 文件当做模块启动<br>man python 查看 python 文档<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-m module-name</div><div class="line">    Searches sys.path for the named module and runs the corresponding .py file as a script.</div></pre></td></tr></table></figure></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li>python xxx.py</li>
<li>python -m xxx.py</li>
</ol>
<p>这是两种加载py文件的方式:<br>1叫做直接运行<br>2把模块当作脚本来启动(注意：但是<strong>name</strong>的值为’main’ )</p>
<p><strong>不同的加载py文件的方式，主要是影响——sys.path 这个属性。sys.path 就相当于liunx中的PATH。</strong></p>
<p>下面来看一下sys.path<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</div><div class="line">[<span class="string">''</span>, <span class="string">'/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python27.zip'</span>,  </div><div class="line">...]</div></pre></td></tr></table></figure></p>
<p>上面的内容我只截取了一段。此为当前python解释器运行的环境，python解释器会在这些目录下去寻找依赖的库!<br>注解一点：‘’’——为当前目录</p>
<p>下面有两个例子，通过不同方式启动同一文件，sys.path属性的值有何不同。<br>run.py 内容如下:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line">print(sys.path)</div></pre></td></tr></table></figure></p>
<p>直接启动：python run.py<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">test_import_project git:(master) ✗ python run.py</div><div class="line">[<span class="string">'/Users/sx/Documents/note/test_py/test_import_project'</span>,  </div><div class="line"> <span class="string">'/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python27.zip'</span>,  </div><div class="line">  ...]</div></pre></td></tr></table></figure></p>
<p>以模块方式启动：python -m run.py<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">test_import_project git:(master) ✗ python -m run.py</div><div class="line">[<span class="string">''</span>,  </div><div class="line"> <span class="string">'/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python27.zip'</span>,</div></pre></td></tr></table></figure></p>
<p><strong> 细心的同学会发现，区别就是在第一行。直接启动是把run.py文件，所在的目录放到了sys.path属性中。模块启动是把你输入命令的目录（也就是当前路径），放到了sys.path属性中</strong></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>目录结构如下<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">package/</div><div class="line">    __init__.py</div><div class="line">    mod1.py</div><div class="line">package2/</div><div class="line">    __init__.py</div><div class="line">    run.py</div></pre></td></tr></table></figure></p>
<p>run.py 内容如下<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">from</span> package <span class="keyword">import</span> mod1</div><div class="line">print(sys.path)</div></pre></td></tr></table></figure></p>
<p>如何才能启动run.py文件？<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># 直接启动（失败）</span></div><div class="line">➜  test_import_project git:(master) ✗ python package2/run.py</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"package2/run.py"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">    <span class="keyword">from</span> package <span class="keyword">import</span> mod1</div><div class="line">ImportError: No module named package</div><div class="line"></div><div class="line"><span class="comment"># 以模块方式启动（成功）</span></div><div class="line">➜  test_import_project git:(master) ✗ python -m package2.run</div><div class="line">[<span class="string">''</span>,</div><div class="line"><span class="string">'/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python27.zip'</span>,</div><div class="line">...]</div></pre></td></tr></table></figure></p>
<p>当需要启动的py文件引用了一个模块。你需要注意：在启动的时候需要考虑sys.path中有没有你import的模块的路径！<br>这个时候，到底是使用直接启动，还是以模块的启动？目的就是把import的那个模块的路径放到sys.path中。你是不是明白了呢？<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">官方文档参考： http://www.pythondoc.com/pythontutorial3/modules.html</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>导入一个叫 mod1 的模块时，解释器先在当前目录中搜索名为 mod1.py 的文件。如果没有找到的话，接着会到 sys.path 变量中给出的目录列表中查找。 sys.path 变量的初始值来自如下：</p>
<p>输入脚本的目录（当前目录）。<br>环境变量 PYTHONPATH 表示的目录列表中搜索(这和 shell 变量 PATH 具有一样的语法，即一系列目录名的列表)。<br>Python 默认安装路径中搜索。<br>实际上，解释器由 sys.path 变量指定的路径目录搜索模块，该变量初始化时默认包含了输入脚本（或者当前目录）， PYTHONPATH 和安装目录。这样就允许 Python程序了解如何修改或替换模块搜索目录。</p>
<p>ref:<a href="http://www.cnblogs.com/xueweihan/p/5118222.html?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="external">http://www.cnblogs.com/xueweihan/p/5118222.html?utm_source=tuicool&amp;utm_medium=referral</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-self</title>
    <url>/2017/09/28/Python-self/</url>
    <content><![CDATA[<p>首先明确的是self只有在类的方法中才会有，独立的函数或方法是不必带有self的。self在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。</p>
<a id="more"></a>
<h2 id="self代表类的实例-而非类"><a href="#self代表类的实例-而非类" class="headerlink" title="self代表类的实例,而非类"></a>self代表类的实例,而非类</h2><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></div><div class="line">        print(self)</div><div class="line">        print(self.__class__)</div><div class="line"> </div><div class="line">t = Test()</div><div class="line">t.prt()</div></pre></td></tr></table></figure>
<p>执行结果如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;__main__.Test object at 0x000000000284E080&gt;</div><div class="line">&lt;class &apos;__main__.Test&apos;&gt;</div></pre></td></tr></table></figure></p>
<p>从上面的例子中可以很明显的看出,self代表的是类的实例。而self.class则指向类。</p>
<p>再举个栗子<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">_init_</span><span class="params">(self,name)</span>:</span></div><div class="line">          self.name=name</div><div class="line">     <span class="function"><span class="keyword">def</span> <span class="title">sayhello</span><span class="params">(self)</span>:</span></div><div class="line">          <span class="keyword">print</span> <span class="string">'My name is:'</span>,self.name</div><div class="line">p=Person(<span class="string">'Bill'</span>)</div><div class="line">p1=Person(<span class="string">'Tom'</span>)</div><div class="line"><span class="keyword">print</span> p</div><div class="line"><span class="keyword">print</span> p1</div></pre></td></tr></table></figure></p>
<p>在上述例子中，self指向Person的实例p。 为什么不是指向类本身呢，如果self指向类本身，那么当有多个实例对象时，self指向哪一个呢</p>
<h2 id="self不必非写成self"><a href="#self不必非写成self" class="headerlink" title="self不必非写成self"></a>self不必非写成self</h2><p>有很多童鞋是先学习别的语言然后学习Python的,所以总觉得self怪怪的,想写成this,可以吗？<br>当然可以,还是把上面的代码改写一下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(this)</span>:</span></div><div class="line">        print(this)</div><div class="line">        print(this.__class__)</div><div class="line"> </div><div class="line">t = Test()</div><div class="line">t.prt()</div></pre></td></tr></table></figure>
<p>改成this后,运行结果完全一样。<br>当然,最好还是尊重约定俗成的习惯,使用self。</p>
<h2 id="self可以不写吗"><a href="#self可以不写吗" class="headerlink" title="self可以不写吗"></a>self可以不写吗</h2><p>在Python的解释器内部,当我们调用t.prt()时,实际上Python解释成Test.prt(t),也就是说把self替换成类的实例。<br>有兴趣的童鞋可以把上面的t.prt()一行改写一下,运行后的实际结果完全相同。<br>实际上已经部分说明了self在定义时不可以省略,如果非要试一下,那么请看下面:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></div><div class="line">        print(self)</div><div class="line"> </div><div class="line">t = Test()</div><div class="line">t.prt()</div></pre></td></tr></table></figure></p>
<p>运行时提醒错误如下:prt在定义时没有参数,但是我们运行时强行传了一个参数。</p>
<p>由于上面解释过了t.prt()等同于Test.prt(t),所以程序提醒我们多传了一个参数t。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;h.py&quot;, line 6, in &lt;module&gt;</div><div class="line">    t.prt()</div><div class="line">TypeError: prt() takes 0 positional arguments but 1 was given</div></pre></td></tr></table></figure></p>
<p>当然,如果我们的定义和调用时均不传类实例是可以的,这就是类方法。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">()</span>:</span></div><div class="line">        print(__class__)</div><div class="line">Test.prt()</div></pre></td></tr></table></figure></p>
<p>运行结果如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;class &apos;__main__.Test&apos;&gt;</div></pre></td></tr></table></figure></p>
<h2 id="在继承时-传入的是哪个实例-就是那个传入的实例-而不是指定义了self的类的实例"><a href="#在继承时-传入的是哪个实例-就是那个传入的实例-而不是指定义了self的类的实例" class="headerlink" title="在继承时,传入的是哪个实例,就是那个传入的实例,而不是指定义了self的类的实例"></a>在继承时,传入的是哪个实例,就是那个传入的实例,而不是指定义了self的类的实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pprt</span><span class="params">(self)</span>:</span></div><div class="line">        print(self)</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Parent)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cprt</span><span class="params">(self)</span>:</span></div><div class="line">        print(self)</div><div class="line">c = Child()</div><div class="line">c.cprt()</div><div class="line">c.pprt()</div><div class="line">p = Parent()</div><div class="line">p.pprt()</div></pre></td></tr></table></figure>
<p>运行结果如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;__main__.Child object at 0x0000000002A47080&gt;</div><div class="line">&lt;__main__.Child object at 0x0000000002A47080&gt;</div><div class="line">&lt;__main__.Parent object at 0x0000000002A47240&gt;</div></pre></td></tr></table></figure></p>
<p>解释:<br>运行c.cprt()时应该没有理解问题,指的是Child类的实例。<br>但是在运行c.pprt()时,等同于Child.pprt(c),所以self指的依然是Child类的实例,由于self中没有定义pprt()方法,所以沿着继承树往上找,发现在父类Parent中定义了pprt()方法,所以就会成功调用。</p>
<h2 id="在描述符类中-self指的是描述符类的实例"><a href="#在描述符类中-self指的是描述符类的实例" class="headerlink" title="在描述符类中,self指的是描述符类的实例"></a>在描述符类中,self指的是描述符类的实例</h2><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desc</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, ins, cls)</span>:</span></div><div class="line">        print(<span class="string">'self in Desc: %s '</span> % self )</div><div class="line">        print(self, ins, cls)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    x = Desc()</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></div><div class="line">        print(<span class="string">'self in Test: %s'</span> % self)</div><div class="line">t = Test()</div><div class="line">t.prt()</div><div class="line">t.x</div></pre></td></tr></table></figure>
<p>运行结果如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">self in Test: &lt;__main__.Test object at 0x0000000002A570B8&gt;</div><div class="line">self in Desc: &lt;__main__.Desc object at 0x000000000283E208&gt;</div><div class="line">&lt;__main__.Desc object at 0x000000000283E208&gt; &lt;__main__.Test object at 0x0000000002A570B8&gt; &lt;class &apos;__main__.Test&apos;&gt;</div></pre></td></tr></table></figure></p>
<p>大部分童鞋开始有疑问了,为什么在Desc类中定义的self不是应该是调用它的实例t吗？怎么变成了Desc类的实例了呢？<br>注意:此处需要睁大眼睛看清楚了,这里调用的是t.x,也就是说是Test类的实例t的属性x,由于实例t中并没有定义属性x,所以找到了类属性x,而该属性是描述符属性,为Desc类的实例而已,所以此处并没有顶用Test的任何方法。</p>
<p>那么我们如果直接通过类来调用属性x也可以得到相同的结果。<br>下面是把t.x改为Test.x运行的结果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">self in Test: &lt;__main__.Test object at 0x00000000022570B8&gt;</div><div class="line">self in Desc: &lt;__main__.Desc object at 0x000000000223E208&gt;</div><div class="line">&lt;__main__.Desc object at 0x000000000223E208&gt; None &lt;class &apos;__main__.Test&apos;&gt;</div></pre></td></tr></table></figure></p>
<p>题外话:由于在很多时候描述符类中仍然需要知道调用该描述符的实例是谁,所以在描述符类中存在第二个参数ins,用来表示调用它的类实例,所以t.x时可以看到第三行中的运行结果中第二项为<main.test object="" at="" 0x0000000002a570b8="">。而采用Test.x进行调用时,由于没有实例,所以返回None。</main.test></p>
<h2 id="从OO的本质理解python中的self"><a href="#从OO的本质理解python中的self" class="headerlink" title="从OO的本质理解python中的self"></a>从OO的本质理解python中的self</h2><p>举个栗子，假设我要对用户的数据进行操作，用户的数据包含name和age。如果用面向过程的话，实现出来是下面这样子的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def user_init(user,name,age): </div><div class="line">  user[&apos;name&apos;] = name </div><div class="line">  user[&apos;age&apos;] = age </div><div class="line">  </div><div class="line">def set_user_name(user, x): </div><div class="line">  user[&apos;name&apos;] = x </div><div class="line">  </div><div class="line">def set_user_age(user, x): </div><div class="line">  user[&apos;age&apos;] = x </div><div class="line">  </div><div class="line">def get_user_name(user): </div><div class="line">  return user[&apos;name&apos;] </div><div class="line">  </div><div class="line">def get_user_age(user): </div><div class="line">  return user[&apos;age&apos;] </div><div class="line">  </div><div class="line">myself = &#123;&#125; </div><div class="line">user_init(myself,&apos;kzc&apos;,17) </div><div class="line">print get_user_age(myself) </div><div class="line">set_user_age(myself,20) </div><div class="line">print get_user_age(myself)</div></pre></td></tr></table></figure></p>
<p>可以看到，对用户的各种操作，都要传user参数进去。<br>如果用面向对象的话，就不用每次把user参数传来传去，把相关的数据和操作绑定在一个地方，在这个类的各个地方，可以方便的获取数据。<br>之所以可以在类中的各个地方访问数据，本质就是绑定了self这个东西，它方法的第一个参数，当然可以不叫self，叫其它名字，self只不过是个约定。<br>下面是面向对象的实现，可以看到，结构化多了，清晰可读。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span> </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span> </div><div class="line">    self.name = name </div><div class="line">    self.age = age </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">SetName</span><span class="params">(self,name)</span>:</span> </div><div class="line">    self.name = name </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">SetAge</span><span class="params">(self,age)</span>:</span> </div><div class="line">    self.age = age </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">GetName</span><span class="params">(self)</span>:</span> </div><div class="line">    <span class="keyword">return</span> self.name </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">GetAge</span><span class="params">(self)</span>:</span> </div><div class="line">    <span class="keyword">return</span> self.age </div><div class="line">  </div><div class="line">u = User(<span class="string">'kzc'</span>,<span class="number">17</span>) </div><div class="line"><span class="keyword">print</span> u.GetName() </div><div class="line"><span class="keyword">print</span> u.GetAge()</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>self在定义时需要定义,但是在调用时会自动传入。</li>
<li>self的名字并不是规定死的,但是最好还是按照约定是用self</li>
<li>self总是指调用时的类的实例。</li>
</ul>
<p>ref:<br><a href="http://python.jobbole.com/81921/" target="_blank" rel="external">http://python.jobbole.com/81921/</a><br><a href="http://www.jb51.net/article/85871.htm" target="_blank" rel="external">http://www.jb51.net/article/85871.htm</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-文件名乱码解决</title>
    <url>/2017/09/25/Linux-%E6%96%87%E4%BB%B6%E5%90%8D%E4%B9%B1%E7%A0%81%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>Windows 下正常显示的文件名, 上传到 Linux 下后, 含有中文的文件名都显示乱码</p>
<a id="more"></a>
<p>文件是在Windows下创建的，而Windows的文件名中文编码默认GBK，Linux中默认文件名编码为UTF-8，编码不一致导致了文件名乱码的问题，解决这个问题需要对文件名进行转码，这个工具就是convmv。<br>SYNOPSIS：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">convmv -f 源编码 -t 新编码 [options] FILES ... DIRECTORYS</div></pre></td></tr></table></figure></p>
<p>本人用的是openSuSE，首先安装这个工具，man convmv查看用法<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo zypper install convmv</div></pre></td></tr></table></figure></p>
<p>然后，进行转码<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">convmv -f GBK -t zh_CN.UTF-8 -r the/directory</div></pre></td></tr></table></figure></p>
<p>给出的提示显示了有意义的中文，但是ls还是没有变化！man一下，有一个选项–notest，这里不解释了，大家自己去看。</p>
<p>最后的命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">convmv -f GBK -t zh_CN.UTF-8 -r --notest the/directory</div></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>BloomFilter</title>
    <url>/2017/09/22/BloomFilter/</url>
    <content><![CDATA[<p>布隆过滤器 (Bloom Filter)是由Burton Howard Bloom于1970年提出，它是一种space efficient的概率型数据结构，用于判断一个元素是否在集合中。在垃圾邮件过滤的黑白名单方法、爬虫(Crawler)的网址判重模块中等等经常被用到。哈希表也能用于判断元素是否在集合中，但是布隆过滤器只需要哈希表的1/8或1/4的空间复杂度就能完成同样的问题。布隆过滤器可以插入元素，但不可以删除已有元素。其中的元素越多，false positive rate(误报率)越大，但是false negative (漏报)是不可能的。<br>本文将详解布隆过滤器的相关算法和参数设计，在此之前希望大家可以先通过谷歌黑板报的<a href="http://www.google.com.hk/ggblog/googlechinablog/2007/07/bloom-filter_7469.html" target="_blank" rel="external">数学之美系列二十一 － 布隆过滤器（Bloom Filter）</a>来得到些基础知识。</p>
<a id="more"></a>
<h2 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h2><p>本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。<br>相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="HashMap-的问题"><a href="#HashMap-的问题" class="headerlink" title="HashMap 的问题"></a>HashMap 的问题</h3><p>讲述布隆过滤器的原理之前，我们先思考一下，通常你判断某个元素是否存在用的是什么？应该蛮多人回答 HashMap 吧，确实可以将值映射到 HashMap 的 Key，然后可以在 O(1) 的时间复杂度内返回结果，效率奇高。但是 HashMap 的实现也有缺点，例如存储容量占比高，考虑到负载因子的存在，通常空间是不能被用满的，而一旦你的值很多例如上亿的时候，那 HashMap 占据的内存大小就变得很可观了。<br>还比如说你的数据集存储在远程服务器上，本地服务接受输入，而数据集非常大不可能一次性读进内存构建 HashMap 的时候，也会存在问题。</p>
<h3 id="布隆过滤器数据结构"><a href="#布隆过滤器数据结构" class="headerlink" title="布隆过滤器数据结构"></a>布隆过滤器数据结构</h3><p>布隆过滤器是一个 bit 向量或者说 bit 数组，长这样：<br><img src="Snipaste_20190722154518.png" alt="Snipaste_20190722154518.png"></p>
<p>如果我们要映射一个值到布隆过滤器中，我们需要使用多个不同的哈希函数生成多个哈希值，并对每个生成的哈希值指向的 bit 位置 1，例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 1、4、7，则上图转变为：<br><img src="Snipaste_20190722154649.png" alt="Snipaste_20190722154649.png"></p>
<p>Ok，我们现在再存一个值 “tencent”，如果哈希函数返回 3、4、8 的话，图继续变为：</p>
<p><img src="Snipaste_20190722154755.png" alt="Snipaste_20190722154755.png"></p>
<p>值得注意的是，4 这个 bit 位由于两个值的哈希函数都返回了这个 bit 位，因此它被覆盖了。现在我们如果想查询 “dianping” 这个值是否存在，哈希函数返回了 1、5、8三个值，结果我们发现 5 这个 bit 位上的值为 0，说明没有任何一个值映射到这个 bit 位上，因此我们可以很确定地说 “dianping” 这个值不存在。而当我们需要查询 “baidu” 这个值是否存在的话，那么哈希函数必然会返回 1、4、7，然后我们检查发现这三个 bit 位上的值均为 1，那么我们可以说 “baidu” 存在了么？答案是不可以，只能是 “baidu” 这个值可能存在。<br>这是为什么呢？答案跟简单，因为随着增加的值越来越多，被置为 1 的 bit 位也会越来越多，这样某个值 “taobao” 即使没有被存储过，但是万一哈希函数返回的三个 bit 位都被其他值置位了 1 ，那么程序还是会判断 “taobao” 这个值存在。</p>
<p>再上一个原理讲解, 个人觉得这个更清晰</p>
<p>布隆过滤器（Bloom Filter）的核心实现是一个超大的位数组和几个哈希函数。假设位数组的长度为m，哈希函数的个数为k</p>
<p><img src="Snipaste_20190724103403.png" alt="Snipaste_20190724103403.png"></p>
<p>以上图为例，具体的操作流程：假设集合里面有3个元素{x, y, z}，哈希函数的个数为3。首先将位数组进行初始化，将里面每个位都设置位0。对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1。查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点。如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合中。反之，如果3个点都为1，则该元素可能存在集合中。注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率。可以从图中可以看到：假设某个元素通过映射对应下标为4，5，6这3个点。虽然这3个点都为1，但是很明显这3个点是不同元素经过哈希得到的位置，因此这种情况说明元素虽然不在集合中，也可能对应的都是1，这是误判率存在的原因</p>
<p>添加元素</p>
<ul>
<li>将要添加的元素给k个哈希函数</li>
<li>得到对应于位数组上的k个位置</li>
<li>将这k个位置设为1</li>
</ul>
<p>查询元素</p>
<ul>
<li>将要查询的元素给k个哈希函数</li>
<li>得到对应于位数组上的k个位置</li>
<li>如果k个位置有一个为0，则肯定不在集合中</li>
<li>如果k个位置全部为1，则可能在集合中</li>
</ul>
<h3 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.BitSet;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBloomFilter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_SIZE = <span class="number">2</span> &lt;&lt; <span class="number">24</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] seeds = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">61</span>,&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> BitSet bits = <span class="keyword">new</span> BitSet(DEFAULT_SIZE);</div><div class="line">    <span class="keyword">private</span> SimpleHash[] func = <span class="keyword">new</span> SimpleHash[seeds.length];</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        String value = <span class="string">" stone2083@yahoo.cn "</span>;</div><div class="line">        SimpleBloomFilter filter = <span class="keyword">new</span> SimpleBloomFilter();</div><div class="line">        System.out.println(filter.contains(value));</div><div class="line">        filter.add(value);</div><div class="line">        System.out.println(filter.contains(value));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBloomFilter</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seeds.length; i++) &#123;</div><div class="line">            func[i] = <span class="keyword">new</span> SimpleHash(DEFAULT_SIZE, seeds[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</div><div class="line">            bits.set(f.hash(value), <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (SimpleHash f : func) &#123;</div><div class="line">            ret = ret &amp;&amp; bits.get(f.hash(value));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ret;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHash</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> cap;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> seed;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SimpleHash</span><span class="params">(<span class="keyword">int</span> cap, <span class="keyword">int</span> seed)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.cap = cap;</div><div class="line">            <span class="keyword">this</span>.seed = seed;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">            <span class="keyword">int</span> len = value.length();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</div><div class="line">                result = seed * result + value.charAt(i);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> (cap - <span class="number">1</span>) &amp; result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="支持删除么"><a href="#支持删除么" class="headerlink" title="支持删除么"></a>支持删除么</h2><p>目前我们知道布隆过滤器可以支持 add 和 isExist 操作，那么 delete 操作可以么，答案是不可以，例如上图中的 bit 位 4 被两个值共同覆盖的话，一旦你删除其中一个值例如 “tencent” 而将其置位 0，那么下次判断另一个值例如 “baidu” 是否存在的话，会直接返回 false，而实际上你并没有删除它。<br>如何解决这个问题，答案是计数删除。但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。这样的话，增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0。</p>
<h2 id="为什么布隆过滤器效率比较高"><a href="#为什么布隆过滤器效率比较高" class="headerlink" title="为什么布隆过滤器效率比较高"></a>为什么布隆过滤器效率比较高</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>添加元素时，由于不需要迭代位数组，而是简单的设置索引位的值，所以操作所花费的时间仅取决于散列函数的个数，所以对于对于k个哈希函数的布隆过滤器，添加元素的时间复杂度为O(k) 。<br>查询元素时，对于k个哈希函数的布隆过滤器，只需要在位数组中检查的索引数量有一个不变的上界，所以查询元素的时间复杂度也为O(k)。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>由于不需要存储元素，只需依赖一定长度的位数组判断是否存在，并且数组长度的大小不也取决于集合中元素的多少，可以在误判率变大或效率变低的代价下减少存储（位数组）。</p>
<h2 id="布隆过滤器有哪些缺点"><a href="#布隆过滤器有哪些缺点" class="headerlink" title="布隆过滤器有哪些缺点"></a>布隆过滤器有哪些缺点</h2><p>主要缺点是有一定的误判率和删除比较困难，所以随着存入集合的元素的增加，误判率也随之增加。误判率大小和三个指标有关：位数组长度m、集合长度n、散列函数个数k，对于给定的m、n，当 k = ln(2)* m/n 时误判率是最小的。</p>
<h2 id="如何选择哈希函数个数和布隆过滤器长度"><a href="#如何选择哈希函数个数和布隆过滤器长度" class="headerlink" title="如何选择哈希函数个数和布隆过滤器长度"></a>如何选择哈希函数个数和布隆过滤器长度</h2><p>很显然，过小的布隆过滤器很快所有的 bit 位均为 1，那么查询任何值都会返回“可能存在”，起不到过滤的目的了。布隆过滤器的长度会直接影响误报率，布隆过滤器越长其误报率越小。<br>另外，哈希函数的个数也需要权衡，个数越多则布隆过滤器 bit 位置位 1 的速度越快，且布隆过滤器的效率越低；但是如果太少的话，那我们的误报率会变高</p>
<p><img src="Snipaste_20190724093148.png" alt="Snipaste_20190724093148.png"></p>
<p>k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率。</p>
<p>如何选择适合业务的 k 和 m 值呢，这里直接贴一个公式：<br><img src="v2-1ed5b79aa7ac2e9cd66c83690fdbfcf0_hd.jpg" alt="v2-1ed5b79aa7ac2e9cd66c83690fdbfcf0_hd.jpg"></p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>既然你使用布隆过滤器来加速查找和判断是否存在，那么性能很低的哈希函数不是个好选择，推荐 MurmurHash、Fnv 这些。</p>
<h2 id="大Value拆分"><a href="#大Value拆分" class="headerlink" title="大Value拆分"></a>大Value拆分</h2><p>Redis 因其支持 setbit 和 getbit 操作，且纯内存性能高等特点，因此天然就可以作为布隆过滤器来使用。但是布隆过滤器的不当使用极易产生大 Value，增加 Redis 阻塞风险，因此生成环境中建议对体积庞大的布隆过滤器进行拆分。<br>拆分的形式方法多种多样，但是本质是不要将 Hash(Key) 之后的请求分散在多个节点的多个小 bitmap 上，而是应该拆分成多个小 bitmap 之后，对一个 Key 的所有哈希函数都落在这一个小 bitmap 上。</p>
<p>ref:<br><a href="https://www.jianshu.com/p/2104d11ee0a2" target="_blank" rel="external">https://www.jianshu.com/p/2104d11ee0a2</a><br><a href="https://www.jianshu.com/p/32ed89662d55?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="external">https://www.jianshu.com/p/32ed89662d55?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a><br><a href="https://www.jianshu.com/p/88c6ac4b38c8?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="external">https://www.jianshu.com/p/88c6ac4b38c8?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>BloomFilter</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache-缓存穿透_缓存击穿_缓存雪崩_热点数据失效</title>
    <url>/2017/09/22/Cache-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F_%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF_%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9_%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<p>本文为 缓存穿透<em>缓存击穿</em>缓存雪崩_热点数据失效 相关问题的整理和总结</p>
<a id="more"></a>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3><p>正常情况下，我们去查询数据都是存在。 那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。 这种查询不存在数据的现象我们称为缓存穿透</p>
<h3 id="穿透带来的问题"><a href="#穿透带来的问题" class="headerlink" title="穿透带来的问题"></a>穿透带来的问题</h3><p>试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。</p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="缓存空值"><a href="#缓存空值" class="headerlink" title="缓存空值"></a>缓存空值</h4><p>之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。<br>那么我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。<br>这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。</p>
<h4 id="BloomFilter"><a href="#BloomFilter" class="headerlink" title="BloomFilter"></a>BloomFilter</h4><p>BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中。<br>这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。<br>这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&gt; 查 DB</p>
<p>流程图如下：<br><img src="640.png" alt="640.png"></p>
<h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h4><p>针对于一些恶意攻击，攻击带过来的大量key 是不存在的，那么我们采用第一种方案就会缓存大量不存在key的数据。<br>此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些key。<br>针对这种key异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。<br>而对于空数据的key有限的，重复率比较高的，我们则可以采用第一种方式进行缓存。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是击穿"><a href="#什么是击穿" class="headerlink" title="什么是击穿"></a>什么是击穿</h3><p>缓存击穿是我们可能遇到的第二个使用缓存方案可能遇到的问题。<br>在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。</p>
<h3 id="会带来什么问题"><a href="#会带来什么问题" class="headerlink" title="会带来什么问题"></a>会带来什么问题</h3><p>会造成某一时刻数据库请求量过大，压力剧增</p>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。<br>其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>缓存雪崩的情况是说，当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉。</p>
<h3 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="事前"><a href="#事前" class="headerlink" title="事前"></a>事前</h4><p><strong>使用集群缓存，保证缓存服务的高可用</strong><br>这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况</p>
<h4 id="事中"><a href="#事中" class="headerlink" title="事中"></a>事中</h4><p><strong>ehcache本地缓存 + Hystrix限流&amp;降级,避免MySQL被打死</strong></p>
<p>使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。<br>使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。<br>然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死</p>
<h4 id="事后"><a href="#事后" class="headerlink" title="事后"></a>事后</h4><p><strong>开启Redis持久化机制，尽快恢复缓存集群</strong></p>
<p>一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。</p>
<p>防止雪崩方案如下图所示：<br><img src="640sd.jpeg" alt="640sd.jpeg"></p>
<h2 id="解决热点数据集中失效问题"><a href="#解决热点数据集中失效问题" class="headerlink" title="解决热点数据集中失效问题"></a>解决热点数据集中失效问题</h2><p>我们在设置缓存的时候，一般会给缓存设置一个失效时间，过了这个时间，缓存就失效了。</p>
<p>对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。</p>
<h3 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h3><h4 id="设置不同的失效时间"><a href="#设置不同的失效时间" class="headerlink" title="设置不同的失效时间"></a>设置不同的失效时间</h4><p>为了避免这些热点的数据集中失效，那么我们在设置缓存过期时间的时候，我们让他们失效的时间错开。<br>比如在一个基础的时间上加上或者减去一个范围内的随机值</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>结合上面的击穿的情况，在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，从而保护数据库。<br>但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/5MloHIa5zKvYYsVVEWZjQA" target="_blank" rel="external">https://mp.weixin.qq.com/s/5MloHIa5zKvYYsVVEWZjQA</a></p>
]]></content>
      <categories>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>DB-DML-DDL-DCL</title>
    <url>/2017/09/22/DB-DML-DDL-DCL/</url>
    <content><![CDATA[<p>浅谈 DML、DDL、DCL的区别</p>
<a id="more"></a>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>DML（data manipulation language）数据操纵语言：<br>就是我们最经常用到的 SELECT、UPDATE、INSERT、DELETE。 主要用来对数据库的数据进行一些操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SELECT 列名称 FROM 表名称</div><div class="line">UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</div><div class="line">INSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)</div><div class="line">DELETE FROM 表名称 WHERE 列名称 = 值</div></pre></td></tr></table></figure>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p>DDL（data definition language）数据库定义语言：<br>其实就是我们在创建表的时候用到的一些sql，比如说：CREATE、ALTER、DROP等。DDL主要是用在定义或改变表的结构，数据类型，表之间的链接和约束等初始化工作上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE 表名称</div><div class="line">(</div><div class="line">列名称1 数据类型,</div><div class="line">列名称2 数据类型,</div><div class="line">列名称3 数据类型,</div><div class="line">....</div><div class="line">)</div><div class="line"></div><div class="line">ALTER TABLE table_name</div><div class="line">ALTER COLUMN column_name datatype</div><div class="line"></div><div class="line">DROP TABLE 表名称</div><div class="line">DROP DATABASE 数据库名称</div></pre></td></tr></table></figure>
<h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><p>DCL（Data Control Language）数据库控制语言：<br>是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。这个比较少用到。</p>
<p>在公司呢一般情况下我们用到的是DDL、DML这两种</p>
<p>ref:<br><a href="https://www.cnblogs.com/dato/p/7049343.html" target="_blank" rel="external">https://www.cnblogs.com/dato/p/7049343.html</a></p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>DB</tag>
      </tags>
  </entry>
  <entry>
    <title>DataStructure-RBTree</title>
    <url>/2017/09/22/DataStructure-RBTree/</url>
    <content><![CDATA[<p>二叉搜索树对于某个节点而言，其左子树的节点关键值都小于该节点关键值，右子树的所有节点关键值都大于该节点关键值。二叉搜索树作为一种数据结构，其查找、插入和删除操作的时间复杂度都为O(logn),底数为2。但是我们说这个时间复杂度是在平衡的二叉搜索树上体现的，也就是如果插入的数据是随机的，则效率很高，但是如果插入的数据是有序的，比如从小到大的顺序【10,20,30,40,50】插入到二叉搜索树中：</p>
<a id="more"></a>
<p><img src="1120165-20171220113716443-1667255342.png" alt="1120165-20171220113716443-1667255342.png"></p>
<p>从大到小就是全部在左边，这和链表没有任何区别了，这种情况下查找的时间复杂度为O(N)，而不是O(logN)。当然这是在最不平衡的条件下，<strong>实际情况下，二叉搜索树的效率应该在O(N)和O(logN)之间</strong>，这取决于树的不平衡程度。</p>
<p>那么为了能够以较快的时间O(logN)来搜索一棵树，我们需要保证树总是平衡的（或者大部分是平衡的），也就是说每个节点的左子树节点个数和右子树节点个数尽量相等。红-黑树的就是这样的一棵平衡树，对一个要插入的数据项（删除也是），插入例程要检查会不会破坏树的特征，如果破坏了，程序就会进行纠正，根据需要改变树的结构，从而保持树的平衡。</p>
<h2 id="红-黑树的特征"><a href="#红-黑树的特征" class="headerlink" title="红-黑树的特征"></a>红-黑树的特征</h2><p>有如下两个特征:</p>
<ul>
<li>节点都有颜色；</li>
<li>在插入和删除的过程中，要遵循保持这些颜色的不同排列规则。</li>
</ul>
<p>第一个很好理解，在红-黑树中，每个节点的颜色或者是黑色或者是红色的。当然也可以是任意别的两种颜色，这里的颜色用于标记，我们可以在节点类Node中增加一个boolean型变量isRed，以此来表示颜色的信息。</p>
<p>第二点，在插入或者删除一个节点时，必须要遵守的规则称为红-黑规则：</p>
<ol>
<li><strong>非红即黑</strong> 每个节点不是红色就是黑色的；</li>
<li><strong>黑根</strong> 根节点总是黑色的；</li>
<li><strong>红子为黑</strong> 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）,(也就是从每个叶子到根的所有路径上不能有两个连续的红色节点)；</li>
<li><strong>相同的黑色高度</strong> 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点。</li>
</ol>
<p>从根节点到叶节点的路径上的黑色节点的数目称为黑色高度，规则 4 另一种表示就是从根到叶节点路径上的黑色高度必须相同。</p>
<p>注意：<strong>新插入的节点颜色总是红色的</strong>，这是因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小，原因是插入黑色节点总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3（因为父节点是黑色的没事，父节点是红色的就违背规则3）。另外违背规则3比违背规则4要更容易修正。当插入一个新的节点时，可能会破坏这种平衡性，那么红-黑树是如何修正的呢？</p>
<h2 id="红-黑树的自我修正"><a href="#红-黑树的自我修正" class="headerlink" title="红-黑树的自我修正"></a>红-黑树的自我修正</h2><p>红-黑树主要通过三种方式对平衡进行修正，改变节点颜色、左旋和右旋。</p>
<p>①、改变节点颜色</p>
<p><img src="1120165-20171220164306537-599617363.png" alt="1120165-20171220164306537-599617363.png"></p>
<p>新插入的节点为15，一般新插入颜色都为红色，那么我们发现直接插入会违反规则3，改为黑色却发现违反规则4。这时候我们将其父节点颜色改为黑色，父节点的兄弟节点颜色也改为黑色。通常其祖父节点50颜色会由黑色变为红色，但是由于50是根节点，所以我们这里不能改变根节点颜色。</p>
<p>②、右旋<br>首先要说明的是节点本身是不会旋转的，旋转改变的是节点之间的关系，选择一个节点作为旋转的顶端，如果做一次右旋，这个顶端节点会向下和向右移动到它右子节点的位置，它的左子节点会上移到它原来的位置。右旋的顶端节点必须要有左子节点。</p>
<p><img src="1120165-20171220170015303-267904943.gif" alt="1120165-20171220170015303-267904943.gif"></p>
<p>③、左旋<br>左旋的顶端节点必须要有右子节点。</p>
<p><img src="1120165-20171220170041631-2108296110.gif" alt="1120165-20171220170041631-2108296110.gif"></p>
<p>注意：我们改变颜色也是为了帮助我们判断何时执行什么旋转，而旋转是为了保证树的平衡。光改变节点颜色是不能起到任何作用的，旋转才是关键的操作，在新增节点或者删除节点之后，可能会破坏二叉树的平衡，那么何时执行旋转以及执行什么旋转，这是我们需要重点关注的。</p>
<h2 id="左旋和右旋代码"><a href="#左旋和右旋代码" class="headerlink" title="左旋和右旋代码"></a>左旋和右旋代码</h2><p>①、节点类<br>节点类和二叉树的节点类差不多，只不过在其基础上增加了一个 boolean 类型的变量来表示节点的颜色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class RBNode&lt;T extends Comparable&lt;T&gt;&gt; &#123;</div><div class="line">    boolean color;//颜色</div><div class="line">    T key;//关键值</div><div class="line">    RBNode&lt;T&gt; left;//左子节点</div><div class="line">    RBNode&lt;T&gt; right;//右子节点</div><div class="line">    RBNode&lt;T&gt; parent;//父节点</div><div class="line">     </div><div class="line">    public RBNode(boolean color,T key,RBNode&lt;T&gt; parent,RBNode&lt;T&gt; left,RBNode&lt;T&gt; right)&#123;</div><div class="line">        this.color = color;</div><div class="line">        this.key = key;</div><div class="line">        this.parent = parent;</div><div class="line">        this.left = left;</div><div class="line">        this.right = right;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //获得节点的关键值</div><div class="line">    public T getKey()&#123;</div><div class="line">        return key;</div><div class="line">    &#125;</div><div class="line">    //打印节点的关键值和颜色信息</div><div class="line">    public String toString()&#123;</div><div class="line">        return &quot;&quot;+key+(this.color == RED ? &quot;R&quot;:&quot;B&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>②、左旋的具体实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*************对红黑树节点x进行左旋操作 ******************/</div><div class="line">/* </div><div class="line"> * 左旋示意图：对节点x进行左旋 </div><div class="line"> *     p                       p </div><div class="line"> *    /                       / </div><div class="line"> *   x                       y </div><div class="line"> *  / \                     / \ </div><div class="line"> * lx  y      -----&gt;       x  ry </div><div class="line"> *    / \                 / \ </div><div class="line"> *   ly ry               lx ly </div><div class="line"> * 左旋做了三件事： </div><div class="line"> * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时) </div><div class="line"> * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右) </div><div class="line"> * 3. 将y的左子节点设为x，将x的父节点设为y </div><div class="line"> */</div><div class="line">private void leftRotate(RBNode&lt;T&gt; x)&#123;</div><div class="line">    //1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时)</div><div class="line">    RBNode&lt;T&gt; y = x.right;</div><div class="line">    x.right = y.left;</div><div class="line">    if(y.left != null)&#123;</div><div class="line">        y.left.parent = x;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</div><div class="line">    y.parent = x.parent;</div><div class="line">    if(x.parent == null)&#123;</div><div class="line">        this.root = y;//如果x的父节点为空(即x为根节点)，则将y设为根节点</div><div class="line">    &#125;else&#123;</div><div class="line">        if(x == x.parent.left)&#123;//如果x是左子节点</div><div class="line">            x.parent.left = y;//则也将y设为左子节点 </div><div class="line">        &#125;else&#123;</div><div class="line">            x.parent.right = y;//否则将y设为右子节点 </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //3. 将y的左子节点设为x，将x的父节点设为y</div><div class="line">    y.left = x;</div><div class="line">    x.parent = y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>③、右旋的具体实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*************对红黑树节点y进行右旋操作 ******************/ </div><div class="line">/*</div><div class="line"> * 左旋示意图：对节点y进行右旋</div><div class="line"> *        p                   p</div><div class="line"> *       /                   /</div><div class="line"> *      y                   x</div><div class="line"> *     / \                 / \</div><div class="line"> *    x  ry   -----&gt;      lx  y</div><div class="line"> *   / \                     / \</div><div class="line"> * lx  rx                   rx ry</div><div class="line"> * 右旋做了三件事：</div><div class="line"> * 1. 将x的右子节点赋给y的左子节点,并将y赋给x右子节点的父节点(x右子节点非空时)</div><div class="line"> * 2. 将y的父节点p(非空时)赋给x的父节点，同时更新p的子节点为x(左或右)</div><div class="line"> * 3. 将x的右子节点设为y，将y的父节点设为x</div><div class="line"> */</div><div class="line">private void rightRotate(RBNode&lt;T&gt; y)&#123;</div><div class="line">    //1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时)</div><div class="line">    RBNode&lt;T&gt; x = y.left;</div><div class="line">    y.left = x.right;</div><div class="line">    if(x.right != null)&#123;</div><div class="line">        x.right.parent = y;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)</div><div class="line">    x.parent = y.parent;</div><div class="line">    if(y.parent == null)&#123;</div><div class="line">        this.root = x;//如果y的父节点为空(即y为根节点)，则旋转后将x设为根节点</div><div class="line">    &#125;else&#123;</div><div class="line">        if(y == y.parent.left)&#123;//如果y是左子节点</div><div class="line">            y.parent.left = x;//则将x也设置为左子节点</div><div class="line">        &#125;else&#123;</div><div class="line">            y.parent.right = x;//否则将x设置为右子节点</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //3. 将x的左子节点设为y，将y的父节点设为y</div><div class="line">    x.right = y;</div><div class="line">    y.parent = x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>和二叉树的插入操作一样，都是得先找到插入的位置，然后再将节点插入。先看看插入的前段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*********************** 向红黑树中插入节点 **********************/</div><div class="line">public void insert(T key)&#123;</div><div class="line">    RBNode&lt;T&gt; node = new RBNode&lt;T&gt;(RED, key, null, null, null);</div><div class="line">    if(node != null)&#123;</div><div class="line">        insert(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">public void insert(RBNode&lt;T&gt; node)&#123;</div><div class="line">    RBNode&lt;T&gt; current = null;//表示最后node的父节点</div><div class="line">    RBNode&lt;T&gt; x = this.root;//用来向下搜索</div><div class="line">     </div><div class="line">    //1.找到插入位置</div><div class="line">    while(x != null)&#123;</div><div class="line">        current = x;</div><div class="line">        int cmp = node.key.compareTo(x.key);</div><div class="line">        if(cmp &lt; 0)&#123;</div><div class="line">            x = x.left;</div><div class="line">        &#125;else&#123;</div><div class="line">            x = x.right;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    node.parent = current;//找到了插入的位置，将当前current作为node的父节点</div><div class="line">     </div><div class="line">    //2.接下来判断node是左子节点还是右子节点</div><div class="line">    if(current != null)&#123;</div><div class="line">        int cmp = node.key.compareTo(current.key);</div><div class="line">        if(cmp &lt; 0)&#123;</div><div class="line">            current.left = node;</div><div class="line">        &#125;else&#123;</div><div class="line">            current.right = node;</div><div class="line">        &#125;</div><div class="line">    &#125;else&#123;</div><div class="line">        this.root = node;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //3.利用旋转操作将其修正为一颗红黑树</div><div class="line">    insertFixUp(node);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这与二叉搜索树中实现的思路一样，这里不再赘述，主要看看方法里面最后一步insertFixUp(node)操作。因为插入后可能会导致树的不平衡，insertFixUp(node) 方法里主要是分情况讨论，分析何时变色，何时左旋，何时右旋。我们先从理论上分析具体的情况，然后再看insertFixUp(node) 的具体实现。</p>
<p>如果是第一次插入，由于原树为空，所以只会违反红-黑树的规则2，所以只要把根节点涂黑即可；如果插入节点的父节点是黑色的，那不会违背红-黑树的规则，什么也不需要做；但是遇到如下三种情况，我们就要开始变色和旋转了：</p>
<ol>
<li>插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色。</li>
<li>插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的右子节点。</li>
<li>插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的左子节点。</li>
</ol>
<p>下面我们挨个分析这三种情况都需要如何操作，然后给出实现代码。</p>
<p>在下面的讨论中，使用N,P,G,U表示关联的节点。N(now)表示当前节点，P(parent)表示N的父节点，U(uncle)表示N的叔叔节点，G(grandfather)表示N的祖父节点，也就是P和U的父节点。</p>
<p>对于情况1：插入节点的父节点和其叔叔节点（祖父节点的另一个子节点）均为红色。此时，肯定存在祖父节点，但是不知道父节点是其左子节点还是右子节点，但是由于对称性，我们只要讨论出一边的情况，另一种情况自然也与之对应。这里考虑父节点是其祖父节点的左子节点的情况，如下左图所示：</p>
<p><img src="1120165-20171224131058990-520825689.png" alt="1120165-20171224131058990-520825689.png"></p>
<p><img src="1120165-20171224131107115-1429056985.png" alt="1120165-20171224131107115-1429056985.png"></p>
<p>对于这种情况，我们要做的操作有：将当前节点(4) 的父节点(5) 和叔叔节点(8) 涂黑，将祖父节点(7)涂红,变成了上有图所示的情况。再将当前节点指向其祖父节点，再次从新的当前节点开始算法（具体看下面的步骤）。这样上右图就变成情况2了。</p>
<p>对于情况2：插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的右子节点。我们要做的操作有：将当前节点(7)的父节点(2)作为新的节点，以新的当前节点为支点做左旋操作。完成后如左下图所示，这样左下图就变成情况3了。</p>
<p><img src="1120165-20171224132524225-1171882786.png" alt="1120165-20171224132524225-1171882786.png"></p>
<p><img src="1120165-20171224132533537-1859473656.png" alt="1120165-20171224132533537-1859473656.png"></p>
<p>对于情况3：插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。我们要做的操作有：将当前节点的父节点(7)涂黑，将祖父节点(11)涂红，在祖父节点为支点做右旋操作。最后把根节点涂黑，整个红-黑树重新恢复了平衡，如右上图所示。至此，插入操作完成！</p>
<p>我们可以看出，如果是从情况1开始发生的，必然会走完情况2和3，也就是说这是一整个流程，当然咯，实际中可能不一定会从情况1发生，如果从情况2开始发生，那再走个情况3即可完成调整，如果直接只要调整情况3，那么前两种情况均不需要调整了。故变色和旋转之间的先后关系可以表示为：变色-&gt;左旋-&gt;右旋。</p>
<p>至此，我们完成了全部的插入操作。下面我们看看insertFixUp方法中的具体实现（可以结合上面的分析图，更加利与理解）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private void insertFixUp(RBNode&lt;T&gt; node)&#123;</div><div class="line">    RBNode&lt;T&gt; parent,gparent;//定义父节点和祖父节点</div><div class="line">     </div><div class="line">    //需要修正的条件：父节点存在，且父节点的颜色是红色</div><div class="line">    while(((parent = parentOf(node)) != null) &amp;&amp; isRed(parent))&#123;</div><div class="line">        gparent = parentOf(parent);//获得祖父节点</div><div class="line">         </div><div class="line">        //若父节点是祖父节点的左子节点，下面的else相反</div><div class="line">        if(parent == gparent.left)&#123;</div><div class="line">            RBNode&lt;T&gt; uncle = gparent.right;//获得叔叔节点</div><div class="line">             </div><div class="line">            //case1:叔叔节点也是红色</div><div class="line">            if(uncle != null &amp;&amp; isRed(uncle))&#123;</div><div class="line">                setBlack(parent);//把父节点和叔叔节点涂黑</div><div class="line">                setBlack(gparent);</div><div class="line">                setRed(gparent);//把祖父节点涂红</div><div class="line">                node = gparent;//把位置放到祖父节点处</div><div class="line">                continue;//继续while循环，重新判断</div><div class="line">            &#125;</div><div class="line">             </div><div class="line">            //case2:叔叔节点是黑色，且当前节点是右子节点</div><div class="line">            if(node == parent.right)&#123;</div><div class="line">                leftRotate(parent);//从父节点出左旋</div><div class="line">                RBNode&lt;T&gt; tmp = parent;//然后将父节点和自己调换一下，为下面右旋做准备</div><div class="line">                parent = node;</div><div class="line">                node = tmp;</div><div class="line">            &#125;</div><div class="line">             </div><div class="line">            //case3:叔叔节点是黑色，且当前节点是左子节点</div><div class="line">            setBlack(parent);</div><div class="line">            setRed(gparent);</div><div class="line">            rightRotate(gparent);</div><div class="line">        &#125;else&#123;//若父节点是祖父节点的右子节点，与上面的情况完全相反，本质是一样的</div><div class="line">            RBNode&lt;T&gt; uncle = gparent.left;</div><div class="line">             </div><div class="line">            //case1:叔叔节点也是红色的</div><div class="line">            if(uncle != null &amp;&amp; isRed(uncle))&#123;</div><div class="line">                setBlack(parent);</div><div class="line">                setBlack(uncle);</div><div class="line">                setRed(gparent);</div><div class="line">                node = gparent;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">             </div><div class="line">            //case2:叔叔节点是黑色的，且当前节点是左子节点</div><div class="line">            if(node == parent.left)&#123;</div><div class="line">                rightRotate(parent);</div><div class="line">                RBNode&lt;T&gt; tmp = parent;</div><div class="line">                parent = node;</div><div class="line">                node = tmp;</div><div class="line">            &#125;</div><div class="line">             </div><div class="line">            //case3:叔叔节点是黑色的，且当前节点是右子节点</div><div class="line">            setBlack(parent);</div><div class="line">            setRed(gparent);</div><div class="line">            leftRotate(gparent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    setBlack(root);//将根节点设置为黑色</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>上面探讨完了红-黑树的插入操作，接下来讨论删除，红-黑树的删除和二叉查找树的删除是一样的，只不过删除后多了个平衡的修复而已。我们先来回忆一下二叉搜索树的删除：</p>
<ol>
<li>如果待删除的节点没有子节点，那么直接删除即可。</li>
<li>如果待删除的节点只有一个子节点，那么直接删掉，并用其子节点去顶替它。</li>
<li>如果待删除的节点有两个子节点，这种情况比较复杂：首先找出它的后继节点，然后处理“后继节点”和“被删除节点的父节点”之间的关系，最后处理“后继节点的子节点”和“被删除节点的子节点”之间的关系。每一步中也会有不同的情况。</li>
</ol>
<p>实际上，删除过程太复杂了，很多情况下会采用在节点类中添加一个删除标记，并不是真正的删除节点。详细的删除我们这里不做讨论。</p>
<h2 id="红黑树的效率"><a href="#红黑树的效率" class="headerlink" title="红黑树的效率"></a>红黑树的效率</h2><p>红黑树的查找、插入和删除时间复杂度都为O(log2N)，额外的开销是每个节点的存储空间都稍微增加了一点，因为一个存储红黑树节点的颜色变量。插入和删除的时间要增加一个常数因子，因为要进行旋转，平均一次插入大约需要一次旋转，因此插入的时间复杂度还是O(log2N),(时间复杂度的计算要省略常数)，但实际上比普通的二叉树是要慢的。</p>
<p>大多数应用中，查找的次数比插入和删除的次数多，所以应用红黑树取代普通的二叉搜索树总体上不会有太多的时间开销。而且红黑树的优点是对于有序数据的操作不会慢到O(N)的时间复杂度。</p>
<p>ref: <a href="https://www.cnblogs.com/ysocean/p/8004211.html" target="_blank" rel="external">https://www.cnblogs.com/ysocean/p/8004211.html</a></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>DataStructure-Tree</title>
    <url>/2017/09/22/DataStructure-Tree/</url>
    <content><![CDATA[<p>前面我们介绍数组的数据结构，我们知道对于有序数组，查找很快，并介绍可以通过二分法查找，但是想要在有序数组中插入一个数据项，就必须先找到插入数据项的位置，然后将所有插入位置后面的数据项全部向后移动一位，来给新数据腾出空间，平均来讲要移动N/2次，这是很费时的。同理，删除数据也是。</p>
<p>　　然后我们介绍了另外一种数据结构——链表，链表的插入和删除很快，我们只需要改变一些引用值就行了，但是查找数据却很慢了，因为不管我们查找什么数据，都需要从链表的第一个数据项开始，遍历到找到所需数据项为止，这个查找也是平均需要比较N/2次。</p>
<p>　　那么我们就希望一种数据结构能同时具备数组查找快的优点以及链表插入和删除快的优点，于是 树 诞生了。</p>
<a id="more"></a>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>　　树（tree）是一种抽象数据类型（ADT），用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点通过连接它们的边组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p>
<p><img src="1120165-20171214212257388-1784629215.png" alt="1120165-20171214212257388-1784629215.png"></p>
<p>①、节点：上图的圆圈，比如A,B,C等都是表示节点。节点一般代表一些实体，在java面向对象编程中，节点一般代表对象。</p>
<p>②、边：连接节点的线称为边，边表示节点的关联关系。一般从一个节点到另一个节点的唯一方法就是沿着一条顺着有边的道路前进。在Java当中通常表示引用。</p>
<p>　　树有很多种，向上面的一个节点有多余两个的子节点的树，称为多路树，后面会讲解2-3-4树和外部存储都是多路树的例子。而每个节点最多只能有两个子节点的一种形式称为二叉树，这也是本篇博客讲解的重点。</p>
<h2 id="树的常用术语"><a href="#树的常用术语" class="headerlink" title="树的常用术语"></a>树的常用术语</h2><p><img src="1120165-20190317103508280-1532806856.png" alt="1120165-20190317103508280-1532806856.png"></p>
<p>①、路径：顺着节点的边从一个节点走到另一个节点，所经过的节点的顺序排列就称为“路径”。</p>
<p>　　②、根：树顶端的节点称为根。一棵树只有一个根，如果要把一个节点和边的集合称为树，那么从根到其他任何一个节点都必须有且只有一条路径。A是根节点。</p>
<p>　　③、父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；B是D的父节点。</p>
<p>　　④、子节点：一个节点含有的子树的根节点称为该节点的子节点；D是B的子节点。</p>
<p>　　⑤、兄弟节点：具有相同父节点的节点互称为兄弟节点；比如上图的D和E就互称为兄弟节点。</p>
<p>　　⑥、叶节点：没有子节点的节点称为叶节点，也叫叶子节点，比如上图的H、E、F、G都是叶子节点。</p>
<p>　　⑦、子树：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中。</p>
<p>　　⑧、节点的层次：从根开始定义，根为第一层，根的子节点为第二层，以此类推。</p>
<p>　　⑨、深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</p>
<p>　　⑩、高度：对于任意节点n,n的高度为从n到一片树叶的最长路径长，所有树叶的高度为0；</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>　　二叉树：树的每个节点最多只能有两个子节点</p>
<p>　　上图的第一幅图B节点有DEF三个子节点，就不是二叉树，称为多路树；而第二幅图每个节点最多只有两个节点，是二叉树，并且二叉树的子节点称为“左子节点”和“右子节点”。上图的D,E分别是B的左子节点和右子节点。</p>
<p>　　如果我们给二叉树加一个额外的条件，就可以得到一种被称作二叉搜索树(binary search tree)的特殊二叉树。</p>
<p>　　二叉搜索树要求：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
<p><img src="1120165-20171220112909771-634334318.png" alt="1120165-20171220112909771-634334318.png"></p>
<p>二叉搜索树作为一种数据结构，那么它是如何工作的呢？它查找一个节点，插入一个新节点，以及删除一个节点，遍历树等工作效率如何，下面我们来一一介绍。</p>
<p>二叉树的节点类：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Node &#123;</div><div class="line">    private Object data;    //节点数据</div><div class="line">    private Node leftChild; //左子节点的引用</div><div class="line">    private Node rightChild; //右子节点的引用</div><div class="line"></div><div class="line">    public void display()&#123; //打印节点内容</div><div class="line">        System.out.println(data);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>二叉树的接口:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface Tree &#123;</div><div class="line">    //查找节点</div><div class="line">    public Node find(Object key);</div><div class="line">    //插入新节点</div><div class="line">    public boolean insert(Object key);</div><div class="line">    //删除节点</div><div class="line">    public boolean delete(Object key);</div><div class="line">    //Other Method......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h2><p>　　查找某个节点，我们必须从根节点开始遍历。</p>
<p>　　①、查找值比当前节点值大，则搜索右子树；</p>
<p>　　②、查找值等于当前节点值，停止搜索（终止条件）；</p>
<p>　　③、查找值小于当前节点值，则搜索左子树；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//查找节点</div><div class="line">public Node find(int key) &#123;</div><div class="line">    Node current = root;</div><div class="line">    while(current != null)&#123;</div><div class="line">        if(current.data &gt; key)&#123;//当前值比查找值大，搜索左子树</div><div class="line">            current = current.leftChild;</div><div class="line">        &#125;else if(current.data &lt; key)&#123;//当前值比查找值小，搜索右子树</div><div class="line">            current = current.rightChild;</div><div class="line">        &#125;else&#123;</div><div class="line">            return current;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return null;//遍历完整个树没找到，返回null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用变量current来保存当前查找的节点，参数key是要查找的值，刚开始查找将根节点赋值到current。接在在while循环中，将要查找的值和current保存的节点进行对比。如果key小于当前节点，则搜索当前节点的左子节点，如果大于，则搜索右子节点，如果等于，则直接返回节点信息。当整个树遍历完全，即current == null，那么说明没找到查找值，返回null。</p>
<p>　　树的效率：查找节点的时间取决于这个节点所在的层数，每一层最多有2n-1个节点，总共N层共有2n-1个节点，那么时间复杂度为O(logn),底数为2。</p>
<h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>　　 要插入节点，必须先找到插入的位置。与查找操作相似，由于二叉搜索树的特殊性，待插入的节点也需要从根节点开始进行比较，小于根节点则与根节点左子树比较，反之则与右子树比较，直到左子树为空或右子树为空，则插入到相应为空的位置，在比较的过程中要注意保存父节点的信息 及 待插入的位置是父节点的左子树还是右子树，才能插入到正确的位置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//插入节点</div><div class="line">public boolean insert(int data) &#123;</div><div class="line">    Node newNode = new Node(data);</div><div class="line">    if(root == null)&#123;//当前树为空树，没有任何节点</div><div class="line">        root = newNode;</div><div class="line">        return true;</div><div class="line">    &#125;else&#123;</div><div class="line">        Node current = root;</div><div class="line">        Node parentNode = null;</div><div class="line">        while(current != null)&#123;</div><div class="line">            parentNode = current;</div><div class="line">            if(current.data &gt; data)&#123;//当前值比插入值大，搜索左子节点</div><div class="line">                current = current.leftChild;</div><div class="line">                if(current == null)&#123;//左子节点为空，直接将新值插入到该节点</div><div class="line">                    parentNode.leftChild = newNode;</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;else&#123;</div><div class="line">                current = current.rightChild;</div><div class="line">                if(current == null)&#123;//右子节点为空，直接将新值插入到该节点</div><div class="line">                    parentNode.rightChild = newNode;</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="遍历树"><a href="#遍历树" class="headerlink" title="遍历树"></a>遍历树</h2><p>　　遍历树是根据一种特定的顺序访问树的每一个节点。比较常用的有前序遍历，中序遍历和后序遍历。而二叉搜索树最常用的是中序遍历。</p>
<p>　　①、中序遍历:左子树——》根节点——》右子树</p>
<p>　　②、前序遍历:根节点——》左子树——》右子树</p>
<p>　　③、后序遍历:左子树——》右子树——》根节点</p>
<p><img src="1120165-20171218095635037-690274195.png" alt="1120165-20171218095635037-690274195.png"></p>
<h2 id="查找最大值和最小值"><a href="#查找最大值和最小值" class="headerlink" title="查找最大值和最小值"></a>查找最大值和最小值</h2><p>　　这没什么好说的，要找最小值，先找根的左节点，然后一直找这个左节点的左节点，直到找到没有左节点的节点，那么这个节点就是最小值。同理要找最大值，一直找根节点的右节点，直到没有右节点，则就是最大值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//找到最大值</div><div class="line">public Node findMax()&#123;</div><div class="line">    Node current = root;</div><div class="line">    Node maxNode = current;</div><div class="line">    while(current != null)&#123;</div><div class="line">        maxNode = current;</div><div class="line">        current = current.rightChild;</div><div class="line">    &#125;</div><div class="line">    return maxNode;</div><div class="line">&#125;</div><div class="line">//找到最小值</div><div class="line">public Node findMin()&#123;</div><div class="line">    Node current = root;</div><div class="line">    Node minNode = current;</div><div class="line">    while(current != null)&#123;</div><div class="line">        minNode = current;</div><div class="line">        current = current.leftChild;</div><div class="line">    &#125;</div><div class="line">    return minNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点　　"></a>删除节点　　</h2><p>　　删除节点是二叉搜索树中最复杂的操作，删除的节点有三种情况，前两种比较简单，但是第三种却很复杂。</p>
<p>　　1、该节点是叶节点（没有子节点）</p>
<p>　　2、该节点有一个子节点</p>
<p>　　3、该节点有两个子节点</p>
<p>　　下面我们分别对这三种情况进行讲解。</p>
<p>　　①、删除没有子节点的节点<br>　　要删除叶节点，只需要改变该节点的父节点引用该节点的值，即将其引用改为 null 即可。要删除的节点依然存在，但是它已经不是树的一部分了，由于Java语言的垃圾回收机制，我们不需要非得把节点本身删掉，一旦Java意识到程序不在与该节点有关联，就会自动把它清理出存储器。</p>
<p><img src="1120165-20171218104533818-844513438.png" alt="1120165-20171218104533818-844513438.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean delete(int key) &#123;</div><div class="line">    Node current = root;</div><div class="line">    Node parent = root;</div><div class="line">    boolean isLeftChild = false;</div><div class="line">    //查找删除值，找不到直接返回false</div><div class="line">    while(current.data != key)&#123;</div><div class="line">        parent = current;</div><div class="line">        if(current.data &gt; key)&#123;</div><div class="line">            isLeftChild = true;</div><div class="line">            current = current.leftChild;</div><div class="line">        &#125;else&#123;</div><div class="line">            isLeftChild = false;</div><div class="line">            current = current.rightChild;</div><div class="line">        &#125;</div><div class="line">        if(current == null)&#123;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //如果当前节点没有子节点</div><div class="line">    if(current.leftChild == null &amp;&amp; current.rightChild == null)&#123;</div><div class="line">        if(current == root)&#123;</div><div class="line">            root = null;</div><div class="line">        &#125;else if(isLeftChild)&#123;</div><div class="line">            parent.leftChild = null;</div><div class="line">        &#125;else&#123;</div><div class="line">            parent.rightChild = null;</div><div class="line">        &#125;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>删除节点，我们要先找到该节点，并记录该节点的父节点。在检查该节点是否有子节点。如果没有子节点，接着检查其是否是根节点，如果是根节点，只需要将其设置为null即可。如果不是根节点，是叶节点，那么断开父节点和其的关系即可。</p>
<p>　　②、删除有一个子节点的节点<br>　　删除有一个子节点的节点，我们只需要将其父节点原本指向该节点的引用，改为指向该节点的子节点即可。</p>
<p><img src="1120165-20171218124801818-344487472.png" alt="1120165-20171218124801818-344487472.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//当前节点有一个子节点</div><div class="line">if(current.leftChild == null &amp;&amp; current.rightChild != null)&#123;</div><div class="line">    if(current == root)&#123;</div><div class="line">        root = current.rightChild;</div><div class="line">    &#125;else if(isLeftChild)&#123;</div><div class="line">        parent.leftChild = current.rightChild;</div><div class="line">    &#125;else&#123;</div><div class="line">        parent.rightChild = current.rightChild;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;else&#123;</div><div class="line">    //current.leftChild != null &amp;&amp; current.rightChild == null</div><div class="line">    if(current == root)&#123;</div><div class="line">        root = current.leftChild;</div><div class="line">    &#125;else if(isLeftChild)&#123;</div><div class="line">        parent.leftChild = current.leftChild;</div><div class="line">    &#125;else&#123;</div><div class="line">        parent.rightChild = current.leftChild;</div><div class="line">    &#125;</div><div class="line">    return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>③、删除有两个子节点的节点</p>
<p><img src="1120165-20171218140803631-1553482835.png" alt="1120165-20171218140803631-1553482835.png"></p>
<p>当删除的节点存在两个子节点，那么删除之后，两个子节点的位置我们就没办法处理了。既然处理不了，我们就想到一种办法，用另一个节点来代替被删除的节点，那么用哪一个节点来代替呢？</p>
<p>　　我们知道二叉搜索树中的节点是按照关键字来进行排列的，某个节点的关键字次高节点是它的中序遍历后继节点。用后继节点来代替删除的节点，显然该二叉搜索树还是有序的。（这里用后继节点代替，如果该后继节点自己也有子节点，我们后面讨论。）</p>
<p><img src="1120165-20171218152127162-7787702.png" alt="1120165-20171218152127162-7787702.png"></p>
<p>那么如何找到删除节点的中序后继节点呢？其实我们稍微分析，这实际上就是要找比删除节点关键值大的节点集合中最小的一个节点，只有这样代替删除节点后才能满足二叉搜索树的特性。</p>
<p>　　后继节点也就是：比删除节点大的最小节点。</p>
<p>　　算法：程序找到删除节点的右节点，(注意这里前提是删除节点存在左右两个子节点，如果不存在则是删除情况的前面两种)，然后转到该右节点的左子节点，依次顺着左子节点找下去，最后一个左子节点即是后继节点；如果该右节点没有左子节点，那么该右节点便是后继节点。</p>
<p><img src="1120165-20171218153529678-164263393.png" alt="1120165-20171218153529678-164263393.png"></p>
<p>需要确定后继节点没有子节点，如果后继节点存在子节点，那么又要分情况讨论了。</p>
<p>　　①、后继节点是删除节点的右子节点</p>
<p>　　这种情况简单，只需要将后继节点表示的子树移到被删除节点的位置即可！<br><img src="1120165-20171218171031162-1271094495.png" alt="1120165-20171218171031162-1271094495.png"></p>
<p>②、后继节点是删除节点的右子节点的左子节点</p>
<p><img src="1120165-20171218171120021-1191312951.png" alt="1120165-20171218171120021-1191312951.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public Node getSuccessor(Node delNode)&#123;</div><div class="line">    Node successorParent = delNode;</div><div class="line">    Node successor = delNode;</div><div class="line">    Node current = delNode.rightChild;</div><div class="line">    while(current != null)&#123;</div><div class="line">        successorParent = successor;</div><div class="line">        successor = current;</div><div class="line">        current = current.leftChild;</div><div class="line">    &#125;</div><div class="line">    //将后继节点替换删除节点</div><div class="line">    if(successor != delNode.rightChild)&#123;</div><div class="line">        successorParent.leftChild = successor.rightChild;</div><div class="line">        successor.rightChild = delNode.rightChild;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    return successor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>④、删除有必要吗？<br> 　　通过上面的删除分类讨论，我们发现删除其实是挺复杂的，那么其实我们可以不用真正的删除该节点，只需要在Node类中增加一个标识字段isDelete，当该字段为true时，表示该节点已经删除，反正没有删除。那么我们在做比如find()等操作的时候，要先判断isDelete字段是否为true。这样删除的节点并不会改变树的结构。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Node &#123;</div><div class="line">    int data;   //节点数据</div><div class="line">    Node leftChild; //左子节点的引用</div><div class="line">    Node rightChild; //右子节点的引用</div><div class="line">    boolean isDelete;//表示节点是否被删除</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="二叉树的效率"><a href="#二叉树的效率" class="headerlink" title="二叉树的效率"></a>二叉树的效率</h2><p>　　从前面的大部分对树的操作来看，都需要从根节点到下一层一层的查找。</p>
<p>　　一颗满树，每层节点数大概为2n-1，那么最底层的节点个数比树的其它节点数多1，因此，查找、插入或删除节点的操作大约有一半都需要找到底层的节点，另外四分之一的节点在倒数第二层，依次类推。</p>
<p>　　总共N层共有2n-1个节点，那么时间复杂度为O(logn),底数为2。</p>
<p>　　在有1000000 个数据项的无序数组和链表中，查找数据项平均会比较500000 次，但是在有1000000个节点的二叉树中，只需要20次或更少的比较即可。</p>
<p>　　有序数组可以很快的找到数据项，但是插入数据项的平均需要移动 500000 次数据项，在 1000000 个节点的二叉树中插入数据项需要20次或更少比较，在加上很短的时间来连接数据项。</p>
<p>　　同样，从 1000000 个数据项的数组中删除一个数据项平均需要移动 500000 个数据项，而在 1000000 个节点的二叉树中删除节点只需要20次或更少的次数来找到他，然后在花一点时间来找到它的后继节点，一点时间来断开节点以及连接后继节点。</p>
<p>　　所以，树对所有常用数据结构的操作都有很高的效率。</p>
<p>　　遍历可能不如其他操作快，但是在大型数据库中，遍历是很少使用的操作，它更常用于程序中的辅助算法来解析算术或其它表达式。</p>
<h2 id="用数组表示树"><a href="#用数组表示树" class="headerlink" title="用数组表示树"></a>用数组表示树</h2><p> 　　用数组表示树，那么节点是存在数组中的，节点在数组中的位置对应于它在树中的位置。下标为 0 的节点是根，下标为 1 的节点是根的左子节点，以此类推，按照从左到右的顺序存储树的每一层。</p>
<p><img src="1120165-20171218222447459-50016438.png" alt="1120165-20171218222447459-50016438.png"></p>
<p>树中的每个位置，无论是否存在节点，都对应于数组中的一个位置，树中没有节点的在数组中用0或者null表示。</p>
<p>　　假设节点的索引值为index，那么节点的左子节点是 2<em>index+1，节点的右子节点是 2</em>index+2，它的父节点是 （index-1）/2。</p>
<p>　　在大多数情况下，使用数组表示树效率是很低的，不满的节点和删除掉的节点都会在数组中留下洞，浪费存储空间。更坏的是，删除节点如果要移动子树的话，子树中的每个节点都要移到数组中新的位置，这是很费时的。</p>
<p>　　不过如果不允许删除操作，数组表示可能会很有用，尤其是因为某种原因要动态的为每个字节分配空间非常耗时。</p>
<h2 id="完整的BinaryTree代码"><a href="#完整的BinaryTree代码" class="headerlink" title="完整的BinaryTree代码"></a>完整的BinaryTree代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Node &#123;</div><div class="line">    int data;   //节点数据</div><div class="line">    Node leftChild; //左子节点的引用</div><div class="line">    Node rightChild; //右子节点的引用</div><div class="line">    boolean isDelete;//表示节点是否被删除</div><div class="line">     </div><div class="line">    public Node(int data)&#123;</div><div class="line">        this.data = data;</div><div class="line">    &#125;</div><div class="line">    //打印节点内容</div><div class="line">    public void display()&#123;</div><div class="line">        System.out.println(data);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface Tree &#123;</div><div class="line">    //查找节点</div><div class="line">    public Node find(int key);</div><div class="line">    //插入新节点</div><div class="line">    public boolean insert(int data);</div><div class="line">     </div><div class="line">    //中序遍历</div><div class="line">    public void infixOrder(Node current);</div><div class="line">    //前序遍历</div><div class="line">    public void preOrder(Node current);</div><div class="line">    //后序遍历</div><div class="line">    public void postOrder(Node current);</div><div class="line">     </div><div class="line">    //查找最大值</div><div class="line">    public Node findMax();</div><div class="line">    //查找最小值</div><div class="line">    public Node findMin();</div><div class="line">     </div><div class="line">    //删除节点</div><div class="line">    public boolean delete(int key);</div><div class="line">     </div><div class="line">    //Other Method......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class BinaryTree implements Tree &#123;</div><div class="line">    //表示根节点</div><div class="line">    private Node root;</div><div class="line"> </div><div class="line">    //查找节点</div><div class="line">    public Node find(int key) &#123;</div><div class="line">        Node current = root;</div><div class="line">        while(current != null)&#123;</div><div class="line">            if(current.data &gt; key)&#123;//当前值比查找值大，搜索左子树</div><div class="line">                current = current.leftChild;</div><div class="line">            &#125;else if(current.data &lt; key)&#123;//当前值比查找值小，搜索右子树</div><div class="line">                current = current.rightChild;</div><div class="line">            &#125;else&#123;</div><div class="line">                return current;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;//遍历完整个树没找到，返回null</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    //插入节点</div><div class="line">    public boolean insert(int data) &#123;</div><div class="line">        Node newNode = new Node(data);</div><div class="line">        if(root == null)&#123;//当前树为空树，没有任何节点</div><div class="line">            root = newNode;</div><div class="line">            return true;</div><div class="line">        &#125;else&#123;</div><div class="line">            Node current = root;</div><div class="line">            Node parentNode = null;</div><div class="line">            while(current != null)&#123;</div><div class="line">                parentNode = current;</div><div class="line">                if(current.data &gt; data)&#123;//当前值比插入值大，搜索左子节点</div><div class="line">                    current = current.leftChild;</div><div class="line">                    if(current == null)&#123;//左子节点为空，直接将新值插入到该节点</div><div class="line">                        parentNode.leftChild = newNode;</div><div class="line">                        return true;</div><div class="line">                    &#125;</div><div class="line">                &#125;else&#123;</div><div class="line">                    current = current.rightChild;</div><div class="line">                    if(current == null)&#123;//右子节点为空，直接将新值插入到该节点</div><div class="line">                        parentNode.rightChild = newNode;</div><div class="line">                        return true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //中序遍历</div><div class="line">    public void infixOrder(Node current)&#123;</div><div class="line">        if(current != null)&#123;</div><div class="line">            infixOrder(current.leftChild);</div><div class="line">            System.out.print(current.data+&quot; &quot;);</div><div class="line">            infixOrder(current.rightChild);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //前序遍历</div><div class="line">    public void preOrder(Node current)&#123;</div><div class="line">        if(current != null)&#123;</div><div class="line">            System.out.print(current.data+&quot; &quot;);</div><div class="line">            infixOrder(current.leftChild);</div><div class="line">            infixOrder(current.rightChild);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    //后序遍历</div><div class="line">    public void postOrder(Node current)&#123;</div><div class="line">        if(current != null)&#123;</div><div class="line">            infixOrder(current.leftChild);</div><div class="line">            infixOrder(current.rightChild);</div><div class="line">            System.out.print(current.data+&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //找到最大值</div><div class="line">    public Node findMax()&#123;</div><div class="line">        Node current = root;</div><div class="line">        Node maxNode = current;</div><div class="line">        while(current != null)&#123;</div><div class="line">            maxNode = current;</div><div class="line">            current = current.rightChild;</div><div class="line">        &#125;</div><div class="line">        return maxNode;</div><div class="line">    &#125;</div><div class="line">    //找到最小值</div><div class="line">    public Node findMin()&#123;</div><div class="line">        Node current = root;</div><div class="line">        Node minNode = current;</div><div class="line">        while(current != null)&#123;</div><div class="line">            minNode = current;</div><div class="line">            current = current.leftChild;</div><div class="line">        &#125;</div><div class="line">        return minNode;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    @Override</div><div class="line">    public boolean delete(int key) &#123;</div><div class="line">        Node current = root;</div><div class="line">        Node parent = root;</div><div class="line">        boolean isLeftChild = false;</div><div class="line">        //查找删除值，找不到直接返回false</div><div class="line">        while(current.data != key)&#123;</div><div class="line">            parent = current;</div><div class="line">            if(current.data &gt; key)&#123;</div><div class="line">                isLeftChild = true;</div><div class="line">                current = current.leftChild;</div><div class="line">            &#125;else&#123;</div><div class="line">                isLeftChild = false;</div><div class="line">                current = current.rightChild;</div><div class="line">            &#125;</div><div class="line">            if(current == null)&#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //如果当前节点没有子节点</div><div class="line">        if(current.leftChild == null &amp;&amp; current.rightChild == null)&#123;</div><div class="line">            if(current == root)&#123;</div><div class="line">                root = null;</div><div class="line">            &#125;else if(isLeftChild)&#123;</div><div class="line">                parent.leftChild = null;</div><div class="line">            &#125;else&#123;</div><div class="line">                parent.rightChild = null;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">             </div><div class="line">            //当前节点有一个子节点，右子节点</div><div class="line">        &#125;else if(current.leftChild == null &amp;&amp; current.rightChild != null)&#123;</div><div class="line">            if(current == root)&#123;</div><div class="line">                root = current.rightChild;</div><div class="line">            &#125;else if(isLeftChild)&#123;</div><div class="line">                parent.leftChild = current.rightChild;</div><div class="line">            &#125;else&#123;</div><div class="line">                parent.rightChild = current.rightChild;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">            //当前节点有一个子节点，左子节点</div><div class="line">        &#125;else if(current.leftChild != null &amp;&amp; current.rightChild == null)&#123;</div><div class="line">            if(current == root)&#123;</div><div class="line">                root = current.leftChild;</div><div class="line">            &#125;else if(isLeftChild)&#123;</div><div class="line">                parent.leftChild = current.leftChild;</div><div class="line">            &#125;else&#123;</div><div class="line">                parent.rightChild = current.leftChild;</div><div class="line">            &#125;</div><div class="line">            return true;</div><div class="line">        &#125;else&#123;</div><div class="line">            //当前节点存在两个子节点</div><div class="line">            Node successor = getSuccessor(current);</div><div class="line">            if(current == root)&#123;</div><div class="line">                root= successor;</div><div class="line">            &#125;else if(isLeftChild)&#123;</div><div class="line">                parent.leftChild = successor;</div><div class="line">            &#125;else&#123;</div><div class="line">                parent.rightChild = successor;</div><div class="line">            &#125;</div><div class="line">            successor.leftChild = current.leftChild;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public Node getSuccessor(Node delNode)&#123;</div><div class="line">        Node successorParent = delNode;</div><div class="line">        Node successor = delNode;</div><div class="line">        Node current = delNode.rightChild;</div><div class="line">        while(current != null)&#123;</div><div class="line">            successorParent = successor;</div><div class="line">            successor = current;</div><div class="line">            current = current.leftChild;</div><div class="line">        &#125;</div><div class="line">        //后继节点不是删除节点的右子节点，将后继节点替换删除节点</div><div class="line">        if(successor != delNode.rightChild)&#123;</div><div class="line">            successorParent.leftChild = successor.rightChild;</div><div class="line">            successor.rightChild = delNode.rightChild;</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        return successor;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        BinaryTree bt = new BinaryTree();</div><div class="line">        bt.insert(50);</div><div class="line">        bt.insert(20);</div><div class="line">        bt.insert(80);</div><div class="line">        bt.insert(10);</div><div class="line">        bt.insert(30);</div><div class="line">        bt.insert(60);</div><div class="line">        bt.insert(90);</div><div class="line">        bt.insert(25);</div><div class="line">        bt.insert(85);</div><div class="line">        bt.insert(100);</div><div class="line">        bt.delete(10);//删除没有子节点的节点</div><div class="line">        bt.delete(30);//删除有一个子节点的节点</div><div class="line">        bt.delete(80);//删除有两个子节点的节点</div><div class="line">        System.out.println(bt.findMax().data);</div><div class="line">        System.out.println(bt.findMin().data);</div><div class="line">        System.out.println(bt.find(100));</div><div class="line">        System.out.println(bt.find(200));</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="哈夫曼-Huffman-编码"><a href="#哈夫曼-Huffman-编码" class="headerlink" title="哈夫曼(Huffman)编码"></a>哈夫曼(Huffman)编码</h2><p>我们知道计算机里每个字符在没有压缩的文本文件中由一个字节（比如ASCII码）或两个字节（比如Unicode,这个编码在各种语言中通用）表示，在这些方案中，每个字符需要相同的位数。</p>
<p>　　有很多压缩数据的方法，就是减少表示最常用字符的位数量，比如英语中，E是最常用的字母，我们可以只用两位01来表示，2位有四种组合：00、01、10、11，那么我们可以用这四种组合表示四种常用的字符吗？</p>
<p>　　答案是不可以的，因为在编码序列中是没有空格或其他特殊字符存在的，全都是有0和1构成的序列，比如E用01来表示，X用01011000表示，那么在解码的时候就弄不清楚01是表示E还是表示X的起始部分，所以在编码的时候就定下了一个规则：每个代码都不能是其它代码的前缀。</p>
<p>　　①、哈夫曼编码　<br>　　二叉树中有一种特别的树——哈夫曼树（最优二叉树），其通过某种规则（权值）来构造出一哈夫曼二叉树，在这个二叉树中，只有叶子节点才是有效的数据节点（很重要），其他的非叶子节点是为了构造出哈夫曼而引入的！<br>哈夫曼编码是一个通过哈夫曼树进行的一种编码，一般情况下，以字符：‘0’与‘1’表示。编码的实现过程很简单，只要实现哈夫曼树，通过遍历哈夫曼树，规定向左子树遍历一个节点编码为“0”，向右遍历一个节点编码为“1”，结束条件就是遍历到叶子节点！因为上面说过：哈夫曼树叶子节点才是有效数据节点！</p>
<p><img src="1120165-20171219173209850-694346812.png" alt="1120165-20171219173209850-694346812.png"></p>
<p>我们用01表示S，用00表示空格后，就不能用01和11表示某个字符了，因为它们是其它字符的前缀。在看三位的组合，分别有000,001,010,100,101,110和111，A是010，I是110，为什么没有其它三位的组合了呢？因为已知是不能用01和11开始的组合了，那么就减少了四种选择，同时011用于U和换行符的开始，111用于E和Y的开始，这样就只剩下2个三位的组合了，同理可以理解为什么只有三个四位的代码可用。</p>
<p>　　所以对于消息：SUSIE SAYS IT IS EASY</p>
<p>　　哈夫曼编码为：100111110110111100100101110100011001100011010001111010101110</p>
<p>②、哈夫曼解码<br>　　如果收到上面的一串哈夫曼编码，怎么解码呢？消息中出现的字符在哈夫曼树中是叶节点，也就是没有子节点，如下图：它们在消息中出现的频率越高，在树中的位置就越高，每个圆圈外面的数字就是频率，非叶节点外面的数字是它子节点数字的和。</p>
<p>　　每个字符都从根开始，如果遇到0，就向左走到下一个节点，如果遇到1，就向右。比如字符A是010，那么先向左，再向右，再向左，就找到了A，其它的依次类推。</p>
<p><img src="1120165-20171219174503303-846536327.png" alt="1120165-20171219174503303-846536327.png"></p>
<p>总结<br>　　树是由边和节点构成，根节点是树最顶端的节点，它没有父节点；二叉树中，最多有两个子节点；某个节点的左子树每个节点都比该节点的关键字值小，右子树的每个节点都比该节点的关键字值大，那么这种树称为二叉搜索树，其查找、插入、删除的时间复杂度都为logN；可以通过前序遍历、中序遍历、后序遍历来遍历树，前序是根节点-左子树-右子树，中序是左子树-根节点-右子树，后序是左子树-右子树-根节点；删除一个节点只需要断开指向它的引用即可；哈夫曼树是二叉树，用于数据压缩算法，最经常出现的字符编码位数最少，很少出现的字符编码位数多一些。</p>
<p>ref:<br><a href="https://www.cnblogs.com/ysocean/p/8032642.html" target="_blank" rel="external">https://www.cnblogs.com/ysocean/p/8032642.html</a></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>DataStructure-linklist-in-java</title>
    <url>/2017/09/22/DataStructure-linklist-in-java/</url>
    <content><![CDATA[<p>用Java实现单链表</p>
<a id="more"></a>
<h2 id="单链表的概念"><a href="#单链表的概念" class="headerlink" title="单链表的概念"></a>单链表的概念</h2><p>链表是最基本的数据结构，其存储的你原理图如下图所示</p>
<p><img src="874710-20170320154206471-485287156.png" alt="874710-20170320154206471-485287156.png"></p>
<p>head为头节点，他不存放任何的数据，只是充当一个指向链表中真正存放数据的第一个节点的作用，而每个节点中都有一个next引用，指向下一个节点，就这样一节一节往下面记录，直到最后一个节点，其中的next指向null。</p>
<h2 id="用java实现单链表"><a href="#用java实现单链表" class="headerlink" title="用java实现单链表"></a>用java实现单链表</h2><p>Node类<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Node &#123;</div><div class="line">    //为了方便，这两个变量都使用public，而不用private就不需要编写get、set方法了。</div><div class="line">    //存放数据的变量，简单点，直接为int型</div><div class="line">    public int data;</div><div class="line">    //存放结点的变量,默认为null</div><div class="line">    public Node next;</div><div class="line">    </div><div class="line">    //构造方法，在构造时就能够给data赋值</div><div class="line">    public Node(int data)&#123;</div><div class="line">        this.data = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单链表的简单操作(增加，删除，获取总长度，链表元素排序，链表遍历)　　</p>
<p><img src="874710-20170321144436174-1272807821.png" alt="874710-20170321144436174-1272807821.png"></p>
<p>1、增加结点操作，addNode(Node)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * 增加操作</div><div class="line">     *         直接在链表的最后插入新增的结点即可</div><div class="line">     *         将原本最后一个结点的next指向新结点</div><div class="line">     */</div><div class="line">    public void addNode(Node node)&#123;</div><div class="line">        //链表中有结点，遍历到最后一个结点</div><div class="line">        Node temp = head;    //一个移动的指针(把头结点看做一个指向结点的指针)</div><div class="line">        while(temp.next != null)&#123;    //遍历单链表，直到遍历到最后一个则跳出循环。</div><div class="line">            temp = temp.next;        //往后移一个结点，指向下一个结点。</div><div class="line">        &#125;</div><div class="line">        temp.next = node;    //temp为最后一个结点或者是头结点，将其next指向新结点</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>插入结点到链表的指定位置。　insertNodeByIndex(int index,Node node)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * insertNodeByIndex:在链表的指定位置插入结点。</div><div class="line">     *         插入操作需要知道1个结点即可，当前位置的前一个结点</div><div class="line">     * index:插入链表的位置，从1开始</div><div class="line">     * node:插入的结点</div><div class="line">     */</div><div class="line">    public void insertNodeByIndex(int index,Node node)&#123;</div><div class="line">        //首先需要判断指定位置是否合法，</div><div class="line">        if(index&lt;1||index&gt;length()+1)&#123;</div><div class="line">            System.out.println(&quot;插入位置不合法。&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        int length = 1;            //记录我们遍历到第几个结点了，也就是记录位置。</div><div class="line">        Node temp = head;        //可移动的指针</div><div class="line">        while(head.next != null)&#123;//遍历单链表</div><div class="line">            if(index == length++)&#123;        //判断是否到达指定位置。</div><div class="line">                //注意，我们的temp代表的是当前位置的前一个结点。</div><div class="line">                //前一个结点        当前位置        后一个结点</div><div class="line">                //temp            temp.next     temp.next.next</div><div class="line">                //插入操作。</div><div class="line">                node.next = temp.next;            </div><div class="line">                temp.next = node;                </div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            temp = temp.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>删除指定位置上的结点　　delNodeByIndex(int index)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * 通过index删除指定位置的结点,跟指定位置增加结点是一样的，先找到准确位置。然后进行删除操作。</div><div class="line">     *             删除操作需要知道1个结点即可：和当前位置的前一个结点。</div><div class="line">     * @param index：链表中的位置，从1开始</div><div class="line">     * </div><div class="line">     */</div><div class="line">    public void delNodeByIndex(int index)&#123;</div><div class="line">        //判断index是否合理</div><div class="line">        if(index&lt;1 || index&gt;length())&#123;</div><div class="line">            System.out.println(&quot;给定的位置不合理&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //步骤跟insertNodeByIndex是一样的，只是操作不一样。    </div><div class="line">        int length=1;</div><div class="line">        Node temp = head;</div><div class="line">        while(temp.next != null)&#123;</div><div class="line">            if(index == length++)&#123;</div><div class="line">                //删除操作。</div><div class="line">                temp.next = temp.next.next;    </div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            temp = temp.next;</div><div class="line">        &#125;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>单链表进行选择排序　　selectSortNode()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * 对链表中的结点进行排序，按照从小到大的顺序，使用选择排序。</div><div class="line">     *         使用双层遍历。第一层遍历，正常遍历链表，第二层遍历，遍历第一层遍历时所用的结点后面所有结点并与之比较</div><div class="line">     *         选择排序比较简单，明白其原理，就能够写的出来。</div><div class="line">     */</div><div class="line">    public void selectSortNode()&#123;</div><div class="line">        //判断链表长度大于2，不然只有一个元素，就不用排序了。</div><div class="line">        if(length()&lt;2)&#123;</div><div class="line">            System.out.println(&quot;无需排序&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //选择排序</div><div class="line">        Node temp = head;            //第一层遍历使用的移动指针，最处指向头结点，第一个结点用temp.next表示</div><div class="line">        while(temp.next != null)&#123;    //第一层遍历链表，从第一个结点开始遍历</div><div class="line">            Node secondTemp = temp.next;        //第二层遍历使用的移动指针，secondTemp指向第一个结点，我们需要用到是第二个结点开始，所以用secondNode.next</div><div class="line">            while(secondTemp.next != null)&#123;//第二层遍历,从第二个结点开始遍历</div><div class="line">                if( temp.next.data &gt; secondTemp.next.data)&#123;    //第二层中的所有结点依次与第一次遍历中选定的结点进行比较，</div><div class="line">                    int t = secondTemp.next.data;</div><div class="line">                    secondTemp.next.data =  temp.next.data;</div><div class="line">                    temp.next.data = t;                </div><div class="line">                &#125;</div><div class="line">                secondTemp = secondTemp.next;</div><div class="line">            &#125;</div><div class="line">            temp = temp.next;</div><div class="line">        &#125;        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>分析</p>
<p><img src="874710-20170321154017596-2075963507.png" alt="874710-20170321154017596-2075963507.png"></p>
<p>单链表进行插入排序　　insertSortNode()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * 对链表进行插入排序，按从大到小的顺序，只要这里会写，那么手写用数组插入排序</div><div class="line">     *    也是一样的。先要明白原理。什么是插入排序，这样才好写代码。</div><div class="line">     *    插入排序：分两组，一组当成有序序列，一组当成无序，将无序组中的元素与有序组中的元素进行比较(如何比较，那么就要知道插入排序的原理是什么这里不过多阐述)</div><div class="line">     *        这里我想到的方法是，构建一个空的链表当成有序序列，而原先的旧链表为无序序列，按照原理，一步步进行编码即可。</div><div class="line">     *    </div><div class="line">     */</div><div class="line">    public void insertSortNode()&#123;</div><div class="line">        //判断链表长度大于2，不然只有一个元素，就不用排序了。</div><div class="line">        if(length()&lt;2)&#123;</div><div class="line">            System.out.println(&quot;无需排序&quot;);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        //创建新链表</div><div class="line">        Node newHead = new Node(0);    //新链表的头结点</div><div class="line">        Node newTemp = newHead;        //新链表的移动指针</div><div class="line">        Node temp = head;        //旧链表的移动指针</div><div class="line">        if(newTemp.next == null)&#123;        //将第一个结点直接放入新链表中。</div><div class="line">            Node node = new Node(temp.next.data);</div><div class="line">            newTemp.next = node;</div><div class="line">            temp = temp.next;    //旧链表中指针移到下一位(第二个结点处)。</div><div class="line">        &#125;</div><div class="line">        while(temp.next != null)&#123;     //    遍历现有链表</div><div class="line">            while(newTemp.next != null)&#123;</div><div class="line">                //先跟新链表中的第一个结点进行比较,如果符合条件则添加到新链表，注意是在第一个位置上增加结点</div><div class="line">                //如果不符合，则跟新链表中第二个结点进行比较，如果都不符合，跳出while，判断是否是到了新链表的最后一个结点，如果是则直接在新链表后面添加即可</div><div class="line">                </div><div class="line">                if(newTemp.next.data &lt; temp.next.data)&#123;</div><div class="line">                    Node node = new Node(temp.next.data);</div><div class="line">                    node.next = newTemp.next;</div><div class="line">                    newTemp.next = node;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                newTemp = newTemp.next;</div><div class="line">            &#125;</div><div class="line">            if(newTemp.next == null)&#123;//到达最末尾还没符合，那么说明该值是新链表中最小的数，直接添加即可到链表中即可</div><div class="line">                //直接在新链表后面添加</div><div class="line">                Node node = new Node(temp.next.data);</div><div class="line">                newTemp.next = node;</div><div class="line">            &#125;</div><div class="line">            //旧链表指针指向下一位结点，继续重复和新链表中的结点进行比较。</div><div class="line">            temp = temp.next;</div><div class="line">            //新链表中的移动指针需要复位，指向头结点</div><div class="line">            newTemp = newHead;            </div><div class="line">        &#125;</div><div class="line">        //开始使用新链表，旧链表等待垃圾回收机制将其收回。</div><div class="line">        head = newHead;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>计算单链表的长度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/** 计算单链表的长度，也就是有多少个结点</div><div class="line"> * @return    结点个数</div><div class="line"> */</div><div class="line">public int length() &#123;</div><div class="line">    int length=0;</div><div class="line">    Node temp = head;</div><div class="line">    while(temp.next != null)&#123;</div><div class="line">        length++;</div><div class="line">        temp = temp.next;</div><div class="line">    &#125;</div><div class="line">    return length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://www.cnblogs.com/whgk/p/6589920.html" target="_blank" rel="external">https://www.cnblogs.com/whgk/p/6589920.html</a></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>linklist</tag>
      </tags>
  </entry>
  <entry>
    <title>DataStructure-sort-in-java</title>
    <url>/2017/09/22/DataStructure-sort-in-java/</url>
    <content><![CDATA[<p>用Java实现7种排序算法</p>
<a id="more"></a>
<h2 id="排序种类"><a href="#排序种类" class="headerlink" title="排序种类"></a>排序种类</h2><p><img src="874710-20170325174528971-1958932805.png" alt="874710-20170325174528971-1958932805.png"></p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><img src="874710-20170321200015221-636653952.png" alt="874710-20170321200015221-636653952.png"><br>原理图如上所示：先将第一个位值上的数跟之后所有位置上的数依次进行比较，如果第一个位置上的数比第二个位置上的数大，则进行互换，然后继续将第一个位置上的数与第三个位置上的数进行比较，经过一轮的比较后，第一个位值上的数就是所有数中最小的一个，接着将第二个位置上的数与之后所有位置上的数进行比较，同样的规则，第二轮比较结束后，第二位放的就是所有数中第二小的数，依次往下比，直到最后一个位置结束。按照这种方法进行排序，就叫做选择排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class SelectSort &#123;</div><div class="line">    //选择排序,将数组按从小到大排序</div><div class="line">    //根据原理分析，使用两层循环即可实现</div><div class="line">    public void selectSort(int[] array)&#123;</div><div class="line">        for(int i=0; i&lt;array.length; i++)&#123;//第一层</div><div class="line">            for (int j = i + 1; j &lt; array.length; j++) &#123;// 第二层</div><div class="line">                if (array[i] &gt; array[j]) &#123;// 数据互换。将小的放前面</div><div class="line">                    int t = array[i];</div><div class="line">                    array[i] = array[j];</div><div class="line">                    array[j] = t;</div><div class="line">                &#125;</div><div class="line">                printProcess(i, j, array);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void printArray(int[] array) &#123;</div><div class="line">        for (int i : array) &#123;</div><div class="line">            System.out.print(i + &quot;,&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void printProcess(int i, int j, int[] array) &#123;</div><div class="line">        System.out.print(String.format(&quot;i=%d, j=%d: &quot;, i, j));</div><div class="line">        printArray(array);</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] array = &#123;5, 8, 3, 1, 4, 10, 7&#125;;</div><div class="line">        SelectSort ss = new SelectSort();</div><div class="line">        ss.selectSort(array);</div><div class="line"></div><div class="line">        System.out.println(&quot;\n=== final result ===&quot;);</div><div class="line">        printArray(array);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">/*</div><div class="line">i=0, j=1: 5,8,3,1,4,10,7,</div><div class="line">i=0, j=2: 3,8,5,1,4,10,7,</div><div class="line">i=0, j=3: 1,8,5,3,4,10,7,</div><div class="line">i=0, j=4: 1,8,5,3,4,10,7,</div><div class="line">i=0, j=5: 1,8,5,3,4,10,7,</div><div class="line">i=0, j=6: 1,8,5,3,4,10,7,</div><div class="line"></div><div class="line">i=1, j=2: 1,5,8,3,4,10,7,</div><div class="line">i=1, j=3: 1,3,8,5,4,10,7,</div><div class="line">i=1, j=4: 1,3,8,5,4,10,7,</div><div class="line">i=1, j=5: 1,3,8,5,4,10,7,</div><div class="line">i=1, j=6: 1,3,8,5,4,10,7,</div><div class="line"></div><div class="line">i=2, j=3: 1,3,5,8,4,10,7,</div><div class="line">i=2, j=4: 1,3,4,8,5,10,7,</div><div class="line">i=2, j=5: 1,3,4,8,5,10,7,</div><div class="line">i=2, j=6: 1,3,4,8,5,10,7,</div><div class="line"></div><div class="line">i=3, j=4: 1,3,4,5,8,10,7,</div><div class="line">i=3, j=5: 1,3,4,5,8,10,7,</div><div class="line">i=3, j=6: 1,3,4,5,8,10,7,</div><div class="line"></div><div class="line">i=4, j=5: 1,3,4,5,8,10,7,</div><div class="line">i=4, j=6: 1,3,4,5,7,10,8,</div><div class="line"></div><div class="line">i=5, j=6: 1,3,4,5,7,8,10,</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">=== final result ===</div><div class="line">1,3,4,5,7,8,10,</div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>简单，给定的一组记录，将其分为两个序列组，一个为有序序列(按照顺序从小到大或者从大到小)，一个为无序序列，初始时，将记录中的第一个数当成有序序列组中的一个数据，剩下其他所有数都当做是无序序列组中的数据。然后从无序序列组中的数据中(也就是从记录中的第二个数据开始)依次与有序序列中的记录进行比较，然后插入到有序序列组中合适的位置，直到无序序列组中的最后一个数据插入到有序序列组中为止。<br><img src="874710-20170321212328377-95116156.png" alt="874710-20170321212328377-95116156.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class InsertSort &#123;</div><div class="line">    //插入排序，按从小到大的顺序</div><div class="line">    public void insertSort(int[] array)&#123;</div><div class="line">        int j, temp;// temp：记录</div><div class="line">        for(int i = 1; i &lt; array.length; i++)&#123;</div><div class="line">            if(array[i] &lt; array[i-1])&#123;</div><div class="line">                temp = array[i];</div><div class="line">                for (j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; temp; j--) &#123;</div><div class="line">                    array[j + 1] = array[j];</div><div class="line">                    printProcess(i, j, array);</div><div class="line">                &#125;</div><div class="line">                array[j+1] = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //如果上面的方法不好理解, 可以看下面的方法</div><div class="line">    public void insertSort2(int[] array) &#123;</div><div class="line">        int j, temp;</div><div class="line">        for (int i = 1; i &lt; array.length; i++) &#123;</div><div class="line">            j = i;</div><div class="line">            temp = array[i];</div><div class="line">            while (j &gt; 0 &amp;&amp; temp &lt; array[j - 1]) &#123;</div><div class="line">                array[j] = array[j - 1];</div><div class="line">                printProcess(i, j, array);</div><div class="line">                j--;</div><div class="line">            &#125;</div><div class="line">            array[j] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void printArray(int[] array) &#123;</div><div class="line">        for (int i : array) &#123;</div><div class="line">            System.out.print(i + &quot;,&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void printProcess(int i, int j, int[] array) &#123;</div><div class="line">        System.out.print(String.format(&quot;i=%d, j=%d: &quot;, i, j));</div><div class="line">        printArray(array);</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        int[] array = &#123;38, 65, 97, 76, 13, 27, 49&#125;;</div><div class="line">        InsertSort ss = new InsertSort();</div><div class="line">        ss.insertSort(array);</div><div class="line">        System.out.println(&quot;\n&quot;);</div><div class="line"></div><div class="line">        int[] arr = &#123;38, 65, 97, 76, 13, 27, 49&#125;;</div><div class="line">        ss.insertSort2(arr);</div><div class="line"></div><div class="line">        System.out.println(&quot;\n=== final result ===&quot;);</div><div class="line">        printArray(array);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">/*</div><div class="line">i=0, j=1: 5,8,3,1,4,10,7,</div><div class="line">i=0, j=2: 3,8,5,1,4,10,7,</div><div class="line">i=0, j=3: 1,8,5,3,4,10,7,</div><div class="line">i=0, j=4: 1,8,5,3,4,10,7,</div><div class="line">i=0, j=5: 1,8,5,3,4,10,7,</div><div class="line">i=0, j=6: 1,8,5,3,4,10,7,</div><div class="line"></div><div class="line">i=1, j=2: 1,5,8,3,4,10,7,</div><div class="line">i=1, j=3: 1,3,8,5,4,10,7,</div><div class="line">i=1, j=4: 1,3,8,5,4,10,7,</div><div class="line">i=1, j=5: 1,3,8,5,4,10,7,</div><div class="line">i=1, j=6: 1,3,8,5,4,10,7,</div><div class="line"></div><div class="line">i=2, j=3: 1,3,5,8,4,10,7,</div><div class="line">i=2, j=4: 1,3,4,8,5,10,7,</div><div class="line">i=2, j=5: 1,3,4,8,5,10,7,</div><div class="line">i=2, j=6: 1,3,4,8,5,10,7,</div><div class="line"></div><div class="line">i=3, j=4: 1,3,4,5,8,10,7,</div><div class="line">i=3, j=5: 1,3,4,5,8,10,7,</div><div class="line">i=3, j=6: 1,3,4,5,8,10,7,</div><div class="line"></div><div class="line">i=4, j=5: 1,3,4,5,8,10,7,</div><div class="line">i=4, j=6: 1,3,4,5,7,10,8,</div><div class="line"></div><div class="line">i=5, j=6: 1,3,4,5,7,8,10,</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">=== final result ===</div><div class="line">1,3,4,5,7,8,10,</div><div class="line">*/</div></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序跟选择排序一样的简单，好理解，整个过程就想气泡一样往上升，假设从小到大排序，对于给定的n个记录，从第一个记录开始依次对相邻的两个记录进行比较，当前面的记录大于后面的记录时，交换位置，进行一轮比较后，第n位上就是整个记录中最大的数，然后在对前n-1个记录进行第二轮比较，重复该过程直到进行比较的记录只剩下一个为止。</p>
<p><img src="874710-20170322200231440-1649992463.png" alt="874710-20170322200231440-1649992463.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//冒泡排序，从小到大</div><div class="line">    /**</div><div class="line">     * 通过看冒泡排序的原理图，我们知道只要让其一直遍历数组即可，只不过每遍历一次，就要让遍历的长度减1，</div><div class="line">     *     所有就在遍历的外面加一层while循环。判断的条件为，当遍历的长度&gt;=1时，此时就只需要遍历两个数据了，比完后不应该在继续。</div><div class="line">     *     非常简单的逻辑。</div><div class="line">     */</div><div class="line">    public void bubbleSort(int[] array)&#123;</div><div class="line">        int j = array.length - 1;</div><div class="line">        while( j &gt;= 1)&#123;</div><div class="line">            for(int i = 0; i &lt; j; i++)&#123;</div><div class="line">                if(array[i] &gt; array[i+1])&#123;</div><div class="line">                    int t = array[i];</div><div class="line">                    array[i] = array[i+1];</div><div class="line">                    array[i+1] = t;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序有两种实现方式，一种是非递归的，一种是递归的，但是我觉得如果你理解了非递归的实现，那么你就知道了归并排序的原理，而递归的也就非常简单了。</p>
<p>什么是归并排序呢？(我们讲解的是2路归并排序)</p>
<p>一张图就可理解什么叫做2路归并排序</p>
<p><img src="874710-20170328210217983-1689530325.png" alt="874710-20170328210217983-1689530325.png"></p>
<p>初始将一个数组中每个元素都看成一个有序序列(数组长度为n)，然后将相邻两个有序序列合并成一个有序序列，第一趟归并就可以得到n/2个长度为2(最后一个有序序列的长度可能是1，也可能不是，关键看数组中元素的个数了)的有序序列，在进行两两归并，得到n/4个长度为4的有序序列(最后一个的长度可能小于4)…一直这样归并下去，直到得到一个长度为n的有序序列1</p>
<p>简单来说，通过三步，解决三个问题，就可以写出归并排序　　　　　　</p>
<p>1、解决相邻两个有序序列归并成一个有序序列，非常简单，新增一个数组(长度和需要排列的数组相同)，</p>
<p>二路归并的核心操作，在归并的过程中，可能会破坏原来的有序序列，所以，将归并的结果存入另外一个数组中，设两个相邻的有序序列为r[s] ~r[m]和r[m+1]~r[t]，将这两个有序序列归并成一个有序序列，r1[s]~r1[t]，设三个参数i,j,k。 i和j分别指向两个有序序列的第一个记录，即i=s，j=m+1，k指向存放归并结果的位置(也就是将归并结果放到r1中的哪个位置)k=s。然后，比较i和j所指记录的数，取出较小者作为归并结果存入k所指的位置，然后将较小者的指向往后移动，直至两个有序序列之一的所有记录都取完，在将另一个有序序列的剩余记录顺序送到归并后的有序序列中(也就是放到r1中)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//一次归并</div><div class="line">    /**</div><div class="line">     *         相邻两个有序序列归并成一个有序序列的过程</div><div class="line">     * @param r        原数组，需要归并的数组</div><div class="line">     * @param r1    新数组，归并后的数组</div><div class="line">     * @param s        两个有序序列的第一个有序序列的第一个元素的下标</div><div class="line">     * @param m        两个有序序列的第一个有序序列的最后一个元素的下标</div><div class="line">     * @param t        两个有序序列的第二个有序序列的最后一个元素的下标</div><div class="line">     */</div><div class="line">    public void merge(int[] r, int[] r1, int s, int m, int t)&#123;</div><div class="line">        int i = s;    //两个有序序列的第一个有序序列的第一个元素的下标</div><div class="line">        int j = m+1;    //两个有序序列的第二个有序序列的第一个元素的下标</div><div class="line">        int k = s;        //新数组中的指向</div><div class="line">        while(i &lt;= m &amp;&amp; j &lt;= t)&#123;//两个有序序列都没有遍历完</div><div class="line">            if(r[i] &lt; r[j])&#123;</div><div class="line">                r1[k++] = r[i++];</div><div class="line">            &#125;else&#123;</div><div class="line">                r1[k++] = r[j++];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        //当其中一个序列遍历完之后，将剩下那个序列加到新数组中,判断是哪一个序列没有遍历完</div><div class="line">        while(i &lt;= m)&#123;</div><div class="line">            r1[k++] = r[i++];</div><div class="line">        &#125;</div><div class="line">        while(j&lt;=t)&#123;</div><div class="line">            r1[k++] = r[j++];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>2、如何完成一趟归并？</p>
<p>这里就需要分情况了，三种情况，</p>
<p>假设每个有序序列中的元素个数为h(第一次归并的h=1)，i=0，从第一个元素开始。归并每次取两个有序序列，那么跨度就是2h，问题就来了，只要知道长度为n(n为数组的最大下标值)的数组中有几个这样的两个有序序列，那么可以进行不同的操作了。</p>
<p>第一种情况：(i+2<em>h-1) &lt;= n  //比如，i=0，h=1时，(i+2</em>h-1)的意思就是指向了第一个两个有序序列的最后一个位置的下标值，用它来跟n(n为数组最大的下标值)比较，如果小于n，那么说明后面还有别的数，如果等于n，说明到结尾了，整个数组正好全是两个有序序列得，不会有多余数。那么就执行一次归并，将这两个有序序列归并，然后i加2h。如果还符合这个条件，继续归并，如果不符合，判断别的情况。</p>
<p>第二种情况：(i+h-1) &lt; n //说明最后还有两个有序序列，但是最后一个有序序列的长度不是h，同样将其进行归并</p>
<p>第三种情况: (i+h-1) &gt;= n //说明只剩下最后一个有序序列，则直接将其有序序列送到r1的相应位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * 一趟归并排序</div><div class="line">     * @param r    原数组，需要归并操作的数组</div><div class="line">     * @param r1 新数组，归并好的数组</div><div class="line">     * @param h 步长多少(有序序列中含有的元素个数)</div><div class="line">     * @param n    数组长度(数组下标的最大值)</div><div class="line">     */</div><div class="line">    public void mergePass(int[] r, int[] r1, int h, int n)&#123;</div><div class="line">        //判断根据步长能分成多个有序序列，</div><div class="line">        int i = 0;</div><div class="line">        while((i+2*h-1) &lt;= n)&#123;//待归并的两个相邻有序序列的长度均为h,需要理解(i+2*h-1)的意思。</div><div class="line">            merge(r,r1,i,i+h-1,i+2*h-1);//需要注意一次归并需要的参数</div><div class="line">            i += 2*h;            </div><div class="line">        &#125;</div><div class="line">        if(i+h-1 &lt; n)&#123;//说明最后还有两个序列，第一个序列长度为h，第二个序列长度小于h</div><div class="line">            merge(r,r1,i,i+h-1,n);</div><div class="line">            i += 2*h;</div><div class="line">        &#125;else&#123;//剩下最后一个序列，长度并且小于或等于h,不用归并了，直接放入新数组中</div><div class="line">            for(; i&lt;=n; i++)&#123;</div><div class="line">                r1[i] = r[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>3、完成整个归并排序</p>
<p>前面我们解决了两个问题，一个是两个有序序列如何进行归并，一个是如何判断完成一趟归并过程。现在就需要解决如何控制二路归并的结束呢？也就是需要归并多少趟。</p>
<p>当步长等于n或者大于n时，说明只剩下一个有序序列了，那么即归并结束了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//二分归并排序非递归算法</div><div class="line">    //n：数组最大下标</div><div class="line">    public void mergeSort(int[] r, int[] r1,int n)&#123;</div><div class="line">        int h = 1;    //从1开始排序</div><div class="line">        while(h&lt;n)&#123;    //直到h&gt;=n才结束，也就步长小于n时都要进行归并</div><div class="line">            mergePass(r,r1,h,n);    //一趟归并</div><div class="line">            h = 2*h;</div><div class="line">            mergePass(r1,r,h,n);//因为经过一趟归并后，r1就变为了那个需要归并的数组，那么r就充当新数组，并且这也能够让排序好的数组放回到r数组中</div><div class="line">            h = 2*h;            </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p> 快速排序是对冒泡排序的增强，增强得点在于：冒泡排序中，记录的比较和移动是在相邻两个位置进行的，记录每次交换只能后移一个位置，因而总的比较次数和移动次数较多，而快排记录的比较和移动是从两端向中间进行的，较大的记录一次就能从前面移动到后面，较小的记录一次就能从后面移动到前面，这样就减少了比较次数和移动次数</p>
<p>快速排序原理：选取一个轴值(比较的基准)，将待排序记录分为独立的两个部分，左侧记录都是小于或等于轴值，右侧记录都是大于或等于轴值，然后分别对左侧部分和右侧部分重复前面的过程，也就是左侧部分又选择一个轴值，又分为两个独立的部分，这就使用了递归了。到最后，整个序列就变得有序了。</p>
<p>问题：如何选择轴值？如何将序列变成左右两部分？ </p>
<p>轴值的选择有三种：<br>1、选取序列的第一个位置上的记录<br>2、选择序列的中间位置上的记录<br>3、将序列第一个位置 和 中间位置 和 末尾位置上的记录进行比较，选择大小居中的记录，</p>
<p> 如何将序列划分成左右两部分？　　　　　　　　　</p>
<p>看图的执行流程，当一趟比较下来，轴值的左侧和右侧就被排好了，其中利用了first和end两个参数，一个从起点开始，一个从末尾开始，当两个相等时，就将序列中所有记录都遍历了一遍，第一次的比较次数是和选择排序第一次比较次数是一样的，但是之后就开始不一样了，因为在轴值的左侧的元素就不用跟轴值右侧的元素进行比较了，而选择排序还是跟所有的比。</p>
<p><img src="874710-20170325201940690-1630559904.png" alt="874710-20170325201940690-1630559904.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*</div><div class="line">     * 对序列划分为左右两个部分,</div><div class="line">     * 轴值为数组第一个元素</div><div class="line">     * i，first:指向需要进行左右两侧排序的序列的第一个位置</div><div class="line">     * j，end:指向需要进行左右两侧排序的序列的最后一个位置</div><div class="line">     */</div><div class="line">    public int Partition(int[] array, int first, int end)&#123;</div><div class="line">        int i = first;</div><div class="line">        int j = end;</div><div class="line">        while(i &lt; j)&#123;        //i和j会慢慢往中间靠，当i==j时，说明已经排好左右两侧的数据了，这里为什么不写i!=j作为条件呢？原因是有些情况是first&gt;end，比如first=0，而end=-1，</div><div class="line">            while(i&lt;j&amp;&amp;array[i] &lt; array[j])&#123;//右侧进行扫描，array[i]是轴值</div><div class="line">                j--;    //最后一个元素是大于轴值的，那么就不动，因为已经在其右边的，j--，往前移动一个位置</div><div class="line">            &#125;</div><div class="line">            if(i &lt; j)&#123;    //这一步是当array[i] &gt; array[j]。轴值的位置变为了j</div><div class="line">                int temp = array[i];</div><div class="line">                array[i] = array[j];</div><div class="line">                array[j] = temp;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            while(i&lt;j&amp;&amp;array[i] &lt; array[j])&#123;//左侧扫描，如果都比轴值小的话，i往后移动</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            if(i &lt; j)&#123;    //当发现有比轴值大的数时，进行互换</div><div class="line">                int temp = array[i];</div><div class="line">                array[i] = array[j];</div><div class="line">                array[j] = temp;</div><div class="line">                j--;        </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return j;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void quickSort(int[] array, int first, int end)&#123;</div><div class="line">        if(first &lt; end)&#123;</div><div class="line">            int pivot = Partition(array,first,end);    //返回轴值的位置，</div><div class="line">            quickSort(array,first,pivot-1);//第一次排好后，pivot-1就是左侧最尾部的位置</div><div class="line">            quickSort(array,pivot+1,end);    //pivot+1，右侧最开始的位置。</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序其实是插入排序的升级版本，本质上进行的也是插入排序的操作，但是希尔排序并不是把一组记录看成一个整体，而将整个记录分为了若干组记录，然后在对每组记录进行插入排序，</p>
<p>分组规则为如下所示：假设有 1 2 3 4 5  6 7 8 9 10 十个位置(每个位置上都会放数，这里忽略数，只讨论位置)。(省略了插入排序操作，只对如何分组进行讲解，而完整的希尔排序就是在每次分组完之后进行插入排序操作即可)</p>
<p>步长为：5、3、1</p>
<p>第一次分为5组记录(组数跟步长是一样的)：1,6 、2,7、3,8、 4,9、 5,10 这五组记录，分别对这五组记录进行插入排序。<br>第二次分为3组记录：1,4,7,10、2,5,8、3,6,9 这三组记录，分别对这三组记录进行插入排序<br>第三次分为1组记录：1 2 3 4 5 6  7 8 9 10， 为这组记录进行插入排序，</p>
<p>而步长只要满足最后一次为1，并且是从大到小即可。一般使用(数组长度/2) 或者 (数组长度/3 +1) 来代表步长。</p>
<p>这样做的好处是：<br>将待排序的数组元素分成多组，每组中记录数相对较少<br>经过前几次的排序后，整个序列变为了“基本有序序列”，最后在对所有元素进行一次直接插入排序。<br>直接插入排序对基本有序和记录数少的序列的效率是非常高的，而希尔排序就是利用了这两点。</p>
<p><img src="874710-20170323203454752-1019588241.png" alt="874710-20170323203454752-1019588241.png"></p>
<p>解释：第一次分组，49,13、38,27、65,49、97,55、76,04  五组，对这五组分别进行插入排序，在49找到13时，就会进行插入排序，位置会进行互换，而并非先全部分组，后排序。</p>
<p>按照步长一直重复执行，直到步长为1后，执行完最后一次直接插入排序，整个希尔排序就完成了。　　　　</p>
<p>运行时动态图：看最下面我分享的资源即可<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void shellSort(int[] array)&#123;</div><div class="line">        int i,j,temp;    //i,j分别为for循环中的控制变量 temp作用是临时记录数</div><div class="line">        int length = array.length;</div><div class="line">        int gap = length;</div><div class="line">        do&#123;</div><div class="line">            gap = gap/2;    //步长， 假设length为10，则步长为5 2 1</div><div class="line">            for(i = gap; i&lt;length; i++)&#123;</div><div class="line">                if(array[i] &lt; array[i-gap])&#123;</div><div class="line">                    temp = array[i];</div><div class="line">                    for(j = i-gap; j&gt;=0 &amp;&amp; array[j]&gt;temp; j-=gap)&#123;</div><div class="line">                        array[j+gap] = array[j];</div><div class="line">                    &#125;</div><div class="line">                    array[j+gap] = temp;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        &#125;while(gap&gt;0);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>上面说的希尔排序是对插入排序的增强，那么堆排序呢，就是对选择排序进行增强，选择排序一个数据要跟每个数据都进行一次比较，并没有利用到一些比较的结果，比如，4 跟10比较，3跟4比较后，按理说不用让3跟10在比了，但是选择排序并没有这种智能化，而是老老实实的比较，而堆排序就完美的利用了前几次比较的结果，从而增加了效率。</p>
<p>讲解堆排序之前，必须要知道什么是堆？</p>
<p>堆是一颗完全二叉树，什么是完全二叉树？只有最下面的两层结点度能够小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树(还不懂就去百度一下什么是完全二叉树)<br><img src="874710-20170324195035346-1788803109.png" alt="874710-20170324195035346-1788803109.png"></p>
<p>这个图是一个完全二叉树，但不是堆。<br>堆分两种，大顶堆和小顶堆<br>大顶堆：在完全二叉树的基础上，每个父节点都比自己的两个子结点大，这样的就是大顶堆，特点是根节点是最大的值，看下图，90比70,80大，70比60,10大，以此类推</p>
<p><img src="874710-20170324195237752-1176680883.png" alt="874710-20170324195237752-1176680883.png"></p>
<p>小顶堆：和大顶堆相反，根节点是最小的值，并且每个父结点都比自己的子节点要小，如下图</p>
<p><img src="874710-20170324195652627-1999302639.png" alt="874710-20170324195652627-1999302639.png"></p>
<p>堆排序就是利用堆的这种特点进行编写的，原理：先将一组拥有n个元素的序列构建成大顶堆或者小顶堆，在将根结点上的数跟堆最后一位数进行互换，此时，第n位的数就是整个序列中最大或者最小的数了，然后在将前n-1位元素进行构建成大顶堆或者小顶堆，在将根结点跟第n-1位进行互换，得到第2大或者第2小的数，在将前n-2位数进行构建，依次类推，直到只剩下1位元素即结束，排序完成。</p>
<p>通过讲解原理：堆排序分为三步<br>1、构建大顶堆或小顶堆<br>2、循环<br>根节点和末尾结点进行互换，<br>构建大顶堆或小顶堆　<br>3、排序完成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*</div><div class="line">     * 要知道什么是堆这种数据结构</div><div class="line">     *         堆是一颗完全二叉树。分为大顶堆和小顶堆，</div><div class="line">     *         大顶堆，每个父结点都比自己的子节点大，也就是根结点为最大</div><div class="line">     *         小顶堆，每个父结点都比自己的子节点小，也就是根结点最小。</div><div class="line">     * 按照大顶堆和小顶堆这种特点，将一个无序的n个记录的序列构建成大顶堆,将根节点上的数与最后一个</div><div class="line">     * 结点n进行交换，然后在对n-1个记录进行构建大顶堆，继续把根节点与最后一个结点(n-1)互换，继续上面的操作。</div><div class="line">     *         从小到大排序，则使用大顶堆</div><div class="line">     *         从大到小排序，则使用小顶堆</div><div class="line">     *     从小到大</div><div class="line">     */</div><div class="line">    public void heapSort(int[] array)&#123;</div><div class="line">        //第一步：将数组构建成一个大顶堆 </div><div class="line">        int length = array.length;    //length为数组的长度，有几个数就是几，不要跟数组最大的下标值搞混淆了，有10个数，length就是10，数组最大下标为9</div><div class="line">        //找到完全二叉树中的最后一个父结点(拥有子结点)的位置length/2，也就是最后一个父节点是在完全二叉树的第length/2的位置上，但是在数组中的位置是 (length/2)-1，它代表父节点在数组中的位置</div><div class="line">        for(int i = length/2-1; i &gt;= 0; i--)&#123;//依次遍历每一个父节点，比如最后一个父节点是4，那么它前面所有结点都是父节点，都需要进行构建</div><div class="line">            adjustMaxHeap(array,i,length);    //无序序列，所以需要从下往上全部进行构建。该方法做的事情就是，比较找到父节点，和两个子节点中最大的数放置到父节点的位置上。</div><div class="line">        &#125;</div><div class="line">        //第二步：构建好了大顶堆后，将第一个数与最后一个进行互换,互换后继续调整大顶堆，</div><div class="line">        for(int i = length-1; i &gt; 0; i--)&#123;</div><div class="line">            wrap(array, 0, i);        //互换数据，提取出来了。互换数据后，就已经不在是大顶堆了，需要重新进行构建</div><div class="line">            adjustMaxHeap(array, 0, i);    //从上往下，因为基本上都已经有序了，没必要在从下往上重新进行构建堆了，这就利用了前面比较的结果，减少了很多次比较。</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //互换数据</div><div class="line">    private void wrap(int[] array, int i, int j)&#123;</div><div class="line">        int temp = array[i];</div><div class="line">        array[i] = array[j];</div><div class="line">        array[j] = temp;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    /**</div><div class="line">     *             构建大顶堆的操作，</div><div class="line">     *         父节点和其左右子节点的大小比较和互换，每次将父结点的位置和数组传进来，</div><div class="line">     *         就能构建出大顶堆了。</div><div class="line">     * </div><div class="line">     * @param array    排序数组</div><div class="line">     * @param s    当前所指父节点在数组中位置(下标)</div><div class="line">     * @param length 数组的长度。用来判断父节点的两个子节点是否存在。</div><div class="line">     *         父节点和左子结点的关系： 2s+1</div><div class="line">     *         父结点和右子结点的关系： 2s+2</div><div class="line">     */</div><div class="line">    private void adjustMaxHeap(int[] array, int s, int length) &#123;</div><div class="line">        int temp = array[s];</div><div class="line">        int child;            //代表更大一方的子节点的数组下标</div><div class="line">        //2s+1 是左子节点在数组中的位置，本来s+1是父节点在二叉树中的位置，2*(s+1) 是左子节点在二叉树中的位置，那么左子节点在数组中的位置为2*(s+1)-1，简化就为2s+1了</div><div class="line">        //为什么需要这个for循环？很多人不理解，觉得这个方法里只需要找到父节点和两个子结点最大的一个即可，这是因为忽略了一个小问题，看下面到152行的解释应该就明白了。</div><div class="line">        for(child=s*2+1; child &lt;= length-1; child=child*2+1)&#123;    //child &lt;= length-1 说明肯定有子节点，如果child=length-1，说明只有左结点</div><div class="line">            </div><div class="line">            if(child &lt; length-1&amp;&amp;array[child] &lt; array[child+1])&#123;//child&lt;length-1，就说明肯定右子结点，将其进行比较，找出大的一方的数组下标</div><div class="line">                child++;    //变成右子节点所在数组中的下标，找到那个较大的子节点</div><div class="line">            &#125;</div><div class="line">            if(array[child] &gt; temp)&#123;    //将子节点(可能是左结点，也可能是右结点，就看上面这个判断了)与父节点进行比较，子节点大的话，将大的赋给父节点</div><div class="line">                array[s] = array[child];    </div><div class="line">            &#125;else&#123;        //父节点大，什么也不做，跳出这层循环。</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            array[child] = temp;    //父结点变为最大时，要将原先的父节点的值给现在的子节点。</div><div class="line">            s = child;        //因为子节点的值变了，那么就不知道这个子节点在他自己的两个子节点中是否还是最大，所以需要将该子节点的数组下标给s，去重新检测一遍。只有当父节点为最大时，才会执行break退出循环。</div><div class="line">            </div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="总结比较各种排序算法的优缺点"><a href="#总结比较各种排序算法的优缺点" class="headerlink" title="总结比较各种排序算法的优缺点"></a>总结比较各种排序算法的优缺点</h2><p><img src="874710-20170330164032149-319598517.png" alt="874710-20170330164032149-319598517.png"><br>1、注意，排序的稳定性的意思是：举例说明。<br>排序前：5,6（1）,1,4,3,6（2）,（第一个6在第二个6之前）<br>排序后：如果排序后的结果是1,2,3,4,5,6（1），6（2）那么就说此排序算 法是稳定的，反之为不稳定<br>2、当待排序记录个数n较大，并且是无序序列，对稳定性不作要求时，采用快速排序为宜<br>3、当待排序记录个数n较大，内存空间允许，要求排序稳定时，采用归并排序为宜<br>4、当待排序记录个数n较大，且序列中可能出现正序或逆序的情况，不要求稳定性，采用堆排序或归并排序为宜</p>
<p>ref: <a href="https://www.cnblogs.com/whgk/p/6596787.html" target="_blank" rel="external">https://www.cnblogs.com/whgk/p/6596787.html</a></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>DataStructure</title>
    <url>/2017/09/22/DataStructure/</url>
    <content><![CDATA[<p>数据结构和算法简介</p>
<a id="more"></a>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构是计算机存储、组织数据的方式，指相互之间存在一种或多种特定关系的数据元素的集合。</p>
<p>通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p>
<p>一、数据结构的基本功能<br>　　①、如何插入一条新的数据项</p>
<p>　　②、如何寻找某一特定的数据项</p>
<p>　　③、如何删除某一特定的数据项</p>
<p>　　④、如何迭代的访问各个数据项，以便进行显示或其他操作</p>
<p>二、常用的数据结构</p>
<p><img src="1120165-20171124224517593-271461566.png" alt="1120165-20171124224517593-271461566.png"></p>
<p>这几种结构优缺点如下<br><img src="1120165-20171124223229656-408723583.png" alt="1120165-20171124223229656-408723583.png"></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>　　算法简单来说就是解决问题的步骤。</p>
<p>　　在Java中，算法通常都是由类的方法来实现的。前面的数据结构，比如链表为啥插入、删除快，而查找慢，平衡的二叉树插入、删除、查找都快，这都是实现这些数据结构的算法所造成的。后面我们讲的各种排序实现也是算法范畴的重要领域。</p>
<p>　　一、算法的五个特征<br>　　①、有穷性：对于任意一组合法输入值，在执行又穷步骤之后一定能结束，即：算法中的每个步骤都能在有限时间内完成。</p>
<p>　　②、确定性：在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行。并且在任何条件下，算法都只有一条执行路径。</p>
<p>　　③、可行性：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。</p>
<p>　　④、有输入：作为算法加工对象的量值，通常体现在算法当中的一组变量。有些输入量需要在算法执行的过程中输入，而有的算法表面上可以没有输入，实际上已被嵌入算法之中。</p>
<p>　　⑤、有输出：它是一组与“输入”有确定关系的量值，是算法进行信息加工后得到的结果，这种确定关系即为算法功能。</p>
<p>　　</p>
<p>　　二、算法的设计原则<br>　　①、正确性：首先，算法应当满足以特定的“规则说明”方式给出的需求。其次，对算法是否“正确”的理解可以有以下四个层次：</p>
<p>　　　　　　　　一、程序语法错误。</p>
<p>　　　　　　　　二、程序对于几组输入数据能够得出满足需要的结果。</p>
<p>　　　　　　　　三、程序对于精心选择的、典型、苛刻切带有刁难性的几组输入数据能够得出满足要求的结果。</p>
<p>　　　　　　　　四、程序对于一切合法的输入数据都能得到满足要求的结果。</p>
<p>　　　　　　　　PS：通常以第 三 层意义的正确性作为衡量一个算法是否合格的标准。</p>
<p>　　②、可读性：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。</p>
<p>　　③、健壮性：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。</p>
<p>　　④、高效率与低存储量需求：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。</p>
<p>　　前面三点 正确性，可读性和健壮性相信都好理解。对于第四点算法的执行效率和存储量，我们知道比较算法的时候，可能会说“A算法比B算法快两倍”之类的话，但实际上这种说法没有任何意义。因为当数据项个数发生变化时，A算法和B算法的效率比例也会发生变化，比如数据项增加了50%，可能A算法比B算法快三倍，但是如果数据项减少了50%，可能A算法和B算法速度一样。所以描述算法的速度必须要和数据项的个数联系起来。也就是“大O”表示法，它是一种算法复杂度的相对表示方式，这里我简单介绍一下，后面会根据具体的算法来描述。</p>
<p>　　相对(relative)：你只能比较相同的事物。你不能把一个做算数乘法的算法和排序整数列表的算法进行比较。但是，比较2个算法所做的算术操作（一个做乘法，一个做加法）将会告诉你一些有意义的东西；</p>
<p>　　表示(representation)：大O(用它最简单的形式)把算法间的比较简化为了一个单一变量。这个变量的选择基于观察或假设。例如，排序算法之间的对比通常是基于比较操作(比较2个结点来决定这2个结点的相对顺序)。这里面就假设了比较操作的计算开销很大。但是，如果比较操作的计算开销不大，而交换操作的计算开销很大，又会怎么样呢？这就改变了先前的比较方式；</p>
<p>　　复杂度(complexity)：如果排序10,000个元素花费了我1秒，那么排序1百万个元素会花多少时间？在这个例子里，复杂度就是相对其他东西的度量结果。</p>
<p>　　然后我们在说说算法的存储量，包括：</p>
<p>　　程序本身所占空间；</p>
<p>　　输入数据所占空间；</p>
<p>　　辅助变量所占空间；</p>
<p>　　一个算法的效率越高越好，而存储量是越低越好。</p>
<p>ref:<br><a href="https://www.cnblogs.com/ysocean/p/7889153.html" target="_blank" rel="external">https://www.cnblogs.com/ysocean/p/7889153.html</a></p>
]]></content>
      <categories>
        <category>DataStructure</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub-高效搜索开源项目</title>
    <url>/2017/09/22/GitHub-%E9%AB%98%E6%95%88%E6%90%9C%E7%B4%A2%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>你在 GitHub上搜索代码时，是怎么样操作的呢？是不是也是像我这样，直接在搜索框里输入要检索的内容，然后不断在列表里翻页找自己需要的内容？<br><img src="WX20190528-1450422x.png" alt="WX20190528-1450422x.png"></p>
<p>或者是简单筛选下，在左侧加个语言的过滤项。<br><img src="WX20190528-1451472x.png" alt="WX20190528-1451472x.png"></p>
<p>再或者改变一下列表的排序方式<br><img src="WX20190528-1452262x.png" alt="WX20190528-1452262x.png"></p>
<p>这就是「全部」了吗？ </p>
<p>一般的系统检索功能，都会有一个「高级搜索」的功能。需要在另外的界面里展开，进行二次搜索之类的。 GitHub 有没有类似的呢？</p>
<p>答案是「肯定的」。做为一个为万千工程师提供服务的网站，不仅要有，而且还要技术范儿。</p>
<p>如果我们自己开发一个类似的应用，会怎样实现呢？ </p>
<p>带着思路，咱们一起来看看，GitHub 是怎样做的。</p>
<p>这里我们假设正要学习 Spring Cloud，要找一个 Spring Cloud 的 Demo 参考练手。</p>
<a id="more"></a>
<h2 id="明确搜索仓库标题、仓库描述、README"><a href="#明确搜索仓库标题、仓库描述、README" class="headerlink" title="明确搜索仓库标题、仓库描述、README"></a>明确搜索仓库标题、仓库描述、README</h2><p>GitHub 提供了便捷的搜索方式，可以限定只搜索仓库的标题、或者描述、README等。<br>以Spring Cloud 为例，一般一个仓库，大概是这样的<br><img src="WX20190528-1454002x.png" alt="WX20190528-1454002x.png"></p>
<p>其中，红色箭头指的两个地方，分别是仓库的<strong>名称</strong>和<strong>描述</strong>。咱们可以直接限定关键字只查特定的地方。比如咱们只想查找仓库名称包含 spring cloud 的仓库，可以使用语法</p>
<p><strong>in:name</strong> 关键词<br><img src="WX20190528-1457292x.png" alt="WX20190528-1457292x.png"></p>
<p>如果想查找描述的内容，可以使用这样的方式：</p>
<p><strong>in:descripton</strong> 关键词</p>
<p>这里就是搜索上面项目描述的内容。</p>
<p>一般项目，都会有个README文件，如果要查该文件包含特定关键词的话，我想你猜到了</p>
<p><strong>in:readme</strong> 关键词</p>
<h2 id="明确搜索-star、fork-数大于多少的"><a href="#明确搜索-star、fork-数大于多少的" class="headerlink" title="明确搜索 star、fork 数大于多少的"></a>明确搜索 star、fork 数大于多少的</h2><p>一个项目 star 数的多少，一般代表该项目有受欢迎程度。虽然现在也有垃圾项目刷 star ，但毕竟是少数， star 依然是个不错的衡量标准。</p>
<p><strong>stars: &gt;</strong> 数字  关键字。</p>
<p>比如咱们要找 star 数大于 3000 的Spring Cloud 仓库，就可以这样<br>stars:&gt;3000 spring cloud</p>
<p>如果不加 &gt;= 的话，是要精确找 star 数等于具体数字的，这个一般有点困难。<br>如果要找在指定数字区间的话，使用</p>
<p><strong>stars: 10..20</strong> 关键词</p>
<p>fork 数同理，将上面的 stars 换成 fork，其它语法相同</p>
<h2 id="明确搜索仓库大小的"><a href="#明确搜索仓库大小的" class="headerlink" title="明确搜索仓库大小的"></a>明确搜索仓库大小的</h2><p>比如你只想看个简单的 Demo，不想找特别复杂的且占用磁盘空间较多的，可以在搜索的时候直接限定仓库的 size 。<br>使用方式：</p>
<p><strong>size:&gt;=5000</strong> 关键词</p>
<p>这里注意下，这个数字代表K, 5000代表着5M。</p>
<h2 id="明确仓库是否还在更新维护"><a href="#明确仓库是否还在更新维护" class="headerlink" title="明确仓库是否还在更新维护"></a>明确仓库是否还在更新维护</h2><p>我们在确认是否要使用一些开源产品，框架的时候，是否继续维护是很重要的一点。如果已经过时没人维护的东西，踩了坑就不好办了。而在 GitHub 上找项目的时候，不再需要每个都点到项目里看看最近 push 的时间，直接在搜索框即可完成。</p>
<p>元旦刚过，比如咱们要找临近年底依然在勤快更新的项目，就可以直接指定<strong>更新时间</strong>在哪个时间前或后的 </p>
<p><strong>pushed:&gt;</strong>2019-01-03 spring cloud</p>
<p>咱们就找到了1月3号之后，还在更新的项目。</p>
<p>你是想找指定时间之前或之后创建的仓库也是可以的，把 pushed 改成 <strong>created</strong> 就行</p>
<h2 id="明确搜索仓库的-LICENSE"><a href="#明确搜索仓库的-LICENSE" class="headerlink" title="明确搜索仓库的 LICENSE"></a>明确搜索仓库的 LICENSE</h2><p>咱们经常使用开源软件，一定都知道，开源软件也是分不同的「门派」不同的LICENSE。开源不等于一切免费，不同的许可证要求也大不相同。 2018年就出现了 Facebook 修改 React 的许可协议导致各个公司纷纷修改自己的代码，寻找替换的框架。</p>
<p>例如咱们要找协议是最为宽松的 Apache License 2 的代码，可以这样</p>
<p><strong>license:</strong>apache-2.0 spring cloud</p>
<h2 id="明确搜索仓库的语言"><a href="#明确搜索仓库的语言" class="headerlink" title="明确搜索仓库的语言"></a>明确搜索仓库的语言</h2><p>比如咱们就找 Java 的库， 除了像上面在左侧点击选择之外，还可以在搜索中过滤。像这样：</p>
<p><strong>language:</strong>java  关键词</p>
<h2 id="明确搜索某个人或组织的仓库"><a href="#明确搜索某个人或组织的仓库" class="headerlink" title="明确搜索某个人或组织的仓库"></a>明确搜索某个人或组织的仓库</h2><p>比如咱们想在 GitHub 上找一下某个大神是不是提交了新的功能，就可以指定其名称后搜索，例如咱们看下 Josh Long 有没有提交新的 Spring Cloud 的代码，可以这样使用</p>
<p><strong>user:</strong>joshlong</p>
<p>找某个组织的代码话，可以这样：</p>
<p><strong>org:spring-cloud</strong> 就可以列出具体org 的仓库。</p>
<h2 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h2><p>把 Java 项目过滤出来，多个查询之间「空格」分隔即可。</p>
<p>user:joshlong language:java</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/__MXKPICzAL4mLetycfc9A" target="_blank" rel="external">https://mp.weixin.qq.com/s/__MXKPICzAL4mLetycfc9A</a></p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava-DirectExecutor</title>
    <url>/2017/09/22/Guava-DirectExecutor/</url>
    <content><![CDATA[<p>DirectExecutor</p>
<a id="more"></a>
<p>源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.google.common.util.concurrent;</div><div class="line"></div><div class="line">import com.google.common.annotations.GwtCompatible;</div><div class="line">import java.util.concurrent.Executor;</div><div class="line"></div><div class="line">/**</div><div class="line"> * An &#123;@link Executor&#125; that runs each task in the thread that invokes &#123;@link Executor#execute</div><div class="line"> * execute&#125;.</div><div class="line"> */</div><div class="line">@GwtCompatible</div><div class="line">enum DirectExecutor implements Executor &#123;</div><div class="line">  INSTANCE;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void execute(Runnable command) &#123;</div><div class="line">    command.run();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public String toString() &#123;</div><div class="line">    return &quot;MoreExecutors.directExecutor()&quot;;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>文档的大意: DirectExecutor 是哪样一种Executor? 在调用execute的线程中执行每个任务, 并不会开启新线程。下面验证下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.google.common.util.concurrent.MoreExecutors;</div><div class="line">import java.util.concurrent.Executor;</div><div class="line"></div><div class="line">public class DirectExecutorTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(&quot;main thread: &quot; + Thread.currentThread().getName());</div><div class="line">        Executor executor = MoreExecutors.directExecutor();</div><div class="line">        executor.execute(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                System.out.println(&quot;current thread: &quot;+Thread.currentThread().getName());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /* output:</div><div class="line">    main thread: main</div><div class="line">    current thread: main</div><div class="line">     */</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一般使用异步模式的时候，都会用一个线程池来提交任务，不会像上面那样简单的开一个线程去做，那样效率太低下了,故, Guava在很多场景并不推荐使用该executor</p>
]]></content>
      <categories>
        <category>Guava</category>
      </categories>
      <tags>
        <tag>Guava</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava-ListenableFuture</title>
    <url>/2017/09/22/Guava-ListenableFuture/</url>
    <content><![CDATA[<p>Guava-ListenableFuture</p>
<a id="more"></a>
<p>jdk原生的 Future 已经提供了异步操作，但是不能直接回调。Guava 对 Future 进行了增强，核心接口就是ListenableFuture。如果已经开始使用了jdk8，可以直接学习使用原生的CompletableFuture</p>
<p>Guava 对jdk的异步增强可以通过看 MoreExecutor 和 Futures 两个类的源码入手，写的并不复杂，没有一层一层的调用，逻辑很清晰，建议读完本文通过这两个类由点到面的理解 Guava 到底做了什么</p>
<h2 id="ListenableFuture"><a href="#ListenableFuture" class="headerlink" title="ListenableFuture"></a>ListenableFuture</h2><p>ListenableFuture 继承了 Future，额外新增了一个方法，listener 是任务结束后的回调方法，executor 是执行回调方法的执行器(通常是线程池)。Guava 中对 Future 的增强就是在 addListener 这个方法上进行了各种各样的封装，所以 addListener 是核心方法<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">void addListener(Runnable listener, Executor executor);</div></pre></td></tr></table></figure></p>
<h2 id="ListenableFutureTask"><a href="#ListenableFutureTask" class="headerlink" title="ListenableFutureTask"></a>ListenableFutureTask</h2><p>jdk 原生 FutureTask 类是对 Future 接口的实现，Guava中 ListenableFutureTask 继承了 FutureTask 并实现了 ListenableFuture，Guava 异步回调最简单的使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//ListenableFutureTask通过静态create方法返回实例，还有一个重载方法，不太常用</div><div class="line">ListenableFutureTask&lt;String&gt; task = ListenableFutureTask.create(new Callable&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public String call() throws Exception &#123;</div><div class="line">        return &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">//启动任务</div><div class="line">new Thread(task).start();</div><div class="line">//增加回调方法，MoreExecutors.directExecutor()返回guava默认的Executor，执行回调方法不会新开线程，所有回调方法都在当前线程做(可能是主线程或者执行ListenableFutureTask的线程，具体可以看最后面的代码)。</div><div class="line">//guava异步模块中参数有Executor的方法，一般还会有一个没有Executor参数的重载方法，使用的就是MoreExecutors.directExecutor()</div><div class="line">task.addListener(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;done&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;, MoreExecutors.directExecutor());</div><div class="line">//MoreExecutors.directExecutor()源码，execute方法就是直接运行，没有新开线程</div><div class="line">public static Executor directExecutor() &#123;</div><div class="line">    return DirectExecutor.INSTANCE;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private enum DirectExecutor implements Executor &#123;</div><div class="line">    INSTANCE;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void execute(Runnable command) &#123;</div><div class="line">        command.run();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String toString() &#123;</div><div class="line">        return &quot;MoreExecutors.directExecutor()&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一般使用异步模式的时候，都会用一个线程池来提交任务，不会像上面那样简单的开一个线程去做，那样效率太低下了，所以需要说说guava对jdk原生线程池的封装。guava对原生线程池的增强都在MoreExecutor类中，guava对ExecutorService和ScheduledExecutorService的增强类似，这里只介绍ExecutorService的增强</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//真正干活的线程池</div><div class="line">ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(</div><div class="line">        5,</div><div class="line">        5,</div><div class="line">        0,</div><div class="line">        TimeUnit.SECONDS,</div><div class="line">        new ArrayBlockingQueue&lt;&gt;(100),</div><div class="line">        new CustomizableThreadFactory(&quot;demo&quot;),</div><div class="line">        new ThreadPoolExecutor.DiscardPolicy());</div><div class="line">//guava的接口ListeningExecutorService继承了jdk原生ExecutorService接口，重写了submit方法，修改返回值类型为ListenableFuture</div><div class="line">ListeningExecutorService listeningExecutor = MoreExecutors.listeningDecorator(poolExecutor);</div><div class="line"></div><div class="line">//获得一个随着jvm关闭而关闭的线程池，通过Runtime.getRuntime().addShutdownHook(hook)实现</div><div class="line">//修改ThreadFactory为创建守护线程，默认jvm关闭时最多等待120秒关闭线程池，重载方法可以设置时间</div><div class="line">ExecutorService newPoolExecutor = MoreExecutors.getExitingExecutorService(poolExecutor);</div><div class="line"></div><div class="line">//只增加关闭线程池的钩子，不改变ThreadFactory</div><div class="line">MoreExecutors.addDelayedShutdownHook(poolExecutor, 120, TimeUnit.SECONDS);</div></pre></td></tr></table></figure>
<p>有了上面的学习，就可以真正使用guava的异步回调了<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//像线程池提交任务，并得到ListenableFuture</div><div class="line">ListenableFuture&lt;String&gt; listenableFuture = listeningExecutor.submit(new Callable&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public String call() throws Exception &#123;</div><div class="line">        return &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">//可以通过addListener对listenableFuture注册回调，但是通常使用Futures中的工具方法</div><div class="line">Futures.addCallback(listenableFuture, new FutureCallback&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void onSuccess(String result) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onFailure(Throwable t) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">/**</div><div class="line"> * Futures.addCallback源码，其实就是包装了一层addListener，可以不加executor参数，使用上文说的DirectExecutor</div><div class="line"> * 需要说明的是不加Executor的情况，只适用于轻型的回调方法，如果回调方法很耗时占资源，会造成线程阻塞</div><div class="line"> * 因为DirectExecutor有可能在主线程中执行回调</div><div class="line"> */</div><div class="line">public static &lt;V&gt; void addCallback(final ListenableFuture&lt;V&gt; future, final FutureCallback&lt;? super V&gt; callback, Executor executor) &#123;</div><div class="line">    Preconditions.checkNotNull(callback);</div><div class="line">    Runnable callbackListener =</div><div class="line">            new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    final V value;</div><div class="line">                    try &#123;</div><div class="line">                        value = getDone(future);</div><div class="line">                    &#125; catch (ExecutionException e) &#123;</div><div class="line">                        callback.onFailure(e.getCause());</div><div class="line">                        return;</div><div class="line">                    &#125; catch (RuntimeException e) &#123;</div><div class="line">                        callback.onFailure(e);</div><div class="line">                        return;</div><div class="line">                    &#125; catch (Error e) &#123;</div><div class="line">                        callback.onFailure(e);</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                    callback.onSuccess(value);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">    future.addListener(callbackListener, executor);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>guava还提供了多个异步任务的链式执行方法，如果使用addListener实现大概是这样，会一层一层不断地套下去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ListenableFutureTask&lt;String&gt; task1 = ListenableFutureTask.create(new Callable&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public String call() throws Exception &#123;</div><div class="line">        return &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">new Thread(task1).start();</div><div class="line">task1.addListener(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        ListenableFutureTask&lt;String&gt; task2 = ListenableFutureTask.create(new Callable&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String call() throws Exception &#123;</div><div class="line">                return &quot;&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        task2.addListener(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                ...</div><div class="line">            &#125;</div><div class="line">        &#125;, MoreExecutors.directExecutor());</div><div class="line">        new Thread(task2).start();</div><div class="line">    &#125;</div><div class="line">&#125;, MoreExecutors.directExecutor());</div></pre></td></tr></table></figure>
<p>使用guava的异步链式执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//当task1执行完毕会回调执行Function的apply方法，如果有task1有异常抛出，则task2也抛出相同异常，不执行apply</div><div class="line">ListenableFuture&lt;String&gt; task2 = Futures.transform(task1, new Function&lt;String, String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public String apply(String input) &#123;</div><div class="line">        return &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">ListenableFuture&lt;String&gt; task3 = Futures.transform(task2, new Function&lt;String, String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public String apply(String input) &#123;</div><div class="line">        return &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">//处理最终的异步任务</div><div class="line">Futures.addCallback(task3, new FutureCallback&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public void onSuccess(String result) &#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onFailure(Throwable t) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>Futures.transform()和Futures.addCallback()都是对addListener做了封装，进行回调的设置，但是transform更适合用在链式处理的中间过程，addCallback更适合用在处理最终的结果上</p>
<h2 id="Futures-transform"><a href="#Futures-transform" class="headerlink" title="Futures.transform"></a>Futures.transform</h2><p>Futures.transform()和Futures.transformAsync()的区别在于一个参数为Function，一个是AsyncFuntion，AsyncFuntion的apply方法返回值类型也是ListenableFuture，也就是回调方法也是异步的<br>transform和transformAsync不传入executor的方法已经被废弃准备删去了，不传入Executor时是哪个线程注意到任务结束了就在哪个线程执行回调方法，既可能是主线程，也可能是执行前一个任务的线程，这样会造成混乱。可以看下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ListenableFutureTask&lt;String&gt; task1 = ListenableFutureTask.create(new Callable&lt;String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public String call() throws Exception &#123;</div><div class="line">        TimeUnit.SECONDS.sleep(5);</div><div class="line">        System.out.println(&quot;task1 over&quot; + new Date());</div><div class="line">        return &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">new Thread(task1).start();</div><div class="line">//放开注释的话，上面的线程已经结束，所以是主线程执行回调方法，因此主线程会阻塞5s</div><div class="line">//TimeUnit.SECONDS.sleep(6);</div><div class="line">ListenableFuture&lt;String&gt; transform = Futures.transform(task1, new Function&lt;String, String&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public String apply(String input) &#123;</div><div class="line">        try &#123;</div><div class="line">            TimeUnit.SECONDS.sleep(5);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;trans over&quot; + new Date());</div><div class="line">        //显示的是执行task1的线程</div><div class="line">        System.out.println(&quot;trans over&quot; + Thread.currentThread());</div><div class="line">        return &quot;&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">while (true) &#123;</div><div class="line">    TimeUnit.MILLISECONDS.sleep(200);</div><div class="line">    System.out.println(new Date().toString() + Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://www.jianshu.com/p/9c57aa5e34af" target="_blank" rel="external">guava异步增强——ListenableFuture</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Guava</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava-Multimap</title>
    <url>/2017/09/22/Guava-Multimap/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">每个有经验的Java程序员都在某处实现过Map&lt;K, List&lt;V&gt;&gt;或Map&lt;K, Set&lt;V&gt;&gt;，并且要忍受这个结构的笨拙。</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>假如目前有个需求是给两个年级添加5个学生，并且统计出一年级学生的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class MultimapTest &#123;</div><div class="line">    class Student &#123;</div><div class="line">        String name;</div><div class="line">        int age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static final String CLASS_NAME_1 = &quot;一年级&quot;;</div><div class="line">    private static final String CLASS_NAME_2 = &quot;二年级&quot;;</div><div class="line">    </div><div class="line">    Map&lt;String, List&lt;Student&gt;&gt; StudentsMap = new HashMap&lt;String, List&lt;Student&gt;&gt;();</div><div class="line"></div><div class="line">    public void testStudent() &#123;</div><div class="line">        </div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            Student student = new Student();</div><div class="line">            student.name = &quot;Tom&quot; + i;</div><div class="line">            student.age = 6;</div><div class="line">            addStudent(CLASS_NAME_1, student);</div><div class="line">        &#125;</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            Student student = new Student();</div><div class="line">            student.name = &quot;Jary&quot; + i;</div><div class="line">            student.age = 7;</div><div class="line">            addStudent(CLASS_NAME_2, student);</div><div class="line">        &#125;</div><div class="line">        List&lt;Student&gt; class1StudentList = StudentsMap.get(CLASS_NAME_1);</div><div class="line">        </div><div class="line">        for (Student stu : class1StudentList) &#123;</div><div class="line">            System.out.println(&quot;一年级学生 name:&quot; + stu.name + &quot; age:&quot; + stu.age);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void addStudent(String className, Student student) &#123;</div><div class="line">        List&lt;Student&gt; students = StudentsMap.get(className);</div><div class="line">        if (students == null) &#123;</div><div class="line">            students = new ArrayList&lt;Student&gt;();</div><div class="line">            StudentsMap.put(className, students);</div><div class="line">        &#125;</div><div class="line">        students.add(student);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MultimapTest multimapTest = new MultimapTest();</div><div class="line">        multimapTest.testStudent();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到我们实现起来特别麻烦，需要检查key是否存在，不存在时则创建一个，存在时在List后面添加上一个。这个过程是比较痛苦的，如果希望检查List中的对象是否存在，删除一个对象，或者遍历整个数据结构，那么则需要更多的代码来实现。</p>
<h2 id="Multimap-简介"><a href="#Multimap-简介" class="headerlink" title="Multimap 简介"></a>Multimap 简介</h2><p>Multimap 提供了一个方便地把一个键对应到多个值的数据结构。</p>
<p>我们可以这样理解Multimap:”键-单个值映射”的集合(例如：a -&gt; 1 a -&gt; 2 a -&gt;4 b -&gt; 3 c -&gt; 5)</p>
<p>特点：不会有任何键映射到空集合：一个键要么至少到一个值，要么根本就不在Multimap中。</p>
<p>主要方法介绍：</p>
<ul>
<li>put(K, V)：添加键到单个值的映射</li>
<li>putAll(K, Iterable<v>)：依次添加键到多个值的映射</v></li>
<li>remove(K, V)：移除键到值的映射；如果有这样的键值并成功移除，返回true</li>
<li>removeAll(K)：清除键对应的所有值，返回的集合包含所有之前映射到K的值，但修改这个集合就不会影响Multimap了</li>
<li>replaceValues(K, Iterable<v>)：清除键对应的所有值，并重新把key关联到Iterable中的每个元素。返回的集合包含所有之前映射到K的值</v></li>
</ul>
<h2 id="Multimap的视图"><a href="#Multimap的视图" class="headerlink" title="Multimap的视图"></a>Multimap的视图</h2><p>Multimap还支持若干强大的视图：</p>
<ul>
<li>asMap为Multimap<k, v="">提供Map<k,collection<v>&gt;形式的视图。返回的Map支持remove操作，并且会反映到底层的 Multimap，但它不支持put或putAll操作。更重要的是，如果你想为Multimap中没有的键返回null，而不是一个新的、可写的空集 合，你就可以使用asMap().get(key)。（你可以并且应当把asMap.get(key)返回的结果转化为适当的集合类型——如 SetMultimap.asMap.get(key)的结果转为Set，ListMultimap.asMap.get(key)的结果转为List ——Java类型系统不允许ListMultimap直接为asMap.get(key)返回List——译者注：也可以用Multimaps中的asMap静态方法帮你完成类型转换）</k,collection<v></k,></li>
<li>entries用Collection<map.entry<k, v="">&gt;返回Multimap中所有”键-单个值映射”——包括重复键。（对SetMultimap，返回的是Set）</map.entry<k,></li>
<li>keySet用Set表示Multimap中所有不同的键。</li>
<li>keys用Multiset表示Multimap中的所有键，每个键重复出现的次数等于它映射的值的个数。可以从这个Multiset中移除元素，但不能做添加操作；移除操作会反映到底层的Multimap。</li>
<li>values()用 一个”扁平”的Collection<v>包含Multimap中的所有值。这有一点类似于 Iterables.concat(multimap.asMap().values())，但它直接返回了单个Collection，而不像 multimap.asMap().values()那样是按键区分开的Collection。</v></li>
</ul>
<h2 id="Multimap不是Map"><a href="#Multimap不是Map" class="headerlink" title="Multimap不是Map"></a>Multimap不是Map</h2><p>Multimap<k, v="">不是Map<k,collection<v>&gt;，虽然某些Multimap实现中可能使用了map。它们之间的显著区别包括：</k,collection<v></k,></p>
<ul>
<li>Multimap.get(key)总是返回非null、但是可能空的集合。这并不意味着Multimap为相应的键花费内存创建了集合，而只是提供一个集合视图方便你为键增加映射值——译者注：如果有这样的键，返回的集合只是包装了Multimap中已有的集合；如果没有这样的键，返回的空集合也只是持有Multimap引用的栈对象，让你可以用来操作底层的Multimap。因此，返回的集合不会占据太多内存，数据实际上还是存放在Multimap中。</li>
<li>如果你更喜欢像Map那样，为Multimap中没有的键返回null，请使用asMap()视图获取一个Map<k, collection<v="">&gt;。（或者用静态方法Multimaps.asMap()为ListMultimap返回一个Map<k, list<v="">&gt;。对于SetMultimap和SortedSetMultimap，也有类似的静态方法存在）</k,></k,></li>
<li>当且仅当有值映射到键时，Multimap.containsKey(key)才会返回true。尤其需要注意的是，如果键k之前映射过一个或多个值，但它们都被移除后，Multimap.containsKey(key)会返回false。</li>
<li>Multimap.entries()返回Multimap中所有”键-单个值映射”——包括重复键。如果你想要得到所有”键-值集合映射”，请使用asMap().entrySet()。<br>Multimap.size()返回所有”键-单个值映射”的个数，而非不同键的个数。要得到不同键的个数，请改用Multimap.keySet().size()。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.google.common.collect.ArrayListMultimap;</div><div class="line">import com.google.common.collect.Multimap;</div><div class="line"></div><div class="line">public class MultimapTest &#123;</div><div class="line">    class Student &#123;</div><div class="line">        String name;</div><div class="line">        int age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static final String CLASS_NAME_1 = &quot;一年级&quot;;</div><div class="line">    private static final String CLASS_NAME_2 = &quot;二年级&quot;;</div><div class="line">    </div><div class="line">    Multimap&lt;String, Student&gt; multimap = ArrayListMultimap.create();</div><div class="line"></div><div class="line">    public void testStudent() &#123;</div><div class="line">        </div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            Student student = new Student();</div><div class="line">            student.name = &quot;Tom&quot; + i;</div><div class="line">            student.age = 6;</div><div class="line">            multimap.put(CLASS_NAME_1, student);</div><div class="line">        &#125;</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            Student student = new Student();</div><div class="line">            student.name = &quot;Jary&quot; + i;</div><div class="line">            student.age = 7;</div><div class="line">            multimap.put(CLASS_NAME_2, student);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        for (Student stu : multimap.get(CLASS_NAME_1)) &#123;</div><div class="line">            System.out.println(&quot;一年级学生 name:&quot; + stu.name + &quot; age:&quot; + stu.age);</div><div class="line">        &#125;</div><div class="line">        //判断键是否存在</div><div class="line">        if(multimap.containsKey(CLASS_NAME_1))&#123;</div><div class="line">            System.out.println(&quot;键值包含：&quot;+CLASS_NAME_1);</div><div class="line">        &#125;</div><div class="line">        //”键-单个值映射”的个数</div><div class="line">        System.out.println(multimap.size());</div><div class="line">        //不同键的个数</div><div class="line">        System.out.print(multimap.keySet().size());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        MultimapTest multimapTest = new MultimapTest();</div><div class="line">        multimapTest.testStudent();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>//TODO<br>demo code 补充完整</p>
<p>ref:<br><a href="https://www.cnblogs.com/parryyang/p/5776654.html" target="_blank" rel="external">https://www.cnblogs.com/parryyang/p/5776654.html</a><br><a href="https://blog.csdn.net/xiangliqu/article/details/68953059" target="_blank" rel="external">https://blog.csdn.net/xiangliqu/article/details/68953059</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Guava</tag>
        <tag>Multimap</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-AQS</title>
    <url>/2017/09/22/JUC-AQS/</url>
    <content><![CDATA[<p>这篇文章，我们聊一聊Java并发中的核武器， AQS底层实现。<br>不管是工作三四年、还是五六年的在工作或者面试中涉及到并发的是时候总是绕不过AQS这个词。<br>首先，确实还有很多人连AQS是什么都不知道，甚至有的竟不知其为何物。或者有的听说过其名，但怎么拼写的都忘记了。<br>总的来说确实有很多同学对AQS总有一种云里雾里的感觉，在搜索引擎中搜下AQS看个几篇文章，估计对其还是醉醺醺的。<br>所以根据上面的难点，这篇我们使用由简入难的方式，让你一次搞定这Java并发中这个核武器AQS</p>
<a id="more"></a>
<h2 id="ReentrantLock-和-AQS-的关系"><a href="#ReentrantLock-和-AQS-的关系" class="headerlink" title="ReentrantLock 和 AQS 的关系"></a>ReentrantLock 和 AQS 的关系</h2><p>首先我们以你最受的方式带你进入这个核武器库，Java 并发包下的 ReentrantLock大家肯定很熟悉了。<br>基本上学过Java 的都知道ReentrantLock，下面我就不多说了直接上一段代码。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ReentrantLock lock = new ReentrantLock();</div><div class="line">try &#123;</div><div class="line">    lock.lock(); // 加锁</div><div class="line"></div><div class="line">    // 业务逻辑代码</div><div class="line"></div><div class="line">&#125; finally &#123;</div><div class="line">    lock.unlock(); // 释放锁</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码大家应该很熟悉了，无非就是获取一把锁，加锁和释放锁的过程。<br>有同学就问了这和AQS有毛关系呀！别着急，告诉你关系大着去了。在Java并发包中很多锁都是通过AQS来实现加锁和释放锁的过程的，AQS就是并发包基础。<br>例如：ReentrantLock、ReentrantReadWriteLock 底层都是通过AQS来实现的。<br>那么AQS到底为何物尼？别急，我们一步一来揭开其神秘的面纱。<br>AQS 的全称 AbstractQueuedSynchronizers抽象队列同步器，给大家画三张图来说明其在Java 并发包的地位、 长啥样、和ReentrantLock 的关系。<br><img src="3756008545-5cbd1b7d35c14_articlex.jpeg" alt="3756008545-5cbd1b7d35c14_articlex.jpeg"><br>通过此类图可以彰显出了AQS的地位、上层锁实现基本都是通过其底层来实现的。<br><img src="2867562215-5cbd1c0035666_articlex.jpeg" alt="2867562215-5cbd1c0035666_articlex.jpeg"><br>你没看错AQS就长这个鸟样。说白了其内部就是包含了三个组件</p>
<ul>
<li>state 资源状态</li>
<li>exclusiveOwnerThread 持有资源的线程</li>
<li>CLH 同步等待队列。</li>
</ul>
<p><img src="153595153-5cbd1c206c634_articlex.jpeg" alt="153595153-5cbd1c206c634_articlex.jpeg"></p>
<p>在看这张图现在明白ReentrantLock 和 AQS 的关系了吧！大白话说就是ReentrantLock其内部包含一个AQS对象（内部类），AQS就是ReentrantLock可以获取和释放锁实现的核心部件。</p>
<h2 id="ReentrantLock-加锁和释放锁底层原理实现"><a href="#ReentrantLock-加锁和释放锁底层原理实现" class="headerlink" title="ReentrantLock 加锁和释放锁底层原理实现"></a>ReentrantLock 加锁和释放锁底层原理实现</h2><p>好了！ 经过上面的介绍估计大家已经对AQS混了个脸熟，下面我们就来说说这一段代码。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ReentrantLock lock = new ReentrantLock();</div><div class="line">try &#123;</div><div class="line">    lock.lock(); // 加锁</div><div class="line"></div><div class="line">    // 业务逻辑代码</div><div class="line"></div><div class="line">&#125; finally &#123;</div><div class="line">    lock.unlock(); // 释放锁</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码加锁和释放锁到底会发生什么故事尼？<br>很简单在AQS 内部有一个核心变量 （volatile）state 变量其代表了加锁的状态，初始值为0。<br>另外一个重要的关键 OwnerThread 持有锁的线程，默认值为null 在回顾下这张图。<br><img src="153595153-5cbd1c206c634_articlex.jpeg" alt="153595153-5cbd1c206c634_articlex.jpeg"></p>
<p>接着线程1过来通过lock.lock()方式获取锁，获取锁的过程就是通过CAS操作volatile 变量state 将其值从0变为1。<br>如果之前没有人获取锁，那么state的值肯定为0，此时线程1加锁成功将state = 1。<br>线程1加锁成功后还有一步重要的操作，就是将OwnerThread 设置成为自己。如下图线程1加锁过程。<br><img src="2668268918-5cbd1c8865cb0_articlex.jpeg" alt="2668268918-5cbd1c8865cb0_articlex.jpeg"><br>其实到这大家应该对AQS有个大概认识了，说白了就是并发包下面的一个核心组件，其内部维持state变量、线程变量等核型的东西，来实现加锁和释放锁的过程。<br>大家有没有不管是ReentrantLock还是ReentrantReadWriteLock 等为什么都是Reentrant 开头尼？<br>从单词本身意思也能看出，Reentrant 可重入的意思 ，也就说其是一个可重入锁。</p>
<h2 id="可重入锁？"><a href="#可重入锁？" class="headerlink" title="可重入锁？"></a>可重入锁？</h2><p>就是你可以对一个 ReentrantLock 进行多次的lock() 和 unlock() 操作，也就是可以对一个锁加多次，叫做可重入锁。 来一段代码直观感受下。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ReentrantLock lock = new ReentrantLock();</div><div class="line">try &#123;</div><div class="line">    lock.lock(); // 加锁1</div><div class="line"></div><div class="line">    // 业务逻辑代码</div><div class="line">    lock.lock() // 加锁2</div><div class="line">    </div><div class="line">    // 业务逻辑代码</div><div class="line">    </div><div class="line">    lock.lock() // 加锁3</div><div class="line"></div><div class="line">&#125; finally &#123;</div><div class="line">    lock.unlock(); // 释放锁3</div><div class="line">    lock.unlock(); // 释放锁2</div><div class="line">    lock.unlock(); // 释放锁1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意：释放锁是由内到外依次释放的，不可缺少。<br>问题又来了？ReentrantLock 内部又是如何来实现的尼？<br>说白了！还是我们AQS这个核心组件帮我实现的，很 easy~ 上述两个核心变量 state 和 OwnerThread 还记得吧！<br>重入就是判断当前锁是不是自己加上的，如果是就代表自己可以在次上锁，每重入一次就是将state值加1。就是这么简单啦！！！<br>说完了可重入我们再来看看锁的互斥又是如何实现的尼？<br>此时线程2也跑过来想加锁，CAS操作尝试将 state 从0 变成 1， 哎呀！糟糕state已经不是0了，说明此锁已经被别人拿到了。<br>接着线程2想？？？ 这个锁是不是我以前加上的，瞅瞅 OwnerThread=线程1 哎！ 明显不是自己上的 ，悲催加锁失败了～～～。来张图记录下线程2的悲苦经历。<br><img src="1087207409-5cbd1c9986e80_articlex.jpeg" alt="1087207409-5cbd1c9986e80_articlex.jpeg"><br>可是线程2加锁失败将何去何从尼？<br>线程2：想，要是有个地方让我休息下，等线程1释放锁后通知我下再来从新尝试上锁就好了。<br>这时我们的核心部件AQS又登场了！<br>AQS: OK！ 好吧！那我就给你提供一个落脚地吧（CLH）进去待着吧！一会让线程1叫你。<br>线程2: 屁颠屁颠的就去等待区小憩一会去了。同样来张图记录下线程2高兴样。<br><img src="4147618370-5cbd1ca7c4599_articlex.jpeg" alt="4147618370-5cbd1ca7c4599_articlex.jpeg"><br>此时线程1业务执行完了，开始释放锁</p>
<ul>
<li>将state值改为0</li>
<li>将OwnerThread 设为null</li>
<li>通知线程2锁我已经用完了，该你登场了</li>
</ul>
<p>线程2一听，乐坏了！立马开始尝试获取取锁，CAS 尝试将 state 值设为 1 ，如果成功将OwnerThread设为自己 线程2。<br>此时线程2成功获取到了锁，再来张图瞅瞅。<br><img src="2271061762-5cbd1cb415cf3_articlex.jpeg" alt="2271061762-5cbd1cb415cf3_articlex.jpeg"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Ok ！到这借着Reentrantkock 的加锁和释放锁的过程给大家讲解了一下AQS工作原理。</p>
<p>用一句话总结下：AQS就是Java并发包下的一个基础组件，用来实现各种锁和同步组件的，其核心分为三个组件。</p>
<ul>
<li>Volatile state 变量</li>
<li>OwnerThread 加锁线程</li>
<li>CLH 同步等待队列</li>
</ul>
<p>等并发核心组件。</p>
<p>ref:<br><a href="https://segmentfault.com/a/1190000018942945" target="_blank" rel="external">https://segmentfault.com/a/1190000018942945</a></p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC-CLH</title>
    <url>/2017/09/22/JUC-CLH/</url>
    <content><![CDATA[<p>这篇我们来给大家聊聊AQS中核心同步队列（CLH）。</p>
<a id="more"></a>
<h2 id="什么是同步队列（CLH）"><a href="#什么是同步队列（CLH）" class="headerlink" title="什么是同步队列（CLH）"></a>什么是同步队列（CLH）</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>一个FIFO双向队列，队列中每个节点等待前驱节点释放共享状态（锁）被唤醒就可以了。</p>
<h3 id="AQS如何使用它？"><a href="#AQS如何使用它？" class="headerlink" title="AQS如何使用它？"></a>AQS如何使用它？</h3><p>AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程已经等待状态等信息构造成一个节点（Node）并将其加入到CLH同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点唤醒（公平锁），使其再次尝试获取同步状态。</p>
<h3 id="Node节点面貌？"><a href="#Node节点面貌？" class="headerlink" title="Node节点面貌？"></a>Node节点面貌？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static final class Node &#123;</div><div class="line">        // 节点分为两种模式： 共享式和独占式</div><div class="line">        /** 共享式 */</div><div class="line">        static final Node SHARED = new Node();</div><div class="line">        /** 独占式 */</div><div class="line">        static final Node EXCLUSIVE = null;</div><div class="line"></div><div class="line">        /** 等待线程超时或者被中断、需要从同步队列中取消等待（也就是放弃资源的竞争），此状态不会在改变 */</div><div class="line">        static final int CANCELLED =  1;</div><div class="line">        /** 后继节点会处于等待状态，当前节点线程如果释放同步状态或者被取消则会通知后继节点线程，使后继节点线程的得以运行 */</div><div class="line">        static final int SIGNAL    = -1;</div><div class="line">        /** 节点在等待队列中，线程在等待在Condition 上，其他线程对Condition调用singnal()方法后，该节点加入到同步队列中。 */</div><div class="line">        static final int CONDITION = -2;</div><div class="line">        /**</div><div class="line">         * 表示下一次共享式获取同步状态的时会被无条件的传播下去。</div><div class="line">         */</div><div class="line">        static final int PROPAGATE = -3;</div><div class="line"></div><div class="line">        /**等待状态*/</div><div class="line">        volatile int waitStatus;</div><div class="line"></div><div class="line">        /**前驱节点 */</div><div class="line">        volatile Node prev;</div><div class="line"></div><div class="line">        /**后继节点*/</div><div class="line">        volatile Node next;</div><div class="line"></div><div class="line">        /**获取同步状态的线程 */</div><div class="line">        volatile Thread thread;</div><div class="line"></div><div class="line">        /**链接下一个等待状态 */</div><div class="line">        Node nextWaiter;</div><div class="line">        </div><div class="line">        // 下面一些方法就不贴了</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>CLH同步队列的结构图<br><img src="253619634-5cbd6a30badb8_articlex.jpeg" alt="253619634-5cbd6a30badb8_articlex.jpeg"><br>这里是基于CAS（保证线程的安全）来设置尾节点的。</p>
<h2 id="入列操作"><a href="#入列操作" class="headerlink" title="入列操作"></a>入列操作</h2><p>如上图了解了同步队列的结构， 我们在分析其入列操作在简单不过。无非就是将tail（使用CAS保证原子操作）指向新节点，新节点的prev指向队列中最后一节点（旧的tail节点），原队列中最后一节点的next节点指向新节点以此来建立联系，来张图帮助大家理解。</p>
<p><img src="1817013129-5cbd6a7a93674_articlex.jpeg" alt="1817013129-5cbd6a7a93674_articlex.jpeg"></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>源码我们可以通过AQS中的以下两个方法来了解下 </p>
<h4 id="addWaiter方法"><a href="#addWaiter方法" class="headerlink" title="addWaiter方法"></a>addWaiter方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private Node addWaiter(Node mode) &#123;</div><div class="line">// 以给定的模式来构建节点， mode有两种模式 </div><div class="line">//  共享式SHARED， 独占式EXCLUSIVE;</div><div class="line">  Node node = new Node(Thread.currentThread(), mode);</div><div class="line">    // 尝试快速将该节点加入到队列的尾部</div><div class="line">    Node pred = tail;</div><div class="line">     if (pred != null) &#123;</div><div class="line">        node.prev = pred;</div><div class="line">            if (compareAndSetTail(pred, node)) &#123;</div><div class="line">                pred.next = node;</div><div class="line">                return node;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        // 如果快速加入失败，则通过 anq方式入列</div><div class="line">        enq(node);</div><div class="line">        return node;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>先通过addWaiter(Node node)方法尝试快速将该节点设置尾成尾节点，设置失败走enq(final Node node)方法</p>
<h4 id="enq"><a href="#enq" class="headerlink" title="enq"></a>enq</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private Node enq(final Node node) &#123;</div><div class="line">// CAS自旋，直到加入队尾成功        </div><div class="line">for (;;) &#123;</div><div class="line">    Node t = tail;</div><div class="line">        if (t == null) &#123; // 如果队列为空，则必须先初始化CLH队列，新建一个空节点标识作为Hader节点,并将tail 指向它</div><div class="line">            if (compareAndSetHead(new Node()))</div><div class="line">                tail = head;</div><div class="line">            &#125; else &#123;// 正常流程，加入队列尾部</div><div class="line">                node.prev = t;</div><div class="line">                    if (compareAndSetTail(t, node)) &#123;</div><div class="line">                        t.next = node;</div><div class="line">                        return t;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过“自旋”也就是死循环的方式来保证该节点能顺利的加入到队列尾部，只有加入成功才会退出循环，否则会一直循序直到成功。</p>
<p>上述两个方法都是通过compareAndSetHead(new Node())方法来设置尾节点，以保证节点的添加的原子性（保证节点的添加的线程安全。）</p>
<h2 id="出列操作"><a href="#出列操作" class="headerlink" title="出列操作"></a>出列操作</h2><p>同步队列（CLH）遵循FIFO，首节点是获取同步状态的节点，首节点的线程释放同步状态后，将会唤醒它的后继节点（next），而后继节点将会在获取同步状态成功时将自己设置为首节点，这个过程非常简单。如下图</p>
<p><img src="2751180000-5cbd6b431be55_articlex.jpeg" alt="2751180000-5cbd6b431be55_articlex.jpeg"><br>设置首节点是通过获取同步状态成功的线程来完成的（获取同步状态是通过CAS来完成），只能有一个线程能够获取到同步状态，因此设置头节点的操作并不需要CAS来保证，只需要将首节点设置为其原首节点的后继节点并断开原首节点的next（等待GC回收）应用即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>聊完后我们来总一下，同步队列就是一个FIFO双向对队列，其每个节点包含获取同步状态失败的线程应用、等待状态、前驱节点、后继节点、节点的属性类型以及名称描述。</p>
<p>其入列操作也就是利用CAS(保证线程安全)来设置尾节点，出列就很简单了直接将head指向新头节点并断开老头节点联系就可以了。</p>
<p>ref:<br><a href="https://segmentfault.com/a/1190000018948010" target="_blank" rel="external">https://segmentfault.com/a/1190000018948010</a></p>
]]></content>
      <categories>
        <category>JUC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-4种IO模型</title>
    <url>/2017/09/22/Java-4%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>同步、异步、阻塞、非阻塞都是和I/O（输入输出）有关的概念，最简单的文件读取就是I/O操作。而在文件读取这件事儿上，可以有多种方式。</p>
<p>本篇会先介绍一下I/O的基本概念，通过一个生活例子来分别解释下这几种I/O模型，以及Java支持的I/O模型。</p>
<a id="more"></a>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在解释I/O模型之前，我先说明一下几个操作系统的概念</p>
<h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（file descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h3 id="缓存I-O"><a href="#缓存I-O" class="headerlink" title="缓存I/O"></a>缓存I/O</h3><p>缓存I/O又被称作标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中， 操作系统会将I/O的数据缓存在文件系统的页缓存中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中， 然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p>缓存I/O的缺点是数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的。</p>
<p>下面我以一个生活中烧开水的例子来形象解释一下同步、异步、阻塞、非阻塞概念。</p>
<h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><p><strong>同步请求</strong> A调用B，B的处理是同步的，在处理完之前他不会通知A，只有处理完之后才会明确的通知A。<br><strong>异步请求</strong> A调用B，B的处理是异步的，B在接到请求后先告诉A我已经接到请求了，然后异步去处理，处理完之后通过回调等方式再通知A。</p>
<p>所以说，同步和异步最大的区别就是被调用方的执行方式和返回时机。 同步指的是被调用方做完事情之后再返回，异步指的是被调用方先返回，然后再做事情，做完之后再想办法通知调用方。</p>
<h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h3><p><strong>阻塞请求</strong> A调用B，A一直等着B的返回，别的事情什么也不干。<br><strong>非阻塞请求</strong> A调用B，A不用一直等着B的返回，先去忙别的事情了。</p>
<p>所以说，阻塞和非阻塞最大的区别就是在被调用方返回结果之前的这段时间内，调用方是否一直等待。 阻塞指的是调用方一直等待别的事情什么都不做。非阻塞指的是调用方先去忙别的事情。</p>
<h3 id="阻塞、非阻塞和同步、异步的区别"><a href="#阻塞、非阻塞和同步、异步的区别" class="headerlink" title="阻塞、非阻塞和同步、异步的区别"></a>阻塞、非阻塞和同步、异步的区别</h3><p>阻塞、非阻塞说的是调用者。同步、异步说的是被调用者。</p>
<h2 id="Unix中的五种I-O模型"><a href="#Unix中的五种I-O模型" class="headerlink" title="Unix中的五种I/O模型"></a>Unix中的五种I/O模型</h2><p>对于一次I/O访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。 所以说，当一个read操作发生时，它会经历两个阶段：</p>
<p>第一阶段：等待数据准备 (Waiting for the data to be ready)。<br>第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。</p>
<p>对于socket流而言</p>
<p>第一阶段：通常涉及等待网络上的数据分组到达，也就是被复制到内核的某个缓冲区。<br>第二阶段：把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p><strong>Unix下五种I/O模型</strong></p>
<ul>
<li>同步阻塞I/O</li>
<li>同步非阻塞I/O</li>
<li>I/O多路复用（select和poll）</li>
<li>信号驱动I/O（SIGIO）</li>
<li>异步非阻塞 IO</li>
</ul>
<h3 id="同步阻塞I-O"><a href="#同步阻塞I-O" class="headerlink" title="同步阻塞I/O"></a>同步阻塞I/O</h3><p>阻塞I/O下请求无法立即完成则保持阻塞，阻塞I/O分为如下两个阶段。</p>
<p>阶段1：等待数据就绪。网络I/O的情况就是等待远端数据陆续抵达，也就是网络数据被复制到内核缓存区中，磁盘I/O的情况就是等待磁盘数据从磁盘上读取到内核态内存中。<br>阶段2：数据拷贝。出于系统安全，用户态的程序没有权限直接读取内核态内存，因此内核负责把内核态内存中的数据拷贝一份到用户态内存中。</p>
<p>这两个阶段必须都完成后才能继续下一步操作</p>
<p><img src="6401.jpeg" alt="6401.jpeg"></p>
<p>所以，blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
<h3 id="同步非阻塞I-O"><a href="#同步非阻塞I-O" class="headerlink" title="同步非阻塞I/O"></a>同步非阻塞I/O</h3><p>就是阶段1的时候用户进程可选择做其他事情，通过轮询的方式看看内核缓冲区是否就绪。如果数据就绪，再去执行阶段2。</p>
<p>也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好， 此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。</p>
<p>重复上面的过程， 循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好， 再拷贝数据到进程，进行数据处理。需要注意，第2阶段的拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>
<p>在linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程如图所示：</p>
<p><img src="6402.jpeg" alt="6402.jpeg"></p>
<p>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p>
<h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>我这里只想重点解释一下I/O多路复用这种模型，因为现在用的最多。很多地方也称为事件驱动IO模型，只是叫法不同，意思都一个样。</p>
<p>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。</p>
<p>目前支持I/O多路复用的系统调用有 select、pselect、poll、epoll，I/O多路复用就是通过一种机制，一个进程可以监视多个描述符， 一旦某个文件描述符fd就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。 </p>
<p>但select、pselect、poll、epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的， 而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<p>相比较于同步非阻塞I/O，它的改进的地方在于，原来需要用户进程去轮询的这事儿交给了内核线程帮你完成， 而且这个内核线程可以等待多个socket，能实现同时对多个IO端口进行监听。</p>
<p><img src="6403.jpeg" alt="6403.jpeg"></p>
<p>多路复用的特点是通过一种机制一个进程能同时等待IO文件描述符，内核监视这些文件描述符（套接字描述符）， 其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式， 又可以分为 select， poll， epoll三种方式。</p>
<p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用多线程 + 阻塞IO的web server性能更好，可能延迟还更大。 也就是说，select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。推荐阅读：Spring Boot 的 10 个核心模块</p>
<p>高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式。要理解这一点，首先要扯到并发和并行的区别。 比如去某部门办事需要依次去几个窗口，办事大厅里的人数就是并发数，而窗口个数就是并行度。 也就是说并发数是指同时进行的任务数（如同时服务的 HTTP 请求），而并行数是可以同时工作的物理资源数量（如 CPU 核数）。 </p>
<p>通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。 在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。而同步非阻塞方式可以把多个 IO 请求丢到后台去， 这就可以在一个进程里服务大量的并发 IO 请求。</p>
<p><strong>IO多路复用归为同步阻塞模式</strong></p>
<h3 id="异步非阻塞-IO"><a href="#异步非阻塞-IO" class="headerlink" title="异步非阻塞 IO"></a>异步非阻塞 IO</h3><p>相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程， 然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段， 进程都是非阻塞的。</p>
<p>Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示：</p>
<p><img src="6404.jpeg" alt="6404.jpeg"></p>
<h2 id="Java中四种I-O模型"><a href="#Java中四种I-O模型" class="headerlink" title="Java中四种I/O模型"></a>Java中四种I/O模型</h2><p>上一章所述Unix中的五种I/O模型，除信号驱动I/O外，Java对其它四种I/O模型都有所支持。</p>
<ul>
<li>Java传统IO模型即是同步阻塞I/O</li>
<li>NIO是同步非阻塞I/O</li>
<li>通过NIO实现的Reactor模式即是I/O多路复用模型的实现</li>
<li>通过AIO实现的Proactor模式即是异步I/O模型的实现</li>
</ul>
<p>ref:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247488064&amp;idx=2&amp;sn=56b6f87cb4e99107737c73f7ed1e5e8e&amp;chksm=eb539776dc241e60f88f7185da4b7fb46bf41f10a66a53898ca672e8942e8b6a8d47ec7d3d3d&amp;scene=21#wechat_redirect" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247488064&amp;idx=2&amp;sn=56b6f87cb4e99107737c73f7ed1e5e8e&amp;chksm=eb539776dc241e60f88f7185da4b7fb46bf41f10a66a53898ca672e8942e8b6a8d47ec7d3d3d&amp;scene=21#wechat_redirect</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-DTO转换</title>
    <url>/2017/09/22/Java-DTO%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>DTO转化</p>
<a id="more"></a>
<h2 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a>DTO</h2><p>数据传输我们应该使用 DTO 对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端 API 设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候(input or output)，这些对象成为 DTO 对象。</p>
<p>请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是 DTO 对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到 OMS 或者 ERP 系统，这些对接的返回值以及入参也叫 DTO 对象。</p>
<p>我们约定某对象如果是 DTO 对象，就将名称改为 XXDTO，比如订单下发OMS：OMSOrderInputDTO</p>
<h2 id="DTO转化"><a href="#DTO转化" class="headerlink" title="DTO转化"></a>DTO转化</h2><p>正如我们所知，DTO 为系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转化为 BO 对象或者是普通的 entity 对象，让 service 层去处理。</p>
<p>场景：比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@RequestMapping(&quot;/v1/api/user&quot;)</div><div class="line">@RestController</div><div class="line">public class UserApi &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private UserService userService;</div><div class="line"></div><div class="line">    @PostMapping</div><div class="line">    public User addUser(UserInputDTO userInputDTO)&#123;</div><div class="line">        User user = new User();</div><div class="line">        user.setUsername(userInputDTO.getUsername());</div><div class="line">        user.setAge(userInputDTO.getAge());</div><div class="line">        return userService.addUser(user);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们只关注一下上述代码中的转化代码，其他内容请忽略：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">User user = new User();</div><div class="line">user.setUsername(userInputDTO.getUsername());</div><div class="line">user.setAge(userInputDTO.getAge());</div></pre></td></tr></table></figure></p>
<p><strong>请使用工具</strong>：</p>
<p>上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有 20 个字段，我们要如何做呢？一个一个进行 set 数据吗？当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。</p>
<p>网上有很多工具，支持浅拷贝或深拷贝的 Utils。举个例子，我们可以使用 org.springframework.beans.BeanUtils#copyProperties 对代码进行重构和优化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@PostMapping</div><div class="line">public User addUser(UserInputDTO userInputDTO)&#123;</div><div class="line">    User user = new User();</div><div class="line">    BeanUtils.copyProperties(userInputDTO,user);</div><div class="line">    return userService.addUser(user);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BeanUtils.copyProperties 是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了</p>
<p><strong>转化的语义</strong>：</p>
<p>上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写 Java 代码时，更多的需要考虑语义的操作，再看上边的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">User user = new User();</div><div class="line">BeanUtils.copyProperties(userInputDTO,user);</div></pre></td></tr></table></figure></p>
<p>虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好，所以代码改成如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@PostMapping</div><div class="line"> public User addUser(UserInputDTO userInputDTO)&#123;</div><div class="line">         User user = convertFor(userInputDTO);</div><div class="line">         return userService.addUser(user);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> private User convertFor(UserInputDTO userInputDTO)&#123;</div><div class="line">         User user = new User();</div><div class="line">         BeanUtils.copyProperties(userInputDTO,user);</div><div class="line">         return user;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">User user = convertFor(userInputDTO);</div><div class="line">return userService.addUser(user);</div></pre></td></tr></table></figure></p>
<p>这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。</p>
<p>如上所述，是一种重构方式，读者可以参考 Martin Fowler 的《Refactoring Imporving the Design of Existing Code》(重构 改善既有代码的设计) 这本书中的 Extract Method 重构方式。</p>
<p><strong>抽象接口定义</strong>：</p>
<p>当实际工作中，完成了几个 API 的 DTO 转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。</p>
<p>如果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。</p>
<p>看一下抽象后的接口：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface DTOConvert&lt;S,T&gt; &#123;</div><div class="line">    T convert(S s);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的 Java 程序员，请为你想做的抽象接口，做好泛型吧。</p>
<p>我们再来看接口实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class UserInputDTOConvert implements DTOConvert &#123;</div><div class="line">    @Override</div><div class="line">    public User convert(UserInputDTO userInputDTO) &#123;</div><div class="line">        User user = new User();</div><div class="line">        BeanUtils.copyProperties(userInputDTO,user);</div><div class="line">        return user;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@RequestMapping(&quot;/v1/api/user&quot;)</div><div class="line">@RestController</div><div class="line">public class UserApi &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private UserService userService;</div><div class="line"></div><div class="line">    @PostMapping</div><div class="line">    public User addUser(UserInputDTO userInputDTO)&#123;</div><div class="line">        User user = new UserInputDTOConvert().convert(userInputDTO);</div><div class="line">        return userService.addUser(user);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>review code</strong>：</p>
<p>如果你是一个优秀的 Java 程序员，我相信你应该和我一样，已经数次重复 review 过自己的代码很多次了。</p>
<p>我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的，所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@PostMapping</div><div class="line">public UserOutputDTO addUser(UserInputDTO userInputDTO)&#123;</div><div class="line">        User user = new UserInputDTOConvert().convert(userInputDTO);</div><div class="line">        User saveUserResult = userService.addUser(user);</div><div class="line">        UserOutputDTO result = new UserOutDTOConvert().convertToUser(saveUserResult);</div><div class="line">        return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样你的 API 才更健全。</p>
<p>不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的 Java 程序员，请看一下这段我们刚刚抽象完的代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">User user = new UserInputDTOConvert().convert(userInputDTO);</div></pre></td></tr></table></figure></p>
<p>你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢，看一下我的聚合结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Data</div><div class="line">public class UserInputDTO &#123;</div><div class="line">    private String username;</div><div class="line">    private int age;</div><div class="line"></div><div class="line">    public User convertToUser()&#123;</div><div class="line">        UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert();</div><div class="line">        User convert = userInputDTOConvert.convert(this);</div><div class="line">        return convert;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class UserInputDTOConvert implements DTOConvert&lt;UserInputDTO,User&gt; &#123;</div><div class="line">        @Override</div><div class="line">        public User convert(UserInputDTO userInputDTO) &#123;</div><div class="line">            User user = new User();</div><div class="line">            BeanUtils.copyProperties(userInputDTO,user);</div><div class="line">            return user;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后 API 中的转化则由：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">User user = new UserInputDTOConvert().convert(userInputDTO);</div><div class="line">User saveUserResult = userService.addUser(user);</div></pre></td></tr></table></figure></p>
<p>变成了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">User user = userInputDTO.convertToUser();</div><div class="line">User saveUserResult = userService.addUser(user);</div></pre></td></tr></table></figure></p>
<p>我们在 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。</p>
<p><strong>再查工具类</strong>：</p>
<p>再来看 DTO 内部转化的代码，它实现了我们自己定义的 DTOConvert 接口，但是这样真的就没有问题，不需要再思考了吗？</p>
<p>我觉得并不是，对于 Convert 这种转化语义来讲，很多工具类中都有这样的定义，这中 Convert 并不是业务级别上的接口定义，它只是用于普通 bean 之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有 Convert 转化语义的代码。</p>
<p>我仔细阅读了一下 GUAVA 的源码，发现了 com.google.common.base.Convert 这样的定义：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public abstract class Converter&lt;A, B&gt; implements Function&lt;A, B&gt; &#123;</div><div class="line">    protected abstract B doForward(A a);</div><div class="line">    protected abstract A doBackward(B b);</div><div class="line">    //其他略</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码可以了解到，GUAVA 中的 Convert 可以完成正向转化和逆向转化，继续修改我们 DTO 中转化的这段代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static class UserInputDTOConvert implements DTOConvert&lt;UserInputDTO,User&gt; &#123;</div><div class="line">        @Override</div><div class="line">        public User convert(UserInputDTO userInputDTO) &#123;</div><div class="line">                User user = new User();</div><div class="line">                BeanUtils.copyProperties(userInputDTO,user);</div><div class="line">                return user;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static class UserInputDTOConvert extends Converter&lt;UserInputDTO, User&gt; &#123;</div><div class="line">         @Override</div><div class="line">         protected User doForward(UserInputDTO userInputDTO) &#123;</div><div class="line">                 User user = new User();</div><div class="line">                 BeanUtils.copyProperties(userInputDTO,user);</div><div class="line">                 return user;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         @Override</div><div class="line">         protected UserInputDTO doBackward(User user) &#123;</div><div class="line">                 UserInputDTO userInputDTO = new UserInputDTO();</div><div class="line">                 BeanUtils.copyProperties(user,userInputDTO);</div><div class="line">                 return userInputDTO;</div><div class="line">         &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的 UserInputDTO 和 UserOutputDTO 都转成 UserDTO 展示给大家。</p>
<p>DTO：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Data</div><div class="line">public class UserDTO &#123;</div><div class="line">    private String username;</div><div class="line">    private int age;</div><div class="line"></div><div class="line">    public User convertToUser()&#123;</div><div class="line">            UserDTOConvert userDTOConvert = new UserDTOConvert();</div><div class="line">            User convert = userDTOConvert.convert(this);</div><div class="line">            return convert;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public UserDTO convertFor(User user)&#123;</div><div class="line">            UserDTOConvert userDTOConvert = new UserDTOConvert();</div><div class="line">            UserDTO convert = userDTOConvert.reverse().convert(user);</div><div class="line">            return convert;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; &#123;</div><div class="line">            @Override</div><div class="line">            protected User doForward(UserDTO userDTO) &#123;</div><div class="line">                    User user = new User();</div><div class="line">                    BeanUtils.copyProperties(userDTO,user);</div><div class="line">                    return user;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            protected UserDTO doBackward(User user) &#123;</div><div class="line">                    UserDTO userDTO = new UserDTO();</div><div class="line">                    BeanUtils.copyProperties(user,userDTO);</div><div class="line">                    return userDTO;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>API：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@PostMapping</div><div class="line"> public UserDTO addUser(UserDTO userDTO)&#123;</div><div class="line">         User user =  userDTO.convertToUser();</div><div class="line">         User saveResultUser = userService.addUser(user);</div><div class="line">         UserDTO result = userDTO.convertFor(saveResultUser);</div><div class="line">         return result;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的 DTO 对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static class UserDTOConvert extends Converter&lt;UserDTO, User&gt; &#123;</div><div class="line">         @Override</div><div class="line">         protected User doForward(UserDTO userDTO) &#123;</div><div class="line">                 User user = new User();</div><div class="line">                 BeanUtils.copyProperties(userDTO,user);</div><div class="line">                 return user;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         @Override</div><div class="line">         protected UserDTO doBackward(User user) &#123;</div><div class="line">                 throw new AssertionError(&quot;不支持逆向转化方法!&quot;);</div><div class="line">         &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>看一下 doBackward 方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就”断言”你调用错误了</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/TXsN9U26tMAYAm1QAdWEAQ" target="_blank" rel="external">细思极恐 - 你真的会写 Java 吗?</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-GC-G1</title>
    <url>/2017/09/22/Java-GC-G1/</url>
    <content><![CDATA[<p>为解决CMS算法产生空间碎片和其它一系列的问题缺陷，HotSpot提供了另外一种垃圾回收策略，G1（Garbage First）算法，通过参数 -XX:+UseG1GC来启用，该算法在JDK 7u4版本被正式推出，官网对此描述如下：</p>
<p>G1垃圾收集算法主要应用在多CPU大内存的服务中，在满足高吞吐量的同时，竟可能的满足垃圾回收时的暂停时间，该设计主要针对如下应用场景：</p>
<ul>
<li>垃圾收集线程和应用线程并发执行，和CMS一样</li>
<li>空闲内存压缩时避免冗长的暂停时间</li>
<li>应用需要更多可预测的GC暂停时间</li>
<li>不希望牺牲太多的吞吐性能</li>
<li>不需要很大的Java堆</li>
</ul>
<a id="more"></a>
<h2 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h2><p>1、以往的垃圾回收算法，如CMS，使用的堆内存结构如下：<br><img src="snipaste_20190923151325.jpg" alt="snipaste_20190923151325.jpg"></p>
<ul>
<li>新生代：eden space + 2个survivor</li>
<li>老年代：old space</li>
<li>持久代：1.8之前的perm space</li>
<li>元空间：1.8之后的metaspace</li>
</ul>
<p>这些space必须是地址连续的空间</p>
<p>2、在G1算法中，采用了另外一种完全不同的方式组织堆内存，堆内存被划分为多个大小相等的内存块（Region），每个Region是逻辑连续的一段内存，结构如下：<br><img src="snipaste_20190923151503.jpg" alt="snipaste_20190923151503.jpg"></p>
<p>每个Region被标记了E、S、O和H，说明每个Region在运行时都充当了一种角色，其中H是以往算法中没有的，它代表Humongous，这表示这些Region存储的是巨型对象（humongous object，H-obj），当新建对象大小超过Region大小一半时，直接在新的一个或多个连续Region中分配，并标记为H</p>
<h2 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h2><p>堆内存中一个Region的大小可以通过 -XX:G1HeapRegionSize参数指定，大小区间只能是1M、2M、4M、8M、16M和32M，总之是2的幂次方，如果G1HeapRegionSize为默认值，则在堆初始化时计算Region的实践大小，具体实现如下：</p>
<p><img src="snipaste_20190923151628.jpg" alt="snipaste_20190923151628.jpg"></p>
<p>默认把堆内存按照2048份均分，最后得到一个合理的大小。</p>
<h2 id="GC模式"><a href="#GC模式" class="headerlink" title="GC模式"></a>GC模式</h2><p>G1中提供了三种模式垃圾回收模式，young gc、mixed gc 和 full gc，在不同的条件下被触发。</p>
<h3 id="young-gc"><a href="#young-gc" class="headerlink" title="young gc"></a>young gc</h3><p>发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。</p>
<table>
<thead>
<tr>
<th style="text-align:left">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">-XX:MaxGCPauseMillis</td>
<td style="text-align:left">设置G1收集过程目标时间，默认值200ms</td>
</tr>
<tr>
<td style="text-align:left">-XX:G1NewSizePercent</td>
<td style="text-align:left">新生代最小值，默认值5%</td>
</tr>
<tr>
<td style="text-align:left">-XX:G1MaxNewSizePercent</td>
<td style="text-align:left">新生代最大值，默认值60%</td>
</tr>
</tbody>
</table>
<h3 id="mixed-gc"><a href="#mixed-gc" class="headerlink" title="mixed gc"></a>mixed gc</h3><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。</p>
<p>那么mixed gc什么时候被触发？</p>
<p>先回顾一下cms的触发机制，如果添加了以下参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">-XX:CMSInitiatingOccupancyFraction=80</div><div class="line">-XX:+UseCMSInitiatingOccupancyOnly</div></pre></td></tr></table></figure></p>
<p>当老年代的使用率达到80%时，就会触发一次cms gc。</p>
<p>相对的，mixed gc中也有一个阈值参数 -XX:InitiatingHeapOccupancyPercent，当老年代大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc.</p>
<p>mixed gc的执行过程有点类似cms，主要分为以下几个步骤：</p>
<ul>
<li>initial mark: 初始标记过程，整个过程STW，标记了从GC Root可达的对象</li>
<li>concurrent marking: 并发标记过程，整个过程gc collector线程与应用线程可以并行执行，标记出GC Root可达对象衍生出去的存活对象，并收集各个Region的存活对象信息</li>
<li>remark: 最终标记过程，整个过程STW，标记出那些在并发标记过程中遗漏的，或者内部引用发生变化的对象</li>
<li>clean up: 垃圾清除过程，如果发现一个Region中没有存活对象，则把该Region加入到空闲列表中</li>
</ul>
<h3 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h3><p>如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc.</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/K7T8vjiHEwwN8uiXVLI6AQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/K7T8vjiHEwwN8uiXVLI6AQ</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-HashMap-hash</title>
    <url>/2017/09/22/Java-HashMap-hash/</url>
    <content><![CDATA[<p>看HashMap 源码时, 发现 hash 的算法很巧妙, 特记录之</p>
<a id="more"></a>
<p>为什么要有HashMap的hash()方法，难道不能直接使用KV中K原有的hash值吗？在HashMap的put、get操作时为什么不能直接使用K中原有的hash值<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Computes key.hashCode() and spreads (XORs) higher bits of hash</div><div class="line"> * to lower.  Because the table uses power-of-two masking, sets of</div><div class="line"> * hashes that vary only in bits above the current mask will</div><div class="line"> * always collide. (Among known examples are sets of Float keys</div><div class="line"> * holding consecutive whole numbers in small tables.)  So we</div><div class="line"> * apply a transform that spreads the impact of higher bits</div><div class="line"> * downward. There is a tradeoff between speed, utility, and</div><div class="line"> * quality of bit-spreading. Because many common sets of hashes</div><div class="line"> * are already reasonably distributed (so don&apos;t benefit from</div><div class="line"> * spreading), and because we use trees to handle large sets of</div><div class="line"> * collisions in bins, we just XOR some shifted bits in the</div><div class="line"> * cheapest possible way to reduce systematic lossage, as well as</div><div class="line"> * to incorporate impact of the highest bits that would otherwise</div><div class="line"> * never be used in index calculations because of table bounds.</div><div class="line"> */</div><div class="line">static final int hash(Object key) &#123;</div><div class="line">    int h;</div><div class="line">    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码可以看到key的hash值的计算方法。key的hash值高16位不变，低16位与高16位异或作为key的最终hash值。（h &gt;&gt;&gt; 16，表示无符号右移16位，高位补0，任何数跟0异或都是其本身，因此key的hash值高16位不变。）</p>
<p><img src="Snipaste20190703181705.png" alt="Snipaste20190703181705.png"></p>
<p>为什么要这么干呢？<br>这个与HashMap中table下标的计算有关。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">n = table.length;</div><div class="line">index = （n-1） &amp; hash;</div></pre></td></tr></table></figure>
<p>因为，table的长度都是2的幂，因此index仅与hash值的低n位有关（此n非table.leng，而是2的幂指数），hash值的高位都被与操作置为0了。<br>假设table.length=2^4=16</p>
<p><img src="Snipaste20190703181844.png" alt="Snipaste20190703181844.png"></p>
<p>由上图可以看到，只有hash值的低4位参与了运算。<br>这样做很容易产生碰撞。设计者权衡了speed, utility, and quality，将高16位与低16位异或来减少这种影响。设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞</p>
<p>ref:<br><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="external">https://blog.csdn.net/fan2012huan/article/details/51097331</a> </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-HashMap-tableSizeFor</title>
    <url>/2017/09/22/Java-HashMap-tableSizeFor/</url>
    <content><![CDATA[<p>看HashMap 源码时, 发现 tableSizeFor 的算法很巧妙, 特记录之</p>
<a id="more"></a>
<p>源码<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</div><div class="line">/**</div><div class="line"> * Returns a power of two size for the given target capacity.</div><div class="line"> */</div><div class="line">static final int tableSizeFor(int cap) &#123;</div><div class="line">    int n = cap - 1;</div><div class="line">    n |= n &gt;&gt;&gt; 1;</div><div class="line">    n |= n &gt;&gt;&gt; 2;</div><div class="line">    n |= n &gt;&gt;&gt; 4;</div><div class="line">    n |= n &gt;&gt;&gt; 8;</div><div class="line">    n |= n &gt;&gt;&gt; 16;</div><div class="line">    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法被调用的地方<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</div><div class="line">    /**省略此处代码**/</div><div class="line">    this.loadFactor = loadFactor;</div><div class="line">    this.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由此可以看到，当在实例化HashMap实例时，如果给定了initialCapacity，由于HashMap的capacity都是2的幂，因此这个方法用于找到大于等于initialCapacity的最小的2的幂（initialCapacity如果就是2的幂，则返回的还是这个数）。<br>下面分析这个算法：<br>首先，为什么要对cap做减1操作。int n = cap - 1;<br>这是为了防止，cap已经是2的幂。如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。<br>下面看看这几个无符号右移操作：<br>如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是1（最后有个n+1的操作）。<br>这里只讨论n不等于0的情况</p>
<h3 id="第一次右移"><a href="#第一次右移" class="headerlink" title="第一次右移"></a>第一次右移</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">n |= n &gt;&gt;&gt; 1;</div></pre></td></tr></table></figure>
<p>由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如000011xxxxxx</p>
<h3 id="第二次右移"><a href="#第二次右移" class="headerlink" title="第二次右移"></a>第二次右移</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">n |= n &gt;&gt;&gt; 2;</div></pre></td></tr></table></figure>
<p>注意，这个n已经经过了n |= n &gt;&gt;&gt; 1; 操作。假设此时n为000011xxxxxx ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如00001111xxxxxx </p>
<h3 id="第三次右移"><a href="#第三次右移" class="headerlink" title="第三次右移"></a>第三次右移</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">n |= n &gt;&gt;&gt; 4;</div></pre></td></tr></table></figure>
<p>这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中会有8个连续的1。如00001111 1111xxxxxx </p>
<p><strong>以此类推</strong></p>
<p>注意，容量最大也就是32bit的正数，因此最后n |= n &gt;&gt;&gt; 16; ，最多也就32个1，但是这时已经大于了MAXIMUM_CAPACITY ，所以取值到MAXIMUM_CAPACITY 。</p>
<p><img src="Snipaste20190703180321.png" alt="Snipaste20190703180321.png"></p>
<p>注意，得到的这个capacity却被赋值给了threshold<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">this.threshold = tableSizeFor(initialCapacity);</div></pre></td></tr></table></figure></p>
<p>开始以为这个是个Bug，感觉应该这么写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;</div></pre></td></tr></table></figure></p>
<p>这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。<br>但是，请注意，在构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推迟到了put方法中，在put方法中会对threshold重新计算</p>
<p>ref:<br><a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="external">https://blog.csdn.net/fan2012huan/article/details/51097331</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Java8-CompletableFuture</title>
    <url>/2017/09/22/Java-Java8-CompletableFuture/</url>
    <content><![CDATA[<p>Future基础知识：<a href="http://www.cnblogs.com/shijiaqi1066/p/3412331.html" target="_blank" rel="external">Java并发（6）带返回结果的任务执行</a><br>Guava的Future：<a href="http://www.cnblogs.com/shijiaqi1066/p/5745295.html" target="_blank" rel="external">Guava Future</a><br>Netty的Future：<a href="http://www.cnblogs.com/shijiaqi1066/p/4804875.html" target="_blank" rel="external">Netty Future与Promise</a></p>
<p><strong>异步编排CompletableFuture</strong><br>CompletableFuture是JDK8提供的Future增强类。CompletableFuture异步任务执行线程池，默认是把异步任务都放在ForkJoinPool中执行。</p>
<p>官方文档：<br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="external">https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html</a><br><a href="https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html" target="_blank" rel="external">https://docs.oracle.com/javase/9/docs/api/java/util/concurrent/CompletableFuture.html</a></p>
<p>CompletableFuture接口提供了非常多的方法用于编排异步任务基本每个方法都有两套方法，Async版本的函数与非Async版本的函数。</p>
<p>若方法不以Async结尾，意味着Action使用相同的线程执行，而Async可能会使用其它的线程去执行(如果使用相同的线程池，也可能会被同一个线程选中执行)。</p>
<a id="more"></a>
<h2 id="创建CompletableFuture"><a href="#创建CompletableFuture" class="headerlink" title="创建CompletableFuture"></a>创建CompletableFuture</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value);</div><div class="line"></div><div class="line">// 执行异步任务</div><div class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier);</div><div class="line">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor);</div><div class="line"></div><div class="line">// 执行异步任务</div><div class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable);</div><div class="line">public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor);</div></pre></td></tr></table></figure>
<p>例：创建一个已经有结果值的CompletableFuture。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(&quot;a future value&quot;);</div></pre></td></tr></table></figure></p>
<p>例：异步执行带返回值的异步任务。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    System.out.println(&quot;带有返回值的异步任务&quot;);</div><div class="line">    return &quot;a future value&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>例：异步执行不带返回值的异步任务<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(()-&gt;&#123;</div><div class="line">    System.out.println(&quot;不带返回值的异步任务&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="获取CompletableFuture的返回值"><a href="#获取CompletableFuture的返回值" class="headerlink" title="获取CompletableFuture的返回值"></a>获取CompletableFuture的返回值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public T get() throws InterruptedException, ExecutionException;</div><div class="line">public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException；</div><div class="line">public T getNow(T valueIfAbsent)；</div><div class="line">public T join();</div></pre></td></tr></table></figure>
<p>说明：<br>get方法：阻塞获取CompletableFuture的结果值，另外可以设置该方法的阻塞时间。<br>getNow方法：如果结果已经计算完则返回结果或者抛出异常，否则返回给定的valueIfAbsent值。<br>join方法：返回计算的结果或者抛出一个unchecked异常(CompletionException)。</p>
<p>例：获取Future的结果值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 使用get</div><div class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(&quot;a future value&quot;);</div><div class="line">String string = future.get();</div><div class="line">System.out.println(string);</div><div class="line"></div><div class="line">// 使用join</div><div class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    return &quot;haha&quot;;</div><div class="line">&#125;);</div><div class="line">String join = future.join();</div><div class="line">System.out.println(join);</div></pre></td></tr></table></figure></p>
<h2 id="连接异步任务"><a href="#连接异步任务" class="headerlink" title="连接异步任务"></a>连接异步任务</h2><p>完成完一个任务后继续执行一个异步任务<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// thenRun 处理 Runnable</div><div class="line">public CompletableFuture&lt;Void&gt; thenRun(Runnable action);</div><div class="line">public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action);</div><div class="line">public CompletableFuture&lt;Void&gt; thenRunAsync(Runnable action, Executor executor);</div><div class="line"></div><div class="line">// thenAccept 处理 Consumer</div><div class="line">public CompletableFuture&lt;Void&gt; thenAccept(Consumer&lt;? super T&gt; action);</div><div class="line">public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action);</div><div class="line">public CompletableFuture&lt;Void&gt; thenAcceptAsync(Consumer&lt;? super T&gt; action, Executor executor);</div><div class="line"></div><div class="line">// thenApply 处理 Function</div><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApply(Function&lt;? super T,? extends U&gt; fn);</div><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn);</div><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor);</div><div class="line"></div><div class="line">// handle 处理 BiFunction</div><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; handle(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);</div><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn);</div><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; handleAsync(BiFunction&lt;? super T, Throwable, ? extends U&gt; fn, Executor executor);</div></pre></td></tr></table></figure></p>
<p>例：thenRun方法。执行异步任务，执行完后再接一个异步任务。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(()-&gt;&#123;</div><div class="line">    System.out.println(&quot;不带返回值的异步任务&quot;);</div><div class="line">&#125;).thenRun(()-&gt;&#123;</div><div class="line">    System.out.println(&quot;前一个future后，再异步执行任务。&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>例：执行异步任务，并将结果给下一个异步任务，最后再返回结果值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 转换</div><div class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</div><div class="line">    return &quot;a future value&quot;;</div><div class="line">&#125;);</div><div class="line">CompletableFuture&lt;Integer&gt; future1 = future.thenApplyAsync((str) -&gt; &#123;</div><div class="line">    return str.length();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 返回值</div><div class="line">Integer join = future1.join();</div><div class="line">System.out.println(join);</div></pre></td></tr></table></figure></p>
<p>例：执行异步任务，并将结果给下一个异步任务，最后不返回结果值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 消费</div><div class="line">CompletableFuture&lt;String&gt; future0 = CompletableFuture.completedFuture(&quot;a future value&quot;);</div><div class="line"> </div><div class="line">CompletableFuture&lt;Void&gt; future1 = future0.thenAcceptAsync((str)-&gt;&#123;</div><div class="line">    System.out.println(&quot;没有返回值。消费了字符串：&quot; + str);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">future1.join();</div></pre></td></tr></table></figure></p>
<h2 id="组合两个异步任务"><a href="#组合两个异步任务" class="headerlink" title="组合两个异步任务"></a>组合两个异步任务</h2><h3 id="thenCompose方法"><a href="#thenCompose方法" class="headerlink" title="thenCompose方法"></a>thenCompose方法</h3><p>接着上一个CompletableFuture的结果执行一个异步任务，最新的异步任务返回一个新的CompletableFuture。</p>
<p>具体方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; fn);</div><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; fn);</div><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; thenComposeAsync(Function&lt;? super T,? extends CompletionStage&lt;U&gt;&gt; fn, Executor executor);</div></pre></td></tr></table></figure></p>
<p>例：CompletableFuture后跟一个新的一步方法，产生新的CompletableFuture。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;String&gt; future = CompletableFuture</div><div class="line">    .completedFuture(10)</div><div class="line">    .thenComposeAsync((x)-&gt;&#123;</div><div class="line">        return CompletableFuture.supplyAsync(()-&gt; x.toString());  // 新的ComplatableFuture</div><div class="line">    &#125;</div><div class="line">);</div><div class="line"></div><div class="line">// 获取结果</div><div class="line">String r = future.join();</div><div class="line">System.err.println(r); // 打印：10</div></pre></td></tr></table></figure></p>
<h3 id="thenCombine方法"><a href="#thenCombine方法" class="headerlink" title="thenCombine方法"></a>thenCombine方法</h3><p>为两个CompletableFuture的结果值提供一个函数算子，将结果值计算出来。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[Task0] ---\</div><div class="line">            ==&gt;(fn)--&gt;[Task]</div><div class="line">[Task1] ---/</div></pre></td></tr></table></figure></p>
<p>具体方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombine(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn);</div><div class="line">public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn);</div><div class="line">public &lt;U,V&gt; CompletableFuture&lt;V&gt; thenCombineAsync(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn, Executor executor);</div></pre></td></tr></table></figure></p>
<p>例：定义两个Future组合起来的算子，并计算<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;Integer&gt; f0 = CompletableFuture.completedFuture(10000);</div><div class="line">CompletableFuture&lt;String&gt; f1 = CompletableFuture.completedFuture(&quot;hello&quot;);</div><div class="line"></div><div class="line">CompletableFuture&lt;String&gt; future = f0.thenCombine(f1, (i, s)-&gt; (s + i)); // 定义算子</div><div class="line"></div><div class="line">// 获取结果值 </div><div class="line">String r = future.join(); System.out.println(r); // 打印：hello10000</div></pre></td></tr></table></figure></p>
<h3 id="Both系列方法"><a href="#Both系列方法" class="headerlink" title="Both系列方法"></a>Both系列方法</h3><p>执行两个异步任务，并将两个任务的计算结果获取后，再执行一个异步任务，最后再返回值</p>
<p>thenAcceptBoth方法<br>将两个future的结果值传给第三个算子<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBoth(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action);</div><div class="line">public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action);</div><div class="line">public &lt;U&gt; CompletableFuture&lt;Void&gt; thenAcceptBothAsync(CompletionStage&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; action, Executor executor);</div></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;Integer&gt; f0 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*5);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 2;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*2);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 3;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">// 提供一个异步算子。使用future的计算结果。</div><div class="line">CompletableFuture&lt;Void&gt; f= f0.thenAcceptBothAsync(f1,(x, y) -&gt; &#123;</div><div class="line">    System.out.println(&quot;两个future都完成，才计算算子。&quot;);</div><div class="line">    System.out.println(x*y);</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">f.join();</div></pre></td></tr></table></figure></p>
<p>runAfterBoth方法<br>等待之前的两个异步任务都结束，再执行Action。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public CompletableFuture&lt;Void&gt; runAfterBoth(CompletionStage&lt;?&gt; other,  Runnable action);</div></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;Integer&gt; f0 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*5);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 2;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*2);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 3;</div><div class="line">&#125;);// 提供一个异步算子。使用future的计算结果。</div><div class="line">CompletableFuture&lt;Void&gt; f = f0.runAfterBothAsync(f1, ()-&gt;&#123;</div><div class="line">    System.out.println(&quot;两个future都完成，再执行该任务。&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">f.join();</div></pre></td></tr></table></figure></p>
<h3 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h3><p>runAfterEither方法<br>两个异步任务，任意一个CompletableFuture获取得到结果值，则执行该方法指定的Runnable 任务<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public CompletionStage&lt;Void&gt; runAfterEither(CompletionStage&lt;?&gt; other,Runnable action);</div><div class="line">public CompletionStage&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other,Runnable action);</div><div class="line">public CompletionStage&lt;Void&gt; runAfterEitherAsync(CompletionStage&lt;?&gt; other,Runnable action,Executor executor);</div></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;Integer&gt; f0 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*5);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*2);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line"></div><div class="line">CompletableFuture&lt;Void&gt; f = f0.runAfterEither(f1, ()-&gt;&#123;</div><div class="line">    System.out.println(&quot;有一个任务完成了&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">f.join();</div></pre></td></tr></table></figure></p>
<p>applyToEither方法<br>两个异步任务，任意一个CompletableFuture获取得到结果值，则执行该方法指定的Function任务。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEither(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn);</div><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn);</div><div class="line">public &lt;U&gt; CompletableFuture&lt;U&gt; applyToEitherAsync(CompletionStage&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn, Executor executor);</div></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;Integer&gt; f0 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*5);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*2);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">CompletableFuture&lt;String&gt; f = f0.applyToEither(f1, (Integer i)-&gt; &quot;task:&quot; + i);</div><div class="line">String r = f.join();</div><div class="line">System.out.println(r);  // 打印：task:1</div></pre></td></tr></table></figure></p>
<p>acceptEither方法<br>两个异步任务，任意一个CompletableFuture获取得到结果值，则执行该方法指定的Consumer任务。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public CompletableFuture&lt;Void&gt; acceptEither(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action);</div><div class="line">public CompletableFuture&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action);</div><div class="line">public CompletableFuture&lt;Void&gt; acceptEitherAsync(CompletionStage&lt;? extends T&gt; other, Consumer&lt;? super T&gt; action, Executor executor);</div></pre></td></tr></table></figure></p>
<p>例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;Integer&gt; f0 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*5);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*2);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">CompletableFuture&lt;Void&gt; f = f0.acceptEither(f1, (i)-&gt;&#123;</div><div class="line">    System.out.println(&quot;task:&quot; + i);  // 打印：task:1</div><div class="line">&#125;);</div><div class="line"></div><div class="line">f.join();</div></pre></td></tr></table></figure></p>
<h2 id="多个任务的组合"><a href="#多个任务的组合" class="headerlink" title="多个任务的组合"></a>多个任务的组合</h2><h3 id="anyOf方法"><a href="#anyOf方法" class="headerlink" title="anyOf方法"></a>anyOf方法</h3><p>将多个CompletableFuture组合为一个CompletableFuture，任意一个CompletableFuture有了结果，则该方法的返回值也会得到结果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs);</div></pre></td></tr></table></figure></p>
<p>例：三个CompletableFuture执行完一个就得到一个新的CompletableFuture<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;Integer&gt; f0 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*1);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*2);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*3);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 2;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">long t0 = System.currentTimeMillis();</div><div class="line"></div><div class="line">CompletableFuture&lt;Object&gt; f = CompletableFuture.anyOf(f0, f1, f2);</div><div class="line">Object r = f.join();</div><div class="line">System.out.println(r);   // 打印：0</div><div class="line"></div><div class="line">long t1 = System.currentTimeMillis();</div><div class="line">System.out.println((t1-t0)/1000);   // 打印：1</div></pre></td></tr></table></figure></p>
<h3 id="allOf方法"><a href="#allOf方法" class="headerlink" title="allOf方法"></a>allOf方法</h3><p>将多个CompletableFuture组合为一个CompletableFuture，所有CompletableFuture有了结果，则该方法的返回值也会得到结果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs);</div></pre></td></tr></table></figure></p>
<p>例：三个CompletableFuture都执行完，就得到一个新的CompletableFuture<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;Integer&gt; f0 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*1);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">CompletableFuture&lt;Integer&gt; f1 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*2);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 1;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">CompletableFuture&lt;Integer&gt; f2 = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(1000*3);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    return 2;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">long t0 = System.currentTimeMillis();</div><div class="line"></div><div class="line">CompletableFuture&lt;Void&gt; f = CompletableFuture.allOf(f0, f1, f2);</div><div class="line">f.join();</div><div class="line"></div><div class="line">long t1 = System.currentTimeMillis();</div><div class="line">System.out.println((t1-t0)/1000);   // 打印：3</div></pre></td></tr></table></figure></p>
<h2 id="完成时执行任务"><a href="#完成时执行任务" class="headerlink" title="完成时执行任务"></a>完成时执行任务</h2><p>当一系列的任务计算结果完成或者抛出异常的时候，我们可以执行指定的任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public CompletableFuture&lt;T&gt; whenComplete(BiConsumer&lt;? super T,? super Throwable&gt; action);</div><div class="line">public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action);</div><div class="line">public CompletableFuture&lt;T&gt; whenCompleteAsync(BiConsumer&lt;? super T,? super Throwable&gt; action, Executor executor);</div></pre></td></tr></table></figure>
<p>例：任务完成后，执行最后的任务，并且可以获取最后任务之前的结果值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    try &#123;</div><div class="line">        Thread.sleep(5*1000);</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        throw new RuntimeException(e);</div><div class="line">    &#125;</div><div class="line">    return new Random().nextInt(1000);</div><div class="line">&#125;).whenComplete((i, throwable)-&gt;&#123;</div><div class="line">    System.out.println(&quot;任务结果值：&quot; + throwable);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 阻塞</div><div class="line">future.get();</div></pre></td></tr></table></figure></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>使用CompletableFuture编排异步任务在处理异常的时候，有几种方式：</p>
<ol>
<li>在异步任务中使用try…catch…处理异常。</li>
<li>使用whenComplate方法接收异常。</li>
<li>使用exceptionally方法接收异常。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public CompletableFuture&lt;T&gt; exceptionally(Function&lt;Throwable,? extends T&gt; fn);</div></pre></td></tr></table></figure>
<p>例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CompletableFuture&lt;String&gt; f = CompletableFuture.supplyAsync(()-&gt;&#123;</div><div class="line">    return 100/0;</div><div class="line">&#125;).exceptionally(ex -&gt; &#123;</div><div class="line">    ex.printStackTrace();</div><div class="line">    return 0;</div><div class="line">&#125;).thenApply((i)-&gt; &quot;run:&quot; + i.toString());</div><div class="line"></div><div class="line">String r = f.join();</div><div class="line">System.out.println(r);</div></pre></td></tr></table></figure></p>
<p>打印：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero</div><div class="line">	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(Unknown Source)</div><div class="line">	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(Unknown Source)</div><div class="line">	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source)</div><div class="line">	at java.base/java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source)</div><div class="line">	at java.base/java.util.concurrent.ForkJoinTask.doExec(Unknown Source)</div><div class="line">	at java.base/java.util.concurrent.ForkJoinPool.runWorker(Unknown Source)</div><div class="line">	at java.base/java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source)</div><div class="line">Caused by: java.lang.ArithmeticException: / by zero</div><div class="line">	at test.java/test.TestCompletableFuture.lambda$0(TestCompletableFuture.java:292)</div><div class="line">	... 5 more</div><div class="line">run:0</div></pre></td></tr></table></figure></p>
<p>ref: <a href="https://www.cnblogs.com/shijiaqi1066/p/8758206.html" target="_blank" rel="external">https://www.cnblogs.com/shijiaqi1066/p/8758206.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Lombok</title>
    <url>/2017/09/22/Java-Lombok/</url>
    <content><![CDATA[<p>Lombok是一款Java开发插件，使得Java开发者可以通过其定义的一些注解来消除业务工程中冗长和繁琐的代码，尤其对于简单的Java模型对象（POJO）。在开发环境中使用Lombok插件后，Java开发人员可以节省出重复构建，诸如hashCode和equals这样的方法以及各种业务对象模型的accessor和ToString等方法的大量时间。对于这些方法，它能够在编译源代码期间自动帮我们生成这些方法，并没有如反射那样降低程序的性能。</p>
<p>官网的介绍：Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java. Never write another getter or equals method again. Early access to future java features such as val, and much more.</p>
<p><strong>Bean 的对比</strong><br>传统的 POJO 类是这样的<br><img src="snipaste_20191127165952.jpg" alt="snipaste_20191127165952.jpg"></p>
<p>通过Lombok改造后的 POJO 类是这样的<br><img src="snipaste_20191127170040.jpg" alt="snipaste_20191127170040.jpg"></p>
<a id="more"></a>
<h2 id="Lombok的安装"><a href="#Lombok的安装" class="headerlink" title="Lombok的安装"></a>Lombok的安装</h2><h3 id="引入相应的maven包"><a href="#引入相应的maven包" class="headerlink" title="引入相应的maven包"></a>引入相应的maven包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.18.2-RELEASE&lt;/version&gt;</div><div class="line">    &lt;scope&gt;provided&lt;/scope&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>Lombok的scope=provided，说明它只在编译阶段生效，不需要打入包中。事实正是如此，Lombok在编译期将带Lombok注解的Java文件正确编译为完整的Class文件。</p>
<h3 id="添加IDE工具对Lombok的支持"><a href="#添加IDE工具对Lombok的支持" class="headerlink" title="添加IDE工具对Lombok的支持"></a>添加IDE工具对Lombok的支持</h3><p>普通的包在引用之后一般的 IDE 都能够自动识别语法，但是 Lombok 的这些注解，一般的 IDE 都无法自动识别，因此如果要使用 Lombok 的话还需要配合安装相应的插件来支持 IDE 的编译，防止IDE 的自动检查报错，下面以 IntelliJ IDEA 举例安装插件。</p>
<p>IDEA中引入Lombok支持如下：<br>点击File– Settings设置界面，安装Lombok插件<br><img src="snipaste_20190919110013.jpg" alt="snipaste_20190919110013.jpg"></p>
<p>点击File– Settings设置界面，开启 AnnocationProcessors：<br><img src="snipaste_20190919110114.jpg" alt="snipaste_20190919110114.jpg"><br>开启该项是为了让Lombok注解在编译阶段起到作用</p>
<h2 id="Lombok实现原理"><a href="#Lombok实现原理" class="headerlink" title="Lombok实现原理"></a>Lombok实现原理</h2><p>自从Java 6起，javac就支持“JSR 269 Pluggable Annotation Processing API”规范，只要程序实现了该API，就能在javac运行的时候得到调用。</p>
<p>Lombok就是一个实现了”JSR 269 API”的程序。在使用javac的过程中，它产生作用的具体流程如下：</p>
<ol>
<li>javac对源代码进行分析，生成一棵抽象语法树(AST)</li>
<li>javac编译过程中调用实现了JSR 269的Lombok程序</li>
<li>此时Lombok就对第一步骤得到的AST进行处理，找到Lombok注解所在类对应的语法树(AST)，然后修改该语法树(AST)，增加Lombok注解定义的相应树节点</li>
<li>javac使用修改后的抽象语法树(AST)生成字节码文件</li>
</ol>
<p><img src="snipaste_20191127172613.jpg" alt="snipaste_20191127172613.jpg"></p>
<p>查看下图，@Data的实现，我们发现这个注解是应用在编译阶段的<br><img src="snipaste_20191127165358.jpg" alt="snipaste_20191127165358.jpg"></p>
<p>这和我们大多数使用的注解，如 Spring 的注解（在运行时，通过反射来实现业务逻辑）是有很大差别的，如Spring 的@RestController 注解<br><img src="snipaste_20191127165559.jpg" alt="snipaste_20191127165559.jpg"></p>
<h2 id="Lombok注解的使用"><a href="#Lombok注解的使用" class="headerlink" title="Lombok注解的使用"></a>Lombok注解的使用</h2><h3 id="POJO类常用注解"><a href="#POJO类常用注解" class="headerlink" title="POJO类常用注解"></a>POJO类常用注解</h3><h4 id="Getter-Setter"><a href="#Getter-Setter" class="headerlink" title="@Getter/@Setter"></a>@Getter/@Setter</h4><ol>
<li>作用类上，生成所有成员变量的getter/setter方法；</li>
<li>作用于成员变量上，生成该成员变量的getter/setter方法。可以设定访问权限及是否懒加载等。</li>
</ol>
<p><img src="snipaste_20191127170329.jpg" alt="snipaste_20191127170329.jpg"><br>成员变量name指定生成set方法，并且访问权限为protected； 当把该注解应用在类上，默认为所有非静态成员变量生成 get 和 set 方法，也可以通过 AccessLevel.NONE 手动禁止生成get或set方法，如下图<br><img src="snipaste_20191127170633.jpg" alt="snipaste_20191127170633.jpg"></p>
<h4 id="Accessors"><a href="#Accessors" class="headerlink" title="@Accessors"></a>@Accessors</h4><p>作用于类, 使 bean 支持链式风格<br>这个注解要搭配@Getter与@Setter使用，用来修改默认的setter与getter方法的形式</p>
<p>@Accessors有三个参数可以使用</p>
<ul>
<li>chain 链式的形式</li>
<li>fluent 流式的形式</li>
<li>prefix 生成指定前缀的属性的getter与setter方法，并且生成的getter与setter方法时会去除前缀</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Accessors(chain = true)</div><div class="line">@Setter</div><div class="line">@Getter</div><div class="line">public class Student &#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Student student = new Student()</div><div class="line">        .setAge(24)</div><div class="line">        .setName(&quot;zs&quot;);</div></pre></td></tr></table></figure></p>
<p>这样就完成了一个对于 bean 来讲很友好的链式操作<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Accessors(fluent = true)</div><div class="line">@Setter</div><div class="line">@Getter</div><div class="line">public class Student &#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Student student = new Student()</div><div class="line">        .age(24)</div><div class="line">        .name(&quot;zs&quot;);</div></pre></td></tr></table></figure></p>
<p>@Accessors(prefix = “f”) 意义不大, 略</p>
<h4 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a>@ToString</h4><p>作用于类，覆盖默认的toString()方法，可以通过of属性限定显示某些字段，通过exclude属性排除某些字段<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import lombok.ToString;</div><div class="line"></div><div class="line">@ToString</div><div class="line">public class Demo &#123;</div><div class="line">    private static int post = 272500;//静态字段它是不输出,毕竟静态的东西并不属于对象本身</div><div class="line">    private final int finalVal = 10;</div><div class="line">    private transient String name = &quot;aa&quot;;</div><div class="line">    private int age;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Demo demo = new Demo();</div><div class="line">        System.out.println(demo); //Demo(finalVal=10, age=0)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译后:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">    private static int post = 272500;</div><div class="line">    private final int finalVal = 10;</div><div class="line">    private transient String name = &quot;aa&quot;;</div><div class="line">    private int age;</div><div class="line"></div><div class="line">    public Demo() &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Demo demo = new Demo();</div><div class="line">        System.out.println(demo);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String toString() &#123;</div><div class="line">        StringBuilder var10000 = (new StringBuilder()).append(&quot;Demo(finalVal=&quot;);</div><div class="line">        this.getClass();</div><div class="line">        return var10000.append(10).append(&quot;, name=&quot;).append(this.name).append(&quot;, age=&quot;).append(this.age).append(&quot;)&quot;).toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有些关键的属性，可以控制toString的输出，我们可以了解一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@ToString(</div><div class="line">        includeFieldNames = true, //是否使用字段名</div><div class="line">        exclude = &#123;&quot;name&quot;&#125;, //排除某些字段</div><div class="line">        of = &#123;&quot;age&quot;&#125;, //指定某些字段</div><div class="line">        callSuper = true //是否让父类字段也参与 默认false</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h4 id="EqualsAndHashCode"><a href="#EqualsAndHashCode" class="headerlink" title="@EqualsAndHashCode"></a>@EqualsAndHashCode</h4><p>作用于类，使用该注解，lombok会为我们生成 equals(Object other) 和 hashcode() 方法，包括所有非静态属性和非transient的属性，同样该注解也可以通过 exclude 属性排除某些字段，of 属性指定某些字段，也可以通过 callSuper 属性在重写的方法中使用父类的字段，这样我们可以更灵活的定义bean的比对，如下图：<br><img src="snipaste_20191127171503.jpg" alt="snipaste_20191127171503.jpg"><br>查看编译后的Employee.class文件，如下图：<br><img src="snipaste_20191127171543.jpg" alt="snipaste_20191127171543.jpg"></p>
<h4 id="NonNull"><a href="#NonNull" class="headerlink" title="@NonNull"></a>@NonNull</h4><p>该注解需应用在方法或构造器的参数上或属性上，用来判断参数的合法性，默认抛出 NullPointerException 异常<br><img src="snipaste_20191127171650.jpg" alt="snipaste_20191127171650.jpg"><br>查看NonNullExample.class文件，会为我们抛出空指针异常，如下图：<br><img src="snipaste_20191127171722.jpg" alt="snipaste_20191127171722.jpg"><br>当然我们可以通过指定异常类型抛出其他异常，lombok.nonNull.exceptionType = [NullPointerException | IllegalArgumentException] , 为实现此功能我们需要在项目的根目录新建lombok.config文件：<br><img src="snipaste_20191127171758.jpg" alt="snipaste_20191127171758.jpg"><br>重新编译NonNullExample类，已经为我们抛出非法参数异常：<br><img src="snipaste_20191127171843.jpg" alt="snipaste_20191127171843.jpg"></p>
<h4 id="NoArgsConstructor-RequiredArgsConstructor-AllArgsConstructor"><a href="#NoArgsConstructor-RequiredArgsConstructor-AllArgsConstructor" class="headerlink" title="@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor"></a>@NoArgsConstructor, @RequiredArgsConstructor, @AllArgsConstructor</h4><p>作用于类上，用于生成构造函数。有staticName、access等属性。</p>
<p>staticName属性一旦设定，将采用静态方法的方式生成实例，access属性可以限定访问权限。</p>
<p><strong>@NoArgsConstructor</strong><br>生成无参构造器；</p>
<p><strong>@RequiredArgsConstructor</strong><br>生成包含final和@NonNull注解的成员变量的构造器；<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import lombok.NonNull;</div><div class="line">import lombok.RequiredArgsConstructor;</div><div class="line"></div><div class="line">@RequiredArgsConstructor</div><div class="line">public class Demo &#123;</div><div class="line">    private final int finalVal = 10;</div><div class="line"></div><div class="line">    @NonNull</div><div class="line">    private String name;</div><div class="line">    @NonNull</div><div class="line">    private int age;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import java.beans.ConstructorProperties;</div><div class="line">import lombok.NonNull;</div><div class="line"></div><div class="line">public class Demo &#123;</div><div class="line">    private final int finalVal = 10;</div><div class="line">    @NonNull</div><div class="line">    private String name;</div><div class="line">    @NonNull</div><div class="line">    private int age;</div><div class="line"></div><div class="line">    @ConstructorProperties(&#123;&quot;name&quot;, &quot;age&quot;&#125;)</div><div class="line">    public Demo(@NonNull String name, @NonNull int age) &#123;</div><div class="line">        if (name == null) &#123;</div><div class="line">            throw new NullPointerException(&quot;name&quot;);</div><div class="line">        &#125; else &#123;</div><div class="line">            this.name = name;</div><div class="line">            this.age = age;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解释：该注解会识别@nonNull字段，然后以该字段为元素产生一个构造函数。备注：如果所有字段都没有@nonNull注解，那效果同NoArgsConstructor</p>
<p><strong>@AllArgsConstructor</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import lombok.NoArgsConstructor;</div><div class="line"></div><div class="line">@NoArgsConstructor</div><div class="line">public class Parent &#123;</div><div class="line">    private Integer id;</div><div class="line">&#125;</div><div class="line"></div><div class="line">import lombok.NoArgsConstructor;</div><div class="line"></div><div class="line">@NoArgsConstructor</div><div class="line">public class Parent &#123;</div><div class="line">    private Integer id;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译后的两个class文件如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Parent &#123;</div><div class="line">    private Integer id;</div><div class="line"></div><div class="line">    public Parent() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">import java.beans.ConstructorProperties;</div><div class="line"></div><div class="line">public class Demo extends Parent &#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line"></div><div class="line">    @ConstructorProperties(&#123;&quot;name&quot;, &quot;age&quot;&#125;)</div><div class="line">    public Demo(String name, int age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见, <strong>此注解并不会把父类的属性id拿到Demo的构造器里面去，这是需要注意的地方。并且它也没有默认的构造器了</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@AllArgsConstructor(access = AccessLevel.PROTECTED, staticName = &quot;test&quot;)</div><div class="line">public class Demo &#123;</div><div class="line">	private final int finalVal = 10;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>生成如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Demo &#123;</div><div class="line">	private final int finalVal = 10;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line"></div><div class="line">    private Demo(String name, int age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected static Demo test(String name, int age) &#123;</div><div class="line">        return new Demo(name, age);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看出来的效果为：可以指定生成的构造器的访问权限。但是，<strong>如果指定了一个静态方法，那么构造器会自动会被private，只通过静态方法对外提供访问</strong>，并且我们发现final的属性值，是不会放进构造函数里面的。</p>
<p>再回过头来看刚刚的 Student，很多时候，我们去写 Student 这个 bean 的时候，他会有一些必输字段，比如 Student 中的 name 字段，一般处理的方式是将 name 字段包装成一个构造方法，只有传入 name 这样的构造方法，才能创建一个 Student 对象。</p>
<p>接上上边的静态构造方法和必传参数的构造方法，使用 lombok 将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Accessors(chain = true)</div><div class="line">@Setter</div><div class="line">@Getter</div><div class="line">@RequiredArgsConstructor(staticName = &quot;ofName&quot;)</div><div class="line">public class Student &#123;</div><div class="line">    @NonNull private String name;</div><div class="line">    private int age;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Student student = Student.ofName(&quot;zs&quot;);</div></pre></td></tr></table></figure></p>
<p>这样构建出的 bean 语义是否要比直接 new 一个含参的构造方法(包含  name 的构造方法)要好很多。<br>当然他仍然是支持链式调用的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Student student = Student.ofName(&quot;zs&quot;).setAge(24);</div></pre></td></tr></table></figure></p>
<p><strong>@AllArgsConstructor</strong><br>生成全参构造器。</p>
<p><img src="snipaste_20190919111133.jpg" alt="snipaste_20190919111133.jpg"></p>
<p>编译后结果：<br><img src="Xnip20190919111444.png" alt="Xnip20190919111444.png"></p>
<h4 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h4><p>作用于类上，是以下注解的集合：</p>
<ul>
<li>@ToString</li>
<li>@EqualsAndHashCode</li>
<li>@Getter</li>
<li>@Setter</li>
<li>@RequiredArgsConstructor</li>
</ul>
<p><img src="snipaste_20191127172220.jpg" alt="snipaste_20191127172220.jpg"></p>
<h4 id="Builder"><a href="#Builder" class="headerlink" title="@Builder"></a>@Builder</h4><p>作用于类上，将类转变为建造者模式</p>
<p>看一下 Student 这个类的原始 builder 状态:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Getter</div><div class="line">@Setter</div><div class="line">public class Student &#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line"></div><div class="line">    public static Builder builder()&#123;</div><div class="line">            return new Builder();</div><div class="line">    &#125;</div><div class="line">    public static class Builder&#123;</div><div class="line">            private String name;</div><div class="line">            private int age;</div><div class="line">            public Builder name(String name)&#123;</div><div class="line">                    this.name = name;</div><div class="line">                    return this;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public Builder age(int age)&#123;</div><div class="line">                    this.age = age;</div><div class="line">                    return this;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            public Student build()&#123;</div><div class="line">                    Student student = new Student();</div><div class="line">                    student.setAge(age);</div><div class="line">                    student.setName(name);</div><div class="line">                    return student;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Student student = Student.builder().name(&quot;zs&quot;).age(24).build();</div></pre></td></tr></table></figure></p>
<p>这样的 builder 代码，让我是在恶心难受，于是我打算用 lombok 重构这段代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Builder</div><div class="line">public class Student &#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译后:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Student &#123;</div><div class="line">    private String name;</div><div class="line">    private int age;</div><div class="line"></div><div class="line">    Student(String name, int age) &#123;</div><div class="line">        this.name = name;</div><div class="line">        this.age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static Student.StudentBuilder builder() &#123;</div><div class="line">        return new Student.StudentBuilder();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static class StudentBuilder &#123;</div><div class="line">        private String name;</div><div class="line">        private int age;</div><div class="line"></div><div class="line">        StudentBuilder() &#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Student.StudentBuilder name(String name) &#123;</div><div class="line">            this.name = name;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Student.StudentBuilder age(int age) &#123;</div><div class="line">            this.age = age;</div><div class="line">            return this;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public Student build() &#123;</div><div class="line">            return new Student(this.name, this.age);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public String toString() &#123;</div><div class="line">            return &quot;Student.StudentBuilder(name=&quot; + this.name + &quot;, age=&quot; + this.age + &quot;)&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Student student = Student.builder().name(&quot;zs&quot;).age(24).build();</div></pre></td></tr></table></figure></p>
<p>注意: 上面没有加 @Getter 和 @Setter, 编译后就没有相应的 accessor, 故读取不到相应值, 故在使用 @Builder 时, 建议加上 @Getter 和 @Setter</p>
<h4 id="Log"><a href="#Log" class="headerlink" title="@Log"></a>@Log</h4><p>作用于类上，生成日志变量。针对不同的日志实现产品，有不同的注解：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@CommonsLog</div><div class="line">private static final org.apache.commons.logging.Log log = org.apache.commons.logging.LogFactory.getLog(LogExample.class);</div><div class="line">@JBossLog</div><div class="line">private static final org.jboss.logging.Logger log = org.jboss.logging.Logger.getLogger(LogExample.class);</div><div class="line">@Log</div><div class="line">private static final java.util.logging.Logger log = java.util.logging.Logger.getLogger(LogExample.class.getName());</div><div class="line">@Log4j</div><div class="line">private static final org.apache.log4j.Logger log = org.apache.log4j.Logger.getLogger(LogExample.class);</div><div class="line">@Log4j2</div><div class="line">private static final org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager.getLogger(LogExample.class);</div><div class="line">@Slf4j</div><div class="line">private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(LogExample.class);</div><div class="line">@XSlf4j</div><div class="line">private static final org.slf4j.ext.XLogger log = org.slf4j.ext.XLoggerFactory.getXLogger(LogExample.class);</div></pre></td></tr></table></figure></p>
<p>这个注解还是非常有用的，特别是Slf4j这个，在平时开发中挺有用的<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Slf4j</div><div class="line">class Parent &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Parent &#123;</div><div class="line">    private static final Logger log = LoggerFactory.getLogger(Parent.class);</div><div class="line"></div><div class="line">    Parent() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="其他重要注解"><a href="#其他重要注解" class="headerlink" title="其他重要注解"></a>其他重要注解</h3><h4 id="Cleanup"><a href="#Cleanup" class="headerlink" title="@Cleanup"></a>@Cleanup</h4><p>自动关闭资源，针对实现了java.io.Closeable接口的对象有效，默认是调用资源的close()方法。如果该资源有其它关闭方法，可使用@Cleanup(“methodName”)来指定要调用的方法，就用输入输出流来举个例子吧<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void main(String[] args) throws Exception &#123;</div><div class="line">    @Cleanup InputStream in = new FileInputStream(args[0]);</div><div class="line">    @Cleanup OutputStream out = new FileOutputStream(args[1]);</div><div class="line">    byte[] b = new byte[1024];</div><div class="line">    while (true) &#123;</div><div class="line">        int r = in.read(b);</div><div class="line">        if (r == -1) break;</div><div class="line">        out.write(b, 0, r);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void main(String[] args) throws Exception &#123;</div><div class="line">    FileInputStream in = new FileInputStream(args[0]);</div><div class="line"></div><div class="line">    try &#123;</div><div class="line">        FileOutputStream out = new FileOutputStream(args[1]);</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            byte[] b = new byte[1024];</div><div class="line"></div><div class="line">            while(true) &#123;</div><div class="line">                int r = in.read(b);</div><div class="line">                if (r == -1) &#123;</div><div class="line">                    return;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                out.write(b, 0, r);</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (Collections.singletonList(out).get(0) != null) &#123;</div><div class="line">                out.close();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125; finally &#123;</div><div class="line">        if (Collections.singletonList(in).get(0) != null) &#123;</div><div class="line">            in.close();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实在 JDK1.7 之后就有了 try-with-resource，不用我们显式的关闭流, 也可使用之。</p>
<h4 id="SneakyThrows"><a href="#SneakyThrows" class="headerlink" title="@SneakyThrows"></a>@SneakyThrows</h4><p>这个注解用在方法上，可以将方法中的代码用try-catch语句包裹起来，捕获异常并在catch中用Lombok.sneakyThrow(e)把异常抛出，可以使用@SneakyThrows(Exception.class)的形式指定抛出哪种异常<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SneakyThrows(UnsupportedEncodingException.class)</div><div class="line">   public String utf8ToString(byte[] bytes) &#123;</div><div class="line">       return new String(bytes, &quot;UTF-8&quot;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>编译后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SneakyThrows(UnsupportedEncodingException.class)</div><div class="line">    public String utf8ToString(byte[] bytes) &#123;</div><div class="line">        try&#123;</div><div class="line">            return new String(bytes, &quot;UTF-8&quot;);</div><div class="line">        &#125;catch(UnsupportedEncodingException uee)&#123;</div><div class="line">            throw Lombok.sneakyThrow(uee);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这里有必要贴出来Lombok.sneakyThrow的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static RuntimeException sneakyThrow(Throwable t) &#123;</div><div class="line">       if (t == null) &#123;</div><div class="line">           throw new NullPointerException(&quot;t&quot;);</div><div class="line">       &#125; else &#123;</div><div class="line">           return (RuntimeException)sneakyThrow0(t);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   private static &lt;T extends Throwable&gt; T sneakyThrow0(Throwable t) throws T &#123;</div><div class="line">       throw t;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="@Synchronized"></a>@Synchronized</h4><p>作用于方法级别，可以替换synchronize关键字或lock锁，用处不大。</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI3NjU2ODA5Mg==&amp;mid=2247484565&amp;idx=2&amp;sn=6cc229f530f3961f80d9f1208deff427&amp;scene=21#wechat_redirect" target="_blank" rel="external">IDEA中用好Lombok，撸码效率至少提升5倍</a><br><a href="https://mp.weixin.qq.com/s/hOa-LBNsqwQscPGy7t7Jzg" target="_blank" rel="external">Lombok 使用详解，简化Java编程</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Polymorphism-switch</title>
    <url>/2017/09/22/Java-Polymorphism-switch/</url>
    <content><![CDATA[<p>本文使用多态思想重构 switch 语句</p>
<a id="more"></a>
<h2 id="switch-结构代码"><a href="#switch-结构代码" class="headerlink" title="switch 结构代码"></a>switch 结构代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Base0 &#123;</div><div class="line">    private int arg;</div><div class="line"></div><div class="line">    public Base0(int arg) &#123;</div><div class="line">        this.arg = arg;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void show() &#123;</div><div class="line">        switch(arg)&#123;</div><div class="line">            case 1:</div><div class="line">                System.out.println(&quot;this is 1&quot;);</div><div class="line">                break;</div><div class="line">            case 2:</div><div class="line">                System.out.println(&quot;this is 2&quot;);</div><div class="line">                break;</div><div class="line">            case 3:</div><div class="line">                System.out.println(&quot;this is 3&quot;);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重构后的代码"><a href="#重构后的代码" class="headerlink" title="重构后的代码"></a>重构后的代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public abstract class Base &#123;</div><div class="line">    private int arg;</div><div class="line"></div><div class="line">    public Base(int arg) &#123;</div><div class="line">        this.arg = arg;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public abstract void show();</div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Ext1 extends Base &#123;</div><div class="line"></div><div class="line">    public Ext1(int arg) &#123;</div><div class="line">        super(arg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void show() &#123;</div><div class="line">        System.out.println(&quot;this is 1&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// Ext2, Ext3 代码同理 ...</div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Base0 base01 = new Base0(1);</div><div class="line">        Base0 base02 = new Base0(2);</div><div class="line">        Base0 base03 = new Base0(3);</div><div class="line">        base01.show();</div><div class="line">        base02.show();</div><div class="line">        base03.show();</div><div class="line"></div><div class="line">        Base base1 = new Ext1(1);</div><div class="line">        Base base2 = new Ext2(2);</div><div class="line">        Base base3 = new Ext3(3);</div><div class="line">        base1.show();</div><div class="line">        base2.show();</div><div class="line">        base3.show();</div><div class="line"></div><div class="line">        /* result:</div><div class="line">        this is 1</div><div class="line">        this is 2</div><div class="line">        this is 3</div><div class="line">         */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述完全是一个面向过程到面向对象的转变：将每个case分支都作为一个子对象，然后用java语言的多态性去动态绑定。这样做确实是带来了性能上的损失，但是在当今的CPU计算能力而言，这是可以忽略的，而它带来的好处却很有用：</p>
<ul>
<li>分支的增减只要继续派生即可；</li>
<li>子类代表了一个case，比必须用type去硬编码的case语句更加具有可读性；</li>
<li>代码的可读性增强，使得分支的维护性增加；</li>
<li>面向对象的思想更加符合人看世界的方式；</li>
<li>避免了漏写break语句造成的隐蔽错误；</li>
</ul>
<p>ref：<a href="https://blog.csdn.net/hzh2007/article/details/8042711" target="_blank" rel="external">https://blog.csdn.net/hzh2007/article/details/8042711</a> </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Polymorphism</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Servlet-LifeCycle</title>
    <url>/2017/09/22/Java-Servlet-Lifecycle/</url>
    <content><![CDATA[<p>本文为 ThreadLocal 整理和总结</p>
<a id="more"></a>
<h2 id="Servlet运行原理"><a href="#Servlet运行原理" class="headerlink" title="Servlet运行原理"></a>Servlet运行原理</h2><p><img src="969110-20170212132656901-1174433025.jpg" alt="969110-20170212132656901-1174433025.jpg"></p>
<p>Servlet生命周期定义了一个Servlet如何被加载、初始化，以及它怎样接收请求、响应请求，提供服务。在讨论Servlet生命周期之前，先让我们来看一下这几个方法</p>
<p><img src="0310874cabd1c0f7f64b153f2435cb8b735.jpg" alt="0310874cabd1c0f7f64b153f2435cb8b735.jpg"><br>该图说明了各个方法的前后调用顺序</p>
<h3 id="init-方法"><a href="#init-方法" class="headerlink" title="init()方法"></a>init()方法</h3><p>在Servlet的生命周期中，仅执行一次init()方法，它是在服务器装入Servlet时执行的，可以配置服务器，以在启动服务器或客户机首次访问Servlet时装入Servlet。无论有多少客户机访问Servlet，都不会重复执行init()；</p>
<h3 id="service-方法"><a href="#service-方法" class="headerlink" title="service()方法"></a>service()方法</h3><p>它是Servlet的核心，每当一个客户请求一个HttpServlet对象，该对象的Service()方法就要调用，而且传递给这个方法一个“请求”（ServletRequest）对象和一个“响应”（ServletResponse）对象作为参数。在HttpServlet中已存在Service()方法。默认的服务功能是调用与HTTP请求的方法相应的do功能。service是由web容器来调用的，我们无需对service具体内容做任何处理，service会自动的根据客户端的请求类型去调用doGet、doPost等方法，所以我们只需要做好doGet、doPost方法的实现就可以了</p>
<h3 id="doGet、doPost方法"><a href="#doGet、doPost方法" class="headerlink" title="doGet、doPost方法"></a>doGet、doPost方法</h3><p>实际的业务处理流程，service根据客户端的请求类型来自动匹配需要执行那个方法。</p>
<h3 id="destroy-方法"><a href="#destroy-方法" class="headerlink" title="destroy()方法"></a>destroy()方法</h3><p>仅执行一次，在服务器端停止且卸载Servlet时执行该方法，有点类似于C++的delete方法。一个Servlet在运行service()方法时可能会产生其他的线程，因此需要确认在调用destroy()方法时，这些线程已经终止或完成。</p>
<p>下面来谈谈Servlet的生命周期，Servlet的生命周期是由Servlet容器来控制的，它始于装入Web服务器的内存时，并在终止或重新装入Servlet时结束。这项操作一般是动态执行的。然而，Server通常会提供一个管理的选项，用于在Server启动时强制装载和初始化特定的Servlet。</p>
<p>在代码中，Servlet生命周期由接口javax.servlet.Servlet定义。所有的Java Servlet 必须直接或间接地实现javax.servlet.Servlet接口，这样才能在Servlet Engine上运行。javax.servlet.Servlet接口定义了一些方法，在Servlet 的生命周期中，这些方法会在特定时间按照一定的顺序被调用。</p>
<p><img src="20130825201025734.jpeg" alt="20130825201025734.jpeg"></p>
<h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><h3 id="加载和实例化Servlet"><a href="#加载和实例化Servlet" class="headerlink" title="加载和实例化Servlet"></a>加载和实例化Servlet</h3><p>我们来看一下Tomcat是如何加载的：</p>
<ol>
<li>如果已配置自动装入选项，则在启动时自动载入。</li>
<li>在服务器启动时，客户机首次向Servlet发出请求。</li>
<li>重新装入Servlet时。</li>
</ol>
<p>当启动Servlet容器时，容器首先查找一个配置文件web.xml，这个文件中记录了可以提供服务的Servlet。每个Servlet被指定一个Servlet名，也就是这个Servlet实际对应的Java的完整class文件名。Servlet容器会为每个自动装入选项的Servlet创建一个实例。所以，每个Servlet类必须有一个公共的无参数的构造器。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>当Servlet被实例化后，Servlet容器将调用每个Servlet的init方法来实例化每个实例，执行完init方法之后，Servlet处于“已初始化”状态。所以说，一旦Servlet被实例化，那么必将调用init方法。通过Servlet在启动后不立即初始化，而是收到请求后进行。在web.xml文件中用<load-on-statup> …… </load-on-statup>对Servlet进行预先初始化。</p>
<p>初始化失败后，执行init()方法抛出ServletException异常，Servlet对象将会被垃圾回收器回收，当客户端第一次访问服务器时加载Servlet实现类，创建对象并执行初始化方法。</p>
<h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><p>Servlet 被初始化以后，就处于能响应请求的就绪状态。每个对Servlet 的请求由一个Servlet Request 对象代表。Servlet 给客户端的响应由一个Servlet Response对象代表。对于到达客户机的请求，服务器创建特定于请求的一个“请求”对象和一个“响应”对象。调用service方法，这个方法可以调用其他方法来处理请求。</p>
<p>Service方法会在服务器被访问时调用，Servlet对象的生命周期中service方法可能被多次调用，由于web-server启动后，服务器中公开的部分资源将处于网络中，当网络中的不同主机（客户端）并发访问服务器中的同一资源，服务器将开设多个线程处理不同的请求，多线程同时处理同一对象时，有可能出现数据并发访问的错误。</p>
<p>另外注意，多线程难免同时处理同一变量时（如：对同一文件进行写操作），且有读写操作时，必须考虑是否加上同步，同步添加时，不要添加范围过大，有可能使程序变为纯粹的单线程，大大削弱了系统性能；只需要做到多个线程安全的访问相同的对象就可以了。</p>
<h3 id="卸载Servlet"><a href="#卸载Servlet" class="headerlink" title="卸载Servlet"></a>卸载Servlet</h3><p>当服务器不再需要Servlet实例或重新装入时，会调用destroy方法，使用这个方法，Servlet可以释放掉所有在init方法申请的资源。一个Servlet实例一旦终止，就不允许再次被调用，只能等待被卸载。</p>
<p>Servlet一旦终止，Servlet实例即可被垃圾回收，处于“卸载”状态，如果Servlet容器被关闭，Servlet也会被卸载，一个Servlet实例只能初始化一次，但可以创建多个相同的Servlet实例。如相同的Servlet可以在根据不同的配置参数连接不同的数据库时创建多个实例。</p>
<h2 id="编程注意事项说明"><a href="#编程注意事项说明" class="headerlink" title="编程注意事项说明"></a>编程注意事项说明</h2><p>1) 当Server Thread线程执行Servlet实例的init()方法时，所有的Client Service Thread线程都不能执行该实例的service()方法，更没有线程能够执行该实例的destroy()方法，因此Servlet的init()方法是工作在单线程的环境下，开发者不必考虑任何线程安全的问题。</p>
<p>2) 当服务器接收到来自客户端的多个请求时，服务器会在单独的Client Service Thread线程中执行Servlet实例的service()方法服务于每个客户端。此时会有多个线程同时执行同一个Servlet实例的service()方法，因此必须考虑线程安全的问题。</p>
<p>3) 请大家注意，虽然service()方法运行在多线程的环境下，并不一定要同步该方法。而是要看这个方法在执行过程中访问的资源类型及对资源的访问方式。分析如下：</p>
<pre><code>i. 如果service()方法没有访问Servlet的成员变量也没有访问全局的资源比如静态变量、文件、数据库连接等，而是只使用了当前线程自己的资源，比如非指向全局资源的临时变量、request和response对象等。该方法本身就是线程安全的，不必进行任何的同步控制。

 ii. 如果service()方法访问了Servlet的成员变量，但是对该变量的操作是只读操作，该方法本身就是线程安全的，不必进行任何的同步控制。

 iii. 如果service()方法访问了Servlet的成员变量，并且对该变量的操作既有读又有写，通常需要加上同步控制语句。

 iv. 如果service()方法访问了全局的静态变量，如果同一时刻系统中也可能有其它线程访问该静态变量，如果既有读也有写的操作，通常需要加上同步控制语句。

 v. 如果service()方法访问了全局的资源，比如文件、数据库连接等，通常需要加上同步控制语句。
</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul>
<li>Servlet类的构造方法只执行一次</li>
<li>Servlet对象的init方法只执行一次</li>
<li>Servlet对象的service方法，只要用户请求一次，则执行一次</li>
<li>Servlet对象的destory方法，只执行一次</li>
<li>init方法执行的时候，Servlet对象已经被创建好了。</li>
<li>destory方法执行的时候，Servlet对象还没有被销毁，即将被销毁</li>
</ul>
<p>ref:<br><a href="https://www.cnblogs.com/fifiyong/p/6390805.html" target="_blank" rel="external">https://www.cnblogs.com/fifiyong/p/6390805.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Strategy-Factory-Reflect-switch</title>
    <url>/2017/09/22/Java-Strategy-Factory-Reflect-switch/</url>
    <content><![CDATA[<p>本文使用策略模式+工厂模式+发射重构 switch 语句</p>
<a id="more"></a>
<h2 id="switch-结构代码"><a href="#switch-结构代码" class="headerlink" title="switch 结构代码"></a>switch 结构代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if(payStrategyParam == &quot;ALIPAY&quot;) &#123;</div><div class="line">    System.out.println(&quot;pay with alipay: &quot; + 12);</div><div class="line">&#125;else if(payStrategyParam == &quot;WECHATPAY&quot;) &#123;</div><div class="line">    System.out.println(&quot;pay with wechatpay: &quot; + 12);</div><div class="line">&#125;else if(payStrategyParam == &quot;EBANKPAY&quot;) &#123;</div><div class="line">    System.out.println(&quot;pay with ebankpay: &quot; + 12);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="重构后的代码"><a href="#重构后的代码" class="headerlink" title="重构后的代码"></a>重构后的代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 付款策略接口</div><div class="line"> */</div><div class="line">public interface PayStrategy &#123;</div><div class="line">    void pay(double total);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 支付宝付款</div><div class="line"> */</div><div class="line">public class Alipay implements PayStrategy&#123;</div><div class="line">    @Override</div><div class="line">    public void pay(double total) &#123;</div><div class="line">        System.out.println(&quot;pay with alipay: &quot; + total);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 微信付款</div><div class="line"> */</div><div class="line">public class WechatPay implements PayStrategy&#123;</div><div class="line">    @Override</div><div class="line">    public void pay(double total) &#123;</div><div class="line">        System.out.println(&quot;pay with wechatpay: &quot; + total);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 银行卡付款</div><div class="line"> */</div><div class="line">public class EbankPay implements PayStrategy&#123;</div><div class="line">    @Override</div><div class="line">    public void pay(double total) &#123;</div><div class="line">        System.out.println(&quot;pay with ebankpay: &quot; + total);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 付款枚举类</div><div class="line"> */</div><div class="line">public enum PayEnum &#123;</div><div class="line">    ALIPAY(&quot;com.pattern.reflect.Alipay&quot;),</div><div class="line">    WECHATPAY(&quot;com.pattern.reflect.WechatPay&quot;),</div><div class="line">    EBANKPAY(&quot;com.pattern.reflect.EbankPay&quot;);</div><div class="line"></div><div class="line">    PayEnum(String className) &#123;</div><div class="line">        this.setClassName(className);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private String className;</div><div class="line">    </div><div class="line">    public String getClassName() &#123;</div><div class="line">        return className;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setClassName(String className) &#123;</div><div class="line">        this.className = className;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * 工厂类</div><div class="line"> */</div><div class="line">public class StrategyFactory &#123;</div><div class="line">    public static PayStrategy getStrategy(String strategyType) throws Exception &#123;</div><div class="line">        String className = PayEnum.valueOf(strategyType).getClassName();</div><div class="line">        return (PayStrategy) Class.forName(className).newInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class Client &#123;</div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line"></div><div class="line">        String payStrategyParam = &quot;ALIPAY&quot;;//Param from front end</div><div class="line"></div><div class="line">        PayStrategy strategy = StrategyFactory.getStrategy(payStrategyParam);</div><div class="line">        strategy.pay(12);</div><div class="line"></div><div class="line">        payStrategyParam = &quot;WECHATPAY&quot;;//Param from front end</div><div class="line"></div><div class="line">        strategy = StrategyFactory.getStrategy(payStrategyParam);</div><div class="line">        strategy.pay(12);</div><div class="line"></div><div class="line">        payStrategyParam = &quot;EBANKPAY&quot;;//Param from front end</div><div class="line"></div><div class="line">        strategy = StrategyFactory.getStrategy(payStrategyParam);</div><div class="line">        strategy.pay(12);</div><div class="line"></div><div class="line">        /* result:</div><div class="line">        pay with alipay: 12.0</div><div class="line">        pay with wechatpay: 12.0</div><div class="line">        pay with ebankpay: 12.0</div><div class="line">         */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>if…else if…的缺点<br>多分支和复杂度高的逻辑会使代码冗长，难以理解和维护。<br>违反开闭原则，增删分支需要改动if…else if结构，，增大代码出错风险<br>使用策略模式+工厂模式的优点<br>对应的分支处理分成不同策略类来实现，使代码易于读懂和维护<br>扩展性好，增加分支只需要增加对应的策略实现类和枚举。符合开闭原则</p>
<p>ref：<a href="https://blog.csdn.net/u012557814/article/details/81671928" target="_blank" rel="external">https://blog.csdn.net/u012557814/article/details/81671928</a> </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Strategy</tag>
        <tag>Factory</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-15种锁的介绍</title>
    <url>/2017/09/22/Java-concurrency-15%E7%A7%8D%E9%94%81%E7%9A%84%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>在读很多并发文章中，会提及各种各样锁如公平锁，乐观锁等等，这篇文章介绍各种锁的分类。介绍的内容如下：</p>
<ol>
<li>公平锁 / 非公平锁</li>
<li>可重入锁 / 不可重入锁</li>
<li>独享锁 / 共享锁</li>
<li>互斥锁 / 读写锁</li>
<li>乐观锁 / 悲观锁</li>
<li>分段锁</li>
<li>偏向锁 / 轻量级锁 / 重量级锁</li>
<li>自旋锁</li>
</ol>
<p>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释</p>
<a id="more"></a>
<h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁 / 非公平锁"></a>公平锁 / 非公平锁</h2><h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p>
<h3 id="非公平锁"><a href="#非公平锁" class="headerlink" title="非公平锁"></a>非公平锁</h3><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</p>
<p>对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br>对于Synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p>
<h2 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁 / 不可重入锁"></a>可重入锁 / 不可重入锁</h2><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。ReentrantLock和synchronized都是可重入锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">synchronized void setA() throws Exception&#123;</div><div class="line">   Thread.sleep(1000);</div><div class="line">   setB();</div><div class="line">&#125;</div><div class="line">synchronized void setB() throws Exception&#123;</div><div class="line">   Thread.sleep(1000);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁</p>
<h3 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h3><p>不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。看到一个经典的讲解，使用自旋锁来模拟一个不可重入锁，代码如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import java.util.concurrent.atomic.AtomicReference;</div><div class="line"></div><div class="line">public class UnreentrantLock &#123;</div><div class="line"></div><div class="line">   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();</div><div class="line"></div><div class="line">   public void lock() &#123;</div><div class="line">       Thread current = Thread.currentThread();</div><div class="line">       //这句是很经典的“自旋”语法，AtomicInteger中也有</div><div class="line">       for (;;) &#123;</div><div class="line">           if (!owner.compareAndSet(null, current)) &#123;</div><div class="line">               return;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void unlock() &#123;</div><div class="line">       Thread current = Thread.currentThread();</div><div class="line">       owner.compareAndSet(current, null);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码也比较简单，使用原子引用来存放线程，同一线程两次调用lock()方法，如果不执行unlock()释放锁的话，第二次调用自旋的时候就会产生死锁，这个锁就不是可重入的，而实际上同一个线程不必每次都去释放锁再来获取锁，这样的调度切换是很耗资源的。</p>
<p>把它变成一个可重入锁：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import java.util.concurrent.atomic.AtomicReference;</div><div class="line"></div><div class="line">public class UnreentrantLock &#123;</div><div class="line"></div><div class="line">   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();</div><div class="line">   private int state = 0;</div><div class="line"></div><div class="line">   public void lock() &#123;</div><div class="line">       Thread current = Thread.currentThread();</div><div class="line">       if (current == owner.get()) &#123;</div><div class="line">           state++;</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">       //这句是很经典的“自旋”式语法，AtomicInteger中也有</div><div class="line">       for (;;) &#123;</div><div class="line">           if (!owner.compareAndSet(null, current)) &#123;</div><div class="line">               return;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public void unlock() &#123;</div><div class="line">       Thread current = Thread.currentThread();</div><div class="line">       if (current == owner.get()) &#123;</div><div class="line">           if (state != 0) &#123;</div><div class="line">               state--;</div><div class="line">           &#125; else &#123;</div><div class="line">               owner.compareAndSet(current, null);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在执行每次操作之前，判断当前锁持有者是否是当前对象，采用state计数，不用每次去释放锁。</p>
<p>ReentrantLock中可重入锁实现</p>
<p>这里看非公平锁的锁获取方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">final boolean nonfairTryAcquire(int acquires) &#123;</div><div class="line">   final Thread current = Thread.currentThread();</div><div class="line">   int c = getState();</div><div class="line">   if (c == 0) &#123;</div><div class="line">       if (compareAndSetState(0, acquires)) &#123;</div><div class="line">           setExclusiveOwnerThread(current);</div><div class="line">           return true;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   //就是这里</div><div class="line">   else if (current == getExclusiveOwnerThread()) &#123;</div><div class="line">       int nextc = c + acquires;</div><div class="line">       if (nextc &lt; 0) // overflow</div><div class="line">           throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">       setState(nextc);</div><div class="line">       return true;</div><div class="line">   &#125;</div><div class="line">   return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在AQS中维护了一个private volatile int state来计数重入次数，避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁</p>
<h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁 / 共享锁"></a>独享锁 / 共享锁</h2><p>独享锁和共享锁在你去读C.U.T包下的ReeReentrantLock和ReentrantReadWriteLock你就会发现，它俩一个是独享一个是共享锁。</p>
<p>独享锁：该锁每一次只能被一个线程所持有。<br>共享锁：该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。</p>
<p>另外读锁的共享可保证并发读是非常高效的，但是读写和写写，写读都是互斥的。</p>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<br>对于Synchronized而言，当然是独享锁</p>
<h2 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁 / 读写锁"></a>互斥锁 / 读写锁</h2><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。</p>
<p>如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被编程就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。 在这种方式下，只有一个线程能够访问被互斥锁保护的资源</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁既是互斥锁，又是共享锁，read模式是共享，write是互斥(排它锁)的。</p>
<p>读写锁有三种状态：读加锁状态、写加锁状态和不加锁状态</p>
<p>读写锁在Java中的具体实现就是ReadWriteLock</p>
<p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。<br>只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；如果是处于读状态锁下，允许其它线程获得它的读状态锁，但是不允许获得它的写状态锁，直到所有线程的读状态锁被释放；为了避免想要尝试写操作的线程一直得不到写状态锁，当读写锁感知到有线程想要获得写状态锁时，便会阻塞其后所有想要获得读状态锁的线程。所以读写锁非常适合资源的读操作远多于写操作的情况。</p>
<h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁 / 悲观锁"></a>乐观锁 / 悲观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。</p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p>
<h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于ConcurrentHashMap而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p>
<p>并发容器类的加锁机制是基于粒度更小的分段锁，分段锁也是提升多并发程序性能的重要手段之一。</p>
<p>在并发程序中，串行操作是会降低可伸缩性，并且上下文切换也会减低性能。在锁上发生竞争时将通水导致这两种问题，使用独占锁时保护受限资源的时候，基本上是采用串行方式—-每次只能有一个线程能访问它。所以对于可伸缩性来说最大的威胁就是独占锁。</p>
<p><strong>我们一般有三种方式降低锁的竞争程度</strong>:</p>
<ol>
<li>减少锁的持有时间 </li>
<li>降低锁的请求频率 </li>
<li>使用带有协调机制的独占锁，这些机制允许更高的并发性。</li>
</ol>
<p>在某些情况下我们可以将锁分解技术进一步扩展为一组独立对象上的锁进行分解，这成为分段锁。</p>
<p><strong>其实说的简单一点就是</strong>：</p>
<p>容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>比如：在ConcurrentHashMap中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶由第（N mod 16）个锁来保护。假设使用合理的散列算法使关键字能够均匀的分部，那么这大约能使对锁的请求减少到越来的1/16。也正是这项技术使得ConcurrentHashMap支持多达16个并发的写入线程。</p>
<h2 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁 / 轻量级锁 / 重量级锁"></a>偏向锁 / 轻量级锁 / 重量级锁</h2><p>锁的状态：</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<p>锁的状态是通过对象监视器在对象头中的字段来表明的。<br>四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。<br>这四种状态都不是Java语言中的锁，而是Jvm为了提高锁的获取与释放效率而做的优化(使用synchronized时)。</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p>
<h3 id="轻量级"><a href="#轻量级" class="headerlink" title="轻量级"></a>轻量级</h3><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>我们知道CAS算法是乐观锁的一种实现方式，CAS算法中又涉及到自旋锁，所以这里给大家讲一下什么是自旋锁</p>
<h3 id="简单回顾一下CAS算法"><a href="#简单回顾一下CAS算法" class="headerlink" title="简单回顾一下CAS算法"></a>简单回顾一下CAS算法</h3><p>CAS是英文单词Compare and Swap（比较并交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数</p>
<ol>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ol>
<p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B，否则不会执行任何操作。一般情况下是一个自旋操作，即不断的重试。</p>
<h3 id="什么是自旋锁？"><a href="#什么是自旋锁？" class="headerlink" title="什么是自旋锁？"></a>什么是自旋锁？</h3><p>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p>
<p>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名</p>
<h3 id="Java如何实现自旋锁？"><a href="#Java如何实现自旋锁？" class="headerlink" title="Java如何实现自旋锁？"></a>Java如何实现自旋锁？</h3><p>下面是个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class SpinLock &#123;</div><div class="line">   private AtomicReference&lt;Thread&gt; cas = new AtomicReference&lt;Thread&gt;();</div><div class="line">   public void lock() &#123;</div><div class="line">       Thread current = Thread.currentThread();</div><div class="line">       // 利用CAS</div><div class="line">       while (!cas.compareAndSet(null, current)) &#123;</div><div class="line">           // DO nothing</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   public void unlock() &#123;</div><div class="line">       Thread current = Thread.currentThread();</div><div class="line">       cas.compareAndSet(current, null);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>lock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。</p>
<h3 id="自旋锁存在的问题"><a href="#自旋锁存在的问题" class="headerlink" title="自旋锁存在的问题"></a>自旋锁存在的问题</h3><p>1、如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。<br>2、上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</p>
<h3 id="自旋锁的优点"><a href="#自旋锁的优点" class="headerlink" title="自旋锁的优点"></a>自旋锁的优点</h3><p>1、自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快<br>2、非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</p>
<h3 id="可重入的自旋锁和不可重入的自旋锁"><a href="#可重入的自旋锁和不可重入的自旋锁" class="headerlink" title="可重入的自旋锁和不可重入的自旋锁"></a>可重入的自旋锁和不可重入的自旋锁</h3><p>文章开始的时候的那段代码，仔细分析一下就可以看出，它是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。</p>
<p>而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。</p>
<p>为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class ReentrantSpinLock &#123;</div><div class="line">   private AtomicReference&lt;Thread&gt; cas = new AtomicReference&lt;Thread&gt;();</div><div class="line">   private int count;</div><div class="line">   public void lock() &#123;</div><div class="line">       Thread current = Thread.currentThread();</div><div class="line">       if (current == cas.get()) &#123; // 如果当前线程已经获取到了锁，线程数增加一，然后返回</div><div class="line">           count++;</div><div class="line">           return;</div><div class="line">       &#125;</div><div class="line">       // 如果没获取到锁，则通过CAS自旋</div><div class="line">       while (!cas.compareAndSet(null, current)) &#123;</div><div class="line">           // DO nothing</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   public void unlock() &#123;</div><div class="line">       Thread cur = Thread.currentThread();</div><div class="line">       if (cur == cas.get()) &#123;</div><div class="line">           if (count &gt; 0) &#123;// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟</div><div class="line">               count--;</div><div class="line">           &#125; else &#123;// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。</div><div class="line">               cas.compareAndSet(cur, null);</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自旋锁与互斥锁"><a href="#自旋锁与互斥锁" class="headerlink" title="自旋锁与互斥锁"></a>自旋锁与互斥锁</h3><ol>
<li>自旋锁与互斥锁都是为了实现保护资源共享的机制。</li>
<li>无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。</li>
<li>获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。</li>
</ol>
<h3 id="自旋锁总结"><a href="#自旋锁总结" class="headerlink" title="自旋锁总结"></a>自旋锁总结</h3><ol>
<li>自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。</li>
<li>自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。</li>
<li>自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。</li>
<li>自旋锁本身无法保证公平性，同时也无法保证可重入性。</li>
<li>基于自旋锁，可以实现具备公平性和可重入性质的锁。</li>
</ol>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/F8YDVB407vPr4Pp6KCk0vA" target="_blank" rel="external">https://mp.weixin.qq.com/s/F8YDVB407vPr4Pp6KCk0vA</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-Callback-JDK和Guava和Spring的不同实现</title>
    <url>/2017/09/22/Java-concurrency-Callback-JDK%E5%92%8CGuava%E5%92%8CSpring%E7%9A%84%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Java-concurrency-Callback-JDK和Guava和Spring的不同实现</p>
<a id="more"></a>
<h2 id="概念先行"><a href="#概念先行" class="headerlink" title="概念先行"></a>概念先行</h2><p>随着移动互联网的蓬勃发展，手机App层出不穷，其业务也随之变得错综复杂。针对于开发人员来说，可能之前的一个业务只需要调取一次第三方接口以获取数据，而如今随着需求的增加，该业务需调取多个不同的第三方接口。通常，我们处理方法是让代码同步顺序的去调取这些接口。显然，调取接口数量的增加必然会造成响应时间的增加，势必会对系统性能造成一定影响。</p>
<p>为了保证系统响应迅速，需要寻找一种方法能够使调取接口能够异步执行，而java正好提供了类似的方法，在java.util.concurrent中包含了Future相关的类，运用其中的一些类可以进行异步计算，以减少主线程的等待时间。比如启动一个main方法，main中又包含了若干个其它任务，在不使用java future的情况下，main方法中的任务会同步阻塞执行，一个执行完成后，才能去执行另一个；如果使用java future，则main方法中的任务会异步执行，main方法不用等待一个任务的执行完成，只需往下执行就行。一个任务的执行结果又该怎么获取呢?这里就需要用到Future接口中的isDone()方法来判断任务是否执行完，如果完成完成则可获取结果，如果没有完成则需要等待，可见虽然主线程中的多个任务是异步执行，但是无法确定任务什么时候执行完成，只能通过不断去监听以获取结果，所以这里是阻塞的。这样，可能某一个任务执行时间很长会拖累整个主任务的执行。</p>
<p>针对这样的情况，google对java.util.concurrent中的许多类进行封装，最终产生了google guava框架，其中com.google.common.util中的ListenableFuture就是本文要叙述的重点。查看com.google.common.util，发现其中的很多类都是对java.util.concurrent的封装，以增加特有的方法。ListenableFuture扩展了future方法，增加了addListener方法，该方法可以监听线程，并通过回调函数来获取结果，达到线程之间异步非阻塞执行。</p>
<p>首先，了解下同步、异步、阻塞、非阻塞相关概念；其次，简单介绍java future和guava future相关技术，并通过示例代码进一步对其进行理解；最后，对java future和guava future进行比较。</p>
<p><strong>同步、异步、阻塞、非阻塞</strong></p>
<p>同步：所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。</p>
<p>异步：异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>阻塞：阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</p>
<p>非阻塞：非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<h2 id="关于异步回调"><a href="#关于异步回调" class="headerlink" title="关于异步回调"></a>关于异步回调</h2><h3 id="Java自带的Future-Callback"><a href="#Java自带的Future-Callback" class="headerlink" title="Java自带的Future-Callback"></a>Java自带的Future-Callback</h3><h4 id="Java-Future"><a href="#Java-Future" class="headerlink" title="Java  Future"></a>Java  Future</h4><p><strong>Executors创建线程池的几种常见方式</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">类名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">newCachedThreadPool</td>
<td style="text-align:left">缓存型池子，先查看池中有没有以前建立的线程，如果有，就reuse；如果没有，就建一个新的线程加入池中。缓存型池子通常用于执行一些生存期很短的异步型任务。因此在一些面向连接的daemon型SERVER中用得不多。能reuse的线程，必须是timeout IDLE内的池中线程，缺省timeout为60s，超过这个IDLE时长，线程实例将被终止并移出池子。注意：放入CachedThreadPool的线程超过TIMEOUT不活动，其会自动被终止。</td>
</tr>
<tr>
<td style="text-align:left">newFixedThreadPool</td>
<td style="text-align:left">和cacheThreadPool类似，有可用的线程就使用，但不能随时建新的线程。其独特之处：任意时间点，最多只能有固定数目的活动线程存在，此时如果有新的线程要建立，只能放在另外的队列中等待，直到当前的线程中某个线程终止直接被移出池子。cache池和fixed池调用的是同一个底层池，只不过参数不同:fixed池线程数固定，并且是0秒IDLE（无IDLE）。所以FixedThreadPool多数针对一些很稳定很固定的正规并发线程，多用于服务器。cache池线程数支持0-Integer.MAX_VALUE(显然完全没考虑主机的资源承受能力)，60秒IDLE。</td>
</tr>
<tr>
<td style="text-align:left">ScheduledThreadPool</td>
<td style="text-align:left">调度型线程池。这个池子里的线程可以按schedule依次delay执行，或周期执行。</td>
</tr>
<tr>
<td style="text-align:left">SingleThreadExecutor</td>
<td style="text-align:left">单例线程，任意时间池中只能有一个线程。用的是和cache池和fixed池相同的底层池，但线程数目是1-1,0秒IDLE（无IDLE）。</td>
</tr>
</tbody>
</table>
<p><strong>Executors创建线程池源码</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//调用newCachedThreadPool方法，可以创建一个缓冲型线程池，而在改方法中通过传参创建一个ThreadPoolExecutor，我么你会很奇怪明明返回的是一个ExecutorService，怎么会创建了一个ThreadPoolExecutor呢？</div><div class="line">public static ExecutorService newCachedThreadPool() &#123;</div><div class="line">        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, </div><div class="line">                   TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable());</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// ThreadPoolExecutor继承了抽象的service类AbstractExecutorService</div><div class="line">public class ThreadPoolExecutor extends AbstractExecutorService &#123;&#125;</div><div class="line"> </div><div class="line">//AbstractExecutorService实现了ExecutorService接口</div><div class="line">public abstract class AbstractExecutorService implements ExecutorService &#123;&#125;</div><div class="line"> </div><div class="line">//所以ExecutorService其实是ThreadPoolExecutor的基类，这也就解释清楚了</div></pre></td></tr></table></figure></p>
<p><strong>ExecutorService</strong><br>ExecutorService是一个接口，它继承了Executor，在原有execute方法的基础上新增了submit方法，传入一个任务，该方法能够返回一个Future对象，可以获取异步计算结果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//ExecutorService继承了Executor，并扩展了新方法。</div><div class="line">public interface ExecutorService extends Executor &#123; &#125;</div><div class="line"> </div><div class="line">//Executor中的方法</div><div class="line">void execute(Runnable command);</div><div class="line"> </div><div class="line">//增加了submit方法，该方法传任务来获取Future对象，而Future对象中可以获取任务的执行结果</div><div class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</div><div class="line">Future&lt;?&gt; submit(Runnable task);</div></pre></td></tr></table></figure></p>
<p><strong>Future(获取异步计算结果)</strong><br>Future接口中有下表所示方法，可以获取当前正在执行的任务相关信息</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">boolean cancel(boolean interruptIf)</td>
<td style="text-align:left">取消任务的执行</td>
</tr>
<tr>
<td style="text-align:left">boolean isCancelled()</td>
<td style="text-align:left">任务是否已取消，任务正常完成前将其取消，返回 true</td>
</tr>
<tr>
<td style="text-align:left">boolean isDone()</td>
<td style="text-align:left">任务是否已完成，任务正常终止、异常或取消，返回true</td>
</tr>
<tr>
<td style="text-align:left">V get()</td>
<td style="text-align:left">等待任务结束，然后获取V类型的结果</td>
</tr>
<tr>
<td style="text-align:left">V get(long timeout, TimeUnit unit)</td>
<td style="text-align:left">获取结果，设置超时时间</td>
</tr>
</tbody>
</table>
<p><strong>FutureTask</strong></p>
<p>Executor框架利用FutureTask来完成异步任务，并可以用来进行任何潜在的耗时的计算。一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。</p>
<p>FutureTask包装了Callable和Runnable接口对象,提供对Future接口的基本实现，开始、取消计算、查询计算是否完成、获取计算结果。仅当计算完成时才能检索结果，当计算没有完成时，该方法会一直阻塞直到任务转入完成状态。一旦完成计算，不能够重新开始或取消计算。通过Excutor(线程池)来执行,也可传递给Thread对象执行。如果在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//通过传入任务来构造FutureTask</div><div class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;&#125;</div><div class="line">public FutureTask(Runnable runnable, V result) &#123;&#125;</div><div class="line"> </div><div class="line">//FutureTask中同样有获取当前任务状态的方法</div><div class="line">public boolean isCancelled()&#123;&#125;</div><div class="line">public boolean isDone() &#123;&#125;</div><div class="line">public boolean cancel(boolean mayInterruptIfRunning) &#123;&#125;</div><div class="line"> </div><div class="line">//FutureTask实现RunnableFuture</div><div class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;&#125;</div><div class="line"> </div><div class="line">//RunnableFuture继承Runnable和Future</div><div class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;</div></pre></td></tr></table></figure>
<p><strong>示例代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package future.java;</div><div class="line"> </div><div class="line">import java.util.Random;</div><div class="line">import java.util.concurrent.Callable;</div><div class="line">import java.util.concurrent.ExecutionException;</div><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line">import java.util.concurrent.Future;</div><div class="line"> </div><div class="line">public class TestFuture &#123;</div><div class="line">    // 创建线程池</div><div class="line">    final static ExecutorService service = Executors.newCachedThreadPool();</div><div class="line"> </div><div class="line">    public static void main(String[] args) throws InterruptedException, ExecutionException &#123;</div><div class="line">        Long t1 = System.currentTimeMillis();</div><div class="line"> </div><div class="line">        // 任务1</div><div class="line">        Future&lt;Boolean&gt; booleanTask = service.submit(new Callable&lt;Boolean&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Boolean call() throws Exception &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        while (true) &#123;</div><div class="line">            if (booleanTask.isDone() &amp;&amp; !booleanTask.isCancelled()) &#123;</div><div class="line">                //模拟耗时</div><div class="line">                Thread.sleep(500);</div><div class="line">                Boolean result = booleanTask.get();</div><div class="line">                System.err.println(&quot;BooleanTask: &quot; + result);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        // 任务2</div><div class="line">        Future&lt;String&gt; stringTask = service.submit(new Callable&lt;String&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public String call() throws Exception &#123;</div><div class="line">                return &quot;Hello World&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        while (true) &#123;</div><div class="line">            if (stringTask.isDone() &amp;&amp; !stringTask.isCancelled()) &#123;</div><div class="line">                String result = stringTask.get();</div><div class="line">                System.err.println(&quot;StringTask: &quot; + result);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">        // 任务3</div><div class="line">        Future&lt;Integer&gt; integerTask = service.submit(new Callable&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Integer call() throws Exception &#123;</div><div class="line">                return new Random().nextInt(100);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"> </div><div class="line">        while (true) &#123;</div><div class="line">            if (integerTask.isDone() &amp;&amp; !integerTask.isCancelled()) &#123;</div><div class="line">                Integer result = integerTask.get();</div><div class="line">                System.err.println(&quot;IntegerTask: &quot; + result);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        // 执行时间</div><div class="line">        System.err.println(&quot;time: &quot; + (System.currentTimeMillis() - t1));</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Guava提供的ListenableFuture-Callback"><a href="#Guava提供的ListenableFuture-Callback" class="headerlink" title="Guava提供的ListenableFuture-Callback"></a>Guava提供的ListenableFuture-Callback</h3><p>ListenableFuture是可以监听的Future，它是对java原生Future的扩展增强。Future表示一个异步计算任务，当任务完成时可以得到计算结果。如果希望计算完成时马上就拿到结果展示给用户或者做另外的计算，就必须使用另一个线程不断的查询计算状态。这样做会使得代码复杂，且效率低下。如果使用ListenableFuture，Guava会帮助检测Future是否完成了，如果完成就自动调用回调函数，这样可以减少并发程序的复杂度。</p>
<p><strong>多线程异步处理：常用类</strong></p>
<ol>
<li><strong>MoreExecutors</strong>    该类是final类型的工具类，提供了很多静态方法。例如listeningDecorator方法初始化ListeningExecutorService方法，使用此实例submit方法即可初始化ListenableFuture对象。</li>
<li><strong>ListeningExecutorService</strong> 该类是对ExecutorService的扩展，重写ExecutorService类中的submit方法，返回ListenableFuture对象。</li>
<li><strong>ListenableFuture</strong> 该接口扩展了Future接口，增加了addListener方法，该方法在给定的excutor上注册一个监听器，当计算完成时会马上调用该监听器。不能够确保监听器执行的顺序，但可以在计算完成时确保马上被调用。</li>
<li><strong>FutureCallback</strong>    该接口提供了OnSuccess和OnFailuren方法。获取异步计算的结果并回调。</li>
<li><strong>Futures</strong>    该类提供和很多实用的静态方法以供使用。</li>
<li><strong>ListenableFutureTask</strong>    该类扩展了FutureTask类并实现ListenableFuture接口，增加了addListener方法。</li>
</ol>
<p><strong>代码示例</strong></p>
<p>JayGuavaExecutors.java–基于Guava封装的线程池<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.jay.util.tools.base;</div><div class="line"> </div><div class="line">import java.util.concurrent.SynchronousQueue;</div><div class="line">import java.util.concurrent.ThreadFactory;</div><div class="line">import java.util.concurrent.ThreadPoolExecutor;</div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line">import java.util.concurrent.atomic.AtomicInteger;</div><div class="line"> </div><div class="line">import com.google.common.util.concurrent.ListenableFuture;</div><div class="line">import com.google.common.util.concurrent.ListeningExecutorService;</div><div class="line">import com.google.common.util.concurrent.MoreExecutors;</div><div class="line"> </div><div class="line">/**</div><div class="line"> * 基于Guava封装的线程池</div><div class="line"> *</div><div class="line"> * @author hetiewei</div><div class="line"> * @date 2016年8月15日 上午11:16:54</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class JayGuavaExecutors &#123;</div><div class="line">	public static final int DEFAULT_MAX_THREAD = 1000;</div><div class="line">	private static ListeningExecutorService defaultCompletedExecutorService = null;</div><div class="line">	private static final Object lock = new Object();</div><div class="line"> </div><div class="line">	public static ListeningExecutorService newCachedExecutorService(int maxThreadNumber, final String namePrefix) &#123;</div><div class="line">		return MoreExecutors.listeningDecorator(new ThreadPoolExecutor(0, maxThreadNumber, 60L, TimeUnit.SECONDS,</div><div class="line">				new SynchronousQueue&lt;Runnable&gt;(), new ThreadFactory() &#123;</div><div class="line"> </div><div class="line">					private final AtomicInteger poolNumber = new AtomicInteger(1);</div><div class="line"> </div><div class="line">					@Override</div><div class="line">					public Thread newThread(Runnable r) &#123;</div><div class="line">						Thread thread = new Thread(r, namePrefix + poolNumber.getAndIncrement());</div><div class="line">						return thread;</div><div class="line">					&#125;</div><div class="line">				&#125;));</div><div class="line"> </div><div class="line">	&#125;</div><div class="line"> </div><div class="line">	public static ListeningExecutorService newCachedExecutorService(String namePrefix) &#123;</div><div class="line">		return newCachedExecutorService(DEFAULT_MAX_THREAD, namePrefix);</div><div class="line">	&#125;</div><div class="line"> </div><div class="line">	public static ListeningExecutorService getDefaultCompletedExecutorService() &#123;</div><div class="line">		if (defaultCompletedExecutorService == null) &#123;</div><div class="line">			synchronized (lock) &#123;</div><div class="line">				if (defaultCompletedExecutorService == null) &#123;</div><div class="line">					defaultCompletedExecutorService = newCachedExecutorService(&quot;Completed-Callback-&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return defaultCompletedExecutorService;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>GuavaExecutorsTest.java 测试类<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.jay.util.tools.base.test;</div><div class="line"> </div><div class="line">import java.util.Random;</div><div class="line">import java.util.concurrent.Callable;</div><div class="line"> </div><div class="line">import com.google.common.util.concurrent.FutureCallback;</div><div class="line">import com.google.common.util.concurrent.Futures;</div><div class="line">import com.google.common.util.concurrent.ListenableFuture;</div><div class="line">import com.jay.util.tools.base.JayGuavaExecutors;</div><div class="line"> </div><div class="line">public class GuavaExecutorsTest &#123;</div><div class="line"> </div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Long t1 = System.currentTimeMillis();</div><div class="line"> </div><div class="line">		// 任务1</div><div class="line">		ListenableFuture&lt;Boolean&gt; booleanTask = JayGuavaExecutors.getDefaultCompletedExecutorService()</div><div class="line">				.submit(new Callable&lt;Boolean&gt;() &#123;</div><div class="line"> </div><div class="line">					@Override</div><div class="line">					public Boolean call() throws Exception &#123;</div><div class="line">						return true;</div><div class="line">					&#125;</div><div class="line"> </div><div class="line">				&#125;);</div><div class="line">		Futures.addCallback(booleanTask, new FutureCallback&lt;Boolean&gt;() &#123;</div><div class="line"> </div><div class="line">			@Override</div><div class="line">			public void onSuccess(Boolean result) &#123;</div><div class="line">				System.out.println(&quot;BooleanTask : &quot; + result);</div><div class="line">			&#125;</div><div class="line"> </div><div class="line">			@Override</div><div class="line">			public void onFailure(Throwable t) &#123;</div><div class="line">				System.out.println(&quot;BooleanTask 执行失败 【&quot; + t.getMessage() + &quot;】 &quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"> </div><div class="line">		// 任务2</div><div class="line">		ListenableFuture&lt;String&gt; stringTask = JayGuavaExecutors.getDefaultCompletedExecutorService()</div><div class="line">				.submit(new Callable&lt;String&gt;() &#123;</div><div class="line">					@Override</div><div class="line">					public String call() throws Exception &#123;</div><div class="line">						return &quot;Hello World&quot;;</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line"> </div><div class="line">		Futures.addCallback(stringTask, new FutureCallback&lt;String&gt;() &#123;</div><div class="line">			@Override</div><div class="line">			public void onSuccess(String result) &#123;</div><div class="line">				System.err.println(&quot;StringTask: &quot; + result);</div><div class="line">			&#125;</div><div class="line"> </div><div class="line">			@Override</div><div class="line">			public void onFailure(Throwable t) &#123;</div><div class="line">				System.err.println(&quot;StringTask 执行失败 【&quot; + t.getMessage() + &quot;】 &quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"> </div><div class="line">		// 任务3</div><div class="line">		ListenableFuture&lt;Integer&gt; integerTask = JayGuavaExecutors.getDefaultCompletedExecutorService()</div><div class="line">				.submit(new Callable&lt;Integer&gt;() &#123;</div><div class="line">					@Override</div><div class="line">					public Integer call() throws Exception &#123;</div><div class="line">						return new Random().nextInt(100);</div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">		Futures.addCallback(integerTask, new FutureCallback&lt;Integer&gt;() &#123;</div><div class="line">			@Override</div><div class="line">			public void onSuccess(Integer result) &#123;</div><div class="line">				try &#123;</div><div class="line">					Thread.sleep(500);</div><div class="line">				&#125; catch (InterruptedException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				System.err.println(&quot;IntegerTask: &quot; + result);</div><div class="line">			&#125;</div><div class="line"> </div><div class="line">			@Override</div><div class="line">			public void onFailure(Throwable t) &#123;</div><div class="line">				System.err.println(&quot;IntegerTask 执行失败 【&quot; + t.getMessage() + &quot;】 &quot;);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"> </div><div class="line">		Long t2 = System.currentTimeMillis();</div><div class="line">		</div><div class="line">		 // 执行时间</div><div class="line">        System.err.println(&quot;time: &quot; + (t2 - t1));</div><div class="line">	&#125;</div><div class="line"> </div><div class="line">	public static void main1(String[] args) &#123;</div><div class="line">		for (int i = 0; i &lt; 10; i++) &#123;</div><div class="line">			JayGuavaExecutors.getDefaultCompletedExecutorService().submit(new Runnable() &#123;</div><div class="line"> </div><div class="line">				@Override</div><div class="line">				public void run() &#123;</div><div class="line">					System.out.println(&quot;xxxxx&quot;);</div><div class="line">					try &#123;</div><div class="line">						Thread.sleep(1000);</div><div class="line">					&#125; catch (InterruptedException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">					&#125;</div><div class="line">					System.out.println(&quot;xxxxx1&quot;);</div><div class="line">				&#125;</div><div class="line">			&#125;);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* result:</div><div class="line"></div><div class="line">BooleanTask : true</div><div class="line">StringTask: Hello World</div><div class="line">IntegerTask: 67</div><div class="line">time: 527</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h2 id="Spring4提供的异步请求封装模板"><a href="#Spring4提供的异步请求封装模板" class="headerlink" title="Spring4提供的异步请求封装模板"></a>Spring4提供的异步请求封装模板</h2><p>ListenableFuture通过异步回调机制来实现请求的非阻塞。<br>通常情况下，客户端获取数据并不会只发送一次http请求，可能会有多个http请求。这样，使用上一篇博客中的方法，就会产生大量的冗余代码，因为请求处理的代码除了一些参数不同外，其它地方都大致相同。我们发现不同请求之间的区别在于：请求地址的不同、响应类型的不同，可能还会有额外请求参数的不同。我们可以将请求数据和响应数据进行封装，这样，只需要一个字段来标识每一次http请求属于哪一个业务就可以实现批量发送http请求，整个过程是异步非阻塞的，一旦获取到数据就会触发回调函数，进而获取到响应数据，最后再进行业务逻辑相关处理</p>
<h3 id="RestTemplate简介"><a href="#RestTemplate简介" class="headerlink" title="RestTemplate简介"></a>RestTemplate简介</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>RestTemplate是Spring3.0中出现的新类，其可以简化HTTP服务器通信，处理HTTP连接，使应用程序代码通过提供url和响应类型(可能的模板变量)便可提取结果</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//get方法</div><div class="line">//其中url为请求地址，responseType为响应类(需要自己依据响应格式来确定)</div><div class="line">//urlVariables为数组变量</div><div class="line">public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... urlVariables) throws RestClientException </div><div class="line"> </div><div class="line">//urlVariables为Map类型变量，其中key为请求字段名，value为请求字段值</div><div class="line">public &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; urlVariables)</div><div class="line"> </div><div class="line">public &lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException</div><div class="line"> </div><div class="line">//ResponseEntity</div><div class="line">public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... urlVariables) throws RestClientException</div><div class="line"> </div><div class="line">public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; urlVariables) throws RestClientException</div><div class="line"> </div><div class="line">public &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException </div><div class="line"> </div><div class="line"> </div><div class="line">//post</div><div class="line">public &lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException</div><div class="line"> </div><div class="line">public &lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException</div><div class="line"> </div><div class="line">public &lt;T&gt; T postForObject(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException </div><div class="line"> </div><div class="line">public &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException</div><div class="line"> </div><div class="line">public &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException</div><div class="line"> </div><div class="line">public &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException</div></pre></td></tr></table></figure>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>Spring提供的RestTemplate可用于访问Rest服务的客户端，其提供了多种便捷访问远程Http服务的方法，能够大大提高客户端的编写效率，但其并没有实现异步调用的功能。下面将引入Spring4.0提供的AsyncRestTemplate，该类可实现异步非阻塞处理http请求</p>
<h3 id="AsyncRestTemplate简介"><a href="#AsyncRestTemplate简介" class="headerlink" title="AsyncRestTemplate简介"></a>AsyncRestTemplate简介</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>AsyncRestTemplate是在Spring4.0中对RestTemplate进行扩展产生的新类，其为客户端提供了异步http请求处理的一种机制，通过返回ListenableFuture对象生成回调机制，以达到异步非阻塞发送http请求</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//get</div><div class="line">public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException</div><div class="line"> </div><div class="line">public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; urlVariables) throws RestClientException</div><div class="line"> </div><div class="line">public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException</div><div class="line"> </div><div class="line"> </div><div class="line">//post</div><div class="line">public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; postForEntity(String url, HttpEntity&lt;?&gt; request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException</div><div class="line"> </div><div class="line">public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; postForEntity(String url, HttpEntity&lt;?&gt; request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException </div><div class="line"> </div><div class="line">public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; postForEntity(URI url, HttpEntity&lt;?&gt; request, Class&lt;T&gt; responseType) throws RestClientException</div></pre></td></tr></table></figure>
<h4 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h4><p>相比于RestTemplate，AsyncRestTemplate通过回调机制能够很好地异步处理多个http请求，使得客户端在主方法中不必等待服务器响应，而是继续执行后续代码，这样就较大地提高了代码的执行效率，减少响应时间。</p>
<h3 id="基于AsyncRestTemplate实现批量异步调用"><a href="#基于AsyncRestTemplate实现批量异步调用" class="headerlink" title="基于AsyncRestTemplate实现批量异步调用"></a>基于AsyncRestTemplate实现批量异步调用</h3><p>下面将介绍基于AsyncRestTemplate异步调用的轻量级框架，说框架有点吹牛皮的感觉，不过代码结构整体上看起来还是挺清晰的，如有不妥之处，请提供宝贵建议。其主要分为5个部分：业务标识、请求、响应，异步调用、请求处理。对应的类如下所示：</p>
<ul>
<li>业务标识：IEnum、UserEnum(具体业务标识)</li>
<li>请求：BaseRequest、UserRequest(具体业务请求)、ConcreateWapper(请求包装)</li>
<li>响应：BaseResponse、UserRequest（具体业务响应）</li>
<li>异步调用：Templete、AbstractTemplete、AsynClientTemplete、CommonListenableCallBack</li>
<li>请求处理：FutureTpDao</li>
</ul>
<p>先来个直观的例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void main(String[] args) &#123;  </div><div class="line">    AsyncRestTemplate template = new AsyncRestTemplate();  </div><div class="line">    //调用完后立即返回（没有阻塞）  </div><div class="line">    ListenableFuture&lt;ResponseEntity&lt;User&gt;&gt; future = template.getForEntity(&quot;http://localhost:9080/spring4/api&quot;, User.class);  </div><div class="line">    //设置异步回调  </div><div class="line">    future.addCallback(new ListenableFutureCallback&lt;ResponseEntity&lt;User&gt;&gt;() &#123;  </div><div class="line">        @Override  </div><div class="line">        public void onSuccess(ResponseEntity&lt;User&gt; result) &#123;  </div><div class="line">            System.out.println(&quot;======client get result : &quot; + result.getBody());  </div><div class="line">        &#125;  </div><div class="line">  </div><div class="line">        @Override  </div><div class="line">        public void onFailure(Throwable t) &#123;  </div><div class="line">            System.out.println(&quot;======client failure : &quot; + t);  </div><div class="line">        &#125;  </div><div class="line">    &#125;);  </div><div class="line">    System.out.println(&quot;==no wait&quot;);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="业务标识（使用枚举类来标识业务请求）"><a href="#业务标识（使用枚举类来标识业务请求）" class="headerlink" title="业务标识（使用枚举类来标识业务请求）"></a>业务标识（使用枚举类来标识业务请求）</h4><p>使用枚举类能够比较好地标识具体业务，但是枚举类无法继承，这里通过定义一个空的接口IEnum对其进行抽象。可能看起来会有所不妥，但是也算是一种解决方法吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//空的接口</div><div class="line">package acync;</div><div class="line"> </div><div class="line">public interface IEnum &#123;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">//具体业务标识枚举类，实现了IEnum接口</div><div class="line">public enum UserEnum implements IEnum &#123;</div><div class="line">    ADD,</div><div class="line">    UPDATE,</div><div class="line">    DELETE,</div><div class="line">    MODIFY;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h4><p>通常情况下，客户端都是发送http请求（使用url的方式）来获取数据，这样，我们主需要获取请求的url地址即可。这里，定义接口BaseRequest提供build方法来构建请求接口，对于具体的业务请求只需实现接口并构建请求url即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//基础请求接口，提供构建URL方法</div><div class="line">package acync;</div><div class="line"> </div><div class="line">public interface BaseRequest &#123;</div><div class="line">    public String build();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">//具体的请求类，依据业务情况自行构建URL地址</div><div class="line">package acync;</div><div class="line"> </div><div class="line">public class UserRequest implements BaseRequest &#123;</div><div class="line">    private static final String REQ_URL = &quot;http://www.126.com&quot;;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public String build() &#123;</div><div class="line">        return REQ_URL;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h4><p>对于请求响应这里也是定义抽象类BaseResponse，提供status来表示请求的响应状态，而具体的业务响应只需要实现抽象类，自定义实现即可。（其中，BaseResponse抽象类可依据具体的业务框架来定义实现）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//基础响应抽象类，提供状态码</div><div class="line">package acync;</div><div class="line"> </div><div class="line">import java.io.Serializable;</div><div class="line"> </div><div class="line">public abstract class  BaseResponse implements Serializable&#123;</div><div class="line">    private String status;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line">//具体业务响应类</div><div class="line">package acync;</div><div class="line"> </div><div class="line">public class UserResponse extends BaseResponse&#123;</div><div class="line">//TODO</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h4><p>下面的所列代码是整个请求的核心代码。首先，定义模版接口，接口中只提供了若干主要方法，从整体上看，方法的参数为业务请求类和响应类型，返回值为泛型类型的ListenableFuture对象；其次，定义抽象类和具体的实现类；最后，进过请求处理即可获取请求接口。这里不累赘，见下方代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//异步调用模板接口</div><div class="line">package acync;</div><div class="line"> </div><div class="line">import java.util.Map;</div><div class="line"> </div><div class="line">import org.springframework.core.ParameterizedTypeReference;</div><div class="line">import org.springframework.http.ResponseEntity;</div><div class="line">import org.springframework.util.concurrent.ListenableFuture;</div><div class="line"> </div><div class="line">public interface Templete &#123;</div><div class="line">    &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest, Class&lt;T&gt; responseType) throws Exception;</div><div class="line"> </div><div class="line">    &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest,</div><div class="line">            ParameterizedTypeReference&lt;T&gt; responseType) throws Exception;</div><div class="line"> </div><div class="line">    &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest, Class&lt;T&gt; responseType,</div><div class="line">            Map&lt;String, ?&gt; uriVariables) throws Exception;</div><div class="line"> </div><div class="line">    &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest,</div><div class="line">            ParameterizedTypeReference&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws Exception;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"> </div><div class="line">//异步调用抽象类</div><div class="line">//这里仅仅提供少量的调取方法，可以自行扩展</div><div class="line"> </div><div class="line">package acync;</div><div class="line"> </div><div class="line">import java.util.Map;</div><div class="line">import org.springframework.core.ParameterizedTypeReference;</div><div class="line">import org.springframework.http.HttpMethod;</div><div class="line">import org.springframework.http.ResponseEntity;</div><div class="line">import org.springframework.util.concurrent.ListenableFuture;</div><div class="line">import org.springframework.web.client.AsyncRestTemplate;</div><div class="line"> </div><div class="line">public abstract class AbstractTemplete implements Templete&#123;</div><div class="line">    public AsyncRestTemplate asyncRestTemplate;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest, Class&lt;T&gt; responseType)</div><div class="line">            throws Exception &#123;</div><div class="line">        String url = baserequest.build();</div><div class="line">        try &#123;</div><div class="line">            ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; t = asyncRestTemplate.getForEntity(url, responseType);</div><div class="line">            return t;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            throw e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest,</div><div class="line">            ParameterizedTypeReference&lt;T&gt; responseType) throws Exception &#123;</div><div class="line">        String url = baserequest.build();</div><div class="line">        try &#123;</div><div class="line">            ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; t = asyncRestTemplate.exchange(url, HttpMethod.GET, null, responseType);</div><div class="line">            return t;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            throw e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest, Class&lt;T&gt; responseType,</div><div class="line">            Map&lt;String, ?&gt; uriVariables) throws Exception &#123;</div><div class="line">        String url = baserequest.build();</div><div class="line">        ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; t = null;</div><div class="line">        try &#123;</div><div class="line">            t = asyncRestTemplate.exchange(url, HttpMethod.GET, null, responseType, uriVariables);</div><div class="line">            return t;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            throw e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest,</div><div class="line">            ParameterizedTypeReference&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws Exception &#123;</div><div class="line">        String url = baserequest.build();</div><div class="line">        ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; t = null;</div><div class="line">        try &#123;</div><div class="line">            t = asyncRestTemplate.exchange(url, HttpMethod.GET, null, responseType, uriVariables);</div><div class="line">            return t;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            throw e;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    abstract void setTemplete(AsyncRestTemplate asyncRestTemplate);</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"></div><div class="line"> </div><div class="line"> </div><div class="line">// 具体的异步调用实现类</div><div class="line">package acync;</div><div class="line"> </div><div class="line">import java.util.Map;</div><div class="line">import org.springframework.core.ParameterizedTypeReference;</div><div class="line">import org.springframework.http.ResponseEntity;</div><div class="line">import org.springframework.util.concurrent.ListenableFuture;</div><div class="line">import org.springframework.web.client.AsyncRestTemplate;</div><div class="line"> </div><div class="line">public class AsynClientTemplete extends AbstractTemplete &#123;</div><div class="line"> </div><div class="line">    public AsynClientTemplete(AsyncRestTemplate template) &#123;</div><div class="line">        setTemplete(template);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest, Class&lt;T&gt; responseType)</div><div class="line">            throws Exception &#123;</div><div class="line">        return super.getAsyncForObject(baserequest, responseType);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest,</div><div class="line">            ParameterizedTypeReference&lt;T&gt; responseType) throws Exception &#123;</div><div class="line">        return super.getAsyncForObject(baserequest, responseType);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest, Class&lt;T&gt; responseType,</div><div class="line">            Map&lt;String, ?&gt; uriVariables) throws Exception &#123;</div><div class="line">        return super.getAsyncForObject(baserequest, responseType, uriVariables);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public &lt;T&gt; ListenableFuture&lt;ResponseEntity&lt;T&gt;&gt; getAsyncForObject(BaseRequest baserequest,</div><div class="line">            ParameterizedTypeReference&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws Exception &#123;</div><div class="line">        return super.getAsyncForObject(baserequest, responseType, uriVariables);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    void setTemplete(AsyncRestTemplate template) &#123;</div><div class="line">        asyncRestTemplate = template == null ? new AsyncRestTemplate() : template;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h4><p>上述四步都是为这一步做准备。请求处理这一步是请求的入口，在FutureTpDao中，通过getHttpData方法传入请求包装类ConcreateWapper，返回的Map对象MapIEnum, Object即为响应结果，只需依据具体的业务枚举类即可获取对应的业务请求数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//包装了具体的请求信息</div><div class="line">//其中的每一个Concreate对应一个具体的请求，baseEnum对应业务标识，variables为请求的额外参数，request为请求类和响应类组成的map</div><div class="line"> </div><div class="line">package acync;</div><div class="line"> </div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line">import java.util.Map;</div><div class="line"> </div><div class="line">public class ConcreateWapper &#123;</div><div class="line">    private List&lt;Concreate&gt; wrapper = new ArrayList&lt;Concreate&gt;();</div><div class="line"> </div><div class="line">    public ConcreateWapper()&#123;&#125;</div><div class="line"> </div><div class="line">    public void setParams(IEnum baseEnum, Map&lt;String, ?&gt; variables, Map&lt;BaseRequest, ?&gt; request) &#123;</div><div class="line">        wrapper.add(new Concreate(baseEnum, variables, request));</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public List&lt;Concreate&gt; getWrapper() &#123;</div><div class="line">        return wrapper;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static class Concreate &#123;</div><div class="line">        private IEnum baseEnum;</div><div class="line">        private Map&lt;String, ?&gt; variables;</div><div class="line">        private Map&lt;BaseRequest, ?&gt; request;</div><div class="line"> </div><div class="line">        public Concreate(IEnum baseEnum, Map&lt;String, ?&gt; variables, Map&lt;BaseRequest, ?&gt; request) &#123;</div><div class="line">            this.baseEnum = baseEnum;</div><div class="line">            this.variables = variables;</div><div class="line">            this.request = request;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        public IEnum getBaseEnum() &#123;</div><div class="line">            return baseEnum;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        public void setBaseEnum(IEnum baseEnum) &#123;</div><div class="line">            this.baseEnum = baseEnum;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        public Map&lt;String, ?&gt; getVariables() &#123;</div><div class="line">            return variables;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        public void setVariables(Map&lt;String, ?&gt; variables) &#123;</div><div class="line">            this.variables = variables;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        public Map&lt;BaseRequest, ?&gt; getRequest() &#123;</div><div class="line">            return request;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        public void setRequest(Map&lt;BaseRequest, ?&gt; request) &#123;</div><div class="line">            this.request = request;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">//实现ListenableFutureCallback，实现回调功能</div><div class="line">package acync;</div><div class="line"> </div><div class="line">import java.util.Map;</div><div class="line">import java.util.concurrent.CountDownLatch;</div><div class="line">import org.springframework.http.ResponseEntity;</div><div class="line">import org.springframework.util.concurrent.ListenableFutureCallback;</div><div class="line"> </div><div class="line"> </div><div class="line">public class CommonListenableCallBack&lt;T&gt; implements ListenableFutureCallback&lt;T&gt; &#123;</div><div class="line">    private IEnum type;</div><div class="line">    private Map&lt;IEnum, Object&gt; resultValue;</div><div class="line">    private volatile CountDownLatch latch;</div><div class="line"> </div><div class="line">    public CommonListenableCallBack(IEnum type, Map&lt;IEnum, Object&gt; resultValue, CountDownLatch latch) &#123;</div><div class="line">        this.type = type;</div><div class="line">        this.resultValue = resultValue;</div><div class="line">        this.latch = latch;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public void onSuccess(T result) &#123;</div><div class="line">        ResponseEntity&lt;T&gt; re = (ResponseEntity&lt;T&gt;) result;</div><div class="line">        if (re != null &amp;&amp; re.getBody() != null) &#123;</div><div class="line">            T body = re.getBody();</div><div class="line">            if (type != null) &#123;</div><div class="line">                resultValue.put(type, body);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        latch.countDown();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    @Override</div><div class="line">    public void onFailure(Throwable ex) &#123;</div><div class="line">        latch.countDown();</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">//FutureTpDao的构造函数可以传入自定义的AsyncRestTemplate，不传的话就是默认的</div><div class="line">//其中的getHttpData()方法传入多个请求的包装类ConcreateWapper，返回数据组成的Map</div><div class="line">//其中Map中的key对应的是业务标识，value对应的是请求对应的结果类</div><div class="line"> </div><div class="line">package acync;</div><div class="line"> </div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line">import java.util.concurrent.CountDownLatch;</div><div class="line">import org.springframework.core.ParameterizedTypeReference;</div><div class="line">import org.springframework.util.concurrent.ListenableFuture;</div><div class="line">import org.springframework.web.client.AsyncRestTemplate;</div><div class="line">import acync.ConcreateWapper.Concreate;</div><div class="line"> </div><div class="line">public class FutureTpDao &#123;</div><div class="line">    public AsynClientTemplete asynHttpClient;</div><div class="line"> </div><div class="line">    public FutureTpDao()&#123;</div><div class="line">        asynHttpClient = new AsynClientTemplete(null);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public FutureTpDao(AsyncRestTemplate tp) &#123;</div><div class="line">        asynHttpClient = new AsynClientTemplete(tp);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    //获取数据</div><div class="line">    public Map&lt;IEnum, Object&gt; getHttpData(ConcreateWapper wapper) &#123;</div><div class="line">        if (wapper == null)</div><div class="line">            return new HashMap&lt;IEnum, Object&gt;();</div><div class="line">        final CountDownLatch latch = new CountDownLatch(wapper.getWrapper().size());</div><div class="line">        final Map&lt;IEnum, Object&gt; result = new HashMap&lt;IEnum, Object&gt;();</div><div class="line"> </div><div class="line">        if (wapper.getWrapper() != null) &#123;</div><div class="line">            for (final Concreate wp : wapper.getWrapper()) &#123;</div><div class="line">                try &#123;</div><div class="line">                    Map&lt;BaseRequest, ?&gt; requestMap = wp.getRequest();</div><div class="line">                    for (final BaseRequest tpRequestInfo : requestMap.keySet()) &#123;</div><div class="line">                        getHttpdata(wp, tpRequestInfo, latch, requestMap, result);</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (Exception e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            try &#123;</div><div class="line">                latch.await();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                throw new RuntimeException(e.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">   //发送http请求，获取请求结果</div><div class="line">    private void getHttpdata(Concreate wp, BaseRequest tpRequestInfo, CountDownLatch latch,</div><div class="line">            Map&lt;BaseRequest, ?&gt; requestMap, Map&lt;IEnum, Object&gt; result) throws Exception &#123;</div><div class="line">        ListenableFuture&lt;?&gt; statResponse = null;</div><div class="line"> </div><div class="line">        if (requestMap.get(tpRequestInfo) instanceof ParameterizedTypeReference&lt;?&gt;) &#123;</div><div class="line">            ParameterizedTypeReference&lt;?&gt; responseType = (ParameterizedTypeReference&lt;?&gt;) requestMap.get(tpRequestInfo);</div><div class="line">            statResponse = asynHttpClient.getAsyncForObject(tpRequestInfo, responseType, wp.getVariables());</div><div class="line">        &#125; else if (requestMap.get(tpRequestInfo) instanceof Class&lt;?&gt;) &#123;</div><div class="line">            Class&lt;?&gt; responseType = (Class&lt;?&gt;) requestMap.get(tpRequestInfo);</div><div class="line">            statResponse = asynHttpClient.getAsyncForObject(tpRequestInfo, responseType);</div><div class="line">        &#125; else &#123;</div><div class="line">            throw new RuntimeException(&quot;requestType error...&quot;);</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        addCallBack(statResponse, wp.getBaseEnum(), latch, result);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    //增加回调</div><div class="line">    private &lt;T&gt; void addCallBack(ListenableFuture&lt;T&gt; statResponse, IEnum baseEnum, CountDownLatch latch,</div><div class="line">            Map&lt;IEnum, Object&gt; result) &#123;</div><div class="line">        if (statResponse != null) &#123;</div><div class="line">            statResponse.addCallback(new CommonListenableCallBack&lt;T&gt;(baseEnum, result, latch));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package acync;</div><div class="line"> </div><div class="line">import java.util.HashMap;</div><div class="line">import java.util.Map;</div><div class="line"> </div><div class="line">/**</div><div class="line"> * 示例</div><div class="line"> * 示例仅仅是一个样板，无法运行</div><div class="line"> * 需要在web环境下运行，例如启动tomcat服务器并进行相关配置</div><div class="line"> * @author liqqc</div><div class="line"> *</div><div class="line"> */</div><div class="line">public class Demo &#123;</div><div class="line"> </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        ConcreateWapper wapper = new ConcreateWapper();</div><div class="line"> </div><div class="line">        Map&lt;BaseRequest, Class&lt;? extends BaseResponse&gt;&gt; request = new HashMap&lt;BaseRequest, Class&lt;? extends BaseResponse&gt;&gt;();</div><div class="line">        request.put(new UserRequest(), new UserResponse().getClass());</div><div class="line">        wapper.setParams(UserEnum.ADD, null, request);</div><div class="line">        wapper.setParams(UserEnum.DELETE, null, request);</div><div class="line">        wapper.setParams(UserEnum.UPDATE, null, request);</div><div class="line">        wapper.setParams(UserEnum.MODIFY, null, request);</div><div class="line"> </div><div class="line">        FutureTpDao futureTpDao = new FutureTpDao();</div><div class="line">        Map&lt;IEnum, Object&gt; futureData = futureTpDao.getHttpData(wapper);</div><div class="line">        for (IEnum ienum : futureData.keySet()) &#123;</div><div class="line">            System.err.println(ienum + &quot;=&quot; + futureData.get(ienum));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://blog.csdn.net/he90227/article/details/52210490" target="_blank" rel="external">https://blog.csdn.net/he90227/article/details/52210490</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-ReentrantLock-Synchronized</title>
    <url>/2017/09/22/Java-concurrency-ReentrantLock-Synchronized/</url>
    <content><![CDATA[<p>这篇文章是关于这两个同步锁的简单总结比较</p>
<a id="more"></a>
<h2 id="相似点"><a href="#相似点" class="headerlink" title="相似点"></a>相似点</h2><p>这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的（操作系统需要在用户态与内核态之间来回切换，代价很高，不过可以通过对锁优化进行改善）。</p>
<h2 id="功能区别"><a href="#功能区别" class="headerlink" title="功能区别"></a>功能区别</h2><p>这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成</p>
<p>便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。</p>
<p>锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized</p>
<h2 id="性能的区别"><a href="#性能的区别" class="headerlink" title="性能的区别"></a>性能的区别</h2><p>在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。</p>
<h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>Synchronized进过编译，会在同步块的前后分别形成monitorenter和monitorexit这个两个字节码指令。在执行monitorenter指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class SynDemo&#123;</div><div class="line">	public static void main(String[] arg)&#123;</div><div class="line">		Runnable t1=new MyThread();</div><div class="line">		new Thread(t1,&quot;t1&quot;).start();</div><div class="line">		new Thread(t1,&quot;t2&quot;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class MyThread implements Runnable &#123;</div><div class="line">	@Override</div><div class="line">	public void run() &#123;</div><div class="line">		synchronized (this) &#123;</div><div class="line">			for(int i=0;i&lt;10;i++)</div><div class="line">				System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项</p>
<ol>
<li><strong>等待可中断</strong>，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。通过lock.lockInterruptibly()来实现这个机制。</li>
<li><p><strong>公平锁</strong>，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。<br>公平锁、非公平锁的创建方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//创建一个非公平锁，默认是非公平锁</div><div class="line">Lock lock = new ReentrantLock();</div><div class="line">Lock lock = new ReentrantLock(false);</div><div class="line"> </div><div class="line">//创建一个公平锁，构造传参true</div><div class="line">Lock lock = new ReentrantLock(true);</div></pre></td></tr></table></figure>
</li>
<li><p>锁绑定多个条件，一个ReentrantLock对象可以同时绑定多个对象。ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。o</p>
</li>
</ol>
<h2 id="什么情况下使用ReenTrantLock"><a href="#什么情况下使用ReenTrantLock" class="headerlink" title="什么情况下使用ReenTrantLock"></a>什么情况下使用ReenTrantLock</h2><p>答案是，如果你需要实现ReenTrantLock的三个独有功能时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class SynDemo&#123;</div><div class="line">	public static void main(String[] arg)&#123;</div><div class="line">		Runnable t1=new MyThread();</div><div class="line">		new Thread(t1,&quot;t1&quot;).start();</div><div class="line">		new Thread(t1,&quot;t2&quot;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class MyThread implements Runnable &#123;</div><div class="line">	private Lock lock=new ReentrantLock();</div><div class="line">	public void run() &#123;</div><div class="line">			lock.lock();</div><div class="line">			try&#123;</div><div class="line">				for(int i=0;i&lt;5;i++)</div><div class="line">					System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);</div><div class="line">			&#125;finally&#123;</div><div class="line">				lock.unlock();</div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://blog.csdn.net/zxd8080666/article/details/83214089" target="_blank" rel="external">https://blog.csdn.net/zxd8080666/article/details/83214089</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-ReentrantLock</title>
    <url>/2017/09/22/Java-concurrency-ReentrantLock/</url>
    <content><![CDATA[<p>可重入锁ReentrantLock的实现原理以及源码分析。</p>
<a id="more"></a>
<h2 id="什么是重入锁"><a href="#什么是重入锁" class="headerlink" title="什么是重入锁"></a>什么是重入锁</h2><p>可重入锁 ReentrantLock ，顾名思义，支持重新进入的锁，其表示该锁能支持一个线程对资源的重复加锁。</p>
<p>Java API 描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">一个可重入的互斥锁 Lock，它具有与使用 synchronized 方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。</div><div class="line">ReentrantLock 将由最近成功获得锁，并且还没有释放该锁的线程所拥有。当锁没有被另一个线程所拥有时，调用 lock 的线程将成功获取该锁并返回。如果当前线程已经拥有该锁，此方法将立即返回。可以使用 isHeldByCurrentThread() 和 getHoldCount() 方法来检查此情况是否发生。</div></pre></td></tr></table></figure>
<p>ReentrantLock还提供了公平锁和非公平锁的选择， 其构造方法接受一个公平参数（默认是非公平方式），当传入ture时表示公平锁， 否则为非公平锁。其两者的主要区别在于公平锁获取锁是有顺序的。但是其效率往往没有非公平锁的效率高，在多线程的访问时往往表现很低的吞吐量（即速度慢，常常急慢）。</p>
<p><img src="2121654773-5cc2624fcb3c3_articlex.jpeg" alt="2121654773-5cc2624fcb3c3_articlex.jpeg"></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>我们先来看一段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ReentrantLock lock = new ReentrantLock();</div><div class="line">try &#123;</div><div class="line">    lock.lock();</div><div class="line">    // 业务代码</div><div class="line">&#125; finally &#123;</div><div class="line">    lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一段代码相信学过Java的同学都非常熟悉了，今天我们就以此为入口一步一步的带你深入其底层世界。</p>
<p>共享状态的获取（锁的获取）<br>lock()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// ReentrantLock --&gt; lokc() 实现Lock 接口的方法</div><div class="line">public void lock() &#123;</div><div class="line">    // 调用内部类sync 的lock方法, 这里有两种实现，公平锁（FairSync）非公平锁（NonfairSync）这里我们来主要说 NonfairSync</div><div class="line">    sync.lock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ReentrantLock 的lock 方法， sync 为ReentrantLock的一个内部类，其继承了AbstractQueuedSynchronizer（AQS）, 他有两个子类公平锁FairSync 和非公平锁NonfairSync</p>
<p>ReentrantLock 中其中大部分的功能的实现都是委托给内部类Sync实现的，在Sync 中定义了abstract void lock() 留给子类去实现， 默认实现了final boolean nonfairTryAcquire(int acquires) 方法，可以看出其为非公平锁默认实现方式，下面我讲下给看下非公平锁lock方法。</p>
<p>NonfairSync.lock()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// ReentrantLock$NonfairSync</div><div class="line">final void lock() &#123;</div><div class="line">    if (compareAndSetState(0, 1))</div><div class="line">        // 非公平原则， 上来就插队来尝试下获取共享状态，如果成功则设置当前持有锁线程为自己，获取锁成功。</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    else</div><div class="line">        //如果失败则调用AQS中的acquire方法</div><div class="line">        acquire(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先就尝试获取同步状态（体现非公平锁上来就插队）如果成功则将持有锁线程设置为自己，失败则走AQS中的acquire方法。</p>
<p>AQS.acquire(int arg)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// AQS中的acquire方法，在AQS中已经讲过，首先会调用tryAcquire(arg)方法，tryAcquire(arg)方法会有具体由子类去实现。</div><div class="line">public final void acquire(int arg) &#123;</div><div class="line">    if (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里AQS中的源码我就不再过多的讲解了（无非就是尝试获取同步状态成功直接返回，失败加入同步队列等待被唤醒），主要来将留给子类实现的tryAcquire(arg)方法。<br>如有对AQS不明白的请看文章头中列出的几篇文章过一下或者锁搜引擎中锁搜下。</p>
<p>Nonfairync.tryAcquire(int acquires)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">    // 非公平锁的tryAcquire(arg)实现，委托给Sync.nonfairTryAcquire(int acquires)具体处理</div><div class="line">    return nonfairTryAcquire(acquires);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ReentrantLock中非公平锁tryAcquire(int acquires)的实现，具体调用其父类Sync中默认实现的（上面已经提过）。</p>
<p>Sync.nonfairTryAcquire(int acquires)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">final boolean nonfairTryAcquire(int acquires) &#123;</div><div class="line">    final Thread current = Thread.currentThread();</div><div class="line">    // 获取共享状态</div><div class="line">    int c = getState();</div><div class="line">    if (c == 0) &#123;</div><div class="line">        // 如果共享状态为0，说明锁空闲，利用CAS来获取锁（将共享状态值改为1）</div><div class="line">        if (compareAndSetState(0, acquires)) &#123;</div><div class="line">            // 如果设置成功，则表明获取锁成功，将持有锁线程设置为自己</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 如果c != 0 则说明锁已经被线程持有，判断持有锁的线程是不是自己（这里就是可重入锁的具体体现）</div><div class="line">    else if (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        // 如果当前持有锁的线程是自己，说明可重入，将共享状态值加1，返回ture</div><div class="line">        int nextc = c + acquires;</div><div class="line">        if (nextc &lt; 0) // overflow</div><div class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">        setState(nextc);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要逻辑：</p>
<ul>
<li>首先判断同步状态 state == 0 ?，</li>
<li>如果state == 0 则说明该锁处于空闲状态，直接通过CAS设置同步状态,成功将持有锁线程设置为自己返回ture，</li>
<li>如果state !=0 判断锁的持有者是否是自己，是则说明可重入将state 值加1 返回ture,</li>
<li>否则返回false.</li>
</ul>
<p>来张图加深下理解</p>
<p><img src="2076618888-5cc261d0a1730_articlex.jpeg" alt="2076618888-5cc261d0a1730_articlex.jpeg"></p>
<p>注：此图只是体现了RenntrantLock中的状态，其中涉及到AQS中的状态流转没有在这体现。</p>
<p>锁的释放<br>锁的释放逻辑就比较简单</p>
<p>ReentrantLock.unlock()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void unlock() &#123;</div><div class="line">        sync.release(1);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>同样在ReentrantLock.unlock()方法中将具体释放逻辑委托给了内部类Sync来实现, 在这Sync 同样没有去实现release(1)而是使用其父类AQS的默认实现。</p>
<p>AQS.release(1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 调用AQS中的release 方法</div><div class="line">public final boolean release(int arg) &#123;</div><div class="line">    if (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>AQS释放锁的逻辑比较简单，同样就不解释了(无非就是释放锁，唤醒后继节点)具体来看下需要自类实现的tryRelease(arg) 释放共享状态的方法。</p>
<p>Sync.tryRelease(int releases)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">    // 共享状态值减去releases</div><div class="line">    int c = getState() - releases;</div><div class="line">    // 如果持有锁的线程线程不是自己，则抛出异常（很好理解不能把别人的锁释放了）</div><div class="line">    if (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        throw new IllegalMonitorStateException();</div><div class="line">    boolean free = false;</div><div class="line">    // 共享状态 state = 0 则表明释放锁成功</div><div class="line">    if (c == 0) &#123;</div><div class="line">        free = true;</div><div class="line">        setExclusiveOwnerThread(null);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    return free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>释放共享状态（锁）的逻辑比较简单，主要是将共享状态的值减去releases，减后共享状态值为0表示释放锁成功将持有锁线程设置为null 返回 ture。</p>
<p><img src="3209737936-5cc261e70a714_articlex.jpeg" alt="3209737936-5cc261e70a714_articlex.jpeg"></p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>最后我们来对ReentrantLock加锁和释放锁做个简单总结，ReentrantLock 是一个可重入锁提供了两种实现方式公平锁和非公平锁。<br>非公平锁获取锁流程：<br>1: 首先不管三七二一就来个 CAS 尝试获取锁。<br>2: 成功则皆大欢喜。<br>3: 失败，再次获取下共享状态（万一这会有人释放了尼）判断是否为0<br>4: 如果为0 则说明锁空闲，再次CAS获取锁成功将持有锁线程设置为自己并返回ture<br>5:不为0，判断持有者是否是自己、是自己表明可重入state + 1 返回ture 否则返回false（就去同步队列中排队去）。</p>
<p>非公平锁释放锁流程<br>很简单state - 1 = 0 则释放成功否则失败。</p>
<p>ref:<br><a href="https://segmentfault.com/a/1190000018993293" target="_blank" rel="external">https://segmentfault.com/a/1190000018993293</a></p>
<p>这篇文章也不错：<br><a href="https://segmentfault.com/a/119000001476995" target="_blank" rel="external">https://segmentfault.com/a/119000001476995</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-ScheduledExecutorService</title>
    <url>/2017/09/22/Java-concurrency-ScheduledExecutorService/</url>
    <content><![CDATA[<p>ScheduledExecutorService 是一个支持周期调度的线程池</p>
<a id="more"></a>
<p>ScheduledExecutorService 有3个方法执行定时任务：</p>
<ul>
<li>schedule(runnable, delay, unit)   单次延时任务</li>
<li>scheduleAtFixedRate(runnable, initialDelay, period, unit)     循环任务, 按照上一次任务的发起时间作为开始时间计算下一次任务的开始时间</li>
<li>scheduleWithFixedDelay(runnable, initialDelay, delay, unit)   循环任务, 是以上一次任务的结束时间作为开始时间计算下一次任务的开始时间</li>
</ul>
<p>code:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ScheduledExecutorService mService = Executors.newScheduledThreadPool(5);</div><div class="line">mService.schedule(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;-------单次任务执行--------&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;, 5, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">//1秒后执行线程，以后每隔5秒执行一次线程(线程开始时间开始计时）</div><div class="line">mService.scheduleAtFixedRate(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;-------定期任务执行--------&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;, 1, 5, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">//1秒后执行线程，以后每隔6秒执行一次线程（线程结束时间开始计时）</div><div class="line">mService.scheduleWithFixedDelay(new Runnable() &#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;-------定期任务执行--------&quot;);</div><div class="line">            Thread.sleep(1000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;, 1, 5, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>
<p>总结:</p>
<ul>
<li>scheduleWithFixedDelay(runnable, initialDelay, delay, unit）第一次执行时间是initialDelay时间后，以后每次执行间隔是runnable任务执行完的时间加上delay的时间；</li>
<li>scheduleAtFixedRate(runnable, initialDelay, period, unit)第一次执行时间是initialDelay时间后，以后每次执行间隔就是delay的时间，但这里有一种特殊情况，当period间隔的时间比runnable执行时间还要短的时候，period时间到了并不会立即执行，而是等runnable结束之后才立即执行下一次任务(可参考: <a href="https://www.jianshu.com/p/8c4c160ebdf7" target="_blank" rel="external">https://www.jianshu.com/p/8c4c160ebdf7</a>)</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Thread-start-run</title>
    <url>/2017/09/22/Java-concurrency-Thread-start-run/</url>
    <content><![CDATA[<p>线程Thread类的start()方法和run()方法</p>
<a id="more"></a>
<h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><p>java的线程是通过java.lang.Thread类来实现的。VM启动时会有一个由主方法所定义的线程。可以通过创建Thread的实例来创建新的线程。每个线程都是通过某个特定Thread对象所对应的方法run（）来完成其操作的，方法run()称为线程体。通过调用Thread类的start()方法来启动一个线程。</p>
<p>在Java当中，线程通常都有五种状态，创建、就绪、运行、阻塞和死亡。</p>
<ol>
<li><strong>创建状态</strong> 在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。</li>
<li><strong>就绪状态</strong> 当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</li>
<li><strong>运行状态</strong> 线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。</li>
<li><strong>阻塞状态</strong> 线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。</li>
<li><strong>死亡状态</strong> 如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。</li>
</ol>
<h2 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h2><p><strong>为什么需要start方法；它的作用是什么?</strong></p>
<p><strong>start（）方法来启动线程，真正实现了多线程运行。</strong><br>start方法的作用就是将线程由NEW状态，变为RUNABLE状态。当线程创建成功时，线程处于NEW（新建）状态，如果你不调用start( )方法，那么线程永远处于NEW状态。调用start( )后，才会变为RUNABLE状态，线程才可以运行。</p>
<p><strong>调用start（）方法后，线程是不是马上执行？</strong></p>
<p>线程不是马上执行的；准确来说，调用start( )方法后，线程的状态是“READY（就绪）”状态，而不是“RUNNING（运行中）”状态（关于线程的状态详细。线程要等待CPU调度，不同的JVM有不同的调度算法，线程何时被调度是未知的。因此，start（）方法的被调用顺序不能决定线程的执行顺序</p>
<p>注意：<br>由于在线程的生命周期中，线程的状态由NEW —-&gt; RUNABLE只会发生一次，因此，一个线程只能调用start（）方法一次，多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</p>
<h2 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h2><p><strong>run方法又是一个什么样的方法？run方法与start方法有什么关联？</strong></p>
<p><strong>run（）方法当作普通方法的方式调用</strong><br>run( )其实是一个普通方法，只不过当线程调用了start( )方法后，一旦线程被CPU调度，处于运行状态，那么线程才会去调用这个run（）方法；</p>
<p><strong>run（）方法的执行是不是需要线程调用start（）方法</strong></p>
<p>上面说了，run（）方法是一个普通的对象方法，因此，不需要线程调用start（）后才可以调用的。可以线程对象可以随时随地调用run方法。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>用start方法启动线程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Main &#123;  </div><div class="line">      </div><div class="line">        public static void main(String[] args) &#123;  </div><div class="line">            Thread t1 = new Thread(new T1());  </div><div class="line">            Thread t2 = new Thread(new T2());  </div><div class="line">            t1.start();  </div><div class="line">            t2.start();  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    class T1 implements Runnable &#123;  </div><div class="line">        public void run() &#123;  </div><div class="line">            try &#123;  </div><div class="line">                for(int i=0;i&lt;10;i++)&#123;  </div><div class="line">                    System.out.println(i);  </div><div class="line">                    Thread.sleep(100);  //模拟耗时任务  </div><div class="line">                &#125;  </div><div class="line">            &#125; catch (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    class T2 implements Runnable &#123;  </div><div class="line">        public void run() &#123;  </div><div class="line">            try &#123;  </div><div class="line">                for(int i=0;i&gt;-10;i--)&#123;  </div><div class="line">                    System.out.println(i);  </div><div class="line">                    Thread.sleep(100);  //模拟耗时任务  </div><div class="line">                &#125;  </div><div class="line">            &#125; catch (InterruptedException e) &#123;  </div><div class="line">                e.printStackTrace();  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="5824016-1749f31a5f656db4.png" alt="5824016-1749f31a5f656db4.png"></p>
<p>说明两线程是并发执行的。</p>
<p><strong>用run方法启动线程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Main &#123;  </div><div class="line">      </div><div class="line">        public static void main(String[] args) &#123;  </div><div class="line">            Thread t1 = new Thread(new T1());  </div><div class="line">            Thread t2 = new Thread(new T2());  </div><div class="line">            t1.run();  </div><div class="line">            t2.run();  </div><div class="line">        &#125;  </div><div class="line">      </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><img src="5824016-1c25a05fe0c64ee9.png" alt="5824016-1c25a05fe0c64ee9.png"></p>
<p>说明两线程实际是顺序执行的</p>
<p>总结：<br>通过实例1和实例和我们可以知道start方法是用于启动线程的，可以实现并发，而run方法只是一个普通方法，是不能实现并发的，只是在并发执行的时候会调用。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public synchronized void start() &#123;  </div><div class="line">        // 如果线程不是&quot;就绪状态&quot;，则抛出异常！  </div><div class="line">        if (threadStatus != 0)  </div><div class="line">            throw new IllegalThreadStateException();  </div><div class="line">        // 将线程添加到ThreadGroup中  </div><div class="line">        group.add(this);  </div><div class="line">        boolean started = false;  </div><div class="line">        try &#123;  </div><div class="line">            // 通过start0()启动线程,新线程会调用run()方法  </div><div class="line">            start0();  </div><div class="line">            // 设置started标记=true  </div><div class="line">            started = true;  </div><div class="line">        &#125; finally &#123;  </div><div class="line">            try &#123;  </div><div class="line">                if (!started) &#123;  </div><div class="line">                    group.threadStartFailed(this);  </div><div class="line">                &#125;  </div><div class="line">            &#125; catch (Throwable ignore) &#123;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void run() &#123;  </div><div class="line">    if (target != null) &#123;  </div><div class="line">        target.run();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="真正理解Thread类"><a href="#真正理解Thread类" class="headerlink" title="真正理解Thread类"></a>真正理解Thread类</h2><p>Thread类的对象其实也是一个java对象，只不过每一个Thread类的对象对应着一个线程。Thread类的对象就是提供给用户用于操作线程、获取线程的信息。真正的底层线程用户是看不到的了。<br>因此，当一个线程结束了，死掉了，对应的Thread的对象仍能调用，除了start( )方法外的所有方法（死亡的线程不能再次启动），如run( )、getName( )、getPriority（）等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//简单起见，使用匿名内部类的方法来创建线程</div><div class="line">Thread thread = new Thread()&#123;</div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        System.out.println(&quot;Thread对象的run方法被执行了&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//线程启动</div><div class="line">thread.start();</div><div class="line"></div><div class="line">//用循环去监听线程thread是否还活着，只有当线程thread已经结束了，才跳出循环</div><div class="line">while(thread.isAlive())&#123;&#125;</div><div class="line">//线程thread结束了，但仍能调用thread对象的大部分方法</div><div class="line">System.out.println(&quot;线程&quot;+thread.getName()+&quot;的状态：&quot;+thread.getState()+&quot;---优先级：&quot;+thread.getPriority());</div><div class="line">//调用run方法</div><div class="line">thread.run();</div><div class="line">//当线程结束时，start方法不能调用，下面的方法将会抛出异常</div><div class="line">thread.start();</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://www.jianshu.com/p/88c5cd468b0e" target="_blank" rel="external">https://www.jianshu.com/p/88c5cd468b0e</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-ThreadLocal-设计思想</title>
    <url>/2017/09/22/Java-concurrency-ThreadLocal-%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<p>ThreadLocal 中很多巧妙的设计的讲解，如 ThreadLocal 的 hashCode 算法，ThreadLocalMap 中的 开方地址发 等，探究这些可以更深入理解 ThreadLocal 的设计思想。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ThreadLocal 用一种存储变量与线程绑定的方式，在每个线程中用自己的 ThreadLocalMap 安全隔离变量，为解决多线程程序的并发问题提供了一种新的思路，如为每个线程创建一个独立的数据库连接。因为是线程绑定的，所以在很多场景也被用来实现线程参数传递，如 Spring 的 RequestContextHolder。也因为每个线程拥有自己唯一的 ThreadLocalMap ，所以 ThreadLocalMap 是天然线程安全的。</p>
<h2 id="ThreadLocal-存储结构"><a href="#ThreadLocal-存储结构" class="headerlink" title="ThreadLocal 存储结构"></a>ThreadLocal 存储结构</h2><p>首先我们来聊一聊 ThreadLocal 在多线程运行时，各线程是如何存储变量的，假如我们现在定义两个 ThreadLocal 实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static ThreadLocal&lt;User&gt; threadLocal_1 = new ThreadLocal&lt;&gt;();</div><div class="line">static ThreadLocal&lt;Client&gt; threadLocal_2 = new ThreadLocal&lt;&gt;();</div></pre></td></tr></table></figure>
<p>我们分别在三个线程中使用 ThreadLocal，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// thread-1中</div><div class="line">threadLocal_1.set(user_1);</div><div class="line">threadLocal_2.set(client_1);</div><div class="line"></div><div class="line">// thread-2中</div><div class="line">threadLocal_1.set(user_2);</div><div class="line">threadLocal_2.set(client_2);</div><div class="line"></div><div class="line">// thread-3中</div><div class="line">threadLocal_2 .set(client_3);</div></pre></td></tr></table></figure>
<p>这三个线程都在运行中，那此时各线程中的存数数据应该如下图所示:</p>
<p><img src="WX20190524-1806412x.png" alt="WX20190524-1806412x.png"></p>
<p>每个线程持有自己的 ThreadLocalMap，ThreadLocalMap 初始容量为16（即图中的16个槽位），在调用ThreadLocal 的 set 方法时，将以 ThreadLocal 为 Key 存储在 本线程的 ThreadLocalMap 里面，ThreadLocalMap 的 Value 为Object 类型，实际类型由 ThreadLocal 定义。图没有看懂的不要紧，一步一步往下看其运行原理，再回头看图，会有更清晰的理解。</p>
<h2 id="ThreadLocal-public方法"><a href="#ThreadLocal-public方法" class="headerlink" title="ThreadLocal public方法"></a>ThreadLocal public方法</h2><h3 id="ThreadLocal-之-set-方法"><a href="#ThreadLocal-之-set-方法" class="headerlink" title="ThreadLocal 之 set() 方法"></a>ThreadLocal 之 set() 方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void set(T value) &#123;</div><div class="line">    Thread t = Thread.currentThread(); // 获取当前线程</div><div class="line">    ThreadLocalMap map = getMap(t); // 拿到当前线程的 ThreadLocalMap</div><div class="line">    if (map != null) // 判断 ThreadLocalMap 是否存在</div><div class="line">        map.set(this, value); // 调用 ThreadLocalMap 的 set 方法</div><div class="line">    else</div><div class="line">        createMap(t, value); // 创建 ThreadLocalMap</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次调用时需要 creatMap，创建方式比较简单，不详解。这里重要的还是 ThreadLocalMap 的 set 方法。</p>
<h3 id="ThreadLocal-之-get-方法"><a href="#ThreadLocal-之-get-方法" class="headerlink" title="ThreadLocal 之 get() 方法"></a>ThreadLocal 之 get() 方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this); //调用  ThreadLocalMap 的 getEntry 方法</div><div class="line">        if (e != null) &#123;</div><div class="line">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">            T result = (T)e.value;</div><div class="line">            return result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue(); // 如果还没有设置，可以用子类实现 initialValue ，自定义初始值。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ThreadLocal-之-remove-方法"><a href="#ThreadLocal-之-remove-方法" class="headerlink" title="ThreadLocal 之 remove() 方法"></a>ThreadLocal 之 remove() 方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void remove() &#123;</div><div class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</div><div class="line">    if (m != null)</div><div class="line">        m.remove(this); // 调用 ThreadLocalMap 的 remove方法</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里罗列了 ThreadLocal 的几个public方法，其实所有工作最终都落到了 ThreadLocalMap 的头上，ThreadLocal 仅仅是从当前线程取到 ThreadLocalMap 而已，具体执行，请看下面对 ThreadLocalMap 的分析。</p>
<h2 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h2><h3 id="ThreadLocalMap-简介"><a href="#ThreadLocalMap-简介" class="headerlink" title="ThreadLocalMap 简介"></a>ThreadLocalMap 简介</h3><p>ThreadLocalMap 是ThreadLocal 内部的一个Map实现，然而它并没有实现任何集合的接口规范，因为它仅供内部使用，数据结构采用 数组 + 开方地址法，Entry 继承 WeakReference，是基于 ThreadLocal 这种特殊场景实现的 Map，它的实现方式很值得研究。<br>ThreadLocalMap 的 Entry 定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123;</div><div class="line">    /** The value associated with this ThreadLocal. */</div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal k, Object v) &#123;</div><div class="line">        super(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Entry 继承 WeakReference，以 ThreadLocal 为 key，类似 <a href="https://www.jianshu.com/p/e1b6aefeb807" target="_blank" rel="external">WeakHashMap</a> ，对内存敏感。虽然继承 WeakReference，但只能实现对 Reference 的 key 的回收，而对 value 的回收需要手动解决。value 何时被回收？ 如果没有理解 value 的回收时间，那可能留下内存溢出的隐患。<br>PS：当 map.get() = null 的时候本文中将它称为 <strong>过期</strong>。</p>
<h3 id="ThreadLocalMap-核心方法"><a href="#ThreadLocalMap-核心方法" class="headerlink" title="ThreadLocalMap 核心方法"></a>ThreadLocalMap 核心方法</h3><h4 id="ThreadLocalMap-之-key-的-hashCode-计算"><a href="#ThreadLocalMap-之-key-的-hashCode-计算" class="headerlink" title="ThreadLocalMap 之 key 的 hashCode 计算"></a>ThreadLocalMap 之 key 的 hashCode 计算</h4><p>ThreadLocalMap 的 key 是 ThreadLocal，但它不会传统的调用 ThreadLocal 的 hashCode 方法（继承自Object 的 hashCode），而是调用 nextHashCode() ，具体运算如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private final int threadLocalHashCode = nextHashCode();</div><div class="line"></div><div class="line">private static AtomicInteger nextHashCode = new AtomicInteger();</div><div class="line"></div><div class="line">//1640531527 这是一个神奇的数字，能够让hash槽位分布相当均匀</div><div class="line">private static final int HASH_INCREMENT = 0x61c88647; </div><div class="line"></div><div class="line">private static int nextHashCode() &#123;</div><div class="line">       return nextHashCode.getAndAdd(HASH_INCREMENT);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在 ThreadLocalMap 中 的 hashCode 全部使用 threadLocalHashCode 字段。threadLocalHashCode 用 final 修饰，不可变。threadLocalHashCode 的生成调用 nextHashCode()，所有 ThreadLocalMap 的 hashCode 使用静态的 AtomicInteger 每次增加 1640531527 来产生，对于魔数 1640531527 的工作原理，数学思想比较多，这里写个demo看一下基于这种方式产生的hash分布多均匀：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class ThreadLocalTest &#123;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        printAllSlot(8);</div><div class="line">        printAllSlot(16);</div><div class="line">        printAllSlot(32);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static void printAllSlot(int len) &#123;</div><div class="line">        System.out.println(&quot;********** len = &quot; + len + &quot; ************&quot;);</div><div class="line">        for (int i = 1; i &lt;= 64; i++) &#123;</div><div class="line">            ThreadLocal&lt;String&gt; t = new ThreadLocal&lt;&gt;();</div><div class="line">            int slot = getSlot(t, len);</div><div class="line">            System.out.print(slot + &quot; &quot;);</div><div class="line">            if (i % len == 0)</div><div class="line">                System.out.println(); // 分组换行</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取槽位</div><div class="line">     * </div><div class="line">     * @param t ThreadLocal</div><div class="line">     * @param len 模拟map的table的length</div><div class="line">     * @throws Exception</div><div class="line">     */</div><div class="line">    static int getSlot(ThreadLocal&lt;?&gt; t, int len) &#123;</div><div class="line">        int hash = getHashCode(t);</div><div class="line">        return hash &amp; (len - 1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 反射获取 threadLocalHashCode 字段，因为其为private的</div><div class="line">     */</div><div class="line">    static int getHashCode(ThreadLocal&lt;?&gt; t) &#123;</div><div class="line">        Field field;</div><div class="line">        try &#123;</div><div class="line">            field = t.getClass().getDeclaredField(&quot;threadLocalHashCode&quot;);</div><div class="line">            field.setAccessible(true);</div><div class="line">            return (int) field.get(t);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码模拟了 ThreadLocal 做为 key 的hashCode产生，看看完美槽位分配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">********** len = 8 ************</div><div class="line">2 1 0 7 6 5 4 3 </div><div class="line">2 1 0 7 6 5 4 3 </div><div class="line">2 1 0 7 6 5 4 3 </div><div class="line">2 1 0 7 6 5 4 3 </div><div class="line">2 1 0 7 6 5 4 3 </div><div class="line">2 1 0 7 6 5 4 3 </div><div class="line">2 1 0 7 6 5 4 3 </div><div class="line">2 1 0 7 6 5 4 3 </div><div class="line">********** len = 16 ************</div><div class="line">10 1 8 15 6 13 4 11 2 9 0 7 14 5 12 3 </div><div class="line">10 1 8 15 6 13 4 11 2 9 0 7 14 5 12 3 </div><div class="line">10 1 8 15 6 13 4 11 2 9 0 7 14 5 12 3 </div><div class="line">10 1 8 15 6 13 4 11 2 9 0 7 14 5 12 3 </div><div class="line">********** len = 32 ************</div><div class="line">10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25 0 7 14 21 28 3 </div><div class="line">10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25 0 7 14 21 28 3</div></pre></td></tr></table></figure>
<p>PS：注意 ThreadLocal 的 nextHashCode 是由 static 修饰的，他是一个共享变量，所有的 ThreadLocal 共享一个 AtomicInteger，在其基础上 CAS 增加。</p>
<h4 id="ThreadLocalMap-之-set-方法"><a href="#ThreadLocalMap-之-set-方法" class="headerlink" title="ThreadLocalMap 之 set() 方法"></a>ThreadLocalMap 之 set() 方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class="line"></div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line">    int i = key.threadLocalHashCode &amp; (len-1); // 用key的hashCode计算槽位</div><div class="line">    // hash冲突时，使用开放地址法</div><div class="line">    // 因为独特和hash算法，导致hash冲突很少，一般不会走进这个for循环</div><div class="line">    for (Entry e = tab[i];</div><div class="line">         e != null;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">        if (k == key) &#123; // key 相同，则覆盖value</div><div class="line">            e.value = value; </div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (k == null) &#123; // key = null，说明 key 已经被回收了，进入替换方法</div><div class="line">            replaceStaleEntry(key, value, i);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 新增 Entry</div><div class="line">    tab[i] = new Entry(key, value);</div><div class="line">    int sz = ++size;</div><div class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) // 清除一些过期的值，并判断是否需要扩容</div><div class="line">        rehash(); // 扩容</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个 set 方法涵盖了很多关键点：</p>
<ol>
<li>开放地址法：与我们常用的Map不同，java里大部分Map都是用链表发解决hash冲突的，而 ThreadLocalMap 采用的是开发地址法。</li>
<li>hash算法：hash值算法的精妙之处上面已经讲了，均匀的 hash 算法使其可以很好的配合开方地址法使用；</li>
<li>过期值清理：关于过期值的清理是网上讨论比较多了，因为只要有关于可能内存溢出的话题，就会带来很多噱头和流量。</li>
</ol>
<p><strong>简单介绍一下开放地址法和链表法</strong></p>
<p><strong>开放地址法</strong>：容易产生堆积问题；不适于大规模的数据存储；散列函数的设计对冲突会有很大的影响；插入时可能会出现多次冲突的现象，删除的元素是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂；结点规模很大时会浪费很多空间；</p>
<p><strong>链地址法</strong>：处理冲突简单，且无堆积现象，平均查找长度短；链表中的结点是动态申请的，适合构造表不能确定长度的情况；相对而言，拉链法的指针域可以忽略不计，因此较开放地址法更加节省空间。插入结点应该在链首，删除结点比较方便，只需调整指针而不需要对其他冲突元素作调整。</p>
<p><strong>ThreadLocalMap 为什么采用开放地址法</strong>？<br>个人认为由于 ThreadLocalMap 的 hashCode 的精妙设计，使hash冲突很少，并且 Entry 继承 WeakReference， 很容易被回收，并开方地址可以节省一些指针空间；然而恰恰由于开方地址法的使用，使在处理hash冲突时的代码很难懂，比如在replaceStaleEntry,cleanSomeSlots，expungeStaleEntry 等地方，然而真正调用这些方法的几率却比较小；要把上述方法搞清楚，最好画一画开方地址法发生hash冲突的状态图，容易理解一点，本文不详细探讨。</p>
<p>下面对 set 方法里面的几个关键方法展开：</p>
<p><strong>replaceStaleEntry</strong><br>因为开发地址发的使用，导致 replaceStaleEntry 这个方法有些复杂，它的清理工作会涉及到slot前后的非null的slot。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,</div><div class="line">                               int staleSlot) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line">    Entry e;</div><div class="line"></div><div class="line">    // 往前寻找过期的slot</div><div class="line">    int slotToExpunge = staleSlot;</div><div class="line">    for (int i = prevIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != null;</div><div class="line">         i = prevIndex(i, len))</div><div class="line">        if (e.get() == null)</div><div class="line">            slotToExpunge = i;</div><div class="line"></div><div class="line">    // 找到 key 或者 直到 遇到null 的slot 才终止循环</div><div class="line">    for (int i = nextIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != null;</div><div class="line">         i = nextIndex(i, len)) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">        // 如果找到了key，那么需要将它与过期的 slot 交换来维护哈希表的顺序。</div><div class="line">        // 然后可以将新过期的 slot 或其上面遇到的任何其他过期的 slot </div><div class="line">        // 给 expungeStaleEntry 以清除或 rehash 这个 run 中的所有其他entries。</div><div class="line"></div><div class="line">        if (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line"></div><div class="line">            tab[i] = tab[staleSlot];</div><div class="line">            tab[staleSlot] = e;</div><div class="line"></div><div class="line">            // 如果存在，则开始清除前面过期的entry</div><div class="line">            if (slotToExpunge == staleSlot)</div><div class="line">                slotToExpunge = i;</div><div class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 如果我们没有在向前扫描中找到过期的条目，</div><div class="line">        // 那么在扫描 key 时看到的第一个过期 entry 是仍然存在于 run 中的条目。</div><div class="line">        if (k == null &amp;&amp; slotToExpunge == staleSlot)</div><div class="line">            slotToExpunge = i;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果没有找到 key，那么在 slot 中创建新entry</div><div class="line">    tab[staleSlot].value = null;</div><div class="line">    tab[staleSlot] = new Entry(key, value);</div><div class="line"></div><div class="line">    // 如果还有其他过期的entries存在 run 中，则清除他们</div><div class="line">    if (slotToExpunge != staleSlot)</div><div class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上文中的 run 不好翻译，理解为开放地址中一个slot中前后不为null的连续entry</p>
<p><strong>cleanSomeSlots</strong><br>cleanSomeSlots 清除一些slot（一些？是不是有点模糊，到底是哪些？）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private boolean cleanSomeSlots(int i, int n) &#123;</div><div class="line">    boolean removed = false;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line">    do &#123;</div><div class="line">        i = nextIndex(i, len);</div><div class="line">        Entry e = tab[i];</div><div class="line">        if (e != null &amp;&amp; e.get() == null) &#123;</div><div class="line">            n = len;</div><div class="line">            removed = true;</div><div class="line">            i = expungeStaleEntry(i); // 清除方法 </div><div class="line">        &#125;</div><div class="line">    &#125; while ( (n &gt;&gt;&gt;= 1) != 0);  // n = n / 2， 对数控制循环 </div><div class="line">    return removed;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当新元素被添加时，或者另一个过期元素已被删除时，会调用cleanSomeSlots。该方法会试探性地扫描一些 entry 寻找过期的条目。它执行 对数 数量的扫描，是一种 基于不扫描（快速但保留垃圾）和 所有元素扫描之间的平衡。<br>上面说到的对数数量是多少？循环次数 = log2(N) （log以2为底N的对数），此处N是map的size，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">log2（4） =  2</div><div class="line">log2（5） =  2</div><div class="line">log2（18） =  4</div></pre></td></tr></table></figure></p>
<p>因此，此方法并没有真正的清除，只是找到了要清除的位置，而真正的清除在 expungeStaleEntry(int staleSlot) 里面</p>
<p><strong>expungeStaleEntry(int staleSlot)</strong><br>这里是真正的清除，并且不要被方法名迷惑，不仅仅会清除当前过期的slot，还回往后查找直到遇到null的slot为止。开发地址法的清除也较难理解，清除当前slot后还有往后进行rehash。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private int expungeStaleEntry(int staleSlot) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line"></div><div class="line">    // 清除当前过期的slot</div><div class="line">    tab[staleSlot].value = null;</div><div class="line">    tab[staleSlot] = null;</div><div class="line">    size--;</div><div class="line"></div><div class="line">    // Rehash 直到 null 的 slot</div><div class="line">    Entry e;</div><div class="line">    int i;</div><div class="line">    for (i = nextIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != null;</div><div class="line">         i = nextIndex(i, len)) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        if (k == null) &#123;</div><div class="line">            e.value = null;</div><div class="line">            tab[i] = null;</div><div class="line">            size--;</div><div class="line">        &#125; else &#123;</div><div class="line">            int h = k.threadLocalHashCode &amp; (len - 1);</div><div class="line">            if (h != i) &#123;</div><div class="line">                tab[i] = null;</div><div class="line"></div><div class="line">                while (tab[h] != null)</div><div class="line">                    h = nextIndex(h, len);</div><div class="line">                tab[h] = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ThreadLocalMap-之-getEntry-方法"><a href="#ThreadLocalMap-之-getEntry-方法" class="headerlink" title="ThreadLocalMap 之 getEntry() 方法"></a>ThreadLocalMap 之 getEntry() 方法</h4><p>getEntry() 主要是在 ThreadLocal 的 get() 方法里被调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123;</div><div class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</div><div class="line">    Entry e = table[i];</div><div class="line">    if (e != null &amp;&amp; e.get() == key) // 无hash冲突情况</div><div class="line">        return e;</div><div class="line">    else</div><div class="line">        return getEntryAfterMiss(key, i, e); // 有hash冲突情况</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法比较简洁，首先运算槽位 i ，然后判断  table[i] 是否是目标entry，不是则进入 getEntryAfterMiss(key, i, e)；<br>下面展开 getEntryAfterMiss 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line"></div><div class="line">    while (e != null) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">        if (k == key)</div><div class="line">            return e;</div><div class="line">        if (k == null)</div><div class="line">            expungeStaleEntry(i); // 此方法上面已经讲过了</div><div class="line">        else</div><div class="line">            i = nextIndex(i, len);</div><div class="line">        e = tab[i];</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法是在遇到 hash 冲突时往后继续查找，并且会清除查找路上遇到的过期slot。</p>
<h4 id="ThreadLocalMap-之-rehash-方法"><a href="#ThreadLocalMap-之-rehash-方法" class="headerlink" title="ThreadLocalMap 之 rehash() 方法"></a>ThreadLocalMap 之 rehash() 方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private void rehash() &#123;</div><div class="line">    expungeStaleEntries();</div><div class="line"></div><div class="line">   // 在上面的清除过程中，size会减小，在此处重新计算是否需要扩容</div><div class="line">   // 并没有直接使用threshold，而是用较低的threshold （约 threshold 的 3/4）提前触发resize</div><div class="line">    if (size &gt;= threshold - threshold / 4)</div><div class="line">        resize();</div><div class="line">&#125;</div><div class="line"></div><div class="line">private void expungeStaleEntries() &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line">    for (int j = 0; j &lt; len; j++) &#123;</div><div class="line">        Entry e = tab[j];</div><div class="line">        if (e != null &amp;&amp; e.get() == null)</div><div class="line">            expungeStaleEntry(j);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>rehash() 里首先调用 expungeStaleEntries()，然后循环调用 expungeStaleEntry(j) ,此方法会清除所有过期的slot。<br>继续看 resize()：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private void resize() &#123;</div><div class="line">    Entry[] oldTab = table;</div><div class="line">    int oldLen = oldTab.length;</div><div class="line">    int newLen = oldLen * 2;</div><div class="line">    Entry[] newTab = new Entry[newLen];</div><div class="line">    int count = 0;</div><div class="line"></div><div class="line">    for (int j = 0; j &lt; oldLen; ++j) &#123;</div><div class="line">        Entry e = oldTab[j];</div><div class="line">        if (e != null) &#123;</div><div class="line">            ThreadLocal&lt;?&gt; k = e.get();</div><div class="line">            if (k == null) &#123;</div><div class="line">                e.value = null; // Help the GC</div><div class="line">            &#125; else &#123;</div><div class="line">                int h = k.threadLocalHashCode &amp; (newLen - 1);</div><div class="line">                while (newTab[h] != null)</div><div class="line">                    h = nextIndex(h, newLen);</div><div class="line">                newTab[h] = e;</div><div class="line">                count++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setThreshold(newLen);</div><div class="line">    size = count;</div><div class="line">    table = newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>resize() 方法里也会过滤掉一些 过期的 entry。</p>
<p>PS :ThreadLocalMap 没有 影响因子 的字段，是采用直接设置 threshold 的方式，threshold = len * 2 / 3，相当于不可修改的影响因子为 2/3，比 HashMap 的默认 0.75 要低。这也是减少hash冲突的方式。</p>
<h4 id="ThreadLocalMap-之-remove-key-方法"><a href="#ThreadLocalMap-之-remove-key-方法" class="headerlink" title="ThreadLocalMap 之 remove(key) 方法"></a>ThreadLocalMap 之 remove(key) 方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private void remove(ThreadLocal&lt;?&gt; key) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line">    int i = key.threadLocalHashCode &amp; (len-1);</div><div class="line">    for (Entry e = tab[i];</div><div class="line">         e != null;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        if (e.get() == key) &#123;</div><div class="line">            e.clear();</div><div class="line">            expungeStaleEntry(i);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>remove 方法是删除特定的 ThreadLocal，建议在 ThreadLocal 使用完后执行此方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="ThreadLocalMap-的-value-清理触发时间："><a href="#ThreadLocalMap-的-value-清理触发时间：" class="headerlink" title="ThreadLocalMap 的 value 清理触发时间："></a>ThreadLocalMap 的 value 清理触发时间：</h3><ol>
<li>set(ThreadLocal&lt;?&gt; key, Object value)<br>若无hash冲突，则先向后检测log2(N)个位置，发现过期 slot 则清除，如果没有任何 slot 被清除，则判断 size &gt;= threshold，超过阀值会进行 rehash()，rehash()会清除所有过期的value；</li>
<li>getEntry(ThreadLocal&lt;?&gt; key)  (ThreadLocal 的 get() 方法调用)<br>如果没有直接在hash计算的 slot 中找到entry， 则需要向后继续查找(直到null为止)，查找期间发现的过期 slot 会被清除；</li>
<li>remove(ThreadLocal&lt;?&gt; key)<br>remove 不仅会清除需要清除的 key，还是清除hash冲突的位置的已过期的 key；</li>
</ol>
<p>清晰了以上过程，相信对于 ThreadLocal 的 内存溢出问题会有自己的看法。在实际开发中，不应乱用 ThreadLocal ，如果使用 ThreadLocal 发生了内存溢出，那应该考虑是否使用合理。<br>PS：这里的清除并不代表被回收，只是把 value 置为 null，value 的具体回收时间由 垃圾收集器 决定。</p>
<h3 id="ThreadLocalMap-的-hash-算法和-开方地址法"><a href="#ThreadLocalMap-的-hash-算法和-开方地址法" class="headerlink" title="ThreadLocalMap 的 hash 算法和 开方地址法"></a>ThreadLocalMap 的 hash 算法和 开方地址法</h3><p>由于 ThreadLocal 在每个 Thread 里面的唯一性和特殊性，为其定制了特殊的 hashCode 生成方式，能够很好的散列在 table 中，有效的减少hash冲突。<br>基于较少的hash冲突，于是采用了开放地址法，开放地址法在没有hash冲突的时候很好理解，在发生冲突时的代码就有些绕。因此理解 ThreadLocalMap 的新增、删除、查找、清除等操作，需要对开方地址法的hash冲突处理有较清晰的思路，最好在手边画一画开放地址法的hash冲突情况，目前没有在网上找的很好的讲解，争取在后续文章补充。</p>
<p>ref:<br><a href="https://www.jianshu.com/p/56f64e3c1b6c" target="_blank" rel="external">https://www.jianshu.com/p/56f64e3c1b6c</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-ThreadLocal</title>
    <url>/2017/09/22/Java-concurrency-ThreadLocal/</url>
    <content><![CDATA[<p>本文为 ThreadLocal 整理和总结</p>
<a id="more"></a>
<h2 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h2><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>下图为ThreadLocal的内部结构图<br><img src="WX20190524-1701152x.png" alt="WX20190524-1701152x.png"></p>
<p>从上面的结构图，我们已经窥见ThreadLocal的核心机制：</p>
<ul>
<li>每个Thread线程内部都有一个Map(ThreadLocalMap)。</li>
<li>Map里面存储线程本地对象（key(threadlocal)）和线程的变量副本（value）</li>
<li>但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</li>
</ul>
<p>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。<br>Thread线程内部的Map在类中描述如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Thread implements Runnable &#123;</div><div class="line">    /* ThreadLocal values pertaining to this thread. This map is maintained</div><div class="line">     * by the ThreadLocal class. */</div><div class="line">    ThreadLocal.ThreadLocalMap threadLocals = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="深入解析ThreadLocal"><a href="#深入解析ThreadLocal" class="headerlink" title="深入解析ThreadLocal"></a>深入解析ThreadLocal</h2><p>ThreadLocal类提供如下几个核心方法：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public T get()</div><div class="line">public void set(T value)</div><div class="line">public void remove()</div></pre></td></tr></table></figure></p>
<ul>
<li>get()方法用于获取当前线程的副本变量值。</li>
<li>set()方法用于保存当前线程的副本变量值。</li>
<li>initialValue()为当前线程初始副本变量值。</li>
<li>remove()方法移除当前前程的副本变量值。</li>
</ul>
<h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Returns the value in the current thread&apos;s copy of this</div><div class="line"> * thread-local variable.  If the variable has no value for the</div><div class="line"> * current thread, it is first initialized to the value returned</div><div class="line"> * by an invocation of the &#123;@link #initialValue&#125; method.</div><div class="line"> *</div><div class="line"> * @return the current thread&apos;s value of this thread-local</div><div class="line"> */</div><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">        if (e != null)</div><div class="line">            return (T)e.value;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line">ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">    return t.threadLocals;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private T setInitialValue() &#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">    return value;</div><div class="line">&#125;</div><div class="line"></div><div class="line">protected T initialValue() &#123;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>步骤：</p>
<ol>
<li>获取当前线程的ThreadLocalMap对象threadLocals</li>
<li>从map中获取线程存储的K-V Entry节点。</li>
<li>从Entry节点获取存储的Value副本值返回。</li>
<li>map为空的话返回初始值null，即线程变量副本为null，在使用时需要注意判断NullPointerException。</li>
</ol>
<h3 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Sets the current thread&apos;s copy of this thread-local variable</div><div class="line"> * to the specified value.  Most subclasses will have no need to</div><div class="line"> * override this method, relying solely on the &#123;@link #initialValue&#125;</div><div class="line"> * method to set the values of thread-locals.</div><div class="line"> *</div><div class="line"> * @param value the value to be stored in the current thread&apos;s copy of</div><div class="line"> *        this thread-local.</div><div class="line"> */</div><div class="line">public void set(T value) &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null)</div><div class="line">        map.set(this, value);</div><div class="line">    else</div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">    return t.threadLocals;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void createMap(Thread t, T firstValue) &#123;</div><div class="line">    t.threadLocals = new ThreadLocalMap(this, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>步骤：</p>
<ol>
<li>获取当前线程的成员变量map</li>
<li>map非空，则重新将ThreadLocal和新的value副本放入到map中。</li>
<li>map空，则对线程的成员变量ThreadLocalMap进行初始化创建，并将ThreadLocal和value副本放入map中。</li>
</ol>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Removes the current thread&apos;s value for this thread-local</div><div class="line"> * variable.  If this thread-local variable is subsequently</div><div class="line"> * &#123;@linkplain #get read&#125; by the current thread, its value will be</div><div class="line"> * reinitialized by invoking its &#123;@link #initialValue&#125; method,</div><div class="line"> * unless its value is &#123;@linkplain #set set&#125; by the current thread</div><div class="line"> * in the interim.  This may result in multiple invocations of the</div><div class="line"> * &lt;tt&gt;initialValue&lt;/tt&gt; method in the current thread.</div><div class="line"> *</div><div class="line"> * @since 1.5</div><div class="line"> */</div><div class="line">public void remove() &#123;</div><div class="line"> ThreadLocalMap m = getMap(Thread.currentThread());</div><div class="line"> if (m != null)</div><div class="line">     m.remove(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ThreadLocalMap getMap(Thread t) &#123;</div><div class="line">    return t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>remove方法比较简单，不做赘述。</p>
<p>ThreadLocalMap贯穿始终, 那每个线程中的ThreadLoalMap究竟是什么?</p>
<h2 id="ThreadLoalMap"><a href="#ThreadLoalMap" class="headerlink" title="ThreadLoalMap"></a>ThreadLoalMap</h2><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。</p>
<p><img src="WX20190524-1714532x.png" alt="WX20190524-1714532x.png"></p>
<p>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static class Entry extends WeakReference&lt;ThreadLocal&gt; &#123;</div><div class="line">    /** The value associated with this ThreadLocal. */</div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal k, Object v) &#123;</div><div class="line">        super(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。</p>
<p>ThreadLocalMap的成员变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static class ThreadLocalMap &#123;</div><div class="line">    /**</div><div class="line">     * The initial capacity -- MUST be a power of two.</div><div class="line">     */</div><div class="line">    private static final int INITIAL_CAPACITY = 16;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The table, resized as necessary.</div><div class="line">     * table.length MUST always be a power of two.</div><div class="line">     */</div><div class="line">    private Entry[] table;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The number of entries in the table.</div><div class="line">     */</div><div class="line">    private int size = 0;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * The next size value at which to resize.</div><div class="line">     */</div><div class="line">    private int threshold; // Default to 0</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="hash冲突"><a href="#hash冲突" class="headerlink" title="hash冲突"></a>hash冲突</h2><p>先看看ThreadLoalMap中插入一个key-value的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line">    int i = key.threadLocalHashCode &amp; (len-1);</div><div class="line"></div><div class="line">    for (Entry e = tab[i];</div><div class="line">         e != null;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        ThreadLocal&lt;?&gt; k = e.get();</div><div class="line"></div><div class="line">        if (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (k == null) &#123;</div><div class="line">            replaceStaleEntry(key, value, i);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tab[i] = new Entry(key, value);</div><div class="line">    int sz = ++size;</div><div class="line">    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">        rehash();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。</p>
<p>ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Increment i modulo len.</div><div class="line"> */</div><div class="line">private static int nextIndex(int i, int len) &#123;</div><div class="line">    return ((i + 1 &lt; len) ? i + 1 : 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Decrement i modulo len.</div><div class="line"> */</div><div class="line">private static int prevIndex(int i, int len) &#123;</div><div class="line">    return ((i - 1 &gt;= 0) ? i - 1 : len - 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然ThreadLocalMap采用线性探测的方式解决Hash冲突的效率很低，如果有大量不同的ThreadLocal对象放入map中时发送冲突，或者发生二次冲突，则效率很低。</p>
<p><strong>所以这里引出的良好建议是：每个线程只存一个变量，这样的话所有的线程存放到map中的Key都是相同的ThreadLocal，如果一个线程要保存多个变量，就需要创建多个ThreadLocal，多个ThreadLocal放入Map中时会极大的增加Hash冲突的可能。</strong></p>
<h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>先看看Entry的实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</div><div class="line">    /** The value associated with this ThreadLocal. */</div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</div><div class="line">        super(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看图</p>
<p><img src="WX20190524-1737182x.png" alt="WX20190524-1737182x.png"></p>
<p>由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p>
<p>ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的，因此如果ThreadLocal没有外部强引用来引用它，那么ThreadLocal会在下次JVM垃圾收集时被回收。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取ThreadLocalMap中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长，一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：Thread –》 ThreadLocalMap –》 Entry –》 Value，这条强引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。<br>但是JVM团队已经考虑到这样的情况，并做了一些措施来保证ThreadLocal尽量不会内存泄漏：在ThreadLocal的get()、set()、remove()方法调用的时候会清除掉线程ThreadLocalMap中所有Entry中Key为null的Value，并将整个Entry设置为null，利于下次内存回收。</p>
<p>再次看ThreadLocal的get()方法底层实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public T get() &#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    if (map != null) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(this);</div><div class="line">        if (e != null)</div><div class="line">            return (T)e.value;</div><div class="line">    &#125;</div><div class="line">    return setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在调用map.getEntry(this)时，内部会判断key是否为null，继续看map.getEntry(this)源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private Entry getEntry(ThreadLocal key) </div><div class="line">    int i = key.threadLocalHashCode &amp; (table.length - 1);</div><div class="line">    Entry e = table[i];</div><div class="line">    if (e != null &amp;&amp; e.get() == key)</div><div class="line">        return e;</div><div class="line">    else</div><div class="line">        return getEntryAfterMiss(key, i, e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在getEntry方法中，如果Entry中的key发现是null，会继续调用getEntryAfterMiss(key, i, e)方法，其内部回做回收必要的设置，继续看内部源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line"></div><div class="line">    while (e != null) &#123;</div><div class="line">        ThreadLocal k = e.get();</div><div class="line">        if (k == key)</div><div class="line">            return e;</div><div class="line">        if (k == null)</div><div class="line">            expungeStaleEntry(i);</div><div class="line">        else</div><div class="line">            i = nextIndex(i, len);</div><div class="line">        e = tab[i];</div><div class="line">    &#125;</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意k == null这里，继续调用了expungeStaleEntry(i)方法，expunge的意思是擦除，删除的意思，见名知意，在来看expungeStaleEntry方法的内部实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private int expungeStaleEntry(int staleSlot) &#123;</div><div class="line">    Entry[] tab = table;</div><div class="line">    int len = tab.length;</div><div class="line"></div><div class="line">    // expunge entry at staleSlot（意思是，删除value，设置为null便于下次回收）</div><div class="line">    tab[staleSlot].value = null;</div><div class="line">    tab[staleSlot] = null;</div><div class="line">    size--;</div><div class="line"></div><div class="line">    // Rehash until we encounter null</div><div class="line">    Entry e;</div><div class="line">    int i;</div><div class="line">    for (i = nextIndex(staleSlot, len);</div><div class="line">         (e = tab[i]) != null;</div><div class="line">         i = nextIndex(i, len)) &#123;</div><div class="line">        ThreadLocal k = e.get();</div><div class="line">        if (k == null) &#123;</div><div class="line">            e.value = null;</div><div class="line">            tab[i] = null;</div><div class="line">            size--;</div><div class="line">        &#125; else &#123;</div><div class="line">            int h = k.threadLocalHashCode &amp; (len - 1);</div><div class="line">            if (h != i) &#123;</div><div class="line">                tab[i] = null;</div><div class="line"></div><div class="line">                // Unlike Knuth 6.4 Algorithm R, we must scan until</div><div class="line">                // null because multiple entries could have been stale.</div><div class="line">                while (tab[h] != null)</div><div class="line">                    h = nextIndex(h, len);</div><div class="line">                tab[h] = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意这里，将当前Entry删除后，会继续循环往下检查是否有key为null的节点，如果有则一并删除，防止内存泄漏。<br>但这样也并不能保证ThreadLocal不会发生内存泄漏，例如：</p>
<ul>
<li>使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。</li>
<li>分配使用了ThreadLocal又不再调用get()、set()、remove()方法，那么就会导致内存泄漏。</li>
</ul>
<h3 id="why-弱引用"><a href="#why-弱引用" class="headerlink" title="why 弱引用"></a>why 弱引用</h3><p>从表面上看，发生内存泄漏，是因为Key使用了弱引用类型。但其实是因为整个Entry的key为null后，没有主动清除value导致。很多文章大多分析ThreadLocal使用了弱引用会导致内存泄漏，但为什么使用弱引用而不是强引用？</p>
<p>官方文档的说法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.</div><div class="line">为了处理非常大和生命周期非常长的线程，哈希表使用弱引用作为 key。</div></pre></td></tr></table></figure>
<p>下面我们分两种情况讨论：</p>
<ul>
<li>key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</li>
<li>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set,get，remove的时候会被清除。<br>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set,get,remove的时候会被清除。</li>
</ul>
<p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key的value就会导致内存泄漏，而不是因为弱引用。</p>
<h3 id="如何避免内存泄露"><a href="#如何避免内存泄露" class="headerlink" title="如何避免内存泄露"></a>如何避免内存泄露</h3><p>综合上面的分析，我们可以理解ThreadLocal内存泄漏的前因后果，那么怎么避免内存泄漏呢？</p>
<p>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</p>
<p><strong>在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题</strong>(由于ThreadLocal是以当前线程为key，所以如果前后有两条请求发到后台，并且这两条请求都是使用的线程池里面的同一个线程, 若不清理则之前请求的数据还在ThreadLocal中,则会出现业务逻辑问题)。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ThreadLocal&lt;Session&gt; threadLocal = new ThreadLocal&lt;Session&gt;();</div><div class="line">try &#123;</div><div class="line">    threadLocal.set(new Session(1, &quot;Misout的博客&quot;));</div><div class="line">    // 其它业务逻辑</div><div class="line">&#125; finally &#123;</div><div class="line">    threadLocal.remove();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>还记得Hibernate的session获取场景吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private static final ThreadLocal&lt;Session&gt; threadLocal = new ThreadLocal&lt;Session&gt;();</div><div class="line"></div><div class="line">//获取Session</div><div class="line">public static Session getCurrentSession()&#123;</div><div class="line">    Session session =  threadLocal.get();</div><div class="line">    //判断Session是否为空，如果为空，将创建一个session，并设置到本地线程变量中</div><div class="line">    try &#123;</div><div class="line">        if(session ==null&amp;&amp;!session.isOpen())&#123;</div><div class="line">            if(sessionFactory==null)&#123;</div><div class="line">                rbuildSessionFactory();// 创建Hibernate的SessionFactory</div><div class="line">            &#125;else&#123;</div><div class="line">                session = sessionFactory.openSession();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        threadLocal.set(session);</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        // TODO: handle exception</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return session;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么？每个线程访问数据库都应当是一个独立的Session会话，如果多个线程共享同一个Session会话，有可能其他线程关闭连接了，当前线程再执行提交时就会出现会话已关闭的异常，导致系统异常。此方式能避免线程争抢Session，提高并发下的安全性。<br>使用ThreadLocal的典型场景正如上面的数据库连接管理，线程会话管理等场景，只适用于独立变量副本的情况，如果变量为全局共享的，则不适用在高并发下使用。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。</li>
<li>ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。</li>
<li>适用于无状态，副本变量独立后不影响业务逻辑的高并发场景。如果如果业务逻辑强依赖于副本变量，则不适合用ThreadLocal解决，需要另寻解决方案。</li>
</ul>
<p>ref:<br><a href="https://www.jianshu.com/p/98b68c97df9b" target="_blank" rel="external">https://www.jianshu.com/p/98b68c97df9b</a><br><a href="https://www.jianshu.com/p/a1cd61fa22da" target="_blank" rel="external">https://www.jianshu.com/p/a1cd61fa22da</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-TreiberStack无锁并发</title>
    <url>/2017/09/22/Java-concurrency-TreiberStack%E6%97%A0%E9%94%81%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<p>并发访问的安全性通常有Lock（同步）或者CAS方式实现，其中CAS是无锁（lock-free）并发的基础理念；本文主要简述一下通过Treiber Stack（1986，R.Kent Treiber）实现一个无锁并发栈，其主要思想就是使用CAS原子性的操作栈顶（或者栈底，单端队列），根据其思想，我们可以创造出更多有意义的实现。</p>
<a id="more"></a>
<p>其中在JAVA中，FutureTask.WaitNode是典型的Treiber Stack实现；此外，Fork/Join框架中WorkQueue的实现中借鉴了此思想。</p>
<p>我们展示一下，Treiber Stack的典型示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import java.util.concurrent.atomic.AtomicReference;  </div><div class="line">  </div><div class="line">/** </div><div class="line"> * 一个基于CAS实现的无锁（lock-free）并发栈 </div><div class="line"> **/  </div><div class="line">public class TreiberStack &lt;E&gt; &#123;  </div><div class="line">    private AtomicReference&lt;Node&lt;E&gt;&gt; top = new AtomicReference&lt;Node&lt;E&gt;&gt;();  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 添加到栈顶 </div><div class="line">     * @param item </div><div class="line">     */  </div><div class="line">    public void push(E item) &#123;  </div><div class="line">        Node&lt;E&gt; header = new Node&lt;E&gt;(item);  </div><div class="line">        Node&lt;E&gt; currentHead;  </div><div class="line">        do &#123;  </div><div class="line">            currentHead = top.get();  </div><div class="line">            header.next = currentHead;  </div><div class="line">        &#125; while (!top.compareAndSet(currentHead, header));  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    /** </div><div class="line">     * 弹出栈顶 </div><div class="line">     * @return </div><div class="line">     */  </div><div class="line">    public E pop() &#123;  </div><div class="line">        Node&lt;E&gt; currentHead;  </div><div class="line">        Node&lt;E&gt; header;  </div><div class="line">        do &#123;  </div><div class="line">            currentHead = top.get();  </div><div class="line">            if (currentHead == null)  </div><div class="line">                return null;  </div><div class="line">            header = currentHead.next;  </div><div class="line">        &#125; while (!top.compareAndSet(currentHead, header));  </div><div class="line">        return currentHead.item;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    private static class Node &lt;E&gt; &#123;  </div><div class="line">        public final E item;  </div><div class="line">        public Node&lt;E&gt; next;  </div><div class="line">  </div><div class="line">        public Node(E item) &#123;  </div><div class="line">            this.item = item;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>谈到CAS，我们绕不开ABA的问题，如果你能够预测ABA发生的概率较低或者ABA发生时并不会对数据结果产生错误，我们可以认为ABA是无害的。其实面对ABA问题时，如果考虑性能开销，我们也没有特别有效的解决办法</p>
<p>ref:<br><a href="https://shift-alt-ctrl.iteye.com/blog/2432169" target="_blank" rel="external">https://shift-alt-ctrl.iteye.com/blog/2432169</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
        <tag>TreiberStack</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-list</title>
    <url>/2017/09/22/Java-concurrency-list/</url>
    <content><![CDATA[<p>下次面试官问你线程安全的 List，你可以从 Vector &gt; SynchronizedList &gt; CopyOnWriteArrayList 这样的顺序依次说上来，这样才有带入感，也能体现你对知识点的掌握程度。</p>
<a id="more"></a>
<h2 id="java-util-Collections-SynchronizedList"><a href="#java-util-Collections-SynchronizedList" class="headerlink" title="java.util.Collections.SynchronizedList"></a>java.util.Collections.SynchronizedList</h2><p>它能把所有 List 接口的实现类转换成线程安全的List，比 Vector 有更好的扩展性和兼容性，SynchronizedList的构造方法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">final List&lt;E&gt; list;</div><div class="line"></div><div class="line">SynchronizedList(List&lt;E&gt; list) &#123;</div><div class="line">    super(list);</div><div class="line">    this.list = list;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SynchronizedList的部分方法源码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line">    synchronized (mutex) &#123;return list.get(index);&#125;</div><div class="line">&#125;</div><div class="line">public E set(int index, E element) &#123;</div><div class="line">    synchronized (mutex) &#123;return list.set(index, element);&#125;</div><div class="line">&#125;</div><div class="line">public void add(int index, E element) &#123;</div><div class="line">    synchronized (mutex) &#123;list.add(index, element);&#125;</div><div class="line">&#125;</div><div class="line">public E remove(int index) &#123;</div><div class="line">    synchronized (mutex) &#123;return list.remove(index);&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很可惜，它所有方法都是带同步对象锁的，和 Vector 一样，它不是性能最优的。即使你能说到这里，面试官还会继续往下追问，比如在读多写少的情况，SynchronizedList这种集合性能非常差，还有没有更合适的方案？</p>
<h2 id="CopyOnWrite集合类"><a href="#CopyOnWrite集合类" class="headerlink" title="CopyOnWrite集合类"></a>CopyOnWrite集合类</h2><p>CopyOnWrite集合类也就这两个，Java 1.5 开始加入<br>java.util.concurrent.CopyOnWriteArrayList<br>java.util.concurrent.CopyOnWriteArraySet</p>
<h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWrite（简称：COW）：即复制再写入，就是在添加元素的时候，先把原 List 列表复制一份，再添加新的元素。</p>
<p>先来看下它的 add 方法源码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line">    // 加锁</div><div class="line">    final ReentrantLock lock = this.lock;</div><div class="line">    lock.lock();</div><div class="line">    try &#123;</div><div class="line">        // 获取原始集合</div><div class="line">        Object[] elements = getArray();</div><div class="line">        int len = elements.length;</div><div class="line"></div><div class="line">        // 复制一个新集合</div><div class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</div><div class="line">        newElements[len] = e;</div><div class="line"></div><div class="line">        // 替换原始集合为新集合</div><div class="line">        setArray(newElements);</div><div class="line">        return true;</div><div class="line">    &#125; finally &#123;</div><div class="line">        // 释放锁</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>添加元素时，先加锁，再进行复制替换操作，最后再释放锁。</p>
<p>再来看下它的 get 方法源码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private E get(Object[] a, int index) &#123;</div><div class="line">    return (E) a[index];</div><div class="line">&#125;</div><div class="line"></div><div class="line">public E get(int index) &#123;</div><div class="line">    return get(getArray(), index);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，获取元素并没有加锁。<br>这样做的好处是，在高并发情况下，读取元素时就不用加锁，写数据时才加锁，大大提升了读取性能</p>
<h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>CopyOnWriteArraySet逻辑就更简单了，就是使用 CopyOnWriteArrayList 的 addIfAbsent 方法来去重的，添加元素的时候判断对象是否已经存在，不存在才添加进集合<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Appends the element, if not present.</div><div class="line"> *</div><div class="line"> * @param e element to be added to this list, if absent</div><div class="line"> * @return &#123;@code true&#125; if the element was added</div><div class="line"> */</div><div class="line">public boolean addIfAbsent(E e) &#123;</div><div class="line">    Object[] snapshot = getArray();</div><div class="line">    return indexOf(e, snapshot, 0, snapshot.length) &gt;= 0 ? false :</div><div class="line">        addIfAbsent(e, snapshot);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这两种并发集合，虽然牛逼，但只适合于读多写少的情况，如果写多读少，使用这个就没意义了，因为每次写操作都要进行集合内存复制，性能开销很大，如果集合较大，很容易造成内存溢出。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-volatile</title>
    <url>/2017/09/22/Java-concurrency-volatile/</url>
    <content><![CDATA[<p>volatile两大作用</p>
<ul>
<li>保证内存可见性</li>
<li>防止指令重排</li>
</ul>
<p>此外需注意volatile并不保证操作的原子性。</p>
<a id="more"></a>
<h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>JVM内存模型:主内存和线程独立的工作内存</strong></p>
<p>Java内存模型规定,对于多个线程共享的变量,存储在主内存当中,每个线程都有自己独立的工作内存(比如CPU的寄存器),线程只能访问自己的工作内存,不可以访问其它线程的工作内存。</p>
<p>工作内存中保存了主内存共享变量的副本,线程要操作这些共享变量,只能通过操作工作内存中的副本来实现,操作完毕之后再同步回到主内存当中。</p>
<p>如何保证多个线程操作主内存的数据完整性是一个难题,Java内存模型也规定了工作内存与主内存之间交互的协议,定义了8种原子操作:</p>
<ol>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ol>
<p><strong>通过上面Java内存模型的概述,我们会注意到这么一个问题,每个线程在获取锁之后会在自己的工作内存来操作共享变量,操作完成之后将工作内存中的副本回写到主内存,并且在其它线程从主内存将变量同步回自己的工作内存之前,共享变量的改变对其是不可见的</strong>。其他线程的本地内存中的变量已经是过时的,并不是更新后的值。</p>
<h3 id="内存可见性带来的问题"><a href="#内存可见性带来的问题" class="headerlink" title="内存可见性带来的问题"></a>内存可见性带来的问题</h3><p>很多时候我们需要一个线程对共享变量的改动,其它线程也需要立即得知这个改动该怎么办呢？下面举两个例子说明内存可见性的重要性:</p>
<p>例子1<br>有一个全局的状态变量open:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">boolean</span> open=<span class="keyword">true</span>;</div></pre></td></tr></table></figure></p>
<p>这个变量用来描述对一个资源的打开关闭状态,true表示打开,false表示关闭,假设有一个线程A,在执行一些操作后将open修改为false:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//线程A</span></div><div class="line">resource.close();</div><div class="line">open = <span class="keyword">false</span>;</div></pre></td></tr></table></figure></p>
<p>线程B随时关注open的状态,当open为true的时候通过访问资源来进行一些操作:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//线程B</span></div><div class="line"><span class="keyword">while</span>(open) &#123;</div><div class="line">    doSomethingWithResource(resource);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当A把资源关闭的时候,open变量对线程B是不可见的,如果此时open变量的改动尚未同步到线程B的工作内存中,那么线程B就会用一个已经关闭了的资源去做一些操作,因此产生错误。</p>
<p>例子2<br>下面是一个通过布尔标志判断线程是否结束的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelThreadTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        PrimeGenerator gen = <span class="keyword">new</span> PrimeGenerator();</div><div class="line">        newThread(gen).start();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">           Thread.sleep(<span class="number">3000</span>);</div><div class="line">        &#125;<span class="keyword">finally</span>&#123;</div><div class="line">           gen.cancel();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> cancelled;     </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(!cancelled) &#123;</div><div class="line">           System.out.println(<span class="string">"Running..."</span>);</div><div class="line">           <span class="comment">//doingsomething here...</span></div><div class="line">        &#125;         </div><div class="line">    &#125;      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;cancelled = <span class="keyword">true</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主线程中设置PrimeGenerator线程的是否取消标识,PrimeGenerator线程检测到这个标识后就会结束线程,由于主线程修改cancelled变量的内存可见性,主线程修改cancelled标识后并不马上同步回主内存,所以PrimeGenerator线程结束的时间难以把控(最终是一定会同步回主内存,让PrimeGenerator线程结束)。</p>
<p>如果PrimeGenerator线程执行一些比较关键的操作,主线程希望能够及时终止它,这时将cenceled用volatile关键字修饰就是必要的。</p>
<p><strong>特别注意:上面演示这个并不是正确的取消线程的方法,因为一旦PrimeGenerator线程中包含BolckingQueue.put()等阻塞方法,那么将可能永远不会去检查cancelled标识,导致线程永远不会退出。正确的方法参见另外一篇关于如何正确终止线程的方法。</strong></p>
<h3 id="提供内存可见性"><a href="#提供内存可见性" class="headerlink" title="提供内存可见性"></a>提供内存可见性</h3><p>volatile保证可见性的原理是在每次访问变量时都会进行一次刷新,因此每次访问都是主内存中最新的版本。所以volatile关键字的作用之一就是保证变量修改的实时可见性。</p>
<p>针对上面的例子1:<br>要求一个线程对open的改变,其他的线程能够立即可见,Java为此提供了volatile关键字,在声明open变量的时候加入volatile关键字就可以保证open的内存可见性,即open的改变对所有的线程都是立即可见的。<br>备注:也可以通过提供synchronized同步的open变量的Get/Set方法解决此内存可见性问题,因为要Get变量open,必须等Set方完全释放锁之后。后面将介绍到两者的区别。</p>
<p>针对上面的例子2:<br>将cancelled标志设置的volatile保证主线程针对cancelled标识的修改能够让PrimeGenerator线程立马看到。</p>
<h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>指令重排序是JVM为了优化指令,提高程序运行效率,在不影响单线程程序执行结果的前提下,尽可能地提高并行度。编译器、处理器也遵循这样一个目标。注意是单线程。多线程的情况下指令重排序就会给程序员带来问题。</p>
<p>不同的指令间可能存在数据依赖。比如下面计算圆的面积的语句:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">double</span> r = <span class="number">2.3</span>d;<span class="comment">//(1)</span></div><div class="line"><span class="keyword">double</span> pi =<span class="number">3.1415926</span>; <span class="comment">//(2)</span></div><div class="line"><span class="keyword">double</span> area = pi* r * r; <span class="comment">//(3)</span></div></pre></td></tr></table></figure></p>
<p>area的计算依赖于r与pi两个变量的赋值指令。而r与pi无依赖关系。</p>
<p>as-if-serial语义是指:不管如何重排序(编译器与处理器为了提高并行度),(单线程)程序的结果不能被改变。这是编译器、Runtime、处理器必须遵守的语义。</p>
<p>虽然,(1) – happensbefore -&gt; (2),(2) – happens before -&gt; (3),但是计算顺序(1)(2)(3)与(2)(1)(3) 对于r、pi、area变量的结果并无区别。编译器、Runtime在优化时可以根据情况重排序(1)与(2),而丝毫不影响程序的结果。</p>
<p>指令重排序包括编译器重排序和运行时重排序。</p>
<h3 id="指令重排带来的问题"><a href="#指令重排带来的问题" class="headerlink" title="指令重排带来的问题"></a>指令重排带来的问题</h3><p>如果一个操作不是原子的,就会给JVM留下重排的机会。下面看几个例子:</p>
<p>例子1:A线程指令重排导致B线程出错<br>对于在同一个线程内,这样的改变是不会对逻辑产生影响的,但是在多线程的情况下指令重排序会带来问题。看下面这个情景:</p>
<p>在线程A中:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">context = loadContext();</div><div class="line">inited = <span class="keyword">true</span>;</div></pre></td></tr></table></figure></p>
<p>在线程B中:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span>(!inited )&#123; <span class="comment">//根据线程A中对inited变量的修改决定是否使用context变量</span></div><div class="line">   sleep(<span class="number">100</span>);</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure></p>
<p>假设线程A中发生了指令重排序:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">inited = <span class="keyword">true</span>;</div><div class="line">context = loadContext();</div></pre></td></tr></table></figure></p>
<p>那么B中很可能就会拿到一个尚未初始化或尚未初始化完成的context,从而引发程序错误。</p>
<p>例子2:指令重排导致单例模式失效<br>我们都知道一个经典的懒加载方式的双重判断单例模式:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</div><div class="line">        synchronzied(Singleton.class) &#123;</div><div class="line">           <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</div><div class="line">               instance = <span class="keyword">new</span> Singleton();  <span class="comment">//非原子操作</span></div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> instance;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看似简单的一段赋值语句:instance= new Singleton(),但是很不幸它并不是一个原子操作,其实际上可以抽象为下面几条JVM指令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">memory =allocate();    //1:分配对象的内存空间 </div><div class="line">ctorInstance(memory);  //2:初始化对象 </div><div class="line">instance =memory;     //3:设置instance指向刚分配的内存地址</div></pre></td></tr></table></figure></p>
<p>上面操作2依赖于操作1,但是操作3并不依赖于操作2,所以JVM是可以针对它们进行指令的优化重排序的,经过重排序后如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">memory =allocate();    //1:分配对象的内存空间 </div><div class="line">instance =memory;     //3:instance指向刚分配的内存地址,此时对象还未初始化</div><div class="line">ctorInstance(memory);  //2:初始化对象</div></pre></td></tr></table></figure></p>
<p>可以看到指令重排之后,instance指向分配好的内存放在了前面,而这段内存的初始化被排在了后面。<br>在线程A执行这段赋值语句,在初始化分配对象之前就已经将其赋值给instance引用,恰好另一个线程进入方法判断instance引用不为null,然后就将其返回使用,导致出错。</p>
<h2 id="防止指令重排"><a href="#防止指令重排" class="headerlink" title="防止指令重排"></a>防止指令重排</h2><p>除了前面内存可见性中讲到的volatile关键字可以保证变量修改的可见性之外,还有另一个重要的作用:<strong>在JDK1.5之后,可以使用volatile变量禁止指令重排序.</strong></p>
<p>解决方案:例子1中的inited和例子2中的instance以关键字volatile修饰之后,就会阻止JVM对其相关代码进行指令重排,这样就能够按照既定的顺序指执行。</p>
<p>volatile关键字通过提供“<strong>内存屏障</strong>”的方式来防止指令被重排序,为了实现volatile的内存语义,编译器在生成字节码时,会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p>
<p>大多数的处理器都支持内存屏障的指令。</p>
<p>对于编译器来说,发现一个最优布置来最小化插入屏障的总数几乎不可能,为此,Java内存模型采取保守策略。下面是基于保守策略的JMM内存屏障插入策略:</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>volatile是轻量级同步机制</p>
<p>相对于synchronized块的代码锁,volatile应该是提供了一个轻量级的针对共享变量的锁,当我们在多个线程间使用共享变量进行通信的时候需要考虑将共享变量用volatile来修饰。</p>
<p>volatile是一种稍弱的同步机制,在访问volatile变量时不会执行加锁操作,也就不会执行线程阻塞,因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。</p>
<h3 id="volatile使用建议"><a href="#volatile使用建议" class="headerlink" title="volatile使用建议"></a>volatile使用建议</h3><p>使用建议:在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中,或者为常量时,没必要使用volatile。</p>
<p>由于使用volatile屏蔽掉了JVM中必要的代码优化,所以在效率上比较低,因此一定在必要时才使用此关键字。</p>
<h3 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="headerlink" title="volatile和synchronized区别"></a>volatile和synchronized区别</h3><ol>
<li>volatile不会进行加锁操作:<br>volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作,因此也就不会使执行线程阻塞,因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</li>
<li>volatile变量作用类似于同步变量读写操作:<br>从内存可见性的角度看,写入volatile变量相当于退出同步代码块,而读取volatile变量相当于进入同步代码块。</li>
<li>volatile不如synchronized安全:<br>在代码中如果过度依赖volatile变量来控制状态的可见性,通常会比使用锁的代码更脆弱,也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时,才应该使用它。一般来说,用同步机制会更安全些。</li>
<li>volatile无法同时保证内存可见性和原子性:<br>加锁机制(即同步机制)既可以确保可见性又可以确保原子性,而volatile变量只能确保可见性,原因是声明为volatile的简单变量如果当前值与该变量以前的值相关,那么volatile关键字不起作用,也就是说如下的表达式都不是原子操作:“count++”、“count = count+1”。</li>
</ol>
<h3 id="当且仅当满足以下所有条件时-才应该使用volatile变量"><a href="#当且仅当满足以下所有条件时-才应该使用volatile变量" class="headerlink" title="当且仅当满足以下所有条件时,才应该使用volatile变量:"></a>当且仅当满足以下所有条件时,才应该使用volatile变量:</h3><ol>
<li>对变量的写入操作不依赖变量的当前值,或者你能确保只有单个线程更新变量的值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ol>
<p>总结:在需要同步的时候,第一选择应该是synchronized关键字,这是最安全的方式,尝试其他任何方式都是有风险的。尤其在、jdK1.5之后,对synchronized同步机制做了很多优化,如:自适应的自旋锁、锁粗化、锁消除、轻量级锁等,使得它的性能明显有了很大的提升。</p>
<p>ref:<br><a href="http://www.importnew.com/23535.html" target="_blank" rel="external">http://www.importnew.com/23535.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-volatile解析</title>
    <url>/2017/09/22/Java-concurrency-volatile%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p>
<a id="more"></a>
<h2 id="内存模型的相关概念"><a href="#内存模型的相关概念" class="headerlink" title="内存模型的相关概念"></a>内存模型的相关概念</h2><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<p>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">i = i + 1;</div></pre></td></tr></table></figure>
<p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p>　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>
<p>　　1）通过在总线加LOCK#锁的方式</p>
<p>　　2）通过缓存一致性协议</p>
<p>　　这2种方式都是硬件层面上提供的方式。</p>
<p>　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p><img src="212219343783699.jpg" alt="212219343783699.jpg"></p>
<h2 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h2><p>在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>
<h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>　　原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>　　一个很经典的例子就是银行账户转账问题：</p>
<p>　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>　　同样地反映到并发编程中会出现什么结果呢？</p>
<p>　　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">i = 9;</div></pre></td></tr></table></figure>
<p> 　　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>
<p>　　那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>　　举个简单的例子，看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//线程1执行的代码</div><div class="line">int i = 0;</div><div class="line">i = 10;</div><div class="line"> </div><div class="line">//线程2执行的代码</div><div class="line">j = i;</div></pre></td></tr></table></figure>
<p>假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>　　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>　　有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int i = 0;              </div><div class="line">boolean flag = false;</div><div class="line">i = 1;                //语句1  </div><div class="line">flag = true;          //语句2</div></pre></td></tr></table></figure>
<p>上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int a = 10;    //语句1</div><div class="line">int r = 2;    //语句2</div><div class="line">a = a + 3;    //语句3</div><div class="line">r = a*a;     //语句4</div></pre></td></tr></table></figure>
<p>这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p>![212305263939989.jpg]*(212305263939989.jpg)</p>
<p>那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p>
<p>　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//线程1:</div><div class="line">context = loadContext();   //语句1</div><div class="line">inited = true;             //语句2</div><div class="line"> </div><div class="line">//线程2:</div><div class="line">while(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<p>面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p> 　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>　　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>　　举个简单的例子：在java中，执行下面这个语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">i = 10;</div></pre></td></tr></table></figure>
<p>执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>　　那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<h3 id="1-原子性-1"><a href="#1-原子性-1" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>　　请分析以下哪些操作是原子性操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">x = 10;         //语句1</div><div class="line">y = x;         //语句2</div><div class="line">x++;           //语句3</div><div class="line">x = x + 1;     //语句4</div></pre></td></tr></table></figure>
<p>咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p> 　　所以上面4个语句只有语句1的操作具备原子性。</p>
<p>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>　　不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<h3 id="2-可见性-1"><a href="#2-可见性-1" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>　　对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<h3 id="3-有序性-1"><a href="#3-有序性-1" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>　　下面就来具体介绍下happens-before原则（先行发生原则）：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>
<p>下面我们来解释一下前4条规则：</p>
<p>　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>　　第四条规则实际上就是体现happens-before原则具备传递性。</p>
<h2 id="深入剖析volatile关键字"><a href="#深入剖析volatile关键字" class="headerlink" title="深入剖析volatile关键字"></a>深入剖析volatile关键字</h2><h3 id="1-volatile关键字的两层语义"><a href="#1-volatile关键字的两层语义" class="headerlink" title="1.volatile关键字的两层语义"></a>1.volatile关键字的两层语义</h3><p>　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>　　2）禁止进行指令重排序。</p>
<p>　　先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//线程1</div><div class="line">boolean stop = false;</div><div class="line">while(!stop)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">//线程2</div><div class="line">stop = true;</div></pre></td></tr></table></figure>
<p>这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>　　但是用volatile修饰之后就变得不一样了：</p>
<p>　　第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>　　那么线程1读取到的就是最新的正确的值。</p>
<h3 id="2-volatile保证原子性吗？"><a href="#2-volatile保证原子性吗？" class="headerlink" title="2.volatile保证原子性吗？"></a>2.volatile保证原子性吗？</h3><p>　　从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>
<p>　　下面看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public volatile int inc = 0;</div><div class="line">     </div><div class="line">    public void increase() &#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final Test test = new Test();</div><div class="line">        for(int i=0;i&lt;10;i++)&#123;</div><div class="line">            new Thread()&#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    for(int j=0;j&lt;1000;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>　　假如某个时刻变量inc的值为10，</p>
<p>　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>　　那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>　　把上面的代码改成以下任何一种都可以达到效果：</p>
<p>　　采用synchronized：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public  int inc = 0;</div><div class="line">    </div><div class="line">    public synchronized void increase() &#123;</div><div class="line">        inc++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final Test test = new Test();</div><div class="line">        for(int i=0;i&lt;10;i++)&#123;</div><div class="line">            new Thread()&#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    for(int j=0;j&lt;1000;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用Lock：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public int inc = 0;</div><div class="line">    Lock lock = new ReentrantLock();</div><div class="line">    </div><div class="line">    public void increase() &#123;</div><div class="line">        lock.lock();</div><div class="line">        try &#123;</div><div class="line">            inc++;</div><div class="line">        &#125; finally&#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final Test test = new Test();</div><div class="line">        for(int i=0;i&lt;10;i++)&#123;</div><div class="line">            new Thread()&#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    for(int j=0;j&lt;1000;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用AtomicInteger：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public AtomicInteger inc = new AtomicInteger();</div><div class="line">     </div><div class="line">    public void increase() &#123;</div><div class="line">        inc.getAndIncrement();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        final Test test = new Test();</div><div class="line">        for(int i=0;i&lt;10;i++)&#123;</div><div class="line">            new Thread()&#123;</div><div class="line">                public void run() &#123;</div><div class="line">                    for(int j=0;j&lt;1000;j++)</div><div class="line">                        test.increase();</div><div class="line">                &#125;;</div><div class="line">            &#125;.start();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完</div><div class="line">            Thread.yield();</div><div class="line">        System.out.println(test.inc);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<h3 id="3-volatile能保证有序性吗？"><a href="#3-volatile能保证有序性吗？" class="headerlink" title="3.volatile能保证有序性吗？"></a>3.volatile能保证有序性吗？</h3><p>　　在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>　　volatile关键字禁止指令重排序有两层意思：</p>
<p>　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>　　可能上面说的比较绕，举个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//x、y为非volatile变量</div><div class="line">//flag为volatile变量</div><div class="line"> </div><div class="line">x = 2;        //语句1</div><div class="line">y = 0;        //语句2</div><div class="line">flag = true;  //语句3</div><div class="line">x = 4;         //语句4</div><div class="line">y = -1;       //语句5</div></pre></td></tr></table></figure>
<p>由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>　　那么我们回到前面举的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//线程1:</div><div class="line">context = loadContext();   //语句1</div><div class="line">inited = true;             //语句2</div><div class="line"> </div><div class="line">//线程2:</div><div class="line">while(!inited )&#123;</div><div class="line">  sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<p>前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<h3 id="4-volatile的原理和实现机制"><a href="#4-volatile的原理和实现机制" class="headerlink" title="4.volatile的原理和实现机制"></a>4.volatile的原理和实现机制</h3><p>　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>　　下面这段话摘自《深入理解Java虚拟机》：</p>
<p>　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>　　2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<h2 id="使用volatile关键字的场景"><a href="#使用volatile关键字的场景" class="headerlink" title="使用volatile关键字的场景"></a>使用volatile关键字的场景</h2><p>synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>　　1）对变量的写操作不依赖于当前值</p>
<p>　　2）该变量没有包含在具有其他变量的不变式中</p>
<p>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>　　下面列举几个Java中使用volatile的几个场景。</p>
<h3 id="1-状态标记量"><a href="#1-状态标记量" class="headerlink" title="1.状态标记量"></a>1.状态标记量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">volatile boolean flag = false;</div><div class="line"> </div><div class="line">while(!flag)&#123;</div><div class="line">    doSomething();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public void setFlag() &#123;</div><div class="line">    flag = true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">volatile boolean inited = false;</div><div class="line">//线程1:</div><div class="line">context = loadContext();  </div><div class="line">inited = true;            </div><div class="line"> </div><div class="line">//线程2:</div><div class="line">while(!inited )&#123;</div><div class="line">sleep()</div><div class="line">&#125;</div><div class="line">doSomethingwithconfig(context);</div></pre></td></tr></table></figure>
<h3 id="2-double-check"><a href="#2-double-check" class="headerlink" title="2.double check"></a>2.double check</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Singleton&#123;</div><div class="line">    private volatile static Singleton instance = null;</div><div class="line">     </div><div class="line">    private Singleton() &#123;</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    public static Singleton getInstance() &#123;</div><div class="line">        if(instance==null) &#123;</div><div class="line">            synchronized (Singleton.class) &#123;</div><div class="line">                if(instance==null)</div><div class="line">                    instance = new Singleton();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于为何需要这么写请参考：</p>
<p>　　《Java 中的双重检查（Double-Check）》<a href="http://blog.csdn.net/dl88250/article/details/5439024" target="_blank" rel="external">http://blog.csdn.net/dl88250/article/details/5439024</a></p>
<p>　　和<a href="http://www.iteye.com/topic/652440" target="_blank" rel="external">http://www.iteye.com/topic/652440</a></p>
<p>　　参考资料：</p>
<p>　　《Java编程思想》</p>
<p>　　《深入理解Java虚拟机》</p>
<p>　　<a href="http://jiangzhengjun.iteye.com/blog/652532" target="_blank" rel="external">http://jiangzhengjun.iteye.com/blog/652532</a></p>
<p>　　<a href="http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html</a></p>
<p>　　<a href="http://ifeve.com/volatile/" target="_blank" rel="external">http://ifeve.com/volatile/</a></p>
<p>　　<a href="http://blog.csdn.net/ccit0519/article/details/11241403" target="_blank" rel="external">http://blog.csdn.net/ccit0519/article/details/11241403</a></p>
<p>　　<a href="http://blog.csdn.net/ns_code/article/details/17101369" target="_blank" rel="external">http://blog.csdn.net/ns_code/article/details/17101369</a></p>
<p>　　<a href="http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html" target="_blank" rel="external">http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html</a></p>
<p>　　<a href="http://www.cppblog.com/elva/archive/2011/01/21/139019.html" target="_blank" rel="external">http://www.cppblog.com/elva/archive/2011/01/21/139019.html</a></p>
<p>　　<a href="http://ifeve.com/volatile-array-visiblity/" target="_blank" rel="external">http://ifeve.com/volatile-array-visiblity/</a></p>
<p>　　<a href="http://www.bdqn.cn/news/201312/12579.shtml" target="_blank" rel="external">http://www.bdqn.cn/news/201312/12579.shtml</a></p>
<p>　　<a href="http://exploer.blog.51cto.com/7123589/1193399" target="_blank" rel="external">http://exploer.blog.51cto.com/7123589/1193399</a></p>
<p>　　<a href="http://www.cnblogs.com/Mainz/p/3556430.html" target="_blank" rel="external">http://www.cnblogs.com/Mainz/p/3556430.html</a></p>
<p>ref:<br><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-同步异步阻塞非阻塞</title>
    <url>/2017/09/22/Java-concurrency-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>同步、异步、堵塞、非堵塞对于程序员来说都不会陌生，为避免理解偏差，现分辨如下。</p>
<a id="more"></a>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p>服务（Service）被分割成多个任务（Task），服务的执行结果是否要求任务最终按顺序执行。服务的结果依赖所有任务的执行称为同步服务；服务的结果不依赖所有的任务称为异步服务。</p>
<ul>
<li><p>同步 服务（Service）开始被分割为TaskA，TaskB，TaskC三个任务，TaskB的执行依赖于TaskA的执行，服务最后结果依赖于TaskB、TaskC，所有任务对业务来说都是同步操作。（这里也可以把TaskA、TaskB理解成一个任务，当然啦可以把TaskA、TaskB、TaskC理解成一个任务。我们平时写的比较多的就是同步代码）</p>
</li>
<li><p>异步 服务（Service）开始被分割为TaskA，TaskB，TaskC三个任务，TaskB的执行依赖于TaskA的执行，业务最后结果依赖于TaskB，TaskC的执行结果或者说TaskC中涉及到的数据对服务来说不重要甚至是不需要，所以TaskC任务对于业务来说是一个异步操作，也可以说是一个异步服务。</p>
</li>
</ul>
<h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>如果说线程是程序工作的基本单位、服务是要处理的内容，那么阻塞是指工作线程需要等待服务的响应结果才会处理下一个服务，否则工作线程会一直处于等待状态。非阻塞是指工作线程不需等待结果直接处理下一个服务。</p>
<ul>
<li>阻塞 服务的执行在Handler结果返回之前，工作线程会一直等待。</li>
<li>非阻塞 服务的执行不依赖Handler返回结果，工作线程直接处理下一个服务。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同步：服务依赖任务的执行结果<br>异步：服务不依赖任务的执行结果<br>阻塞：服务执行时线程会出现等待状态<br>非阻塞：不服务执行时线程不会出现等待状态</p>
<p>ref:<br><a href="https://segmentfault.com/a/1190000012666428" target="_blank" rel="external">https://segmentfault.com/a/1190000012666428</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-concurrency-解密线程池工作原理</title>
    <url>/2017/09/22/Java-concurrency-%E6%8F%AD%E7%A7%98%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>为了正确合理的使用线程池工具，我们有必要对线程池的原理进行了解。<br>本篇文章主要从三个方面来对线程池进行分析：线程池状态、重要属性、工作流程。</p>
<a id="more"></a>
<h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><p>首先线程池是有状态的，这些状态标识这线程池内部的一些运行情况，线程池的开启到关闭的过程就是线程池状态的一个流转的过程。</p>
<p>线程池共有五种状态：</p>
<p><img src="WX20190508-0927172x.png" alt="WX20190508-0927172x.png"></p>
<table>
<thead>
<tr>
<th style="text-align:left">状态</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">RUNNING</td>
<td style="text-align:left">运行状态，该状态下线程池可以接受新的任务，也可以处理阻塞队列中的任务;执行 shutdown 方法可进入 SHUTDOWN 状态;执行 shutdownNow 方法可进入 STOP 状态</td>
</tr>
<tr>
<td style="text-align:left">SHUTDOWN</td>
<td style="text-align:left">待关闭状态，不再接受新的任务，继续处理阻塞队列中的任务;当阻塞队列中的任务为空，并且工作线程数为0时，进入 TIDYING 状态</td>
</tr>
<tr>
<td style="text-align:left">STOP</td>
<td style="text-align:left">停止状态，不接收新任务，也不处理阻塞队列中的任务，并且会尝试结束执行中的任务; 当工作线程数为0时，进入 TIDYING 状态</td>
</tr>
<tr>
<td style="text-align:left">TIDYING</td>
<td style="text-align:left">整理状态，此时任务都已经执行完毕，并且也没有工作线程; 执行 terminated 方法后进入 TERMINATED 状态</td>
</tr>
<tr>
<td style="text-align:left">TERMINATED</td>
<td style="text-align:left">终止状态，此时线程池完全终止了，并完成了所有资源的释放</td>
</tr>
</tbody>
</table>
<h2 id="重要属性"><a href="#重要属性" class="headerlink" title="重要属性"></a>重要属性</h2><p>一个线程池的核心参数有很多，每个参数都有着特殊的作用，各个参数聚合在一起后将完成整个线程池的完整工作。</p>
<h3 id="1、线程状态和工作线程数量"><a href="#1、线程状态和工作线程数量" class="headerlink" title="1、线程状态和工作线程数量"></a>1、线程状态和工作线程数量</h3><p>首先线程池是有状态的，不同状态下线程池的行为是不一样的，5种状态已经在上面说过了。</p>
<p>另外线程池肯定是需要线程去执行具体的任务的，所以在线程池中就封装了一个内部类 Worker 作为工作线程，每个 Worker 中都维持着一个 Thread。</p>
<p>线程池的重点之一就是控制线程资源合理高效的使用，所以必须控制工作线程的个数，所以需要保存当前线程池中工作线程的个数。</p>
<p>看到这里，你是否觉得需要用两个变量来保存线程池的状态和线程池中工作线程的个数呢？但是在 ThreadPoolExecutor 中只用了一个 AtomicInteger 型的变量就保存了这两个属性的值，那就是 ctl。</p>
<p><img src="WX20190508-0931252x.png" alt="WX20190508-0931252x.png"></p>
<p>ctl 的高3位用来表示线程池的状态(runState)，低29位用来表示工作线程的个数(workerCnt)，为什么要用3位来表示线程池的状态呢，原因是线程池一共有5种状态，而2位只能表示出4种情况，所以至少需要3位才能表示得了5种状态。</p>
<h3 id="2、核心线程数和最大线程数"><a href="#2、核心线程数和最大线程数" class="headerlink" title="2、核心线程数和最大线程数"></a>2、核心线程数和最大线程数</h3><p>现在有了标志工作线程的个数的变量了，那到底该有多少个线程才合适呢？线程多了浪费线程资源，少了又不能发挥线程池的性能。</p>
<p>为了解决这个问题，线程池设计了两个变量来协作，分别是：</p>
<ul>
<li>核心线程数：corePoolSize 用来表示线程池中的核心线程的数量，也可以称为可闲置的线程数量</li>
<li>最大线程数：maximumPoolSize 用来表示线程池中最多能够创建的线程数量</li>
</ul>
<p>现在我们有一个疑问，既然已经有了标识工作线程的个数的变量了，为什么还要有核心线程数、最大线程数呢？</p>
<p>其实你这样想就能够理解了，创建线程是有代价的，不能每次要执行一个任务时就创建一个线程，但是也不能在任务非常多的时候，只有少量的线程在执行，这样任务是来不及处理的，而是应该创建合适的足够多的线程来及时的处理任务。随着任务数量的变化，当任务数明显很小时，原本创建的多余的线程就没有必要再存活着了，因为这时使用少量的线程就能够处理的过来了，所以说真正工作的线程的数量，是随着任务的变化而变化的。</p>
<p>那核心线程数和最大线程数与工作线程个数的关系是什么呢？</p>
<p><img src="WX20190508-0932312x.png" alt="WX20190508-0932312x.png"></p>
<p>工作线程的个数可能从0到最大线程数之间变化，当执行一段时间之后可能维持在 corePoolSize，但也不是绝对的，取决于核心线程是否允许被超时回收。</p>
<h3 id="3、创建线程的工厂"><a href="#3、创建线程的工厂" class="headerlink" title="3、创建线程的工厂"></a>3、创建线程的工厂</h3><p>既然是线程池，那自然少不了线程，线程该如何来创建呢？这个任务就交给了线程工厂 ThreadFactory 来完成。</p>
<h3 id="4、缓存任务的阻塞队列"><a href="#4、缓存任务的阻塞队列" class="headerlink" title="4、缓存任务的阻塞队列"></a>4、缓存任务的阻塞队列</h3><p>上面我们说了核心线程数和最大线程数，并且也介绍了工作线程的个数是在0和最大线程数之间变化的。但是不可能一下子就创建了所有线程，把线程池装满，而是有一个过程，这个过程是这样的：</p>
<p>当线程池接收到一个任务时，如果工作线程数没有达到corePoolSize，那么就会新建一个线程，并绑定该任务，直到工作线程的数量达到 corePoolSize 前都不会重用之前的线程。</p>
<p>当工作线程数达到 corePoolSize 了，这时又接收到新任务时，会将任务存放在一个阻塞队列中等待核心线程去执行。为什么不直接创建更多的线程来执行新任务呢，原因是核心线程中很可能已经有线程执行完自己的任务了，或者有其他线程马上就能处理完当前的任务，并且接下来就能投入到新的任务中去，所以阻塞队列是一种缓冲的机制，给核心线程一个机会让他们充分发挥自己的能力。另外一个值得考虑的原因是，创建线程毕竟是比较昂贵的，不可能一有任务要执行就去创建一个新的线程。</p>
<p>所以我们需要为线程池配备一个阻塞队列，用来临时缓存任务，这些任务将等待工作线程来执行。</p>
<p><img src="WX20190508-0933372x.png" alt="WX20190508-0933372x.png"></p>
<h3 id="5、非核心线程存活时间"><a href="#5、非核心线程存活时间" class="headerlink" title="5、非核心线程存活时间"></a>5、非核心线程存活时间</h3><p>上面我们说了当工作线程数达到 corePoolSize 时，线程池会将新接收到的任务存放在阻塞队列中，而阻塞队列又两种情况：一种是有界的队列，一种是无界的队列。</p>
<p>如果是无界队列，那么当核心线程都在忙的时候，所有新提交的任务都会被存放在该无界队列中，这时最大线程数将变得没有意义，因为阻塞队列不会存在被装满的情况。</p>
<p>如果是有界队列，那么当阻塞队列中装满了等待执行的任务，这时再有新任务提交时，线程池就需要创建新的“临时”线程来处理，相当于增派人手来处理任务。</p>
<p>但是创建的“临时”线程是有存活时间的，不可能让他们一直都存活着，当阻塞队列中的任务被执行完毕，并且又没有那么多新任务被提交时，“临时”线程就需要被回收销毁，在被回收销毁之前等待的这段时间，就是非核心线程的存活时间，也就是 keepAliveTime 属性。</p>
<p>那么什么是“非核心线程”呢？是不是先创建的线程就是核心线程，后创建的就是非核心线程呢？</p>
<p>其实核心线程跟创建的先后没有关系，而是跟工作线程的个数有关，如果当前工作线程的个数大于核心线程数，那么所有的线程都可能是“非核心线程”，都有被回收的可能。</p>
<p>一个线程执行完了一个任务后，会去阻塞队列里面取新的任务，在取到任务之前它就是一个闲置的线程。</p>
<p>取任务的方法有两种，一种是通过 take() 方法一直阻塞直到取出任务，另一种是通过 poll(keepAliveTime，timeUnit) 方法在一定时间内取出任务或者超时，如果超时这个线程就会被回收，请注意核心线程一般不会被回收。</p>
<p>那么怎么保证核心线程不会被回收呢？还是跟工作线程的个数有关，每一个线程在取任务的时候，线程池会比较当前的工作线程个数与核心线程数：</p>
<ul>
<li>如果工作线程数小于当前的核心线程数，则使用第一种方法取任务，也就是没有超时回收，这时所有的工作线程都是“核心线程”，他们不会被回收；</li>
<li>如果大于核心线程数，则使用第二种方法取任务，一旦超时就回收，所以并没有绝对的核心线程，只要这个线程没有在存活时间内取到任务去执行就会被回收。</li>
</ul>
<p>所以每个线程想要保住自己“核心线程”的身份，必须充分努力，尽可能快的获取到任务去执行，这样才能逃避被回收的命运。</p>
<p>核心线程一般不会被回收，但是也不是绝对的，如果我们设置了允许核心线程超时被回收的话，那么就没有核心线程这种说法了，所有的线程都会通过 poll(keepAliveTime, timeUnit) 来获取任务，一旦超时获取不到任务，就会被回收，一般很少会这样来使用，除非该线程池需要处理的任务非常少，并且频率也不高，不需要将核心线程一直维持着。</p>
<h3 id="6、拒绝策略"><a href="#6、拒绝策略" class="headerlink" title="6、拒绝策略"></a>6、拒绝策略</h3><p>虽然我们有了阻塞队列来对任务进行缓存，这从一定程度上为线程池的执行提供了缓冲期，但是如果是有界的阻塞队列，那就存在队列满的情况，也存在工作线程的数据已经达到最大线程数的时候。如果这时候再有新的任务提交时，显然线程池已经心有余而力不足了，因为既没有空余的队列空间来存放该任务，也无法创建新的线程来执行该任务了，所以这时我们就需要有一种拒绝策略，即 handler。</p>
<p>拒绝策略是一个 RejectedExecutionHandler 类型的变量，用户可以自行指定拒绝的策略，如果不指定的话，线程池将使用默认的拒绝策略：抛出异常。</p>
<p>在线程池中还为我们提供了很多其他可以选择的拒绝策略：</p>
<ul>
<li>直接丢弃该任务</li>
<li>使用调用者线程执行该任务</li>
<li>丢弃任务队列中的最老的一个任务，然后提交该任务</li>
</ul>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>了解了线程池中所有的重要属性之后，现在我们需要来了解下线程池的工作流程了。</p>
<p><img src="WX20190508-0936382x.png" alt="WX20190508-0936382x.png"></p>
<p>上图是一张线程池工作的精简图，实际的过程比这个要复杂的多，不过这些应该能够完全覆盖到线程池的整个工作流程了。</p>
<p>整个过程可以拆分成以下几个部分：</p>
<h3 id="1、提交任务"><a href="#1、提交任务" class="headerlink" title="1、提交任务"></a>1、提交任务</h3><p>当向线程池提交一个新的任务时，线程池有三种处理情况，分别是：创建一个工作线程来执行该任务、将任务加入阻塞队列、拒绝该任务。</p>
<p>提交任务的过程也可以拆分成以下几个部分：</p>
<ul>
<li>当工作线程数小于核心线程数时，直接创建新的核心工作线程</li>
<li>当工作线程数不小于核心线程数时，就需要尝试将任务添加到阻塞队列中去</li>
<li>如果能够加入成功，说明队列还没有满，那么需要做以下的二次验证来保证添加进去的任务能够成功被执行</li>
<li>验证当前线程池的运行状态，如果是非RUNNING状态，则需要将任务从阻塞队列中移除，然后拒绝该任务</li>
<li>验证当前线程池中的工作线程的个数，如果为0，则需要主动添加一个空工作线程来执行刚刚添加到阻塞队列中的任务</li>
<li>如果加入失败，则说明队列已经满了，那么这时就需要创建新的“临时”工作线程来执行任务</li>
<li>如果创建成功，则直接执行该任务</li>
<li>如果创建失败，则说明工作线程数已经等于最大线程数了，则只能拒绝该任务了</li>
</ul>
<p>整个过程可以用下面这张图来表示：</p>
<p><img src="WX20190508-0938342x.png" alt="WX20190508-0938342x.png"></p>
<h3 id="2、创建工作线程"><a href="#2、创建工作线程" class="headerlink" title="2、创建工作线程"></a>2、创建工作线程</h3><p>创建工作线程需要做一系列的判断，需要确保当前线程池可以创建新的线程之后，才能创建。</p>
<p>首先，当线程池的状态是 SHUTDOWN 或者 STOP 时，则不能创建新的线程。</p>
<p>另外，当线程工厂创建线程失败时，也不能创建新的线程。</p>
<p>还有就是当前工作线程的数量与核心线程数、最大线程数进行比较，如果前者大于后者的话，也不允许创建。</p>
<p>除此之外，会尝试通过 CAS 来自增工作线程的个数，如果自增成功了，则会创建新的工作线程，即 Worker 对象。</p>
<p>然后加锁进行二次验证是否能够创建工作线程，最后如果创建成功，则会启动该工作线程。</p>
<h3 id="3、启动工作线程"><a href="#3、启动工作线程" class="headerlink" title="3、启动工作线程"></a>3、启动工作线程</h3><p>当工作线程创建成功后，也就是 Worker 对象已经创建好了，这时就需要启动该工作线程，让线程开始干活了，Worker 对象中关联着一个 Thread，所以要启动工作线程的话，只要通过 worker.thread.start() 来启动该线程即可。</p>
<p>启动完了之后，就会执行 Worker 对象的 run 方法，因为 Worker 实现了 Runnable 接口，所以本质上 Worker 也是一个线程。</p>
<p>通过线程 start 开启之后就会调用到 Runnable 的 run 方法，在 worker 对象的 run 方法中，调用了 runWorker(this) 方法，也就是把当前对象传递给了 runWorker 方法，让他来执行。</p>
<h3 id="4、获取任务并执行"><a href="#4、获取任务并执行" class="headerlink" title="4、获取任务并执行"></a>4、获取任务并执行</h3><p>在 runWorker 方法被调用之后，就是执行具体的任务了，首先需要拿到一个可以执行的任务，而 Worker 对象中默认绑定了一个任务，如果该任务不为空的话，那么就是直接执行。</p>
<p>执行完了之后，就会去阻塞队列中获取任务来执行，而获取任务的过程，需要考虑当前工作线程的个数。</p>
<p>如果工作线程数大于核心线程数，那么就需要通过 poll 来获取，因为这时需要对闲置的线程进行回收；</p>
<p>如果工作线程数小于等于核心线程数，那么就可以通过 take 来获取了，因此这时所有的线程都是核心线程，不需要进行回收，前提是没有设置 allowCoreThreadTimeOut</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/xt-by5Z6msityl9MvuZuUw" target="_blank" rel="external">https://mp.weixin.qq.com/s/xt-by5Z6msityl9MvuZuUw</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-内部类</title>
    <url>/2017/09/22/Java-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>一般情况，我们把类定义成独立的单元。有些情况下，我们把一个类放在另一个类的内部定义，称为内部类(innerclasses)。<br>Java中内部类主要分为成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类<br>内部类可以使用public、default、protected 、private以及static修饰。而外部顶级类(我们以前接触的类)只能使用public和default修饰</p>
<p>注意<br>内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同。</p>
<a id="more"></a>
<h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h2><ol>
<li>变量和方法不能声明为静态的。也不能声明静态代码块。</li>
<li>实例化的时候需要依附在外部类上面。比如：B是A的非静态内部类，实例化B，则：A.B b = new A().new B();</li>
<li>内部类可以引用外部类的静态或者非静态属性或者方法。</li>
</ol>
<h3 id="对于第一条的论证和延伸"><a href="#对于第一条的论证和延伸" class="headerlink" title="对于第一条的论证和延伸"></a>对于第一条的论证和延伸</h3><h4 id="如何理解非静态内部类"><a href="#如何理解非静态内部类" class="headerlink" title="如何理解非静态内部类"></a>如何理解非静态内部类</h4><p><img src="snipaste_20190820115106.png" alt="snipaste_20190820115106.png"><br>我们理解非静态内部类时，可以看作是一个<strong>外部类的一个非静态成员</strong>，那么其实非静态内部类就是隶属于外部类对象的，但是它就其本质还是一个类。只要把握住这个两个核心接下来的内容就很好理解了。所以这也是为什么在TestInner类中测试使用Inner时，我门需要创建外部类对象之后才能使用内部类对象，因为:  <strong>内部类是属于外部类对象的，其次内部类的非静态内容访问也需要内部类对象，所以要new 外部类.new 内部类</strong></p>
<h4 id="非静态内部类定义静态成员是否合法"><a href="#非静态内部类定义静态成员是否合法" class="headerlink" title="非静态内部类定义静态成员是否合法"></a>非静态内部类定义静态成员是否合法</h4><p><img src="snipaste_20190820115655.png" alt="snipaste_20190820115655.png"></p>
<p>我们在测试在非静态内部类中说明静态内容时，会直接报错，此时这是为什么呢？<br>第一：java虚拟机要求所有的静态变量在类加载过程中的初始化阶段将符号引用变为直接引用。我们简单可以理解为：<strong>此时还没有对象呢</strong>！那么这也意味着我在内部类中定义的静态内容，要先于内部类对象存在。因为它是类层面上的<br>第二：由于内部类时依附于外部类对象的，那么也就意味着内部类中的内容时依附于外部类的对象的。但是内部类中的<strong>静态内容是不需要实例</strong>就可以，上述第一条已经说过了，但是由于第二条我们刚说的内部类时依附于外部类的，也就意味着<strong>内部类无法做到在没有外部类实例的情况下而直接使用</strong>，所以和我们刚写的第一条相悖。<br><strong>所以在非静态内部类中不能定义静态内容【编译期常量除外】</strong></p>
<h4 id="非静态内部类是否可以定义静态常量？"><a href="#非静态内部类是否可以定义静态常量？" class="headerlink" title="非静态内部类是否可以定义静态常量？"></a>非静态内部类是否可以定义静态常量？</h4><p>【编译期常量】</p>
<p><img src="snipaste_20190820120345.png" alt="snipaste_20190820120345.png"><br><img src="snipaste_20190820120421.png" alt="snipaste_20190820120421.png"></p>
<p>结论：<strong>我们是可以在非静态内部类中定义静态常量的【这里要注意静态常量一定拥有一个编译期常量的】*</strong><br>第一：根据上面的测试用例2，我们总结的结论，继续向下推导。为什么在非静态内部类中常量是可以被static修饰的。这里要注意，num这个变量被final static修饰后，由于所赋值为字面常量，而此时字面常量会在编译阶段确定值，我们将这样的常量称之为编译期常量，而编译期常量是不需要加载类的字节码文件的，很多书上将这一步称之为编译期常量折叠【编译器在编译阶段通过语法分析计算出常量表达式的具体值】。<br>第二：通过上一步的理解，我们也可以这样说，<strong>编译期常量不会导致类加载</strong>，那么基于这一条，我们就可以理解为什么静态常量在非静态内部类中定义是合</p>
<p>【运行期常量】</p>
<p><img src="snipaste_20190820120830.png" alt="snipaste_20190820120830.png"></p>
<p>思考：为什么用 Math.random(); 就不行了呢？<br>结论：其实这里的原因就是和测试用例2和测试用例3结合起来的。因为此时这里赋值不在时编译期常量，而是非编译期常量，对于这样的值而言编译期无法折叠编译器只能做一些语法检查，比如该常量之是否在其他地方做了修改等。。。既然无法确定值，那么就会导致该常量值的确定需要类被加载时确定，其实也和我们测试用例2一样，就会报错。</p>
<p><strong>所以非静态内部类中不能拥有静态成员变量/方法，但是可以有静态的编译期常量，不能使用非编译期常量。通过这个我们也可以理解为什么有些类中定义的字符串会通过static final修饰了。无需导致类加载，在一定程度上降低了内存消耗。</strong></p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><ol>
<li>属性和方法可以声明为静态的或者非静态的。</li>
<li>实例化静态内部类：比如：B是A的静态内部类，A.B b = new A.B();</li>
<li>内部类只能引用外部类的静态的属性或者方法。(因不一定存在相应外部类的对象)</li>
<li>如果属性或者方法声明为静态的，那么可以直接通过类名直接使用。比如B是A的静态内部类，b（）是B中的一个静态属性，则可以：A.B.b();</li>
</ol>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>适合那种只需要使用一次的类。比如：键盘监听操作等等</p>
<p>注意</p>
<ol>
<li>匿名内部类没有访问修饰符。</li>
<li>匿名内部类没有构造方法。因为它连名字都没有那又何来构造方法呢</li>
</ol>
<p>语法<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">new 父类构造器(实参类表) \实现接口 () &#123;</div><div class="line">           //匿名内部类类体！</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">this.addWindowListener(new WindowAdapter()&#123;</div><div class="line">        @Override</div><div class="line">        public void windowClosing(WindowEvent e) &#123;</div><div class="line">            System.exit(0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">);</div><div class="line">this.addKeyListener(new KeyAdapter()&#123;</div><div class="line">        @Override</div><div class="line">        public void keyPressed(KeyEvent e) &#123;</div><div class="line">            myTank.keyPressed(e);</div><div class="line">        &#125;      </div><div class="line">        @Override</div><div class="line">        public void keyReleased(KeyEvent e) &#123;</div><div class="line">            myTank.keyReleased(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>还有一种内部类，它是定义在方法内部的，作用域只限于本方法，称为局部内部类。</p>
<p>局部内部类的的使用主要是用来解决比较复杂的问题，想创建一个类来辅助我们的解决方案，到那时又不希望这个类是公共可用的，所以就产生了局部内部类。局部内部类和成员内部类一样被编译，只是它的作用域发生了改变，它只能在该方法中被使用，出了该方法就会失效。</p>
<p>局部内部类在实际开发中应用很少</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Test2 &#123;</div><div class="line">    public void show() &#123;</div><div class="line">        //作用域仅限于该方法</div><div class="line">        class Inner &#123;</div><div class="line">            public void fun() &#123;</div><div class="line">                System.out.println(&quot;helloworld&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        new Inner().fun();</div><div class="line">    &#125;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        new Test2().show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//结果: helloword</div></pre></td></tr></table></figure>
<h2 id="关于java静态方法的相关总结："><a href="#关于java静态方法的相关总结：" class="headerlink" title="关于java静态方法的相关总结："></a>关于java静态方法的相关总结：</h2><p>一个类的静态方法只能访问静态属性（静态方法是属于类的，而普通方法是属于对象的。）</p>
<p>一个类的静态方法不能够直接调用非静态方法；<br>如访问控制权限允许，static 属性和方法可以使用类名加“.”方式调用；当然也可以使用实例加“.”方式调用；<br>静态方法中不存在当前对象，因而不能使用“this”，当然也不能使用”super”；<br>静态方法不能被非静态方法覆盖；<br>构造方法不允许声明为 static 的；<br>局部变量不能使用static修饰；</p>
<p>问题：为什么一个类的静态方法只能访问静态属性或静态方法？<br>回答：静态方法是属于类的，而普通方法是属于对象的。<br>属于类的静态方法可以在对象不存在的时候就能访问到，而普通方法必须先new一个对象才能用这个对象访问<br>。当我们访问调用静态方法的时候（使用类名.静态方法名）这个时候就没有对象创建，所以普通方法是访问不到的。<br>为了避免这种错误，所以java就不允许在静态方法中访问非静态方法。可以想一下main方法。</p>
<p>ref:<br><a href="https://www.cnblogs.com/aademeng/articles/6192944.html" target="_blank" rel="external">https://www.cnblogs.com/aademeng/articles/6192944.html</a><br><a href="https://www.jianshu.com/p/4dbe68850e1b" target="_blank" rel="external">https://www.jianshu.com/p/4dbe68850e1b</a><br><a href="https://www.sxt.cn/Java_jQuery_in_action/five-classification.html" target="_blank" rel="external">https://www.sxt.cn/Java_jQuery_in_action/five-classification.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-双亲委派模型</title>
    <url>/2017/09/22/Java-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><strong>双亲委派模型</strong></p>
<p>在介绍这个Java技术点之前，先试着思考以下几个问题：</p>
<ol>
<li>为什么我们不能定义同名的 String 的 java 文件？</li>
<li>多线程的情况下，类的加载为什么不会出现重复加载的情况？</li>
<li>热部署的原理是什么？</li>
<li>下面代码，虚拟机是怎样初始化注册 Mysql 连接驱动(Driver)的？</li>
</ol>
<p><img src="snipaste_20190927143803.jpg" alt="snipaste_20190927143803.jpg"></p>
<p>想理解以上几个问题的前提是了解类加载时机与过程, 这篇文章将会以非常详细的解读方式来回答以上几个问题</p>
<a id="more"></a>
<h2 id="类加载时机与过程"><a href="#类加载时机与过程" class="headerlink" title="类加载时机与过程"></a>类加载时机与过程</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。如图所示<br><img src="snipaste_20190927144353.jpg" alt="snipaste_20190927144353.jpg"></p>
<p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）</p>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段（可以参考java.lang.ClassLoader的loadClass()方法），虚拟机需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流（并没有指明要从一个Class文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口；</li>
</ol>
<p>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>验证阶段大致会完成4个阶段的检验动作：</p>
<ol>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以魔术0xCAFEBABE开头（当class文件以二进制形式打开，会看到这个文件头，cafebabe）、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比javac编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了java.lang.Object之外。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：确保解析动作能正确执行。</li>
</ol>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值<strong>通常情况</strong>下是数据类型的零值，假设一个类变量的定义为：</p>
<p><img src="snipaste_20190927144620.jpg" alt="snipaste_20190927144620.jpg"></p>
<p>有通常情况就有<strong>特殊情况</strong>，这里的特殊是指：</p>
<p><img src="snipaste_20190927144721.jpg" alt="snipaste_20190927144721.jpg"></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在介绍初始化时，要先介绍两个方法：<clinit> 和 <init>:</init></clinit></p>
<ol>
<li>在编译生成class文件时，会自动产生两个方法，一个是类的初始化方法</li>
<li>, 另一个是实例的初始化方法<br>clinit&gt;：在jvm第一次加载class文件时调用，包括静态变量初始化语句和静态块的执行</li>
<li><init>: 在实例创建出来的时候调用，包括调用new操作符；调用 Class 或 Java.lang.reflect.Constructor 对象的newInstance()方法；调用任何现有对象的clone()方法；通过 java.io.ObjectInputStream 类的getObject() 方法反序列化。</init></li>
</ol>
<p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正开始执行类中定义的java程序代码。在准备极端，变量已经付过一次系统要求的初始值，而在初始化阶段，则根据程序猿通过程序制定的主管计划去初始化类变量和其他资源，或者说：初始化阶段是执行类构造器<clinit>()方法的过程.</clinit></p>
<p><clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块 static{} 中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。如下：</clinit></p>
<p><img src="snipaste_20190927150534.jpg" alt="snipaste_20190927150534.jpg"></p>
<p>那么去掉报错的那句，改成下面：</p>
<p><img src="snipaste_20190927150616.jpg" alt="snipaste_20190927150616.jpg"><br>输出结果：1</p>
<p>为什么输出结果是 1，在准备阶段我们知道 i=0，然后类初始化阶段按照顺序执行，首先执行 static 块中的 i=0,接着执行 static赋值操作i=1, 最后在 main 方法中获取 i 的值为1</p>
<ul>
<li><clinit>()方法与实例构造器<init>()方法不同，它不需要显示地调用父类构造器，虚拟机会保证在子类<init>()方法执行之前，父类的<clinit>()方法方法已经执行完毕</clinit></init></init></clinit></li>
<li>由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。</clinit></li>
<li><clinit>()方法对于类或者接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生产<clinit>()方法。</clinit></clinit></li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法。但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</clinit></clinit></clinit></clinit></li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞，在实际应用中这种阻塞往往是隐藏的。</clinit></clinit></clinit></clinit></li>
</ul>
<p>让我们来验证上面的加载规则</p>
<p><strong>验证 1</strong>: 虚拟机会保证在子类<init>()方法执行之前，父类的<clinit>()方法方法已经执行完毕<br><img src="snipaste_20190927150833.jpg" alt="snipaste_20190927150833.jpg"></clinit></init></p>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SSClass</div><div class="line">SuperClass init!</div><div class="line">123</div></pre></td></tr></table></figure></p>
<p><strong>验证 2</strong>: 通过数组定义来引用类，不会触发此类的初始化(我的理解是数组的父类是Object)</p>
<p><img src="snipaste_20190927151007.jpg" alt="snipaste_20190927151007.jpg"></p>
<p>输出结果：无</p>
<p><strong>验证 3</strong>: 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</p>
<p><img src="snipaste_20190927151054.jpg" alt="snipaste_20190927151054.jpg"><br>输出结果：hello world</p>
<p><strong>验证小结</strong></p>
<p>虚拟机规范严格规定了有且只有5中情况（jdk1.7）必须对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到 new, getstatic, putstatic, invokestatic 这些字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用jdk1.7动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果REF_getstatic, REF_putstatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。</li>
</ol>
<p>有了这个加载规则的印象，双亲委派模型就很好理解了，别着急，继续向下看, 你会发现你的理解层面提高了</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>刚看到这个词汇的时候我是完全懵懂的状态，其实就是定义了 JVM 启动的时候类的加载规则, 大家要按规矩办事，好办事，来看下图：</p>
<p><img src="snipaste_20190927151943.jpg" alt="snipaste_20190927151943.jpg"></p>
<p>所谓双亲委派是指每次收到类加载请求时，先将请求委派给父类加载器完成（所有加载请求最终会委派到顶层的Bootstrap ClassLoader加载器中），如果父类加载器无法完成这个加载（该加载器的搜索范围中没有找到对应的类），子类尝试自己加载， 如果都没加载到，则会抛出 ClassNotFoundException 异常， 看到这里其实就解释了文章开头提出的第一个问题，父加载器已经加载了JDK 中的 String.class 文件，所以我们不能定义同名的 String java 文件。</p>
<p>为什么会有这样的规矩设定？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要 ClassLoader 再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义的类型，这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String 已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的ClassLoader永远也无法加载一个自己写的String，除非你改变 JDK 中 ClassLoader 搜索类的默认算法。</div></pre></td></tr></table></figure>
<p>我们发现除了启动类加载器（BootStrap ClassLoader），每个类都有其”父类”加载器. <strong>其实这里的父子关系是组合模式，不是继承关系来实现</strong></p>
<p><img src="snipaste_20190927152141.jpg" alt="snipaste_20190927152141.jpg"></p>
<p>从图中可以看到类 AppClassLoader 和 ExtClassLoader 都继承 URLClassLoader， 而 URLClassLoader 又继承 ClassLoader， 在 ClassLoader 中有一个属性</p>
<p><img src="snipaste_20190927152230.jpg" alt="snipaste_20190927152230.jpg"></p>
<p>在通过构造函数实例化  AppClassLoader 和 ExtClassLoader 的时候都要传入一个 classloader 作为当前 classloader 的 parent</p>
<p><img src="snipaste_20190927152318.jpg" alt="snipaste_20190927152318.jpg"></p>
<p>顶层ClassLoader有几个函数很关键，先有个印象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">指定保护域（protectionDomain），把ByteBuffer的内容转换成 Java 类，这个方法被声明为final的</div></pre></td></tr></table></figure>
<p><img src="snipaste_20190928173406.jpg" alt="snipaste_20190928173406.jpg"><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">把字节数组 b中的内容转换成 Java 类，其开始偏移为off,这个方法被声明为final的</div></pre></td></tr></table></figure></p>
<p><img src="snipaste_20190928173500.jpg" alt="snipaste_20190928173500.jpg"><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">查找指定名称的类</div></pre></td></tr></table></figure></p>
<p><img src="snipaste_20190928173545.jpg" alt="snipaste_20190928173545.jpg"><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">链接指定的类</div></pre></td></tr></table></figure></p>
<p><img src="snipaste_20190928173643.jpg" alt="snipaste_20190928173643.jpg"></p>
<h3 id="类加载器责任范围"><a href="#类加载器责任范围" class="headerlink" title="类加载器责任范围"></a>类加载器责任范围</h3><p>上面我们提到每个加载器都有对应的加载搜索范围</p>
<ol>
<li><strong>Bootstrap ClassLoader</strong>:这个加载器不是一个Java类，而是由底层的c++实现，负责在虚拟机启动时加载Jdk核心类库（如：rt.jar、resources.jar、charsets.jar等）以及加载后两个类加载器。这个ClassLoader完全是JVM自己控制的，需要加载哪个类，怎么加载都是由JVM自己控制，别人也访问不到这个类</li>
<li><strong>Extension ClassLoader</strong>:是一个普通的Java类，继承自ClassLoader类，负责加载{JAVA_HOME}/jre/lib/ext/目录下的所有jar包。</li>
<li><strong>App ClassLoader</strong>：是Extension ClassLoader的子对象，负责加载应用程序classpath目录下的所有jar和class文件。</li>
</ol>
<p><img src="snipaste_20190928173942.jpg" alt="snipaste_20190928173942.jpg"></p>
<p>大家自行运行这个文件，就可以看到每个类加载器加载的文件了</p>
<h3 id="两种类的加载方式"><a href="#两种类的加载方式" class="headerlink" title="两种类的加载方式"></a>两种类的加载方式</h3><p>通常用这两种方式来动态加载一个 java 类，Class.forName() 与 ClassLoader.loadClass() 但是两个方法之间也是有一些细微的差别</p>
<h4 id="Class-forName-方式"><a href="#Class-forName-方式" class="headerlink" title="Class.forName() 方式"></a>Class.forName() 方式</h4><p>查看Class类的具体实现可知，实质上这个方法是调用原生的方法：</p>
<p><img src="snipaste_20190928174056.jpg" alt="snipaste_20190928174056.jpg"></p>
<p>形式上类似于Class.forName(name,true,currentLoader)。综上所述，Class.forName 如果调用成功会：</p>
<ul>
<li>保证一个Java类被有效得加载到内存中；</li>
<li>类默认会被初始化，即执行内部的静态块代码以及保证静态属性被初始化；</li>
<li>默认会使用当前的类加载器来加载对应的类。</li>
</ul>
<h4 id="ClassLoader-loadClass方式"><a href="#ClassLoader-loadClass方式" class="headerlink" title="ClassLoader.loadClass方式"></a>ClassLoader.loadClass方式</h4><p>如果采用这种方式的类加载策略，由于双亲托管模型的存在，最终都会将类的加载任务交付给Bootstrap ClassLoader进行加载。跟踪源代码，最终会调用原生方法：</p>
<p><img src="snipaste_20190928174207.jpg" alt="snipaste_20190928174207.jpg"></p>
<p>与此同时，与上一种方式的最本质的不同是，类不会被初始化，只有显式调用才会进行初始化。综上所述，ClassLoader.loadClass 如果调用成功会：</p>
<ul>
<li>类会被加载到内存中；</li>
<li>类不会被初始化，只有在之后被第一次调用时类才会被初始化；</li>
<li>之所以采用这种方式的类加载，是提供一种灵活度，可以根据自身的需求继承ClassLoader类实现一个自定义的类加载器实现类的加载。（很多开源Web项目中都有这种情况，比如tomcat，struct2，jboss。原因是根据Java Servlet规范的要求，既要Web应用自己的类的优先级要高于Web容器提供的类，但同时又要保证Java的核心类不被任意覆盖，此时重写一个类加载器就很必要了）</li>
</ul>
<h2 id="双亲委派模型源码分析"><a href="#双亲委派模型源码分析" class="headerlink" title="双亲委派模型源码分析"></a>双亲委派模型源码分析</h2><h3 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h3><p>分析类加载器源码要从 sun.misc.Launcher.class 文件看起, 关键代码已添加注释，同时可以在此类中看到 ExtClassLoader 和 AppClassLoader 的定义，也验证了我们上文提到的他们不是继承关系，而是通过指定 parent 属性来形成的组合模型</p>
<p><img src="snipaste_20190928174410.jpg" alt="snipaste_20190928174410.jpg"></p>
<p>进入上面第25行的 loadClass 方法中</p>
<p><img src="snipaste_20190928174525.jpg" alt="snipaste_20190928174525.jpg"></p>
<p>我们看到方法有同步块（synchronized）, 这也就解释了文章开头第2个问题，多线程情况不会出现重复加载的情况。同时会询问parent classloader是否有加载，如果没有，自己尝试加载。</p>
<p>URLClassLoader中的 findClass方法：</p>
<p><img src="snipaste_20190928174605.jpg" alt="snipaste_20190928174605.jpg"></p>
<p>借用网友的一个加载时序图来解释整个过程更加清晰：</p>
<p><img src="snipaste_20190928174653.jpg" alt="snipaste_20190928174653.jpg"></p>
<h2 id="双亲委派模型的破坏"><a href="#双亲委派模型的破坏" class="headerlink" title="双亲委派模型的破坏"></a>双亲委派模型的破坏</h2><p>Java本身有一套资源管理服务JNDI，是放置在rt.jar中，由启动类加载器加载的。以对数据库管理JDBC为例，java给数据库操作提供了一个Driver接口：</p>
<p><img src="snipaste_20190928174739.jpg" alt="snipaste_20190928174739.jpg"></p>
<p>然后提供了一个DriverManager来管理这些Driver的具体实现：</p>
<p><img src="snipaste_20190928174813.jpg" alt="snipaste_20190928174813.jpg"></p>
<p>这里省略了大部分代码，可以看到我们使用数据库驱动前必须先要在DriverManager中使用registerDriver()注册，然后我们才能正常使用。</p>
<h3 id="不破坏双亲委派模型的情况（不使用JNDI服务）"><a href="#不破坏双亲委派模型的情况（不使用JNDI服务）" class="headerlink" title="不破坏双亲委派模型的情况（不使用JNDI服务）"></a>不破坏双亲委派模型的情况（不使用JNDI服务）</h3><p>我们看下mysql的驱动是如何被加载的：</p>
<p><img src="snipaste_20190928174909.jpg" alt="snipaste_20190928174909.jpg"></p>
<p>核心就是这句Class.forName()触发了mysql驱动的加载，我们看下mysql对Driver接口的实现：</p>
<p><img src="snipaste_20190928174946.jpg" alt="snipaste_20190928174946.jpg"></p>
<p>可以看到，Class.forName()其实触发了静态代码块，然后向DriverManager中注册了一个mysql的Driver实现。这个时候，我们通过DriverManager去获取connection的时候只要遍历当前所有Driver实现，然后选择一个建立连接就可以了。</p>
<h3 id="破坏双亲委派模型的情况"><a href="#破坏双亲委派模型的情况" class="headerlink" title="破坏双亲委派模型的情况"></a>破坏双亲委派模型的情况</h3><p>在JDBC4.0以后，开始支持使用spi的方式来注册这个Driver，具体做法就是在mysql的jar包中的META-INF/services/java.sql.Driver 文件中指明当前使用的Driver是哪个，然后使用的时候就直接这样就可以了：</p>
<p><img src="snipaste_20190928175029.jpg" alt="snipaste_20190928175029.jpg"></p>
<p>可以看到这里直接获取连接，省去了上面的Class.forName()注册过程。<br>现在，我们分析下看使用了这种spi服务的模式原本的过程是怎样的:</p>
<ol>
<li>第一，从META-INF/services/java.sql.Driver文件中获取具体的实现类名“com.mysql.jdbc.Driver”</li>
<li>第二，加载这个类，这里肯定只能用class.forName(“com.mysql.jdbc.Driver”)来加载</li>
</ol>
<p>好了，问题来了，Class.forName()加载用的是调用者的Classloader，这个调用者DriverManager是在rt.jar中的，ClassLoader是启动类加载器，而com.mysql.jdbc.Driver肯定不在/lib下，所以肯定是无法加载mysql中的这个类的。这就是双亲委派模型的局限性了，父级加载器无法加载子级类加载器路径中的类。</p>
<p>那么，这个问题如何解决呢？按照目前情况来分析，这个mysql的drvier只有应用类加载器能加载，那么我们只要在启动类加载器中有方法获取应用程序类加载器，然后通过它去加载就可以了。这就是所谓的线程上下文加载器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">文章前半段提到线程上下文类加载器可以通过 Thread.setContextClassLoaser() 方法设置，如果不特殊设置会从父类继承，一般默认使用的是应用程序类加载器</div></pre></td></tr></table></figure>
<p><strong>很明显，线程上下文类加载器让父级类加载器能通过调用子级类加载器来加载类，这打破了双亲委派模型的原则</strong></p>
<p>现在我们看下DriverManager是如何使用线程上下文类加载器去加载第三方jar包中的Driver类的，先来看源码：</p>
<p><img src="6400.jpeg" alt="6400.jpeg"></p>
<p>使用时，我们直接调用DriverManager.getConnection() 方法自然会触发静态代码块的执行，开始加载驱动然后我们看下ServiceLoader.load()的具体实现：</p>
<p><img src="snipaste_20190928175303.jpg" alt="snipaste_20190928175303.jpg"></p>
<p>继续向下看构造函数实例化 ServiceLoader 做了哪些事情：</p>
<p><img src="snipaste_20190928175411.jpg" alt="snipaste_20190928175411.jpg"></p>
<p>查看 reload() 函数：</p>
<p><img src="snipaste_20190928175447.jpg" alt="snipaste_20190928175447.jpg"></p>
<p>继续查看LazyIterator构造器，该类同样实现了Iterator接口：</p>
<p><img src="snipaste_20190928175525.jpg" alt="snipaste_20190928175525.jpg"></p>
<p>实例化到这里我们也将上下文得到的类加载器实例化到这里，来回看ServiceLoader 重写的 iterator() 方法：</p>
<p><img src="snipaste_20190928175614.jpg" alt="snipaste_20190928175614.jpg"></p>
<p>上面next() 方法调用了lookupIterator.next()，这个lookupIterator 就是刚刚实例化的 LazyIterator(); 来看next方法</p>
<p><img src="snipaste_20190928175643.jpg" alt="snipaste_20190928175643.jpg"></p>
<p>继续查看nextService 方法：</p>
<p><img src="snipaste_20190928175724.jpg" alt="snipaste_20190928175724.jpg"></p>
<p>终于到这里了，在上面 nextService函数中第8行调用了c = Class.forName(cn, false, loader) 方法，我们成功的做到了通过线程上下文类加载器拿到了应用程序类加载器（或者自定义的然后塞到线程上下文中的），同时我们也查找到了厂商在子级的jar包中注册的驱动具体实现类名，这样我们就可以成功的在rt.jar包中的DriverManager中成功的加载了放在第三方应用程序包中的类了同时在第16行完成Driver的实例化，等同于new Driver(); 文章开头的问题在理解到这里也迎刃而解了</p>
<h2 id="JAVA热部署实现"><a href="#JAVA热部署实现" class="headerlink" title="JAVA热部署实现"></a>JAVA热部署实现</h2><p>首先谈一下何为热部署（hotswap），热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为。Java 类是通过 Java 虚拟机加载的，某个类的 class 文件在被 classloader 加载后，会生成对应的 Class 对象，之后就可以创建该类的实例。默认的虚拟机行为只会在启动时加载类，如果后期有一个类需要更新的话，单纯替换编译的 class 文件，Java 虚拟机是不会更新正在运行的 class。如果要实现热部署，最根本的方式是修改虚拟机的源代码，改变 classloader 的加载行为，使虚拟机能监听 class 文件的更新，重新加载 class 文件，这样的行为破坏性很大，为后续的 JVM 升级埋下了一个大坑。</p>
<p>另一种友好的方法是创建自己的 classloader 来加载需要监听的 class，这样就能控制类加载的时机，从而实现热部署。</p>
<p>热部署步骤：</p>
<ol>
<li>销毁自定义classloader(被该加载器加载的class也会自动卸载)；</li>
<li>更新class</li>
<li>使用新的ClassLoader去加载class</li>
</ol>
<p>JVM中的Class只有满足以下三个条件，才能被GC回收，也就是该Class被卸载（unload）：</p>
<ul>
<li>该类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例。</li>
<li>加载该类的ClassLoader已经被GC。</li>
<li>该类的java.lang.Class 对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法</li>
</ul>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><p>要创建用户自己的类加载器，只需要继承java.lang.ClassLoader类，然后覆盖它的findClass(String name)方法即可，即指明如何获取类的字节码流。</p>
<p><strong>如果要符合双亲委派规范，则重写findClass方法（用户自定义类加载逻辑）；要破坏的话，重写loadClass方法(双亲委派的具体逻辑实现)。</strong></p>
<p><img src="6401.jpeg" alt="6401.jpeg"></p>
<p>ref:</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjIxMjA1Ng==&amp;mid=2247483821&amp;idx=1&amp;sn=4b51ef0930bd884f13f5c2ab29951edc&amp;scene=21#wechat_redirect" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=Mzg3NjIxMjA1Ng==&amp;mid=2247483821&amp;idx=1&amp;sn=4b51ef0930bd884f13f5c2ab29951edc&amp;scene=21#wechat_redirect</a></p>
<p><a href="https://blog.csdn.net/u014634338/article/details/81434327" target="_blank" rel="external">https://blog.csdn.net/u014634338/article/details/81434327</a></p>
<p><a href="https://www.cnblogs.com/aspirant/p/7200523.html" target="_blank" rel="external">https://www.cnblogs.com/aspirant/p/7200523.html</a></p>
<p><a href="https://www.cnblogs.com/gdpuzxs/p/7044963.html" target="_blank" rel="external">https://www.cnblogs.com/gdpuzxs/p/7044963.html</a></p>
<p><a href="https://www.jianshu.com/p/09f73af48a98" target="_blank" rel="external">https://www.jianshu.com/p/09f73af48a98</a></p>
<p><a href="https://www.cnblogs.com/yahokuma/p/3668138.html" target="_blank" rel="external">https://www.cnblogs.com/yahokuma/p/3668138.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-泛型中的通配符-T-E-K-V</title>
    <url>/2017/09/22/Java-%E6%B3%9B%E5%9E%8B%E4%B8%AD%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6-T-E-K-V/</url>
    <content><![CDATA[<p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许开发者在编译时检测到非法的类型。</p>
<p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数</p>
<a id="more"></a>
<h2 id="泛型带来的好处"><a href="#泛型带来的好处" class="headerlink" title="泛型带来的好处"></a>泛型带来的好处</h2><p>在没有泛型的情况的下，通过对类型 Object 的引用来实现参数的“任意化”，“任意化”带来的缺点是要做显式的强制类型转换，而这种转换是要求开发者对实际参数类型可以预知的情况下进行的。对于强制类型转换错误的情况，编译器可能不提示错误，在运行的时候才出现异常，这是本身就是一个安全隐患。</p>
<p>那么泛型的好处就是在编译的时候能够检查类型安全，并且所有的强制转换都是自动和隐式的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class GlmapperGeneric&lt;T&gt; &#123;</div><div class="line">        private T t;</div><div class="line">    public void set(T t) &#123; this.t = t; &#125;</div><div class="line">    public T get() &#123; return t; &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // do nothing</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">    * 不指定类型</div><div class="line">    */</div><div class="line">  public void noSpecifyType()&#123;</div><div class="line">    GlmapperGeneric glmapperGeneric = new GlmapperGeneric();</div><div class="line">    glmapperGeneric.set(&quot;test&quot;);</div><div class="line">    // 需要强制类型转换</div><div class="line">    String test = (String) glmapperGeneric.get();</div><div class="line">    System.out.println(test);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">    * 指定类型</div><div class="line">    */</div><div class="line">  public void specifyType()&#123;</div><div class="line">    GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric();</div><div class="line">    glmapperGeneric.set(&quot;test&quot;);</div><div class="line">    // 不需要强制类型转换</div><div class="line">    String test = glmapperGeneric.get();</div><div class="line">    System.out.println(test);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码中的 specifyType 方法中 省去了强制转换，可以在编译时候检查类型安全，可以用在类，方法，接口上</p>
<h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p>
<h3 id="常用的-T，E，K，V，？"><a href="#常用的-T，E，K，V，？" class="headerlink" title="常用的 T，E，K，V，？"></a>常用的 T，E，K，V，？</h3><p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？是这样约定的：</p>
<ul>
<li>？表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="？无界通配符"><a href="#？无界通配符" class="headerlink" title="？无界通配符"></a>？无界通配符</h3><p>先从一个小例子看起，原文在 这里 [<a href="https://codeday.me/bug/20180113/116421.html]。" target="_blank" rel="external">https://codeday.me/bug/20180113/116421.html]。</a></p>
<p>我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">List&lt;Animal&gt; listAnimals</div></pre></td></tr></table></figure></p>
<p>但是老板的想法确实这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">List&lt;? extends Animal&gt; listAnimals</div></pre></td></tr></table></figure></p>
<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">static int countLegs (List&lt;? extends Animal &gt; animals ) &#123;</div><div class="line">    int retVal = 0;</div><div class="line">    for ( Animal animal : animals )</div><div class="line">    &#123;</div><div class="line">        retVal += animal.countLegs();</div><div class="line">    &#125;</div><div class="line">    return retVal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int countLegs1 (List&lt; Animal &gt; animals )&#123;</div><div class="line">    int retVal = 0;</div><div class="line">    for ( Animal animal : animals )</div><div class="line">    &#123;</div><div class="line">        retVal += animal.countLegs();</div><div class="line">    &#125;</div><div class="line">    return retVal;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();</div><div class="line">     // 不会报错</div><div class="line">    countLegs( dogs );</div><div class="line">    // 报错</div><div class="line">    countLegs1(dogs);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当调用 countLegs1 时，就会飘红，提示的错误信息如下：<br><img src="snipaste_20190820231103.png" alt="snipaste_20190820231103.png"></p>
<p>所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 &lt;?&gt; ），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt;? extends E&gt;"></a>上界通配符 &lt;? extends E&gt;</h3><p><code>上届：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</code></p>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private &lt;K extends A, E extends B&gt; E test(K arg1, E arg2)&#123;</div><div class="line">    E result = arg2;</div><div class="line">    arg2.compareTo(arg1);</div><div class="line">    //.....</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>类型参数列表中如果有多个类型参数上限，用逗号分开</code></p>
<h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt;? super E&gt;"></a>下界通配符 &lt;? super E&gt;</h3><p><code>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</code></p>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src)&#123;</div><div class="line">    for (T t : src) &#123;</div><div class="line">        dst.add(t);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">public static void main(String[] args) &#123;</div><div class="line">    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();</div><div class="line">    List&lt;Animal&gt; animals = new ArrayList&lt;&gt;();</div><div class="line">    new Test3().test(animals,dogs);</div><div class="line">&#125;</div><div class="line">// Dog 是 Animal 的子类</div><div class="line">class Dog extends Animal &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h3 id="？和-T-的区别"><a href="#？和-T-的区别" class="headerlink" title="？和 T 的区别"></a>？和 T 的区别</h3><p><img src="snipaste_20190820231830.png" alt="snipaste_20190820231830.png"></p>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？不行，比如如下这种 ：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 可以</div><div class="line">T t = operate();</div><div class="line"></div><div class="line">// 不可以</div><div class="line">？car = operate();</div></pre></td></tr></table></figure></p>
<p>简单总结下：</p>
<p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
<h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 通过 T 来 确保 泛型参数的一致性</div><div class="line">public &lt;T extends Number&gt; voidtest(List&lt;T&gt; dest, List&lt;T&gt; src)</div><div class="line"></div><div class="line">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</div><div class="line">public voidtest(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</div></pre></td></tr></table></figure>
<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错</p>
<p><img src="snipaste_20190820232930.png" alt="snipaste_20190820232930.png"></p>
<p>不能保证两个 List 具有相同的元素类型的情况  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric&lt;&gt;();</div><div class="line">List&lt;String&gt; dest = new ArrayList&lt;&gt;();</div><div class="line">List&lt;Number&gt; src = new ArrayList&lt;&gt;();</div><div class="line">glmapperGeneric.testNon(dest,src);</div></pre></td></tr></table></figure>
<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><p><img src="snipaste_20190820233746.png" alt="snipaste_20190820233746.png"></p>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。  </p>
<h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">T extends A</div></pre></td></tr></table></figure></p>
<p>但是通配符 ? 可以进行 两种限定：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">? extends A? super A</div></pre></td></tr></table></figure></p>
<h2 id="Class-和-Class-lt-gt-区别"><a href="#Class-和-Class-lt-gt-区别" class="headerlink" title="Class 和 Class&lt;?&gt; 区别"></a>Class<t> 和 Class&lt;?&gt; 区别</t></h2><p>前面介绍了 ？和 T 的区别，那么对于，Class<t> 和 <class<?> 又有什么区别呢？  </class<?></t></p>
<p>Class<t> 和 Class&lt;?&gt; 最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</t></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 通过反射的方式生成  multiLimit </div><div class="line">// 对象，这里比较明显的是，我们需要使用强制类型转换</div><div class="line">MultiLimit multiLimit = (MultiLimit)Class.forName(&quot;com.glmapper.bridge.boot.generic.MultiLimit&quot;).newInstance();</div></pre></td></tr></table></figure>
<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p>
<p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<p><img src="snipaste_20190820234305.png" alt="snipaste_20190820234305.png"></p>
<p>Class<t> 在实例化的时候，T 要替换成具体类。Class&lt;?&gt; 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：  </t></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 可以public Class&lt;?&gt; clazz;// 不可以，因为 T 需要指定类型public Class&lt;T&gt; clazzT;</div></pre></td></tr></table></figure>
<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个Class&lt;?&gt;</p>
<p><img src="snipaste_20190820234442.png" alt="snipaste_20190820234442.png"></p>
<p>那如果也想 public Class<t> clazzT; 这样的话，就必须让当前的类也指定 T ，  </t></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Test3&lt;T&gt; &#123;    </div><div class="line">	public Class&lt;?&gt; clazz;    </div><div class="line">	// 不会报错    </div><div class="line">	public Class&lt;T&gt; clazzT;</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/Y_f_LNbCc-iRg9JfZa8CPw" target="_blank" rel="external">https://mp.weixin.qq.com/s/Y_f_LNbCc-iRg9JfZa8CPw</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU</title>
    <url>/2017/09/22/LRU/</url>
    <content><![CDATA[<p>淘汰算法–LRU算法</p>
<a id="more"></a>
<h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>最常见的实现是使用一个链表保存缓存数据，详细算法实现如下<br><img src="1337859321_3597.png" alt="1337859321_3597.png"></p>
<ol>
<li>新数据插入到链表头部；</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</li>
<li>当链表满的时候，将链表尾部的数据丢弃。</li>
</ol>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>【命中率】<br>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p>
<p>【复杂度】<br>实现简单。</p>
<p>【代价】<br>命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部</p>
<h2 id="LRU-K"><a href="#LRU-K" class="headerlink" title="LRU-K"></a>LRU-K</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下</p>
<p><img src="1337859332_7838.png" alt="1337859332_7838.png"></p>
<ol>
<li>数据第一次被访问，加入到访问历史列表；</li>
<li>如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</li>
<li>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</li>
<li>缓存数据队列中被再次访问后，重新排序；</li>
<li>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</li>
</ol>
<p>LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。</p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>【命中率】<br>LRU-K降低了“缓存污染”带来的问题，命中率比LRU要高。</p>
<p>【复杂度】<br>LRU-K队列是一个优先级队列，算法复杂度和代价比较高。</p>
<p>【代价】<br>由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多；当数据量很大的时候，内存消耗会比较可观。</p>
<p>LRU-K需要基于时间进行排序（可以需要淘汰时再排序，也可以即时排序），CPU消耗比LRU要高。</p>
<h2 id="Two-queues-2Q"><a href="#Two-queues-2Q" class="headerlink" title="Two queues(2Q)"></a>Two queues(2Q)</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>Two queues（以下使用2Q代替）算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。</p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下</p>
<p><img src="1337859339_6844.png" alt="1337859339_6844.png"></p>
<ol>
<li>新访问的数据插入到FIFO队列；</li>
<li>如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</li>
<li>如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</li>
<li>如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</li>
<li>LRU队列淘汰末尾的数据。</li>
</ol>
<p>注：上图中FIFO队列比LRU队列短，但并不代表这是算法要求，实际应用中两者比例没有硬性规定。</p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>【命中率】<br>2Q算法的命中率要高于LRU。</p>
<p>【复杂度】<br>需要两个队列，但两个队列本身都比较简单。</p>
<p>【代价】<br>FIFO和LRU的代价之和。</p>
<p>2Q算法和LRU-2算法命中率类似，内存消耗也比较接近，但对于最后缓存的数据来说，2Q会减少一次从原始存储读取数据或者计算数据的操作</p>
<h2 id="Multi-Queue（MQ）"><a href="#Multi-Queue（MQ）" class="headerlink" title="Multi Queue（MQ）"></a>Multi Queue（MQ）</h2><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>MQ算法根据访问频率将数据划分为多个队列，不同的队列具有不同的访问优先级，其核心思想是：优先缓存访问次数多的数据</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><p>MQ算法将缓存划分为多个LRU队列，每个队列对应不同的访问优先级。访问优先级是根据访问次数计算出来的，例如</p>
<p>详细的算法结构图如下，Q0，Q1….Qk代表不同的优先级队列，Q-history代表从缓存中淘汰数据，但记录了数据的索引和引用次数的队列</p>
<p><img src="1337859354_3696.png" alt="1337859354_3696.png"></p>
<p>如上图，算法详细描述如下：</p>
<ol>
<li>新插入的数据放入Q0；</li>
<li>每个队列按照LRU管理数据；</li>
<li>当数据的访问次数达到一定次数，需要提升优先级时，将数据从当前队列删除，加入到高一级队列的头部；</li>
<li>为了防止高优先级数据永远不被淘汰，当数据在指定的时间里访问没有被访问时，需要降低优先级，将数据从当前队列删除，加入到低一级的队列头部；</li>
<li>需要淘汰数据时，从最低一级队列开始按照LRU淘汰；每个队列淘汰数据时，将数据从缓存中删除，将数据索引加入Q-history头部；</li>
<li>如果数据在Q-history中被重新访问，则重新计算其优先级，移到目标队列的头部；</li>
<li>Q-history按照LRU淘汰数据的索引。</li>
</ol>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>【命中率】<br>MQ降低了“缓存污染”带来的问题，命中率比LRU要高。</p>
<p>【复杂度】<br>MQ需要维护多个队列，且需要维护每个数据的访问时间，复杂度比LRU高。</p>
<p>【代价】<br>MQ需要记录每个数据的访问时间，需要定时扫描所有队列，代价比LRU要高。</p>
<p>注：虽然MQ的队列看起来数量比较多，但由于所有队列之和受限于缓存容量的大小，因此这里多个队列长度之和和一个LRU队列是一样的，因此队列扫描性能也相近。</p>
<h2 id="LRU类算法对比"><a href="#LRU类算法对比" class="headerlink" title="LRU类算法对比"></a>LRU类算法对比</h2><p>由于不同的访问模型导致命中率变化较大，此处对比仅基于理论定性分析，不做定量分析。</p>
<table>
<thead>
<tr>
<th style="text-align:left">对比点</th>
<th style="text-align:left">对比</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">命中率</td>
<td style="text-align:left">LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</td>
</tr>
<tr>
<td style="text-align:left">复杂度</td>
<td style="text-align:left">LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</td>
</tr>
<tr>
<td style="text-align:left">代价</td>
<td style="text-align:left">LRU-2  &gt; MQ(2) &gt; 2Q &gt; LRU</td>
</tr>
</tbody>
</table>
<p>实际应用中需要根据业务的需求和对数据的访问情况进行选择，并不是命中率越高越好。例如：虽然LRU看起来命中率会低一些，且存在”缓存污染“的问题，但由于其简单和代价小，实际应用中反而应用更多</p>
<h2 id="LRU-算法实现"><a href="#LRU-算法实现" class="headerlink" title="LRU 算法实现"></a>LRU 算法实现</h2><p>java中最简单的LRU算法实现，就是利用jdk的LinkedHashMap，覆写其中的removeEldestEntry(Map.Entry)方法即可</p>
<p>如果你去看LinkedHashMap的源码可知，LRU算法是通过双向链表来实现，当某个位置被命中，通过调整链表的指向将该位置调整到头位置，新加入的内容直接放在链表头，如此一来，最近被命中的内容就向链表头移动，需要替换时，链表最后的位置就是最近最少使用的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList; </div><div class="line"><span class="keyword">import</span> java.util.Collection; </div><div class="line"><span class="keyword">import</span> java.util.LinkedHashMap; </div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock; </div><div class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock; </div><div class="line"><span class="keyword">import</span> java.util.Map; </div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line"> * 类说明：利用LinkedHashMap实现简单的缓存， 必须实现removeEldestEntry方法，具体参见JDK文档</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> dennis</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> &lt;K&gt;</div><div class="line"> * <span class="doctag">@param</span> &lt;V&gt;</div><div class="line"> */ </div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRULinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123; </div><div class="line"> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxCapacity; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; </div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock(); </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRULinkedHashMap</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123; </div><div class="line">        <span class="keyword">super</span>(maxCapacity, DEFAULT_LOAD_FACTOR, <span class="keyword">true</span>); </div><div class="line">        <span class="keyword">this</span>.maxCapacity = maxCapacity; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(java.util.Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123; </div><div class="line">        <span class="keyword">return</span> size() &gt; maxCapacity; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            lock.lock(); </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.containsKey(key); </div><div class="line">        &#125; <span class="keyword">finally</span> &#123; </div><div class="line">            lock.unlock(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            lock.lock(); </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.get(key); </div><div class="line">        &#125; <span class="keyword">finally</span> &#123; </div><div class="line">            lock.unlock(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    <span class="meta">@Override</span> </div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            lock.lock(); </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.put(key, value); </div><div class="line">        &#125; <span class="keyword">finally</span> &#123; </div><div class="line">            lock.unlock(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            lock.lock(); </div><div class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.size(); </div><div class="line">        &#125; <span class="keyword">finally</span> &#123; </div><div class="line">            lock.unlock(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            lock.lock(); </div><div class="line">            <span class="keyword">super</span>.clear(); </div><div class="line">        &#125; <span class="keyword">finally</span> &#123; </div><div class="line">            lock.unlock(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    <span class="keyword">public</span> Collection&lt;Map.Entry&lt;K, V&gt;&gt; getAll() &#123; </div><div class="line">        <span class="keyword">try</span> &#123; </div><div class="line">            lock.lock(); </div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;K, V&gt;&gt;(<span class="keyword">super</span>.entrySet()); </div><div class="line">        &#125; <span class="keyword">finally</span> &#123; </div><div class="line">            lock.unlock(); </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基于双链表 的LRU实现:</p>
<p>传统意义的LRU算法是为每一个Cache对象设置一个计数器，每次Cache命中则给计数器+1，而Cache用完，需要淘汰旧内容，放置新内容时，就查看所有的计数器，并将最少使用的内容替换掉。</p>
<p>它的弊端很明显，如果Cache的数量少，问题不会很大， 但是如果Cache的空间过大，达到10W或者100W以上，一旦需要淘汰，则需要遍历所有计算器，其性能与资源消耗是巨大的。效率也就非常的慢了。</p>
<p>它的原理： 将Cache的所有位置都用双连表连接起来，当一个位置被命中之后，就将通过调整链表的指向，将该位置调整到链表头的位置，新加入的Cache直接加到链表头中。</p>
<p>这样，在多次进行Cache操作后，最近被命中的，就会被向链表头方向移动，而没有命中的，而想链表后面移动，链表尾则表示最近最少使用的Cache。</p>
<p>当需要替换内容时候，链表的最后位置就是最少被命中的位置，我们只需要淘汰链表最后的部分即可。</p>
<p>上面说了这么多的理论， 下面用代码来实现一个LRU策略的缓存。</p>
<p>我们用一个对象来表示Cache，并实现双链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 链表节点 </div><div class="line">     * <span class="doctag">@author</span> Administrator </div><div class="line">     * </div><div class="line">     */  </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CacheNode</span> </span>&#123;  </div><div class="line">        ……  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;<span class="comment">//缓存大小  </span></div><div class="line">    <span class="keyword">private</span> Hashtable nodes;<span class="comment">//缓存容器  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;<span class="comment">//当前缓存对象数量  </span></div><div class="line">    <span class="keyword">private</span> CacheNode first;<span class="comment">//(实现双链表)链表头  </span></div><div class="line">    <span class="keyword">private</span> CacheNode last;<span class="comment">//(实现双链表)链表尾  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面给出完整的实现，这个类也被Tomcat所使用（ org.apache.tomcat.util.collections.LRUCache），但是在tomcat6.x版本中，已经被弃用，使用另外其他的缓存类来替代它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 链表节点 </div><div class="line">     * <span class="doctag">@author</span> Administrator </div><div class="line">     * </div><div class="line">     */  </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CacheNode</span> </span>&#123;  </div><div class="line">        CacheNode prev;<span class="comment">//前一节点  </span></div><div class="line">        CacheNode next;<span class="comment">//后一节点  </span></div><div class="line">        Object value;<span class="comment">//值  </span></div><div class="line">        Object key;<span class="comment">//键  </span></div><div class="line">        CacheNode() &#123; &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;  </div><div class="line">        currentSize = <span class="number">0</span>;  </div><div class="line">        cacheSize = i;  </div><div class="line">        nodes = <span class="keyword">new</span> Hashtable(i);<span class="comment">//缓存容器  </span></div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 获取缓存中对象 </div><div class="line">     * <span class="doctag">@param</span> key </div><div class="line">     * <span class="doctag">@return</span> </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">        CacheNode node = (CacheNode) nodes.get(key);  </div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </div><div class="line">            moveToHead(node);  </div><div class="line">            <span class="keyword">return</span> node.value;  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 添加缓存 </div><div class="line">     * <span class="doctag">@param</span> key </div><div class="line">     * <span class="doctag">@param</span> value </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object key, Object value)</span> </span>&#123;  </div><div class="line">        CacheNode node = (CacheNode) nodes.get(key);  </div><div class="line">          </div><div class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="comment">//缓存容器是否已经超过大小.  </span></div><div class="line">            <span class="keyword">if</span> (currentSize &gt;= cacheSize) &#123;  </div><div class="line">                <span class="keyword">if</span> (last != <span class="keyword">null</span>)<span class="comment">//将最少使用的删除  </span></div><div class="line">                    nodes.remove(last.key);  </div><div class="line">                removeLast();  </div><div class="line">            &#125; <span class="keyword">else</span> &#123;  </div><div class="line">                currentSize++;  </div><div class="line">            &#125;  </div><div class="line">              </div><div class="line">            node = <span class="keyword">new</span> CacheNode();  </div><div class="line">        &#125;  </div><div class="line">        node.value = value;  </div><div class="line">        node.key = key;  </div><div class="line">        <span class="comment">//将最新使用的节点放到链表头，表示最新使用的.  </span></div><div class="line">        moveToHead(node);  </div><div class="line">        nodes.put(key, node);  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 将缓存删除 </div><div class="line">     * <span class="doctag">@param</span> key </div><div class="line">     * <span class="doctag">@return</span> </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">        CacheNode node = (CacheNode) nodes.get(key);  </div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">if</span> (node.prev != <span class="keyword">null</span>) &#123;  </div><div class="line">                node.prev.next = node.next;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) &#123;  </div><div class="line">                node.next.prev = node.prev;  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">if</span> (last == node)  </div><div class="line">                last = node.prev;  </div><div class="line">            <span class="keyword">if</span> (first == node)  </div><div class="line">                first = node.next;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> node;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;  </div><div class="line">        first = <span class="keyword">null</span>;  </div><div class="line">        last = <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 删除链表尾部节点 </div><div class="line">     *  表示 删除最少使用的缓存对象 </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLast</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="comment">//链表尾不为空,则将链表尾指向null. 删除连表尾（删除最少使用的缓存对象）  </span></div><div class="line">        <span class="keyword">if</span> (last != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">if</span> (last.prev != <span class="keyword">null</span>)  </div><div class="line">                last.prev.next = <span class="keyword">null</span>;  </div><div class="line">            <span class="keyword">else</span>  </div><div class="line">                first = <span class="keyword">null</span>;  </div><div class="line">            last = last.prev;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    <span class="comment">/** </span></div><div class="line">     * 移动到链表头，表示这个节点是最新使用过的 </div><div class="line">     * <span class="doctag">@param</span> node </div><div class="line">     */  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(CacheNode node)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span> (node == first)  </div><div class="line">            <span class="keyword">return</span>;  </div><div class="line">        <span class="keyword">if</span> (node.prev != <span class="keyword">null</span>)  </div><div class="line">            node.prev.next = node.next;  </div><div class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)  </div><div class="line">            node.next.prev = node.prev;  </div><div class="line">        <span class="keyword">if</span> (last == node)  </div><div class="line">            last = node.prev;  </div><div class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;  </div><div class="line">            node.next = first;  </div><div class="line">            first.prev = node;  </div><div class="line">        &#125;  </div><div class="line">        first = node;  </div><div class="line">        node.prev = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)  </div><div class="line">            last = first;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cacheSize;  </div><div class="line">    <span class="keyword">private</span> Hashtable nodes;<span class="comment">//缓存容器  </span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;  </div><div class="line">    <span class="keyword">private</span> CacheNode first;<span class="comment">//链表头  </span></div><div class="line">    <span class="keyword">private</span> CacheNode last;<span class="comment">//链表尾  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://blog.csdn.net/crazyhuntsman/article/details/81981014" target="_blank" rel="external">https://blog.csdn.net/crazyhuntsman/article/details/81981014</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven-dependencies-dependencyManagement</title>
    <url>/2017/09/22/Maven-dependencies-dependencyManagement/</url>
    <content><![CDATA[<p>Maven中的dependencyManagement 意义</p>
<a id="more"></a>
<p>1、在Maven中<strong>dependencyManagement</strong>的作用其实相当于一个对所依赖jar包进行<strong>版本管理</strong>的管理器。</p>
<p>2、pom.xml文件中，jar的版本判断的两种途径</p>
<p>1）如果dependencies里的dependency自己没有声明version元素，那么maven就会到dependencyManagement里面去找有没有对该artifactId和groupId进行过版本声明，如果有，就继承它，如果没有就会报错，告诉你必须为dependency声明一个version。</p>
<p>2）如果dependencies中的dependency声明了version，那么无论dependencyManagement中有无对该jar的version声明，都以dependency里的version为准。</p>
<p>3、<br>1）dependencies即使在子项目中不写该依赖项，那么子项目仍然会从父项目中继承该依赖项（全部继承）</p>
<p>2）dependencyManagement里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom;另外如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。</p>
<p>4、如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//只是对版本进行管理，不会实际引入jar </div><div class="line">&lt;dependencyManagement&gt; </div><div class="line">      &lt;dependencies&gt; </div><div class="line">            &lt;dependency&gt; </div><div class="line">                &lt;groupId&gt;org.springframework&lt;/groupId&gt; </div><div class="line">                &lt;artifactId&gt;spring-core&lt;/artifactId&gt; </div><div class="line">                &lt;version&gt;3.2.7&lt;/version&gt; </div><div class="line">            &lt;/dependency&gt; </div><div class="line">    &lt;/dependencies&gt; </div><div class="line">&lt;/dependencyManagement&gt; </div><div class="line">   </div><div class="line">//会实际下载jar包 </div><div class="line">&lt;dependencies&gt; </div><div class="line">       &lt;dependency&gt; </div><div class="line">                &lt;groupId&gt;org.springframework&lt;/groupId&gt; </div><div class="line">                &lt;artifactId&gt;spring-core&lt;/artifactId&gt; </div><div class="line">       &lt;/dependency&gt; </div><div class="line">&lt;/dependencies&gt;</div></pre></td></tr></table></figure></p>
<p>ref: <a href="https://www.cnblogs.com/zhangmingcheng/p/10984036.html" target="_blank" rel="external">https://www.cnblogs.com/zhangmingcheng/p/10984036.html</a></p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql-性能优化的最佳20+条经验</title>
    <url>/2017/09/22/Mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E6%9C%80%E4%BD%B320+%E6%9D%A1%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<p>今天,数据库的操作越来越成为整个应用的性能瓶颈了,这点对于Web应用尤其明显。关于数据库的性能,这并不只是DBA才需要担心的事,而这更是我们程序员需要去关注的事情。当我们去设计数据库表结构,对操作数据库时(尤其是查表时的SQL语句),我们都需要注意数据操作的性能。这里,我们不会讲过多的SQL语句的优化,而只是针对MySQL这一Web应用最多的数据库。希望下面的这些优化技巧对你有用。</p>
<a id="more"></a>
<h2 id="1-为查询缓存优化你的查询"><a href="#1-为查询缓存优化你的查询" class="headerlink" title="1. 为查询缓存优化你的查询"></a>1. 为查询缓存优化你的查询</h2><p>大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一,而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候,这些查询结果会被放到一个缓存中,这样,后续的相同的查询就不用操作表而直接访问缓存结果了。</p>
<p>这里最主要的问题是,对于程序员来说,这个事情是很容易被忽略的。因为,我们某些查询语句会让MySQL不使用缓存。请看下面的示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 查询缓存不开启</div><div class="line">$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= CURDATE()&quot;);</div><div class="line"> </div><div class="line">// 开启查询缓存</div><div class="line">$today = date(&quot;Y-m-d&quot;);</div><div class="line">$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= &apos;$today&apos;&quot;);</div></pre></td></tr></table></figure></p>
<p>上面两条SQL语句的差别就是 CURDATE() ,MySQL的查询缓存对这个函数不起作用。所以,像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存,因为这些函数的返回是会不定的易变的。所以,你所需要的就是用一个变量来代替MySQL的函数,从而开启缓存。</p>
<h2 id="2-EXPLAIN-你的-SELECT-查询"><a href="#2-EXPLAIN-你的-SELECT-查询" class="headerlink" title="2. EXPLAIN 你的 SELECT 查询"></a>2. EXPLAIN 你的 SELECT 查询</h2><p>使用 EXPLAIN 关键字可以让你知道MySQL是如何处理你的SQL语句的。这可以帮你分析你的查询语句或是表结构的性能瓶颈。</p>
<p>EXPLAIN 的查询结果还会告诉你你的索引主键被如何利用的,你的数据表是如何被搜索和排序的……等等,等等。</p>
<p>挑一个你的SELECT语句(推荐挑选那个最复杂的,有多表联接的),把关键字EXPLAIN加到前面。你可以使用phpmyadmin来做这个事。然后,你会看到一张表格。下面的这个示例中,我们忘记加上了group_id索引,并且有表联接:<br><img src="/2017/09/22/Mysql-性能优化的最佳20+条经验/unoptimized_explain.jpg" alt="unoptimized_explain.jpg" title=""><br>当我们为 group_id 字段加上索引后:<br><img src="/2017/09/22/Mysql-性能优化的最佳20+条经验/optimized_explain.jpg" alt="optimized_explain.jpg" title=""><br>我们可以看到,前一个结果显示搜索了 7883 行,而后一个只是搜索了两个表的 9 和 16 行。查看rows列可以让我们找到潜在的性能问题。</p>
<h2 id="3-当只要一行数据时使用-LIMIT-1"><a href="#3-当只要一行数据时使用-LIMIT-1" class="headerlink" title="3. 当只要一行数据时使用 LIMIT 1"></a>3. 当只要一行数据时使用 LIMIT 1</h2><p>当你查询表的有些时候,你已经知道结果只会有一条结果,但因为你可能需要去fetch游标,或是你也许会去检查返回的记录数。</p>
<p>在这种情况下,加上 LIMIT 1 可以增加性能。这样一样,MySQL数据库引擎会在找到一条数据后停止搜索,而不是继续往后查少下一条符合记录的数据。</p>
<p>下面的示例,只是为了找一下是否有“中国”的用户,很明显,后面的会比前面的更有效率。(请注意,第一条中是Select *,第二条是Select 1)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 没有效率的:</div><div class="line">$r = mysql_query(&quot;SELECT * FROM user WHERE country = &apos;China&apos;&quot;);</div><div class="line">if (mysql_num_rows($r) &gt; 0) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 有效率的:</div><div class="line">$r = mysql_query(&quot;SELECT 1 FROM user WHERE country = &apos;China&apos; LIMIT 1&quot;);</div><div class="line">if (mysql_num_rows($r) &gt; 0) &#123;</div><div class="line">    // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-为搜索字段建索引"><a href="#4-为搜索字段建索引" class="headerlink" title="4. 为搜索字段建索引"></a>4. 为搜索字段建索引</h2><p>索引并不一定就是给主键或是唯一的字段。如果在你的表中,有某个字段你总要会经常用来做搜索,那么,请为其建立索引吧。<br><img src="/2017/09/22/Mysql-性能优化的最佳20+条经验/search_index.jpg" alt="search_index.jpg" title=""></p>
<p>从上图你可以看到那个搜索字串 “last_name LIKE ‘a%’”,一个是建了索引,一个是没有索引,性能差了4倍左右。</p>
<p>另外,你应该也需要知道什么样的搜索是不能使用正常的索引的。例如,当你需要在一篇大的文章中搜索一个词时,如: “WHERE post_content LIKE ‘%apple%’”,索引可能是没有意义的。你可能需要使用<a href="http://dev.mysql.com/doc/refman/5.1/en/fulltext-search.html" target="_blank" rel="external">MySQL全文索引</a> 或是自己做一个索引(比如说:搜索关键词或是Tag什么的)</p>
<h2 id="5-在Join表的时候使用相当类型的例-并将其索引"><a href="#5-在Join表的时候使用相当类型的例-并将其索引" class="headerlink" title="5. 在Join表的时候使用相当类型的例,并将其索引"></a>5. 在Join表的时候使用相当类型的例,并将其索引</h2><p>如果你的应用程序有很多 JOIN 查询,你应该确认两个表中Join的字段是被建过索引的。这样,MySQL内部会启动为你优化Join的SQL语句的机制。</p>
<p>而且,这些被用来Join的字段,应该是相同的类型的。例如:如果你要把 DECIMAL 字段和一个 INT 字段Join在一起,MySQL就无法使用它们的索引。对于那些STRING类型,还需要有相同的字符集才行。(两个表的字符集有可能不一样)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 在state中查找company</div><div class="line">$r = mysql_query(&quot;SELECT company_name FROM users</div><div class="line">    LEFT JOIN companies ON (users.state = companies.state)</div><div class="line">    WHERE users.id = $user_id&quot;);</div><div class="line"> </div><div class="line">// 两个 state 字段应该是被建过索引的,而且应该是相当的类型,相同的字符集。</div></pre></td></tr></table></figure></p>
<h2 id="6-千万不要-ORDER-BY-RAND"><a href="#6-千万不要-ORDER-BY-RAND" class="headerlink" title="6. 千万不要 ORDER BY RAND()"></a>6. 千万不要 ORDER BY RAND()</h2><p>想打乱返回的数据行？随机挑一个数据？真不知道谁发明了这种用法,但很多新手很喜欢这样用。但你确不了解这样做有多么可怕的性能问题。</p>
<p>如果你真的想把返回的数据行打乱了,你有N种方法可以达到这个目的。这样使用只让你的数据库的性能呈指数级的下降。这里的问题是:MySQL会不得不去执行RAND()函数(很耗CPU时间),而且这是为了每一行记录去记行,然后再对其排序。就算是你用了Limit 1也无济于事(因为要排序)</p>
<p>下面的示例是随机挑一条记录<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 千万不要这样做:</div><div class="line">$r = mysql_query(&quot;SELECT username FROM user ORDER BY RAND() LIMIT 1&quot;);</div><div class="line"> </div><div class="line">// 这要会更好:</div><div class="line">$r = mysql_query(&quot;SELECT count(*) FROM user&quot;);</div><div class="line">$d = mysql_fetch_row($r);</div><div class="line">$rand = mt_rand(0,$d[0] - 1);</div><div class="line"> </div><div class="line">$r = mysql_query(&quot;SELECT username FROM user LIMIT $rand, 1&quot;);</div></pre></td></tr></table></figure></p>
<h2 id="7-避免-SELECT"><a href="#7-避免-SELECT" class="headerlink" title="7. 避免 SELECT *"></a>7. 避免 SELECT *</h2><p>从数据库里读出越多的数据,那么查询就会变得越慢。并且,如果你的数据库服务器和WEB服务器是两台独立的服务器的话,这还会增加网络传输的负载。</p>
<p>所以,你应该养成一个需要什么就取什么的好的习惯。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 不推荐</div><div class="line">$r = mysql_query(&quot;SELECT * FROM user WHERE user_id = 1&quot;);</div><div class="line">$d = mysql_fetch_assoc($r);</div><div class="line">echo &quot;Welcome &#123;$d[&apos;username&apos;]&#125;&quot;;</div><div class="line"> </div><div class="line">// 推荐</div><div class="line">$r = mysql_query(&quot;SELECT username FROM user WHERE user_id = 1&quot;);</div><div class="line">$d = mysql_fetch_assoc($r);</div><div class="line">echo &quot;Welcome &#123;$d[&apos;username&apos;]&#125;&quot;;</div></pre></td></tr></table></figure></p>
<h2 id="8-永远为每张表设置一个ID"><a href="#8-永远为每张表设置一个ID" class="headerlink" title="8. 永远为每张表设置一个ID"></a>8. 永远为每张表设置一个ID</h2><p>我们应该为数据库里的每张表都设置一个ID做为其主键,而且最好的是一个INT型的(推荐使用UNSIGNED),并设置上自动增加的AUTO_INCREMENT标志。</p>
<p>就算是你 users 表有一个主键叫 “email”的字段,你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外,在你的程序中,你应该使用表的ID来构造你的数据结构。</p>
<p>而且,在MySQL数据引擎下,还有一些操作需要使用主键,在这些情况下,主键的性能和设置变得非常重要,比如,集群,分区……</p>
<p>在这里,只有一个情况是例外,那就是“关联表”的“外键”,也就是说,这个表的主键,通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如:有一个“学生表”有学生的ID,有一个“课程表”有课程ID,那么,“成绩表”就是“关联表”了,其关联了学生表和课程表,在成绩表中,学生ID和课程ID叫“外键”其共同组成主键。</p>
<h2 id="9-使用-ENUM-而不是-VARCHAR"><a href="#9-使用-ENUM-而不是-VARCHAR" class="headerlink" title="9. 使用 ENUM 而不是 VARCHAR"></a>9. 使用 ENUM 而不是 VARCHAR</h2><p><a href="http://dev.mysql.com/doc/refman/5.0/en/enum.html" target="_blank" rel="external">ENUM</a> 类型是非常快和紧凑的。在实际上,其保存的是 TINYINT,但其外表上显示为字符串。这样一来,用这个字段来做一些选项列表变得相当的完美。</p>
<p>如果你有一个字段,比如“性别”,“国家”,“民族”,“状态”或“部门”,你知道这些字段的取值是有限而且固定的,那么,你应该使用 ENUM 而不是 VARCHAR。</p>
<p>MySQL也有一个“建议”(见第十条)告诉你怎么去重新组织你的表结构。当你有一个 VARCHAR 字段时,这个建议会告诉你把其改成 ENUM 类型。使用 PROCEDURE ANALYSE() 你可以得到相关的建议。</p>
<h2 id="10-从-PROCEDURE-ANALYSE-取得建议"><a href="#10-从-PROCEDURE-ANALYSE-取得建议" class="headerlink" title="10. 从 PROCEDURE ANALYSE() 取得建议"></a>10. 从 PROCEDURE ANALYSE() 取得建议</h2><p><a href="http://dev.mysql.com/doc/refman/5.0/en/procedure-analyse.html" target="_blank" rel="external">PROCEDURE ANALYSE()</a> 会让 MySQL 帮你去分析你的字段和其实际的数据,并会给你一些有用的建议。只有表中有实际的数据,这些建议才会变得有用,因为要做一些大的决定是需要有数据作为基础的。</p>
<p>例如,如果你创建了一个 INT 字段作为你的主键,然而并没有太多的数据,那么,PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段,因为数据不多,你可能会得到一个让你把它改成 ENUM 的建议。这些建议,都是可能因为数据不够多,所以决策做得就不够准。</p>
<p>在phpmyadmin里,你可以在查看表时,点击 “Propose table structure” 来查看这些建议<br><br>一定要注意,这些只是建议,只有当你的表里的数据越来越多时,这些建议才会变得准确。一定要记住,你才是最终做决定的人。</p>
<h2 id="11-尽可能的使用-NOT-NULL"><a href="#11-尽可能的使用-NOT-NULL" class="headerlink" title="11. 尽可能的使用 NOT NULL"></a>11. 尽可能的使用 NOT NULL</h2><p>除非你有一个很特别的原因去使用 NULL 值,你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议,请往下看。</p>
<p>首先,问问你自己“Empty”和“NULL”有多大的区别(如果是INT,那就是0和NULL)？如果你觉得它们之间没有什么区别,那么你就不要使用NULL。(你知道吗？在 Oracle 里,NULL 和 Empty 的字符串是一样的！)</p>
<p>不要以为 NULL 不需要空间,其需要额外的空间,并且,在你进行比较的时候,你的程序会更复杂。 当然,这里并不是说你就不能使用NULL了,现实情况是很复杂的,依然会有些情况下,你需要使用NULL值。</p>
<p>下面摘自MySQL自己的文档:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">“NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.”</div></pre></td></tr></table></figure></p>
<h2 id="12-Prepared-Statements"><a href="#12-Prepared-Statements" class="headerlink" title="12. Prepared Statements"></a>12. Prepared Statements</h2><p>Prepared Statements很像存储过程,是一种运行在后台的SQL语句集合,我们可以从使用 prepared statements 获得很多好处,无论是性能问题还是安全问题。</p>
<p>Prepared Statements 可以检查一些你绑定好的变量,这样可以保护你的程序不会受到“SQL注入式”攻击。当然,你也可以手动地检查你的这些变量,然而,手动的检查容易出问题,而且很经常会被程序员忘了。当我们使用一些framework或是ORM的时候,这样的问题会好一些。</p>
<p>在性能方面,当一个相同的查询被使用多次的时候,这会为你带来可观的性能优势。你可以给这些Prepared Statements定义一些参数,而MySQL只会解析一次。</p>
<p>虽然最新版本的MySQL在传输Prepared Statements是使用二进制形势,所以这会使得网络传输非常有效率。</p>
<p>当然,也有一些情况下,我们需要避免使用Prepared Statements,因为其不支持查询缓存。但据说版本5.1后支持了。</p>
<p>在PHP中要使用prepared statements,你可以查看其使用手册:mysqli 扩展 或是使用数据库抽象层,如: PDO.<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 创建 prepared statement</div><div class="line">if ($stmt = $mysqli-&gt;prepare(&quot;SELECT username FROM user WHERE state=?&quot;)) &#123;</div><div class="line"> </div><div class="line">    // 绑定参数</div><div class="line">    $stmt-&gt;bind_param(&quot;s&quot;, $state);</div><div class="line"> </div><div class="line">    // 执行</div><div class="line">    $stmt-&gt;execute();</div><div class="line"> </div><div class="line">    // 绑定结果</div><div class="line">    $stmt-&gt;bind_result($username);</div><div class="line"> </div><div class="line">    // 移动游标</div><div class="line">    $stmt-&gt;fetch();</div><div class="line"> </div><div class="line">    printf(&quot;%s is from %s\n&quot;, $username, $state);</div><div class="line"> </div><div class="line">    $stmt-&gt;close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="13-无缓冲的查询"><a href="#13-无缓冲的查询" class="headerlink" title="13. 无缓冲的查询"></a>13. 无缓冲的查询</h2><p>正常的情况下,当你在当你在你的脚本中执行一个SQL语句的时候,你的程序会停在那里直到没这个SQL语句返回,然后你的程序再往下继续执行。你可以使用无缓冲查询来改变这个行为。</p>
<p>关于这个事情,在PHP的文档中有一个非常不错的说明: mysql_unbuffered_query() 函数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">“mysql_unbuffered_query() sends the SQL query query to MySQL without automatically fetching and buffering the result rows as mysql_query() does. This saves a considerable amount of memory with SQL queries that produce large result sets, and you can start working on the result set immediately after the first row has been retrieved as you don’t have to wait until the complete SQL query has been performed.”</div></pre></td></tr></table></figure></p>
<p>上面那句话翻译过来是说,mysql_unbuffered_query() 发送一个SQL语句到MySQL而并不像mysql_query()一样去自动fethch和缓存结果。这会相当节约很多可观的内存,尤其是那些会产生大量结果的查询语句,并且,你不需要等到所有的结果都返回,只需要第一行数据返回的时候,你就可以开始马上开始工作于查询结果了。</p>
<p>然而,这会有一些限制。因为你要么把所有行都读走,或是你要在进行下一次的查询前调用 mysql_free_result() 清除结果。而且, mysql_num_rows() 或 mysql_data_seek() 将无法使用。所以,是否使用无缓冲的查询你需要仔细考虑。</p>
<h2 id="14-把IP地址存成-UNSIGNED-INT"><a href="#14-把IP地址存成-UNSIGNED-INT" class="headerlink" title="14. 把IP地址存成 UNSIGNED INT"></a>14. 把IP地址存成 UNSIGNED INT</h2><p>很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放,只需要4个字节,并且你可以有定长的字段。而且,这会为你带来查询上的优势,尤其是当你需要使用这样的WHERE条件:IP between ip1 and ip2。</p>
<p>我们必需要使用UNSIGNED INT,因为 IP地址会使用整个32位的无符号整形。</p>
<p>而你的查询,你可以使用 <a href="http://dev.mysql.com/doc/refman/5.0/en/miscellaneous-functions.html#function_inet-aton" target="_blank" rel="external">INET_ATON()</a> 来把一个字符串IP转成一个整形,并使用 <a href="http://dev.mysql.com/doc/refman/5.0/en/miscellaneous-functions.html#function_inet-ntoa" target="_blank" rel="external">INET_NTOA()</a> 把一个整形转成一个字符串IP。在PHP中,也有这样的函数 ip2long() 和 long2ip()。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$r = &quot;UPDATE users SET ip = INET_ATON(&apos;&#123;$_SERVER[&apos;REMOTE_ADDR&apos;]&#125;&apos;) WHERE user_id = $user_id&quot;;</div></pre></td></tr></table></figure></p>
<h2 id="15-固定长度的表会更快"><a href="#15-固定长度的表会更快" class="headerlink" title="15. 固定长度的表会更快"></a>15. 固定长度的表会更快</h2><p>如果表中的所有字段都是“固定长度”的,整个表会被认为是 <a href="http://dev.mysql.com/doc/refman/5.1/en/static-format.html" target="_blank" rel="external">“static” 或 “fixed-length”</a>。 例如,表中没有如下类型的字段: VARCHAR,TEXT,BLOB。只要你包括了其中一个这些字段,那么这个表就不是“固定长度静态表”了,这样,MySQL 引擎会用另一种方法来处理。</p>
<p>固定长度的表会提高性能,因为MySQL搜寻得会更快一些,因为这些固定的长度是很容易计算下一个数据的偏移量的,所以读取的自然也会很快。而如果字段不是定长的,那么,每一次要找下一条的话,需要程序找到主键。</p>
<p>并且,固定长度的表也更容易被缓存和重建。不过,唯一的副作用是,固定长度的字段会浪费一些空间,因为定长的字段无论你用不用,他都是要分配那么多的空间。</p>
<p>使用“垂直分割”技术(见下一条),你可以分割你的表成为两个一个是定长的,一个则是不定长的。</p>
<h2 id="16-垂直分割"><a href="#16-垂直分割" class="headerlink" title="16. 垂直分割"></a>16. 垂直分割</h2><p>“垂直分割”是一种把数据库中的表按列变成几张表的方法,这样可以降低表的复杂度和字段的数目,从而达到优化的目的。(以前,在银行做过项目,见过一张表有100多个字段,很恐怖)</p>
<p>示例一:在Users表中有一个字段是家庭地址,这个字段是可选字段,相比起,而且你在数据库操作的时候除了个人信息外,你并不需要经常读取或是改写这个字段。那么,为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能,大家想想是不是,大量的时候,我对于用户表来说,只有用户ID,用户名,口令,用户角色等会被经常使用。小一点的表总是会有好的性能。</p>
<p>示例二: 你有一个叫 “last_login” 的字段,它会在每次用户登录时被更新。但是,每次更新时会导致该表的查询缓存被清空。所以,你可以把这个字段放到另一个表中,这样就不会影响你对用户ID,用户名,用户角色的不停地读取了,因为查询缓存会帮你增加很多性能。</p>
<p>另外,你需要注意的是,这些被分出去的字段所形成的表,你不会经常性地去Join他们,不然的话,这样的性能会比不分割时还要差,而且,会是极数级的下降。</p>
<h2 id="17-拆分大的-DELETE-或-INSERT-语句"><a href="#17-拆分大的-DELETE-或-INSERT-语句" class="headerlink" title="17. 拆分大的 DELETE 或 INSERT 语句"></a>17. 拆分大的 DELETE 或 INSERT 语句</h2><p>如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询,你需要非常小心,要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的,表一锁住了,别的操作都进不来了。</p>
<p>Apache 会有很多的子进程或线程。所以,其工作起来相当有效率,而我们的服务器也不希望有太多的子进程,线程和数据库链接,这是极大的占服务器资源的事情,尤其是内存。</p>
<p>如果你把你的表锁上一段时间,比如30秒钟,那么对于一个有很高访问量的站点来说,这30秒所积累的访问进程/线程,数据库链接,打开的文件数,可能不仅仅会让你泊WEB服务Crash,还可能会让你的整台服务器马上掛了。</p>
<p>所以,如果你有一个大的处理,你定你一定把其拆分,使用 LIMIT 条件是一个好的方法。下面是一个示例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">while (1) &#123;</div><div class="line">    //每次只做1000条</div><div class="line">    mysql_query(&quot;DELETE FROM logs WHERE log_date &lt;= &apos;2009-11-01&apos; LIMIT 1000&quot;);</div><div class="line">    if (mysql_affected_rows() == 0) &#123;</div><div class="line">        // 没得可删了,退出！</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">    // 每次都要休息一会儿</div><div class="line">    usleep(50000);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="18-越小的列会越快"><a href="#18-越小的列会越快" class="headerlink" title="18. 越小的列会越快"></a>18. 越小的列会越快</h2><p>对于大多数的数据库引擎来说,硬盘操作可能是最重大的瓶颈。所以,把你的数据变得紧凑会对这种情况非常有帮助,因为这减少了对硬盘的访问。</p>
<p>参看 MySQL 的文档 <a href="http://dev.mysql.com/doc/refman/5.0/en/storage-requirements.html" target="_blank" rel="external">Storage Requirements</a> 查看所有的数据类型。</p>
<p>如果一个表只会有几列罢了(比如说字典表,配置表),那么,我们就没有理由使用 INT 来做主键,使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间,使用 DATE 要比 DATETIME 好得多。</p>
<p>当然,你也需要留够足够的扩展空间,不然,你日后来干这个事,你会死的很难看</p>
<h2 id="19-选择正确的存储引擎"><a href="#19-选择正确的存储引擎" class="headerlink" title="19. 选择正确的存储引擎"></a>19. 选择正确的存储引擎</h2><p>在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB,每个引擎都有利有弊。酷壳以前文章《<a href="https://coolshell.cn/articles/652.html" target="_blank" rel="external">MySQL: InnoDB 还是 MyISAM?</a>》讨论和这个事情。</p>
<p>MyISAM 适合于一些需要大量查询的应用,但其对于有大量写操作并不是很好。甚至你只是需要update一个字段,整个表都会被锁起来,而别的进程,就算是读进程都无法操作直到读操作完成。另外,MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。</p>
<p>InnoDB 的趋势会是一个非常复杂的存储引擎,对于一些小的应用,它会比 MyISAM 还慢。他是它支持“行锁” ,于是在写操作比较多的时候,会更优秀。并且,他还支持更多的高级应用,比如:事务。</p>
<p>下面是MySQL的手册</p>
<ul>
<li><a href="http://dev.mysql.com/doc/refman/5.1/en/myisam-storage-engine.html" target="_blank" rel="external">target=”_blank”MyISAM Storage Engine</a></li>
<li><a href="http://dev.mysql.com/doc/refman/5.1/en/innodb.html" target="_blank" rel="external">InnoDB Storage Engine</a></li>
</ul>
<h2 id="20-使用一个对象关系映射器-Object-Relational-Mapper"><a href="#20-使用一个对象关系映射器-Object-Relational-Mapper" class="headerlink" title="20. 使用一个对象关系映射器(Object Relational Mapper)"></a>20. 使用一个对象关系映射器(Object Relational Mapper)</h2><p>使用 ORM (Object Relational Mapper),你能够获得可靠的性能增涨。一个ORM可以做的所有事情,也能被手动的编写出来。但是,这需要一个高级专家。</p>
<p>ORM 的最重要的是“Lazy Loading”,也就是说,只有在需要的去取值的时候才会去真正的去做。但你也需要小心这种机制的副作用,因为这很有可能会因为要去创建很多很多小的查询反而会降低性能。</p>
<p>ORM 还可以把你的SQL语句打包成一个事务,这会比单独执行他们快得多得多。</p>
<p>ref: <a href="https://coolshell.cn/articles/1846.html" target="_blank" rel="external">https://coolshell.cn/articles/1846.html</a></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx-conf</title>
    <url>/2017/09/22/Nginx-conf/</url>
    <content><![CDATA[<p>nginx 安装在 /usr/local/nginx 目录下(假定)，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改，所以本篇博客我们先大致介绍一下该配置文件的结构<br><img src="1120165-20180729225520207-404971432.png" alt="1120165-20180729225520207-404971432.png"></p>
<a id="more"></a>
<h2 id="nginx-conf-的主体结构"><a href="#nginx-conf-的主体结构" class="headerlink" title="nginx.conf 的主体结构"></a>nginx.conf 的主体结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#user  nobody;</div><div class="line">worker_processes  1;</div><div class="line"></div><div class="line">#error_log  logs/error.log;</div><div class="line">#error_log  logs/error.log  notice;</div><div class="line">#error_log  logs/error.log  info;</div><div class="line"></div><div class="line">#pid        logs/nginx.pid;</div><div class="line"></div><div class="line"></div><div class="line">events &#123;</div><div class="line">    worker_connections  1024;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">http &#123;</div><div class="line">    include       mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line"></div><div class="line">    #log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</div><div class="line">    #                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</div><div class="line">    #                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</div><div class="line"></div><div class="line">    #access_log  logs/access.log  main;</div><div class="line"></div><div class="line">    sendfile        on;</div><div class="line">    #tcp_nopush     on;</div><div class="line"></div><div class="line">    #keepalive_timeout  0;</div><div class="line">    keepalive_timeout  65;</div><div class="line"></div><div class="line">    #gzip  on;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        #charset koi8-r;</div><div class="line"></div><div class="line">        #access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            root   html;</div><div class="line">            index  index.html index.htm;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        #error_page  404              /404.html;</div><div class="line"></div><div class="line">        # redirect server error pages to the static page /50x.html</div><div class="line">        #</div><div class="line">        error_page   500 502 503 504  /50x.html;</div><div class="line">        location = /50x.html &#123;</div><div class="line">            root   html;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # proxy the PHP scripts to Apache listening on 127.0.0.1:80</div><div class="line">        #</div><div class="line">        #location ~ \.php$ &#123;</div><div class="line">        #    proxy_pass   http://127.0.0.1;</div><div class="line">        #&#125;</div><div class="line"></div><div class="line">        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</div><div class="line">        #</div><div class="line">        #location ~ \.php$ &#123;</div><div class="line">        #    root           html;</div><div class="line">        #    fastcgi_pass   127.0.0.1:9000;</div><div class="line">        #    fastcgi_index  index.php;</div><div class="line">        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</div><div class="line">        #    include        fastcgi_params;</div><div class="line">        #&#125;</div><div class="line"></div><div class="line">        # deny access to .htaccess files, if Apache&apos;s document root</div><div class="line">        # concurs with nginx&apos;s one</div><div class="line">        #</div><div class="line">        #location ~ /\.ht &#123;</div><div class="line">        #    deny  all;</div><div class="line">        #&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</div><div class="line">    #</div><div class="line">    #server &#123;</div><div class="line">    #    listen       8000;</div><div class="line">    #    listen       somename:8080;</div><div class="line">    #    server_name  somename  alias  another.alias;</div><div class="line"></div><div class="line">    #    location / &#123;</div><div class="line">    #        root   html;</div><div class="line">    #        index  index.html index.htm;</div><div class="line">    #    &#125;</div><div class="line">    #&#125;</div><div class="line"></div><div class="line"></div><div class="line">    # HTTPS server</div><div class="line">    #</div><div class="line">    #server &#123;</div><div class="line">    #    listen       443 ssl;</div><div class="line">    #    server_name  localhost;</div><div class="line"></div><div class="line">    #    ssl_certificate      cert.pem;</div><div class="line">    #    ssl_certificate_key  cert.key;</div><div class="line"></div><div class="line">    #    ssl_session_cache    shared:SSL:1m;</div><div class="line">    #    ssl_session_timeout  5m;</div><div class="line"></div><div class="line">    #    ssl_ciphers  HIGH:!aNULL:!MD5;</div><div class="line">    #    ssl_prefer_server_ciphers  on;</div><div class="line"></div><div class="line">    #    location / &#123;</div><div class="line">    #        root   html;</div><div class="line">    #        index  index.html index.htm;</div><div class="line">    #    &#125;</div><div class="line">    #&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>去掉注释内容，精简之后的内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">worker_processes  1;</div><div class="line"></div><div class="line">events &#123;</div><div class="line">    worker_connections  1024;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">http &#123;</div><div class="line">    include       mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line"></div><div class="line"></div><div class="line">    sendfile        on;</div><div class="line"></div><div class="line">    keepalive_timeout  65;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            root   html;</div><div class="line">            index  index.html index.htm;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        error_page   500 502 503 504  /50x.html;</div><div class="line">        location = /50x.html &#123;</div><div class="line">            root   html;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据上述文件，我们可以很明显的将 nginx.conf 配置文件分为三部分</p>
<h2 id="全局块"><a href="#全局块" class="headerlink" title="全局块"></a>全局块</h2><p>从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。</p>
<p>比如上面第一行配置的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">worker_processes  1;</div></pre></td></tr></table></figure></p>
<p>这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约，这个后面会详细介绍。</p>
<h2 id="events-块"><a href="#events-块" class="headerlink" title="events 块"></a>events 块</h2><p>比如上面的配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">events &#123;</div><div class="line">    worker_connections  1024;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。</p>
<p>上述例子就表示每个 work process 支持的最大连接数为 1024.</p>
<p>这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p>
<h2 id="http-块"><a href="#http-块" class="headerlink" title="http 块"></a>http 块</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">http &#123;</div><div class="line">    include       mime.types;</div><div class="line">    default_type  application/octet-stream;</div><div class="line"></div><div class="line">    sendfile        on;</div><div class="line"></div><div class="line">    keepalive_timeout  65;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            root   html;</div><div class="line">            index  index.html index.htm;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        error_page   500 502 503 504  /50x.html;</div><div class="line">        location = /50x.html &#123;</div><div class="line">            root   html;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。</p>
<p>需要注意的是：http 块也可以包括 <strong>http全局块、server 块</strong></p>
<p>1.<strong>http 全局块</strong><br>http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p>
<p>2.<strong>server 块</strong><br>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。后面会详细介绍虚拟主机的概念。</p>
<p>每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。</p>
<p>而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p>
<ul>
<li>全局 server 块  最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。</li>
<li>location 块  一个 server 块可以配置多个 location 块。<br>这块的主要作用是基于 Nginx  服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</li>
</ul>
<p>ref:<br><a href="https://www.cnblogs.com/ysocean/p/9384880.html" target="_blank" rel="external">https://www.cnblogs.com/ysocean/p/9384880.html</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx-反向代理</title>
    <url>/2017/09/22/Nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>Nginx 服务器的反向代理服务是其最常用的重要功能，由反向代理服务也可以衍生出很多与此相关的 Nginx 服务器重要功能，比如后面会介绍的负载均衡。本篇博客我们会先介绍 Nginx 的反向代理，当然在了解反向代理之前，我们需要先知道什么是代理以及什么是正向代理</p>
<a id="more"></a>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>在Java设计模式中，代理模式是这样定义的：给某个对象提供一个代理对象，并由代理对象控制原对象的引用。</p>
<p>可能大家不太明白这句话，在举一个现实生活中的例子：比如我们要买一间二手房，虽然我们可以自己去找房源，但是这太花费时间精力了，而且房屋质量检测以及房屋过户等一系列手续也都得我们去办，再说现在这个社会，等我们找到房源，说不定房子都已经涨价了，那么怎么办呢？最简单快捷的方法就是找二手房中介公司（为什么？别人那里房源多啊），于是我们就委托中介公司来给我找合适的房子，以及后续的质量检测过户等操作，我们只需要选好自己想要的房子，然后交钱就行了。</p>
<p>代理简单来说，就是如果我们想做什么，但又不想直接去做，那么这时候就找另外一个人帮我们去做。那么这个例子里面的中介公司就是给我们做代理服务的，我们委托中介公司帮我们找房子。</p>
<p>Nginx 主要能够代理如下几种协议，其中用到的最多的就是做Http代理服务器</p>
<p><img src="1120165-20180905232339438-913760288.png" alt="1120165-20180905232339438-913760288.png"></p>
<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>弄清楚什么是代理了，那么什么又是正向代理呢？</p>
<p>这里我再举一个例子：大家都知道，现在国内是访问不了 Google的，那么怎么才能访问 Google呢？我们又想，美国人不是能访问 Google吗（这不废话，Google就是美国的），如果我们电脑的对外公网 IP 地址能变成美国的 IP 地址，那不就可以访问 Google了。你很聪明，VPN 就是这样产生的。我们在访问 Google 时，先连上 VPN 服务器将我们的 IP 地址变成美国的 IP 地址，然后就可以顺利的访问了。</p>
<p>这里的 VPN 就是做正向代理的。正向代理服务器位于客户端和服务器之间，为了向服务器获取数据，客户端要向代理服务器发送一个请求，并指定目标服务器，代理服务器将目标服务器返回的数据转交给客户端。这里客户端是要进行一些正向代理的设置的。</p>
<p>PS：这里介绍一下什么是 VPN，VPN 通俗的讲就是一种中转服务，当我们电脑接入 VPN 后，我们对外 IP 地址就会变成 VPN 服务器的 公网 IP，我们请求或接受任何数据都会通过这个VPN 服务器然后传入到我们本机。这样做有什么好处呢？比如 VPN 游戏加速方面的原理，我们要玩网通区的 LOL，但是本机接入的是电信的宽带，玩网通区的会比较卡，这时候就利用 VPN 将电信网络变为网通网络，然后在玩网通区的LOL就不会卡了（注意：VPN 是不能增加带宽的，不要以为不卡了是因为网速提升了）。</p>
<p>可能听到这里大家还是很抽象，没关系，和下面的反向代理对比理解就简单了。</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>反向代理和正向代理的区别就是：<strong>正向代理代理客户端，反向代理代理服务器</strong>。</p>
<p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p>
<p>下面我们通过两张图来对比正向代理和方向代理：</p>
<p><img src="1120165-20180730224449157-560730759.png" alt="1120165-20180730224449157-560730759.png"></p>
<p>![1120165-20180730224512924-952923331.png]*(1120165-20180730224512924-952923331.png)</p>
<p>理解这两种代理的关键在于代理服务器所代理的对象是什么，正向代理代理的是客户端，我们需要在客户端进行一些代理的设置。而反向代理代理的是服务器，作为客户端的我们是无法感知到服务器的真实存在的。</p>
<p>总结起来还是一句话：正向代理代理客户端，反向代理代理服务器。</p>
<h2 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h2><p>范例：使用 nginx 反向代理 www.123.com 直接跳转到127.0.0.1:8080</p>
<p>①、启动一个 tomcat，浏览器地址栏输入 127.0.0.1:8080，出现如下界面</p>
<p><img src="1120165-20180905235823351-2004614694.png" alt="1120165-20180905235823351-2004614694.png"></p>
<p>②、通过修改本地 host 文件，将 www.123.com 映射到 127.0.0.1<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">127.0.0.1 www.123.com</div></pre></td></tr></table></figure></p>
<p>配置完成之后，我们便可以通过 www.123.com:8080 访问到第一步出现的 Tomcat初始界面。</p>
<p>那么如何只需要输入 www.123.com 便可以跳转到 Tomcat初始界面呢？便用到 nginx的反向代理。</p>
<p>③、在 nginx.conf 配置文件中增加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  www.123.com;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://127.0.0.1:8080;</div><div class="line">            index  index.html index.htm index.jsp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如上配置，我们监听80端口，访问域名为www.123.com，不加端口号时默认为80端口，故访问该域名时会跳转到127.0.0.1:8080路径上。</p>
<p>我们在浏览器端输入 www.123.com 结果如下：</p>
<p><img src="1120165-20180906073551600-75534434.png" alt="1120165-20180906073551600-75534434.png"></p>
<p>④、总结</p>
<p>其实这里更贴切的说是通过nginx代理端口，原先访问的是8080端口，通过nginx代理之后，通过80端口就可以访问了。</p>
<h2 id="Nginx-反向代理相关指令介绍"><a href="#Nginx-反向代理相关指令介绍" class="headerlink" title="Nginx 反向代理相关指令介绍"></a>Nginx 反向代理相关指令介绍</h2><h3 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h3><p>该指令用于配置网络监听。主要有如下三种配置语法结构：</p>
<p>一、配置监听的IP地址<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">listen address[:port] [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [deferred] [accept_filter=filter] [bind] [ssl];</div></pre></td></tr></table></figure></p>
<p>二、配置监听端口<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">listen port[default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [ssl];</div></pre></td></tr></table></figure></p>
<p>三、配置 UNIX Domain Socket<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">listen unix:path [default_server]  [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ssl];</div></pre></td></tr></table></figure></p>
<p>上面的配置看似比较复杂，其实使用起来是比较简单的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">listen *:80 | *:8080 #监听所有80端口和8080端口</div><div class="line">listen  IP_address:port   #监听指定的地址和端口号</div><div class="line">listen  IP_address     #监听指定ip地址所有端口</div><div class="line">listen port     #监听该端口的所有IP连接</div></pre></td></tr></table></figure>
<p>下面分别解释每个选项的具体含义：</p>
<ol>
<li>address:IP地址，如果是 IPV6地址，需要使用中括号[] 括起来，比如[fe80::1]等。</li>
<li>port:端口号，如果只定义了IP地址，没有定义端口号，那么就使用80端口。</li>
<li>path:socket文件路径，如 var/run/nginx.sock等。</li>
<li>default_server:标识符，将此虚拟主机设置为 address:port 的默认主机。（在 nginx-0.8.21 之前使用的是 default 指令）</li>
<li>setfib=number:Nginx-0.8.44 中使用这个变量监听 socket 关联路由表，目前只对 FreeBSD 起作用，不常用。</li>
<li>backlog=number:设置监听函数listen()最多允许多少网络连接同时处于挂起状态，在 FreeBSD 中默认为 -1,其他平台默认为511.</li>
<li>rcvbuf=size:设置监听socket接收缓存区大小。</li>
<li>sndbuf=size:设置监听socket发送缓存区大小。</li>
<li>deferred:标识符，将accept()设置为Deferred模式。</li>
<li>accept_filter=filter:设置监听端口对所有请求进行过滤，被过滤的内容不能被接收和处理，本指令只在 FreeBSD 和 NetBSD 5.0+ 平台下有效。filter 可以设置为 dataready 或 httpready 。</li>
<li>bind:标识符，使用独立的bind() 处理此address:port，一般情况下，对于端口相同而IP地址不同的多个连接，Nginx 服务器将只使用一个监听指令，并使用 bind() 处理端口相同的所有连接。</li>
<li>ssl:标识符，设置会话连接使用 SSL模式进行，此标识符和Nginx服务器提供的 HTTPS 服务有关。</li>
</ol>
<h3 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a>server_name</h3><p>该指令用于虚拟主机的配置。通常分为以下两种：</p>
<h4 id="基于名称的虚拟主机配置"><a href="#基于名称的虚拟主机配置" class="headerlink" title="基于名称的虚拟主机配置"></a>基于名称的虚拟主机配置</h4><p>语法格式如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server_name   name ...;</div></pre></td></tr></table></figure></p>
<p>一、对于name 来说，可以只有一个名称，也可以有多个名称，中间用空格隔开。而每个名字由两段或者三段组成，每段之间用“.”隔开。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server_name 123.com www.123.com</div><div class="line">``` </div><div class="line"></div><div class="line">二、可以使用通配符“*”，但通配符只能用在由三段字符组成的首段或者尾端，或者由两端字符组成的尾端。</div><div class="line"></div><div class="line">``` </div><div class="line">server_name *.123.com www.123.*</div><div class="line">``` </div><div class="line"></div><div class="line">三、还可以使用正则表达式，用“~”作为正则表达式字符串的开始标记。</div><div class="line">``` </div><div class="line">server_name ~^www\d+\.123\.com$;</div><div class="line">``` </div><div class="line">该表达式“~”表示匹配正则表达式，以www开头（“^”表示开头），紧跟着一个0~9之间的数字，在紧跟“.123.co”，最后跟着“m”($表示结尾)</div><div class="line"></div><div class="line">以上匹配的顺序优先级如下：</div></pre></td></tr></table></figure></p>
<p>①、准确匹配 server_name<br>②、通配符在开始时匹配 server_name 成功<br>③、通配符在结尾时匹配 server_name 成功<br>④、正则表达式匹配 server_name 成功<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">#### 基于 IP 地址的虚拟主机配置</div><div class="line"></div><div class="line">语法结构和基于域名匹配一样，而且不需要考虑通配符和正则表达式的问题。</div></pre></td></tr></table></figure></p>
<p>server_name 192.168.1.1<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">### location</div><div class="line"></div><div class="line">该指令用于匹配 URL。</div><div class="line"></div><div class="line">语法如下：</div></pre></td></tr></table></figure></p>
<p>location [ = | ~ | ~* | ^~] uri {</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. = ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。</div><div class="line">2. ~：用于表示 uri 包含正则表达式，并且区分大小写。</div><div class="line">3. ~*：用于表示 uri 包含正则表达式，并且不区分大小写。</div><div class="line">4. ^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。</div><div class="line">注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。</div><div class="line"></div><div class="line">### proxy_pass</div><div class="line"></div><div class="line">该指令用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式。</div><div class="line"></div><div class="line">语法结构如下：</div></pre></td></tr></table></figure></p>
<p>proxy_pass URL;<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">URL 为被代理服务器的地址，可以包含传输协议、主机名称或IP地址加端口号，URI等。</div></pre></td></tr></table></figure></p>
<p>proxy_pass  <a href="http://www.123.com/uri" target="_blank" rel="external">http://www.123.com/uri</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">### index</div><div class="line"></div><div class="line">该指令用于设置网站的默认首页。</div><div class="line"></div><div class="line">语法为：</div></pre></td></tr></table></figure></p>
<p>index  filename …;<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">后面的文件名称可以有多个，中间用空格隔开。</div></pre></td></tr></table></figure></p>
<p>index  index.html index.jsp;<br>```<br>通常该指令有两个作用：第一个是用户在请求访问网站时，请求地址可以不写首页名称；第二个是可以对一个请求，根据请求内容而设置不同的首页。</p>
<p>ref: <a href="https://www.cnblogs.com/ysocean/p/9392908.html" target="_blank" rel="external">https://www.cnblogs.com/ysocean/p/9392908.html</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx-负载均衡</title>
    <url>/2017/09/22/Nginx-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p>Nginx-负载均衡</p>
<a id="more"></a>
<h2 id="负载均衡的由来"><a href="#负载均衡的由来" class="headerlink" title="负载均衡的由来"></a>负载均衡的由来</h2><p>早期的系统架构，基本上都是如下形式的：<br><img src="1120165-20180908121550571-375749058.png" alt="1120165-20180908121550571-375749058.png"></p>
<p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。</p>
<p>这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？</p>
<p>我们首先想到的可能是升级服务器的配置，比如提高CPU执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？</p>
<p>上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡</p>
<p><img src="1120165-20180908131139969-1777205215.png" alt="1120165-20180908131139969-1777205215.png"></p>
<p>负载均衡完美的解决了单个服务器硬件性能瓶颈的问题，但是随着而来的如何实现负载均衡呢？客户端怎么知道要将请求发送到那个服务器去处理呢？</p>
<h2 id="Nginx实现负载均衡"><a href="#Nginx实现负载均衡" class="headerlink" title="Nginx实现负载均衡"></a>Nginx实现负载均衡</h2><p>Nginx 服务器是介于客户端和服务器之间的中介，通过上一篇博客讲解的反向代理的功能，客户端发送的请求先经过 Nginx ，然后通过 Nginx 将请求根据相应的规则分发到相应的服务器。</p>
<p><img src="1120165-20180908131700302-1529457842.png" alt="1120165-20180908131700302-1529457842.png"></p>
<p>主要配置指令为上一讲的 pass_proxy 指令以及 upstream 指令。负载均衡主要通过专门的硬件设备或者软件算法实现。通过硬件设备实现的负载均衡效果好、效率高、性能稳定，但是成本较高。而通过软件实现的负载均衡主要依赖于均衡算法的选择和程序的健壮性。均衡算法又主要分为两大类：</p>
<ul>
<li>静态负载均衡算法：主要包括轮询算法、基于比率的加权轮询算法或者基于优先级的加权轮询算法。</li>
<li>动态负载均衡算法：主要包括基于任务量的最少连接优化算法、基于性能的最快响应优先算法、预测算法及动态性能分配算法等。</li>
</ul>
<p>静态负载均衡算法在一般网络环境下也能表现的比较好，动态负载均衡算法更加适用于复杂的网络环境。</p>
<p>例子：</p>
<p>①、<strong>普通轮询算法</strong><br>这是Nginx 默认的轮询算法。</p>
<p>例子：两台相同的Tomcat服务器，通过 localhost:8080 访问Tomcat1，通过 localhost:8081访问Tomcat2，现在我们要输入 localhost 这个地址，可以在这两个Tomcat服务器之间进行交替访问。</p>
<p>一、分别修改两个Tomcat服务器的端口为8080和8081。然后再修改Tomcat的首页，使得访问这两个页面时能够区分。如下：</p>
<p>修改端口号文件为 server.xml ：<br><img src="1120165-20180908145855894-2044798993.png" alt="1120165-20180908145855894-2044798993.png"></p>
<p>修改首页的路径为：webapps/ROOT/index.jsp</p>
<p><img src="1120165-20180908150006858-630938275.png" alt="1120165-20180908150006858-630938275.png"></p>
<p>修改完成之后，分别启动这两个Tomcat服务器，然后分别输入相应的地址端口号：</p>
<p>输入地址：localhost:8081</p>
<p><img src="1120165-20180908150514476-1375755078.png" alt="1120165-20180908150514476-1375755078.png"></p>
<p>输入地址：localhost:8080</p>
<p><img src="1120165-20180908150452914-866570966.png" alt="1120165-20180908150452914-866570966.png"></p>
<p>二、修改 nginx 的配置文件 nginx.conf </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">upstream OrdinaryPolling &#123;</div><div class="line">    server 127.0.0.1:8080;</div><div class="line">    server 127.0.0.1:8081;</div><div class="line">    &#125;</div><div class="line">    server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://OrdinaryPolling;</div><div class="line">            index  index.html index.htm index.jsp;</div><div class="line">        </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>三、启动 nginx。然后在浏览器输入localhost 地址，观看页面变化：</p>
<p><img src="1120165-20180908152509125-1859907953.gif" alt="1120165-20180908152509125-1859907953.gif"></p>
<p>②、<strong>基于比例加权轮询</strong><br>上述两台Tomcat服务器基本上是交替进行访问的。但是这里我们有个需求：</p>
<p>由于Tomcat1服务器的配置更高点，我们希望该服务器接受更多的请求，而 Tomcat2 服务器配置低，希望其处理相对较少的请求。</p>
<p>那么这时候就用到了加权轮询机制了。</p>
<p>nginx.conf 配置文件如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">upstream OrdinaryPolling &#123;</div><div class="line">    server 127.0.0.1:8080 weight=5;</div><div class="line">    server 127.0.0.1:8081 weight=2;</div><div class="line">    &#125;</div><div class="line">    server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://OrdinaryPolling;</div><div class="line">            index  index.html index.htm index.jsp;</div><div class="line">        </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>其实对比上面不加权的轮询方式，这里在 upstream 指令中多了一个 weight 指令。该指令用于配置前面请求处理的权重，默认值为 1。</p>
<p>也就是说：第一种不加权的普通轮询，其实其加权值 weight 都为 1。</p>
<p>下面我们看页面相应结果：</p>
<p><img src="1120165-20180908153300294-418662600.gif" alt="1120165-20180908153300294-418662600.gif"></p>
<p>明显 8080 端口号出现的次数更多，试验的次数越多越接近我们配置的比例。</p>
<p>③、<strong>基于IP路由负载</strong><br>我们知道一个请求在经过一个服务器处理时，服务器会保存相关的会话信息，比如session，但是该请求如果第一个服务器没处理完，通过nginx轮询到第二个服务器上，那么这个服务器是没有会话信息的。</p>
<p>最典型的一个例子：用户第一次进入一个系统是需要进行登录身份验证的，首先将请求跳转到Tomcat1服务器进行处理，登录信息是保存在Tomcat1 上的，这时候需要进行别的操作，那么可能会将请求轮询到第二个Tomcat2上，那么由于Tomcat2 没有保存会话信息，会以为该用户没有登录，然后继续登录一次，如果有多个服务器，每次第一次访问都要进行登录，这显然是很影响用户体验的。</p>
<p>这里产生的一个问题也就是集群环境下的 session 共享，如何解决这个问题？</p>
<p>通常由两种方法：</p>
<p>1、第一种方法是选择一个中间件，将登录信息保存在一个中间件上，这个中间件可以为 Redis 这样的数据库。那么第一次登录，我们将session 信息保存在 Redis 中，跳转到第二个服务器时，我们可以先去Redis上查询是否有登录信息，如果有，就能直接进行登录之后的操作了，而不用进行重复登录。</p>
<p>2、第二种方法是根据客户端的IP地址划分，每次都将同一个 IP 地址发送的请求都分发到同一个 Tomcat 服务器，那么也不会存在 session 共享的问题。</p>
<p>而 nginx 的基于 IP 路由负载的机制就是上诉第二种形式。大概配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">upstream OrdinaryPolling &#123;</div><div class="line">    ip_hash;</div><div class="line">    server 127.0.0.1:8080 weight=5;</div><div class="line">    server 127.0.0.1:8081 weight=2;</div><div class="line">    &#125;</div><div class="line">    server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://OrdinaryPolling;</div><div class="line">            index  index.html index.htm index.jsp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意：我们在 upstream 指令块中增加了 ip_hash 指令。该指令就是告诉 nginx 服务器，同一个 IP 地址客户端发送的请求都将分发到同一个 Tomcat 服务器进行处理。</p>
<p>④、<strong>基于服务器响应时间负载分配</strong><br>根据服务器处理请求的时间来进行负载，处理请求越快，也就是响应时间越短的优先分配</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">upstream OrdinaryPolling &#123;</div><div class="line">    server 127.0.0.1:8080 weight=5;</div><div class="line">    server 127.0.0.1:8081 weight=2;</div><div class="line">    fair;</div><div class="line">    &#125;</div><div class="line">    server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            proxy_pass http://OrdinaryPolling;</div><div class="line">            index  index.html index.htm index.jsp;</div><div class="line">        </div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过增加了 fair 指令。</p>
<p>⑤、<strong>对不同域名实现负载均衡</strong><br>通过配合location 指令块我们还可以实现对不同域名实现负载均衡。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">upstream wordbackend &#123;</div><div class="line">    server 127.0.0.1:8080;</div><div class="line">    server 127.0.0.1:8081;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    upstream pptbackend &#123;</div><div class="line">    server 127.0.0.1:8082;</div><div class="line">    server 127.0.0.1:8083;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        location /word/ &#123;</div><div class="line">            proxy_pass http://wordbackend;</div><div class="line">            index  index.html index.htm index.jsp;</div><div class="line">        &#125;</div><div class="line">        location /ppt/ &#123;</div><div class="line">            proxy_pass http://pptbackend;</div><div class="line">            index  index.html index.htm index.jsp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>ref: <a href="https://www.cnblogs.com/ysocean/p/9392912.html" target="_blank" rel="external">https://www.cnblogs.com/ysocean/p/9392912.html</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层协议和TCPIP四层协议</title>
    <url>/2017/09/22/OSI%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B%E5%92%8CTCPIP%E5%9B%9B%E5%B1%82%E5%8D%8F%E8%AE%AE%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>OSI七层协议和TCPIP四层协议</p>
<a id="more"></a>
<h2 id="OSI七层协议"><a href="#OSI七层协议" class="headerlink" title="OSI七层协议"></a>OSI七层协议</h2><p><img src="0_1325744597WM32.gif" alt="0_1325744597WM32.gif"></p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>　　在OSI参考模型中，物理层(Physical Layer)是参考模型的最低层。物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>　　数据链路层(Data Link Layer)是OSI模型的第二层，负责建立和管理节点间的链路。该层的主要功能是:通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。在计算机网络中由于各种干扰的存在，物理链路是不可靠的。因此，这一层的主要功能是在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。数据链路层的具体工作是接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>　　网络层(Network Layer)是OSI模型的第三层，它是OSI参考模型中最复杂的一层。它在下两层的基础上向资源子网提供服务。其主要任务是:通过路由选择算法，为报文或分组通过通信子网选择最适当的路径。具体地说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺 序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。一般地，数据链路层是解决同一网络内节点之间的通信，而网络层主要解决不同子网间的通信。例如在广域网之间通信时，必然会遇到路由(即两节点间可能有多条路径)选择问题。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>　　传输层(Transport Layer)是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。该层的主要任务是:向用户提供可靠的端到端的差错和流量控制，保证报文的正确传输。传输层的作用是向高层屏蔽下层数据通信的细节，即向用户透明地传送报文。该层常见的协议:TCP/IP中的TCP协议和UDP协议。传输层提供会话层和网络层之间的传输服务，这种服务从会话层获得数据，并在必要时，对数据进行分割。然后，传输层将数据传递到网络层，并确保数据能正确无误地传送到网络层。因此，传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作。综上，传输层的主要功能如下:监控服务质量。</p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>　　会话层(Session Layer)是OSI模型的第5层，是用户应用程序和网络之间的接口，主要任务是:向两个实体的表示层提供建立和使用连接的方法。将不同实体之间的表示层 的连接称为会话。因此会话层的任务就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。 用户可以按照半双工、单工和全双工的方式建立会话。当建立会话时，用户必须提供他们想要连接的远程地址。而这些地址与MAC(介质访问控制子层)地址或网络层的逻辑地址不同，它们是为用户专门设计的，更便于用户记忆。</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>　　表示层(Presentation Layer)是OSI模型的第六层，它对来自应用层的命令和数据进行解释，对各种语法赋予相应的含义，并按照一定的格式传送给会话层。其主要功能是“处理用户信息的表示问题，如编码、数据格式转换和加密解密”等。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>　　应用层(Application Layer)是OSI参考模型的最高层，它是计算机用户，以及各种应用程序和网络之间的接口，其功能是直接向用户提供服务，完成用户希望在网络上完成的各种工作。它在其他6层工作的基础上，负责完成网络中应用程序与网络操作系统之间的联系，建立与结束使用者之间的联系，并完成网络用户提出的各种网络服务及 应用所需的监督、管理和服务等各种协议。此外，该层还负责协调各个应用程序间的工作。</p>
<p><strong>七层结构记忆方法:应、表、会、传、网、数、物</strong></p>
<h3 id="OSI参考模型中的数据传输过程"><a href="#OSI参考模型中的数据传输过程" class="headerlink" title="OSI参考模型中的数据传输过程"></a>OSI参考模型中的数据传输过程</h3><p>在OSI参考模型中，当一台主机需要传送用户的数据(DATA)时，经历的过程如下:</p>
<ul>
<li>(DATA)数据首先通过应用层的接口进入应用层。在应用层，用户数据被加上应用层的报头(Application Header，AH)，形成应用层协议数据单元(Protocol Data Unit，PDU)，然后被递交到下一层-表示层。</li>
<li>表示层并不”关心”上层-应用层的数据格式而是把整个应用层递交的数据包看成是一个整体进行封装，即加上表示层的报头(Presentation Header，PH)。然后，递交到下层-会话层。　　</li>
<li>同样，会话层、传输层、网络层、数据链路层也都要分别给上层递交下来的数据加上自己的报头。它们是:会话层报头(Session Header，SH)、 传输层报头(Transport Header，TH)、 网络层报头(Network Header，NH)、 数据链路层报头(Data link Header，DH)。 其中，数据链路层还要给网络层递交的数据加上数据链路层报尾(Data link Termination，DT)形成最终的一帧数据。</li>
<li>当一帧数据通过物理层传送到目标主机的物理层时，该主机的物理层把它递交到上层-数据链路层。数据链路层负责去掉数据帧的帧头部DH和尾部DT(同时还进行数据校验)。如果数据没有出错，则递交到上层-网络层。</li>
<li>同样，目标主机的网络层、传输层、会话层、表示层、应用层也要做与物理层类似的去掉各个报头的工作。最终得到原始数据，并递交到目标主机的具体应用程序中。</li>
</ul>
<h2 id="OSI七层协议和TCP-IP四层协议对应关系"><a href="#OSI七层协议和TCP-IP四层协议对应关系" class="headerlink" title="OSI七层协议和TCP/IP四层协议对应关系"></a>OSI七层协议和TCP/IP四层协议对应关系</h2><p><img src="927608-20160704203635124-1548160057.jpg" alt="927608-20160704203635124-1548160057.jpg"></p>
<h2 id="协议族"><a href="#协议族" class="headerlink" title="协议族"></a>协议族</h2><h3 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h3><p>DHCP · DNS · FTP · Gopher ·GTP · HTTP · IMAP4 · IRC · NNTP · NTP · POP3 · RPC · RTCP · RTP ·RTSP · SIP · SMTP ·SNMP · SSH · SDP · SOAP .STUN. SSDP · TELNET · XMPP</p>
<h3 id="表示层-1"><a href="#表示层-1" class="headerlink" title="表示层"></a>表示层</h3><p>HTTP/HTML · FTP · Telnet · ASN.1(具有表示层功能)</p>
<h3 id="会话层-1"><a href="#会话层-1" class="headerlink" title="会话层"></a>会话层</h3><p>ADSP ·ASP ·H.245·ISO-SP ·iSNS ·NetBIOS ·PAP ·RPC·</p>
<p>RTCP ·SMPP ·SCP ·SSH ·ZIP ·SDP(具有会话层功能)</p>
<h3 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h3><p>TCP · UDP · TLS · DCCP · SCTP ·RSVP · PPTP</p>
<h3 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h3><p>IP (IPv4 · IPv6) · ICMP · ICMPv6 · IGMP ·IS-IS · IPsec · BGP · RIP · OSPF ·ARP · RARP</p>
<h3 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>Wi-Fi(IEEE 802.11) · WiMAX(IEEE 802.16) ·ATM · DTM · 令牌环 · 以太网路 ·</p>
<p>FDDI · 帧中继 · GPRS · EVDO · HSPA · HDLC · PPP · L2TP · ISDN ·STP</p>
<h3 id="物理层-1"><a href="#物理层-1" class="headerlink" title="物理层"></a>物理层</h3><p>以太网路卡 · 调制解调器 · 电力线通信(PLC) · SONET/SDH(光同步数字传输网) · </p>
<p>G.709(光传输网络) · 光导纤维 · 同轴电缆 · 双绞线</p>
<p><strong>OSI七层协议和TCP/IP四层协议的协议族图示</strong></p>
<p><img src="WX20190530-0939162x.png" alt="WX20190530-0939162x.png"></p>
<p><strong>TCP/IP协议族图示</strong></p>
<p><img src="WX20190529-1926212x.png" alt="WX20190529-1926212x.png"></p>
<h2 id="TCP-IP参考模型中的数据传输过程"><a href="#TCP-IP参考模型中的数据传输过程" class="headerlink" title="TCP/IP参考模型中的数据传输过程"></a>TCP/IP参考模型中的数据传输过程</h2><p>从上往下，每经过一层，协议就会在数据包包头上面做点手脚，加点东西，传送到接收端，再层层解套出来，如下示意图:<br><img src="20180115134155605.jpeg" alt="20180115134155605.jpeg"></p>
<h2 id="设备所在层"><a href="#设备所在层" class="headerlink" title="设备所在层"></a>设备所在层</h2><ul>
<li>物理层:网卡，网线，集线器，中继器，调制解调器</li>
<li>数据链路层:网桥，交换机</li>
<li>网络层:路由器</li>
<li>网关工作在第四层传输层及其以上</li>
</ul>
<h3 id="设备相关知识"><a href="#设备相关知识" class="headerlink" title="设备相关知识"></a>设备相关知识</h3><h4 id="交换机的工作原理"><a href="#交换机的工作原理" class="headerlink" title="交换机的工作原理"></a>交换机的工作原理</h4><p>　　交换机拥有一条很高带宽的内部总线和内部交换矩阵。交换机的所有的端口都挂接在这条总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC(网卡的硬件地址)的NIC(网卡)挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在则广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部MAC地址表中。 使用交换机也可以把网络“分段”，通过对照MAC地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的隔离广播风暴，减少误包和错包的出现，避免共享冲突。 交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，都有着自己的虚拟连接。总之，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。交换机可以”学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。</p>
<h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><p>　 　集线器的英文称为“Hub”。集线器的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。它 工作于OSI(开放系统互联参考模型)参考模型第一层，即“物理层”。集线器与网卡、网线等传输介质一样，属于局域网中的基础设备，采用 CSMA/CD(即带冲突检测的载波监听多路访问技术)介质访问控制机制。集线器每个接口简单的收发比特，收到1就转发1，收到0就转发0，不进行碰撞检 测。集线器属于纯硬件网络底层设备，基本上不具有类似于交换机的”智能记忆”能力和”学习”能力。它也不具备交换机所具有的MAC地址表，所以它发送数据 时都是没有针对性的，而是采用广播方式发送。也就是说当它要向某节点发送数据时，不是直接把数据发送到目的节点，而是把数据包发送到与集线器相连的所有节 点。HUB是一个多端口的转发器，当以HUB为中心设备时，网络中某条线路产生了故障，并不影响其它线路的工作。所以HUB在局域网中得到了广泛的应用。 大多数的时候它用在星型与树型网络拓扑结构中。</p>
<h4 id="集线器的交换机的区别"><a href="#集线器的交换机的区别" class="headerlink" title="集线器的交换机的区别"></a>集线器的交换机的区别</h4><p>　　首先说HUB,也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。而交换机(又名交换式集线器)作用与集线器大体相同。但是两者在性能上有区别:集线器采用的式共享带宽的工作方式，而交换机是独享带宽。这样在机器很多或数据量很大时，两者将会有比较明显的。</p>
<ul>
<li>工作位置不同。集线器工作在物理层，而交换机工作在数据链路层。</li>
<li>工作方式不同。集线器是一种广播方式，当集线器的某个端口工作时其他端口都能收听到信息。交换机工作时端口互不影响。</li>
<li>带宽不同。集线器是所有端口共享一条带宽，在同一时刻只能有两个端口传输数据；而交换机每个端口独占一条带宽。</li>
<li>性能不同。交换机以MAC地址进行寻址，有一定额外的寻址开销；集线器以广播方式传输数据，流量小时性能下降不明显，适用于共享总线的局域网。</li>
</ul>
<h4 id="路由器与交换机的区别"><a href="#路由器与交换机的区别" class="headerlink" title="路由器与交换机的区别:"></a>路由器与交换机的区别:</h4><p>　　总的来说，路由器与交换机的主要区别体现在以下几个方面: </p>
<ul>
<li>工作层次不同。最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。 </li>
<li>数据转发所依据的对象不同。交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。</li>
<li>传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域。由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。 </li>
<li>交换机负责同一个网段的通信，而路由器负责不同网段的通信。路由器提供了防火墙的服务。路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</li>
</ul>
<h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>　　路由表是指路由器或者其他互联网网络设备上存储的一张路由信息表，该表中存有到达特定网络终端的路径，在某些情况下，还有一些与这些路径相关的度量。路由器的主要工作就是为经过路由器的每个数据包寻找一条最佳的传输路径，并将该数据有效地传送到目的站点。由此可见，选择最佳路径的策略即路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据——路由表(Routing Table)，供路由选择时使用，表中包含的信息决定了数据转发的策略。路由表可以是由系统管理员固定设置好的，也可以由系统动态修改，可以由路由器自动调整，也可以由主机控制。</p>
<ul>
<li>静态路由表:由系统管理员事先设置好固定的路由表称之为静态(static)路由表，一般是在系统安装时就根据网络的配置情况预先设定的，它不会随未来网络结构的改变而改变。</li>
<li><p>动态路由表:动态(Dynamic)路由表是路由器根据网络系统的运行情况而自动调整的路由表。路由器根据路由选择协议(Routing Protocol)提供的功能，自动学习和记忆网络运行情况，在需要时自动计算数据传输的最佳路径。<br>　　路由器通常依靠所建立及维护的路由表来决定如何转发。路由表能力是指路由表内所容纳路由表项数量的极限。路由表中的表项内容包括:</p>
</li>
<li><p>destination mask pre costdestination:目的地址，用来标识IP包的目的地址或者目的网络。</p>
</li>
<li>mask:网络掩码，与目的地址一起标识目的主机或者路由器所在的网段的地址。</li>
<li>pre:标识路由加入IP路由表的优先级。可能到达一个目的地有多条路由，但是优先级的存在让他们先选择优先级高的路由进行利用。</li>
<li>cost:路由开销，当到达一个目的地的多个路由优先级相同时，路由开销最小的将成为最优路由。</li>
<li>interface:输出接口，说明IP包将从该路由器哪个接口转发。 nexthop:下一跳IP地址，说明IP包所经过的下一个路由器</li>
</ul>
<p>ref:<br><a href="https://www.cnblogs.com/wxgblogs/p/5641643.html" target="_blank" rel="external">https://www.cnblogs.com/wxgblogs/p/5641643.html</a><br><a href="https://blog.csdn.net/buknow/article/details/81148684" target="_blank" rel="external">https://blog.csdn.net/buknow/article/details/81148684</a><br><a href="https://www.cnblogs.com/dengyungao/p/7541831.html" target="_blank" rel="external">https://www.cnblogs.com/dengyungao/p/7541831.html</a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>OSI七层协议</tag>
        <tag>TCPIP四层协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Raft</title>
    <url>/2017/09/22/Raft/</url>
    <content><![CDATA[<p>raft是一个共识算法（consensus algorithm），所谓共识，就是多个节点对某个事情达成一致的看法，即使是在部分节点故障、网络延时、网络分割的情况下。这些年最为火热的加密货币（比特币、区块链）就需要共识算法，而在分布式系统中，共识算法更多用于提高系统的容错性，比如分布式存储中的复制集（replication），在<a href="https://www.cnblogs.com/xybaby/p/7153755.html" target="_blank" rel="external">带着问题学习分布式系统之中心化复制集</a>一文中介绍了中心化复制集的相关知识。raft协议就是一种leader-based的共识算法，与之相应的是leaderless的共识算法。</p>
<p>本文基于论文<a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14" target="_blank" rel="external">In Search of an Understandable Consensus Algorithm</a>对raft协议进行分析，当然，还是建议读者直接看论文</p>
<a id="more"></a>
<h2 id="raft算法概览"><a href="#raft算法概览" class="headerlink" title="raft算法概览"></a>raft算法概览</h2><p>Raft算法的头号目标就是容易理解（UnderStandable），这从论文的标题就可以看出来。当然，Raft增强了可理解性，在性能、可靠性、可用性方面是不输于Paxos的</p>
<p>为了达到易于理解的目标，raft做了很多努力，其中最主要是两件事情：</p>
<ul>
<li>问题分解</li>
<li>状态简化</li>
</ul>
<p>问题分解是将”复制集中节点一致性”这个复杂的问题划分为数个可以被独立解释、理解、解决的子问题。在raft，子问题包括，leader election， log replication，safety，membership changes。而状态简化更好理解，就是对算法做出一些限制，减少需要考虑的状态数，使得算法更加清晰，更少的不确定性（比如，保证新选举出来的leader会包含所有commited log entry）</p>
<p><code>Raft implements consensus by first electing a distinguished leader, then giving the leader complete responsibility for managing the replicated log. The leader accepts log entries from clients, replicates them on other servers, and tells servers when it is safe to apply log entries to their state machines. A leader can fail or become disconnected from the other servers, in which case a new leader is elected.</code></p>
<p>上面的引文对raft协议的工作原理进行了高度的概括：raft会先选举出leader，leader完全负责replicated log的管理。leader负责接受所有客户端更新请求，然后复制到follower节点，并在“安全”的时候执行这些请求。如果leader故障，followes会重新选举出新的leader。</p>
<p>这就涉及到raft最新的两个子问题： leader election和log replication</p>
<h2 id="leader-election"><a href="#leader-election" class="headerlink" title="leader election"></a>leader election</h2><p>raft协议中，一个节点任一时刻处于以下三个状态之一：</p>
<ul>
<li>leader</li>
<li>follower</li>
<li>candidate</li>
</ul>
<p>给出状态转移图能很直观的直到这三个状态的区别</p>
<p><img src="1089769-20181216202049306-1194425087.png" alt="1089769-20181216202049306-1194425087.png"></p>
<p>可以看出所有节点启动时都是follower状态；在一段时间内如果没有收到来自leader的心跳，从follower切换到candidate，发起选举；如果收到majority的造成票（含自己的一票）则切换到leader状态；如果发现其他节点比自己更新，则主动切换到follower。</p>
<p>总之，系统中最多只有一个leader，如果在一段时间里发现没有leader，则大家通过选举-投票选出leader。leader会不停的给follower发心跳消息，表明自己的存活状态。如果leader故障，那么follower会转换成candidate，重新选出leader.</p>
<h3 id="term"><a href="#term" class="headerlink" title="term"></a>term</h3><p>从上面可以看出，哪个节点做leader是大家投票选举出来的，每个leader工作一段时间，然后选出新的leader继续负责。这根民主社会的选举很像，每一届新的履职期称之为一届任期，在raft协议中，也是这样的，对应的术语叫<strong>term</strong></p>
<p><img src="1089769-20181216202155162-452543292.png" alt="1089769-20181216202155162-452543292.png"></p>
<p>term（任期）以选举（election）开始，然后就是一段或长或短的稳定工作期（normal Operation）。从上图可以看到，任期是递增的，这就充当了逻辑时钟的作用；另外，term 3展示了一种情况，就是说没有选举出leader就结束了，然后会发起新的选举，后面会解释这种split vote的情况</p>
<h3 id="选举过程详解"><a href="#选举过程详解" class="headerlink" title="选举过程详解"></a>选举过程详解</h3><p>上面已经说过，如果follower在election timeout内没有收到来自leader的心跳，（也许此时还没有选出leader，大家都在等；也许leader挂了；也许只是leader与该follower之间网络故障），则会主动发起选举。步骤如下：</p>
<ul>
<li>增加节点本地的 current term ，切换到candidate状态</li>
<li>投自己一票</li>
<li>并行给其他节点发送 RequestVote RPCs</li>
<li>等待其他节点的回复</li>
</ul>
<p>在这个过程中，根据来自其他节点的消息，可能出现三种结果</p>
<ol>
<li>收到majority的投票（含自己的一票），则赢得选举，成为leader</li>
<li>被告知别人已当选，那么自行切换到follower</li>
<li>一段时间内没有收到majority投票，则保持candidate状态，重新发出选举</li>
</ol>
<p>第一种情况，赢得了选举之后，新的leader会立刻给所有节点发消息，广而告之，避免其余节点触发新的选举。在这里，先回到投票者的视角，投票者如何决定是否给一个选举请求投票呢，有以下约束：</p>
<ul>
<li>在任一任期内，单个节点最多只能投一票</li>
<li>候选人知道的信息不能比自己的少（这一部分，后面介绍log replication和safety的时候会详细介绍）</li>
<li>first-come-first-served 先来先得</li>
</ul>
<p>第二种情况，比如有三个节点A B C。A B同时发起选举，而A的选举消息先到达C，C给A投了一票，当B的消息到达C时，已经不能满足上面提到的第一个约束，即C不会给B投票，而A和B显然都不会给对方投票。A胜出之后，会给B,C发心跳消息，节点B发现节点A的term不低于自己的term，知道有已经有Leader了，于是转换成follower。</p>
<p>第三种情况，没有任何节点获得majority投票，比如下图这种情况：</p>
<p><img src="1089769-20181216202546810-1327167758.png" alt="1089769-20181216202546810-1327167758.png"></p>
<p>总共有四个节点，Node C、Node D同时成为了candidate，进入了term 4，但Node A投了NodeD一票，NodeB投了Node C一票，这就出现了平票 split vote的情况。这个时候大家都在等啊等，直到超时后重新发起选举。如果出现平票的情况，那么就延长了系统不可用的时间（没有leader是不能处理客户端写请求的），因此raft引入了randomized election timeouts来尽量避免平票情况。同时，leader-based 共识算法中，节点的数目都是奇数个，尽量保证majority的出现</p>
<h2 id="log-replication"><a href="#log-replication" class="headerlink" title="log replication"></a>log replication</h2><p>当有了leader，系统应该进入对外工作期了。客户端的一切请求来发送到leader，leader来调度这些并发请求的顺序，并且保证leader与followers状态的一致性。raft中的做法是，将这些请求以及执行顺序告知followers。leader和followers以相同的顺序来执行这些请求，保证状态一致</p>
<h3 id="Replicated-state-machines"><a href="#Replicated-state-machines" class="headerlink" title="Replicated state machines"></a>Replicated state machines</h3><p>共识算法的实现一般是基于复制状态机（Replicated state machines），何为复制状态机：</p>
<p><code>If two identical, deterministic processes begin in the same state and get the same inputs in the same order, they will produce the same output and end in the same state.</code></p>
<p>简单来说：相同的初识状态 + 相同的输入 = 相同的结束状态。引文中有一个很重要的词deterministic，就是说不同节点要以相同且确定性的函数来处理输入，而不要引入一下不确定的值，比如本地时间等。如何保证所有节点 <code>get the same inputs in the same order</code>，使用replicated log是一个很不错的注意，log具有持久化、保序的特点，是大多数分布式系统的基石</p>
<p>因此，可以这么说，在raft中，leader将客户端请求（command）封装到一个个log entry，将这些log entries复制（replicate）到所有follower节点，然后大家按相同顺序应用（apply）log entry中的command，则状态肯定是一致的。</p>
<p>下图形象展示了这种log-based replicated state machine</p>
<p><img src="1089769-20181216202234422-28123572.png" alt="1089769-20181216202234422-28123572.png"></p>
<h3 id="请求完整流程"><a href="#请求完整流程" class="headerlink" title="请求完整流程"></a>请求完整流程</h3><p>当系统（leader）收到一个来自客户端的写请求，到返回给客户端，整个过程从leader的视角来看会经历以下步骤：</p>
<ul>
<li>leader append log entry</li>
<li>leader issue AppendEntries RPC in parallel</li>
<li>leader wait for majority response</li>
<li>leader apply entry to state machine</li>
<li>leader reply to client</li>
<li>leader notify follower apply log</li>
</ul>
<p>可以看到日志的提交过程有点类似两阶段提交(2PC)，不过与2PC的区别在于，leader只需要大多数（majority）节点的回复即可，这样只要超过一半节点处于工作状态则系统就是可用的。</p>
<p>那么日志在每个节点上是什么样子的呢</p>
<p><img src="1089769-20181216202309906-1698663454.png" alt="1089769-20181216202309906-1698663454.png"></p>
<p>不难看到，logs由顺序编号的log entry组成 ，每个log entry除了包含command，还包含产生该log entry时的leader term。从上图可以看到，五个节点的日志并不完全一致，raft算法为了保证高可用，并不是强一致性，而是最终一致性，leader会不断尝试给follower发log entries，直到所有节点的log entries都相同。</p>
<p>在上面的流程中，leader只需要日志被复制到大多数节点即可向客户端返回，一旦向客户端返回成功消息，那么系统就必须保证log（其实是log所包含的command）在任何异常的情况下都不会发生回滚。这里有两个词：commit（committed），apply(applied)，前者是指日志被复制到了大多数节点后日志的状态；而后者则是节点将日志应用到状态机，真正影响到节点状态。</p>
<h3 id="safety"><a href="#safety" class="headerlink" title="safety"></a>safety</h3><p>在上面提到只要日志被复制到majority节点，就能保证不会被回滚，即使在各种异常情况下，这根leader election提到的选举约束有关。在这一部分，主要讨论raft协议在各种各样的异常情况下如何工作的。</p>
<p>衡量一个分布式算法，有许多属性，如</p>
<ul>
<li>safety：nothing bad happens,</li>
<li>liveness： something good eventually happens.</li>
</ul>
<p>在任何系统模型下，都需要满足safety属性，即在任何情况下，系统都不能出现不可逆的错误，也不能向客户端返回错误的内容。比如，raft保证被复制到大多数节点的日志不会被回滚，那么就是safety属性。而raft最终会让所有节点状态一致，这属于liveness属性</p>
<p>raft协议会保证以下属性</p>
<p><img src="1089769-20181216202333639-30919755.png" alt="1089769-20181216202333639-30919755.png"></p>
<h3 id="Election-safety"><a href="#Election-safety" class="headerlink" title="Election safety"></a>Election safety</h3><p>选举安全性，即任一任期内最多一个leader被选出。这一点非常重要，在一个复制集中任何时刻只能有一个leader。系统中同时有多余一个leader，被称之为脑裂（brain split），这是非常严重的问题，会导致数据的覆盖丢失。在raft中，两点保证了这个属性：</p>
<ul>
<li>一个节点某一任期内最多只能投一票；</li>
<li>只有获得majority投票的节点才会成为leader。</li>
</ul>
<p>因此，某一任期内一定只有一个leader。</p>
<h3 id="log-matching"><a href="#log-matching" class="headerlink" title="log matching"></a>log matching</h3><p>很有意思，log匹配特性， 就是说如果两个节点上的某个log entry的log index相同且term相同，那么在该index之前的所有log entry应该都是相同的。如何做到的？依赖于以下两点</p>
<ul>
<li>If two entries in different logs have the same index and term, then they store the same command.</li>
<li>If two entries in different logs have the same index and term, then the logs are identical in all preceding entries.</li>
</ul>
<p>首先，leader在某一term的任一位置只会创建一个log entry，且log entry是append-only。其次，consistency check。leader在AppendEntries中包含最新log entry之前的一个log 的term和index，如果follower在对应的term index找不到日志，那么就会告知leader不一致。</p>
<p>在没有异常的情况下，log matching是很容易满足的，但如果出现了node crash，情况就会变得负责。比如下图</p>
<p><img src="1089769-20181216202408734-1760694063.png" alt="1089769-20181216202408734-1760694063.png"></p>
<p><strong>注意:</strong> 上图的a-f不是6个follower，而是某个follower可能存在的六个状态</p>
<p>leader、follower都可能crash，那么follower维护的日志与leader相比可能出现以下情况</p>
<ul>
<li>比leader日志少，如上图中的ab</li>
<li>比leader日志多，如上图中的cd<br>-某些位置比leader多，某些日志比leader少，如ef（多少是针对某一任期而言）</li>
</ul>
<p>当出现了leader与follower不一致的情况，leader强制follower复制自己的log</p>
<p><code>To bring a follower’s log into consistency with its own, the leader must find the latest log entry where the two logs agree, delete any entries in the follower’s log after that point, and send the follower all of the leader’s entries after that point.</code></p>
<p>leader会维护一个nextIndex[]数组，记录了leader可以发送每一个follower的log index，初始化为eader最后一个log index加1， 前面也提到，leader选举成功之后会立即给所有follower发送AppendEntries RPC（不包含任何log entry， 也充当心跳消息）,那么流程总结为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">s1 leader 初始化nextIndex[x]为 leader最后一个log index + 1</div><div class="line">s2 AppendEntries里prevLogTerm prevLogIndex来自 logs[nextIndex[x] - 1]</div><div class="line">s3 如果follower判断prevLogIndex位置的log term不等于prevLogTerm，那么返回 false，否则返回True</div><div class="line">s4 leader收到follower的恢复，如果返回值是True，则nextIndex[x] -= 1, 跳转到s2. 否则</div><div class="line">s5 同步nextIndex[x]后的所有log entries</div></pre></td></tr></table></figure>
<h3 id="leader-completeness-vs-elcetion-restriction"><a href="#leader-completeness-vs-elcetion-restriction" class="headerlink" title="leader completeness vs elcetion restriction"></a>leader completeness vs elcetion restriction</h3><p>leader完整性：如果一个log entry在某个任期被提交（committed），那么这条日志一定会出现在所有更高term的leader的日志里面。这个跟leader election、log replication都有关。</p>
<ul>
<li>一个日志被复制到majority节点才算committed</li>
<li>一个节点得到majority的投票才能成为leader，而节点A给节点B投票的其中一个前提是，B的日志不能比A的日志旧。下面的引文指处了如何判断日志的新旧</li>
<li></li>
</ul>
<p><code>voter denies its vote if its own log is more up-to-date than that of the candidate.</code></p>
<p><code>If the logs have last entries with different terms, then the log with the later term is more up-to-date. If the logs end with the same term, then whichever log is longer is more up-to-date.</code></p>
<p>上面两点都提到了majority：commit majority and vote majority，根据Quorum，这两个majority一定是有重合的，因此被选举出的leader一定包含了最新的committed的日志。</p>
<p>raft与其他协议（Viewstamped Replication、mongodb）不同，raft始终保证leade包含最新的已提交的日志，因此leader不会从follower catchup日志，这也大大简化了系统的复杂度。</p>
<h2 id="corner-case"><a href="#corner-case" class="headerlink" title="corner case"></a>corner case</h2><h3 id="stale-leader"><a href="#stale-leader" class="headerlink" title="stale leader"></a>stale leader</h3><p>raft保证Election safety，即一个任期内最多只有一个leader，但在网络分割（network partition）的情况下，可能会出现两个leader，但两个leader所处的任期是不同的。如下图所示</p>
<p><img src="1089769-20181216202652306-2050900084.png" alt="1089769-20181216202652306-2050900084.png"></p>
<p>系统有5个节点ABCDE组成，在term1，Node B是leader，但Node A、B和Node C、D、E之间出现了网络分割，因此Node C、D、E无法收到来自leader（Node B）的消息，在election time之后，Node C、D、E会分期选举，由于满足majority条件，Node E成为了term 2的leader。因此，在系统中貌似出现了两个leader：term 1的Node B， term 2的Node E, Node B的term更旧，但由于无法与Majority节点通信，NodeB仍然会认为自己是leader。</p>
<p>在这样的情况下，我们来考虑读写。</p>
<p>首先，如果客户端将请求发送到了NodeB，NodeB无法将log entry 复制到majority节点，因此不会告诉客户端写入成功，这就不会有问题。</p>
<p>对于读请求，stale leader可能返回stale data，比如在read-after-write的一致性要求下，客户端写入到了term2任期的leader Node E，但读请求发送到了Node B。如果要保证不返回stale data，leader需要check自己是否过时了，办法就是与大多数节点通信一次，这个可能会出现效率问题。另一种方式是使用lease，但这就会依赖物理时钟。</p>
<p>从raft的论文中可以看到，leader转换成follower的条件是收到来自更高term的消息，如果网络分割一直持续，那么stale leader就会一直存在。而在raft的一些实现或者raft-like协议中，leader如果收不到majority节点的消息，那么可以自己step down，自行转换到follower状态。</p>
<h3 id="State-Machine-Safety"><a href="#State-Machine-Safety" class="headerlink" title="State Machine Safety"></a>State Machine Safety</h3><p>前面在介绍safety的时候有一条属性没有详细介绍，那就是State Machine Safety：</p>
<p><code>State Machine Safety: if a server has applied a log entry at a given index to its state machine, no other server will ever apply a different log entry for the same index.</code></p>
<p>如果节点将某一位置的log entry应用到了状态机，那么其他节点在同一位置不能应用不同的日志。简单点来说，所有节点在同一位置（index in log entries）应该应用同样的日志。但是似乎有某些情况会违背这个原则：</p>
<p><img src="1089769-20181216202438174-260853001.png" alt="1089769-20181216202438174-260853001.png"></p>
<p>上图是一个较为复杂的情况。在时刻(a), s1是leader，在term2提交的日志只赋值到了s1 s2两个节点就crash了。在时刻（b), s5成为了term 3的leader，日志只赋值到了s5，然后crash。然后在(c)时刻，s1又成为了term 4的leader，开始赋值日志，于是把term2的日志复制到了s3，此刻，可以看出term2对应的日志已经被复制到了majority，因此是committed，可以被状态机应用。不幸的是，接下来（d）时刻，s1又crash了，s5重新当选，然后将term3的日志复制到所有节点，这就出现了一种奇怪的现象：被复制到大多数节点（或者说可能已经应用）的日志被回滚。</p>
<p>究其根本，是因为term4时的leader s1在（C）时刻提交了之前term2任期的日志。为了杜绝这种情况的发生：</p>
<p><code>Raft never commits log entries from previous terms by counting replicas.
Only log entries from the leader’s current term are committed by counting replicas; once an entry from the current term has been committed in this way, then all prior entries are committed indirectly because of the Log Matching Property.</code></p>
<p>也就是说，某个leader选举成功之后，不会直接提交前任leader时期的日志，而是通过提交当前任期的日志的时候“顺手”把之前的日志也提交了，具体怎么实现了，在log matching部分有详细介绍。那么问题来了，如果leader被选举后没有收到客户端的请求呢，论文中有提到，在任期开始的时候发立即尝试复制、提交一条空的log</p>
<p><code>Raft handles this by having each leader commit a blank no-op entry into the log at the start of its term.</code></p>
<p>因此，在上图中，不会出现（C）时刻的情况，即term4任期的leader s1不会复制term2的日志到s3。而是如同(e)描述的情况，通过复制-提交 term4的日志顺便提交term2的日志。如果term4的日志提交成功，那么term2的日志也一定提交成功，此时即使s1crash，s5也不会重新当选。</p>
<h3 id="leader-crash"><a href="#leader-crash" class="headerlink" title="leader crash"></a>leader crash</h3><p>follower的crash处理方式相对简单，leader只要不停的给follower发消息即可。当leader crash的时候，事情就会变得复杂。在<a href="http://www.cnblogs.com/mindwind/p/5231986.html" target="_blank" rel="external">这篇文章</a>中，作者就给出了一个更新请求的流程图。</p>
<p><img src="815275-20160301175358173-526445555.png" alt="815275-20160301175358173-526445555.png"></p>
<p>我们可以分析leader在任意时刻crash的情况，有助于理解raft算法的容错性。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>raft将共识问题分解成两个相对独立的问题，leader election，log replication。流程是先选举出leader，然后leader负责复制、提交log（log中包含command）</p>
<p>为了在任何异常情况下系统不出错，即满足safety属性，对leader election，log replication两个子问题有诸多约束</p>
<p>leader election约束：</p>
<ul>
<li>同一任期内最多只能投一票，先来先得</li>
<li>选举人必须比自己知道的更多（比较term，log index）</li>
</ul>
<p>log replication约束：</p>
<ul>
<li>一个log被复制到大多数节点，就是committed，保证不会回滚</li>
<li>leader一定包含最新的committed log，因此leader只会追加日志，不会删除覆盖日志</li>
<li>不同节点，某个位置上日志相同，那么这个位置之前的所有日志一定是相同的</li>
<li>Raft never commits log entries from previous terms by counting replicas.</li>
</ul>
<p>本文是在看完raft论文后自己的总结，不一定全面。个人觉得，如果只是相对raft协议有一个简单了解，看这个动画演示就足够了，如果想深入了解，还是要看论文，论文中Figure 2对raft算法进行了概括。最后，还是找一个实现了raft算法的系统来看看更好</p>
<p>ref:<br><a href="https://www.cnblogs.com/xybaby/p/10124083.html" target="_blank" rel="external">https://www.cnblogs.com/xybaby/p/10124083.html</a><br><a href="https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14" target="_blank" rel="external">https://web.stanford.edu/~ouster/cgi-bin/papers/raft-atc14</a><br><a href="https://raft.github.io/" target="_blank" rel="external">https://raft.github.io/</a><br><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">http://thesecretlivesofdata.com/raft/</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Raft</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Hash一致性</title>
    <url>/2017/09/22/Redis-Hash%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<p>一致性Hash算法在分布式中普遍使用，那么它到底是何方神圣呢？为何会用到它呢？与其他的算法如取模相比有何优势？在使用的过程中有何问题，又怎么解决？下面来一步步揭开它的神秘面纱。注：本篇博客相当于转载，中间加了一些理解，原地址为：<a href="https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368" target="_blank" rel="external">https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368</a></p>
<a id="more"></a>
<h2 id="redis一致性哈希算法"><a href="#redis一致性哈希算法" class="headerlink" title="redis一致性哈希算法"></a>redis一致性哈希算法</h2><p>一致性哈希算法在1997年由麻省理工学院提出的一种分布式哈希（DHT）实现算法，设计目标是为了解决因特网中的热点(Hot spot)问题，初衷和CARP十分类似。一致性哈希修正了CARP使用的简 单哈希算法带来的问题，使得分布式哈希（DHT）可以在P2P环境中真正得到应用。<br>    一致性hash算法提出了在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</p>
<ul>
<li>1、平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</li>
<li>2、单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。 </li>
<li>3、分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。 </li>
<li>4、负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</li>
</ul>
<h2 id="Redis集群使用"><a href="#Redis集群使用" class="headerlink" title="Redis集群使用"></a>Redis集群使用</h2><p>我们在使用Redis的时候，为了保证Redis的高可用，提高Redis的读写性能，最简单的方式我们会做主从复制，组成Master-Master或者Master-Slave的形式，或者搭建Redis集群，进行数据的读写分离，类似于数据库的主从复制和读写分离。如下所示：</p>
<p><img src="20190119162548631.jpg" alt="20190119162548631.jpg"></p>
<p>同样类似于数据库，当单表数据大于500W的时候需要对其进行分库分表，当数据量很大的时候（标准可能不一样，要看Redis服务器容量）我们同样可以对Redis进行类似的操作，就是分库分表。</p>
<p>假设，我们有一个社交网站，需要使用Redis存储图片资源，存储的格式为键值对，key值为图片名称，value为该图片所在文件服务器的路径，我们需要根据文件名查找该文件所在文件服务器上的路径，数据量大概有2000W左右，按照我们约定的规则进行分库，规则就是随机分配，我们可以部署8台缓存服务器，每台服务器大概含有500W条数据，并且进行主从复制，示意图如下</p>
<p><img src="20190119162805299.jpg" alt="20190119162805299.jpg"></p>
<p>由于规则是随机的，所有我们的一条数据都有可能存储在任何一组Redis中，例如上图我们用户查找一张名称为”a.png”的图片，由于规则是随机的，我们不确定具体是在哪一个Redis服务器上的，因此我们需要进行1、2、3、4，4次查询才能够查询到（也就是遍历了所有的Redis服务器），这显然不是我们想要的结果，有了解过的小伙伴可能会想到，随机的规则不行，可以使用类似于数据库中的分库分表规则：按照Hash值、取模、按照类别、按照某一个字段值等等常见的规则就可以出来了！好，按照我们的主题，我们就使用Hash的方式。</p>
<h2 id="为Redis集群使用Hash"><a href="#为Redis集群使用Hash" class="headerlink" title="为Redis集群使用Hash"></a>为Redis集群使用Hash</h2><p>可想而知，如果我们使用Hash的方式，每一张图片在进行分库的时候都可以定位到特定的服务器，示意图如下：</p>
<p><img src="20190119164136853.jpg" alt="20190119164136853.jpg"></p>
<p>上图中，假设我们查找的是”a.png”，由于有4台服务器（排除从库），因此公式为hash(a.png) % 4 = 2 ，可知定位到了第2号服务器，这样的话就不会遍历所有的服务器，大大提升了性能！</p>
<h2 id="使用Hash的问题"><a href="#使用Hash的问题" class="headerlink" title="使用Hash的问题"></a>使用Hash的问题</h2><p>上述的方式虽然提升了性能，我们不再需要对整个Redis服务器进行遍历！但是，使用上述Hash算法进行缓存时，会出现一些缺陷，主要体现在服务器数量变动的时候，所有缓存的位置都要发生改变！</p>
<p>试想一下，如果4台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？很简单，多增加几台缓存服务器不就行了！假设：我们增加了一台缓存服务器，那么缓存服务器的数量就由4台变成了5台。那么原本hash(a.png) % 4 = 2 的公式就变成了 hash(a.png) % 5 =？ 。假设有20个数据需要存储，在有4个redis节点的时候如下图：</p>
<p><img src="2019011917113921.jpg" alt="2019011917113921.jpg"></p>
<p>当我们添加1个redis节点之后，数据的分布如下图所示：</p>
<p><img src="2019011917141282.jpg" alt="2019011917141282.jpg"></p>
<p>图中蓝色部分代表与4个节点时存储位置一致的数据，其命中率为：4/20=20%。也就是说这种情况带来的结果就是当服务器数量变动时，很多缓存的位置都要发生改变！换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端数据库请求数据（还记得上一篇的<a href="https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247485464&amp;idx=1&amp;sn=8d690fc6f878aadf75977aa7e76cfd08&amp;chksm=e9c5f1a9deb278bf512d8b40c30240d0168cdf2cf02142ee913bc11ec39637ca380a4dad524b&amp;scene=21#wechat_redirect" target="_blank" rel="external">《缓存雪崩》</a>吗？）！</p>
<p>同样的，假设4台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从4台变为3台，也是会出现上述的问题！</p>
<p>所以，我们应该想办法不让这种情况发生，但是由于上述Hash算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，Hash一致性算法（一致性Hash算法）诞生了！</p>
<h2 id="一致性hash算法的神秘面纱"><a href="#一致性hash算法的神秘面纱" class="headerlink" title="一致性hash算法的神秘面纱"></a>一致性hash算法的神秘面纱</h2><p>一致性Hash算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性Hash算法是对2^ 32-1取模，什么意思呢简单来说，一致性Hash算法将整个Hash值控件组织成一个虚拟的圆环，如假设某哈希函数H的值空间为0-2^32-1取模（即哈希值是一个32位无符号整型），整个哈希环如下：</p>
<p><img src="20190119164713714.jpg" alt="20190119164713714.jpg"></p>
<p>整个空间按顺时针方向组织，圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^ 32-1，也就是说0点左侧的第一个点代表2^ 32-1， 0和2^ 32-1在零点中方向重合，我们把这个由2^32个点组成的圆环称为Hash环。<br>下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：</p>
<p><img src="20190119164919108.jpg" alt="20190119164919108.jpg"></p>
<p>接下来使用如下算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p>
<p>例如我们有Object A、Object B、Object C、Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<p><img src="20190119165032230.jpg" alt="20190119165032230.jpg"></p>
<p>根据一致性Hash算法，数据A会被定为到Node A上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。</p>
<h2 id="一致性Hash算法的容错性和可扩展性"><a href="#一致性Hash算法的容错性和可扩展性" class="headerlink" title="一致性Hash算法的容错性和可扩展性"></a>一致性Hash算法的容错性和可扩展性</h2><p>现假设Node C不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器，如下图中NodeC与NodeB之间的数据，图中受影响的是ObjectC）之间数据，其它不会受到影响，如下所示：</p>
<p><img src="20190119165244746.jpg" alt="20190119165244746.jpg"></p>
<p>下面考虑另外一种情况，如果在系统中增加一台服务器Node X，如下图所示：</p>
<p><img src="20190119165318946.jpg" alt="20190119165318946.jpg"></p>
<p>此时对象Object A、B、D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。</p>
<p>综上所述，一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<h2 id="Hash环的数据倾斜问题"><a href="#Hash环的数据倾斜问题" class="headerlink" title="Hash环的数据倾斜问题"></a>Hash环的数据倾斜问题</h2><p>一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下：</p>
<p><img src="20190119165427699.jpg" alt="20190119165427699.jpg"></p>
<p>此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。</p>
<p>例如上面的情况，可以为每台服务器计算三个虚拟节点，于是可以分别计算 “Node A#1”、“Node A#2”、“Node A#3”、“Node B#1”、“Node B#2”、“Node B#3”的哈希值，于是形成六个虚拟节点：</p>
<p><img src="20190119165508121.jpg" alt="20190119165508121.jpg"></p>
<p>同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”、“Node A#2”、“Node A#3”三个虚拟节点的数据均定位到Node A上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布，通俗点的原理如下图所示：</p>
<p><img src="20190119173528435.jpg" alt="20190119173528435.jpg"></p>
<p>由于虚拟节点V1、V2映射到了真实节点N1，当数据object1确定到Hash环上的位置并找到虚拟节点V2的时候，其真实位置则是位于真实节点N1上。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我们一步步分析了什么是一致性Hash算法，主要是考虑到分布式系统每个节点都有可能失效，并且新的节点很可能动态的增加进来的情况，如何保证当系统的节点数目发生变化的时候，我们的系统仍然能够对外提供良好的服务，这是值得考虑的！</p>
<p>ref:<br><a href="https://blog.csdn.net/wlccomeon/article/details/86553831" target="_blank" rel="external">https://blog.csdn.net/wlccomeon/article/details/86553831</a><br><a href="https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368" target="_blank" rel="external">https://blog.csdn.net/bntX2jSQfEHy7/article/details/79549368</a><br><a href="https://blog.csdn.net/qq_35956041/article/details/81026972" target="_blank" rel="external">https://blog.csdn.net/qq_35956041/article/details/81026972</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Hash一致性</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Redission-RedLock</title>
    <url>/2017/09/22/Redis-Redisson-RedLock/</url>
    <content><![CDATA[<p>Redis-Redission-RedLock</p>
<a id="more"></a>
<h2 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h2><p>说道Redis分布式锁大部分人都会想到：setnx+lua，或者知道set key value px milliseconds nx。后一种方式的核心实现命令如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">- 获取锁（unique_value可以是UUID等）</div><div class="line">SET resource_name unique_value NX PX 30000</div><div class="line"></div><div class="line">- 释放锁（lua脚本中，一定要比较value，防止误解锁）</div><div class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</div><div class="line">    return redis.call(&quot;del&quot;,KEYS[1])</div><div class="line">else</div><div class="line">    return 0</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p>这种实现方式有3大要点（也是面试概率非常高的地方）：</p>
<ol>
<li>set命令要用set key value px milliseconds nx；</li>
<li>value要具有唯一性；</li>
<li>释放锁时要验证value值，不能误解锁；</li>
</ol>
<p>事实上这类琐最大的缺点就是它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：</p>
<ol>
<li>在Redis的master节点上拿到了锁；</li>
<li>但是这个加锁的key还没有同步到slave节点；</li>
<li>master故障，发生故障转移，slave节点升级为master节点；</li>
<li>导致锁丢失。</li>
</ol>
<p>正因为如此，Redis作者antirez基于分布式环境下提出了一种更高级的分布式锁的实现方式：Redlock</p>
<h2 id="Redlock实现"><a href="#Redlock实现" class="headerlink" title="Redlock实现"></a>Redlock实现</h2><p>antirez提出的redlock算法大概是这样的：</p>
<p>在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。我们确保将在N个实例上使用与在Redis单实例下相同方法获取和释放锁。现在我们假设有5个Redis master节点，同时我们需要在5台服务器上面运行这些Redis实例，这样保证他们不会同时都宕掉。</p>
<p>为了取到锁，客户端应该执行以下操作:</p>
<ul>
<li>获取当前Unix时间，以毫秒为单位。</li>
<li>依次尝试从5个实例，使用相同的key和具有唯一性的value（例如UUID）获取锁。当向Redis请求获取锁时，客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试去另外一个Redis实例请求获取锁。</li>
<li>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（N/2+1，这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</li>
<li>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</li>
<li>如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功，防止某些节点获取到锁但是客户端没有得到响应而导致接下来的一段时间不能被重新获取锁）。</li>
</ul>
<h2 id="Redlock源码"><a href="#Redlock源码" class="headerlink" title="Redlock源码"></a>Redlock源码</h2><p>redisson已经有对redlock算法封装，接下来对其用法进行简单介绍，并对核心源码进行分析（假设5个redis实例)</p>
<p>POM依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- https://mvnrepository.com/artifact/org.redisson/redisson --&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.redisson&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;redisson&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;3.3.2&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>首先，我们来看一下redission封装的redlock算法实现的分布式锁用法，非常简单，跟重入锁（ReentrantLock）有点类似：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Config config = new Config();</div><div class="line">config.useSentinelServers().addSentinelAddress(&quot;127.0.0.1:6369&quot;,&quot;127.0.0.1:6379&quot;, &quot;127.0.0.1:6389&quot;)</div><div class="line">        .setMasterName(&quot;masterName&quot;)</div><div class="line">        .setPassword(&quot;password&quot;).setDatabase(0);</div><div class="line">RedissonClient redissonClient = Redisson.create(config);</div><div class="line">// 还可以getFairLock(), getReadWriteLock()</div><div class="line">RLock redLock = redissonClient.getLock(&quot;REDLOCK_KEY&quot;);</div><div class="line">boolean isLock;</div><div class="line">try &#123;</div><div class="line">    isLock = redLock.tryLock();</div><div class="line">    // 500ms拿不到锁, 就认为获取锁失败。10000ms即10s是锁失效时间。</div><div class="line">    isLock = redLock.tryLock(500, 10000, TimeUnit.MILLISECONDS);</div><div class="line">    if (isLock) &#123;</div><div class="line">        //TODO if get lock success, do something;</div><div class="line">    &#125;</div><div class="line">&#125; catch (Exception e) &#123;</div><div class="line">&#125; finally &#123;</div><div class="line">    // 无论如何, 最后都要解锁</div><div class="line">    redLock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="唯一ID"><a href="#唯一ID" class="headerlink" title="唯一ID"></a>唯一ID</h3><p>实现分布式锁的一个非常重要的点就是set的value要具有唯一性，redisson的value是怎样保证value的唯一性呢？答案是UUID+threadId。入口在redissonClient.getLock(“REDLOCK_KEY”)，源码在Redisson.java和RedissonLock.java中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">protected final UUID id = UUID.randomUUID();</div><div class="line">String getLockName(long threadId) &#123;</div><div class="line">    return id + &quot;:&quot; + threadId;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h3><p>获取锁的代码为redLock.tryLock()或者redLock.tryLock(500, 10000, TimeUnit.MILLISECONDS)，两者的最终核心源码都是下面这段代码，只不过前者获取锁的默认租约时间（leaseTime）是LOCK_EXPIRATION_INTERVAL_SECONDS，即30s：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123;</div><div class="line">    internalLockLeaseTime = unit.toMillis(leaseTime);</div><div class="line">    // 获取锁时向5个redis实例发送的命令</div><div class="line">    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,</div><div class="line">              // 首先分布式锁的KEY不能存在，如果确实不存在，那么执行hset命令（hset REDLOCK_KEY uuid+threadId 1），并通过pexpire设置失效时间（也是锁的租约时间）</div><div class="line">              &quot;if (redis.call(&apos;exists&apos;, KEYS[1]) == 0) then &quot; +</div><div class="line">                  &quot;redis.call(&apos;hset&apos;, KEYS[1], ARGV[2], 1); &quot; +</div><div class="line">                  &quot;redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[1]); &quot; +</div><div class="line">                  &quot;return nil; &quot; +</div><div class="line">              &quot;end; &quot; +</div><div class="line">              // 如果分布式锁的KEY已经存在，并且value也匹配，表示是当前线程持有的锁，那么重入次数加1，并且设置失效时间</div><div class="line">              &quot;if (redis.call(&apos;hexists&apos;, KEYS[1], ARGV[2]) == 1) then &quot; +</div><div class="line">                  &quot;redis.call(&apos;hincrby&apos;, KEYS[1], ARGV[2], 1); &quot; +</div><div class="line">                  &quot;redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[1]); &quot; +</div><div class="line">                  &quot;return nil; &quot; +</div><div class="line">              &quot;end; &quot; +</div><div class="line">              // 获取分布式锁的KEY的失效时间毫秒数</div><div class="line">              &quot;return redis.call(&apos;pttl&apos;, KEYS[1]);&quot;,</div><div class="line">              // 这三个参数分别对应KEYS[1]，ARGV[1]和ARGV[2]</div><div class="line">                Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取锁的命令中，<br>KEYS[1]就是Collections.singletonList(getName())，表示分布式锁的key，即REDLOCK_KEY；<br>ARGV[1]就是internalLockLeaseTime，即锁的租约时间，默认30s；<br>ARGV[2]就是getLockName(threadId)，是获取锁时set的唯一值，即UUID+threadId：</p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>释放锁的代码为redLock.unlock()，核心源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">protected RFuture&lt;Boolean&gt; unlockInnerAsync(long threadId) &#123;</div><div class="line">    // 向5个redis实例都执行如下命令</div><div class="line">    return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</div><div class="line">            // 如果分布式锁KEY不存在，那么向channel发布一条消息</div><div class="line">            &quot;if (redis.call(&apos;exists&apos;, KEYS[1]) == 0) then &quot; +</div><div class="line">                &quot;redis.call(&apos;publish&apos;, KEYS[2], ARGV[1]); &quot; +</div><div class="line">                &quot;return 1; &quot; +</div><div class="line">            &quot;end;&quot; +</div><div class="line">            // 如果分布式锁存在，但是value不匹配，表示锁已经被占用，那么直接返回</div><div class="line">            &quot;if (redis.call(&apos;hexists&apos;, KEYS[1], ARGV[3]) == 0) then &quot; +</div><div class="line">                &quot;return nil;&quot; +</div><div class="line">            &quot;end; &quot; +</div><div class="line">            // 如果就是当前线程占有分布式锁，那么将重入次数减1</div><div class="line">            &quot;local counter = redis.call(&apos;hincrby&apos;, KEYS[1], ARGV[3], -1); &quot; +</div><div class="line">            // 重入次数减1后的值如果大于0，表示分布式锁有重入过，那么只设置失效时间，还不能删除</div><div class="line">            &quot;if (counter &gt; 0) then &quot; +</div><div class="line">                &quot;redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[2]); &quot; +</div><div class="line">                &quot;return 0; &quot; +</div><div class="line">            &quot;else &quot; +</div><div class="line">                // 重入次数减1后的值如果为0，表示分布式锁只获取过1次，那么删除这个KEY，并发布解锁消息</div><div class="line">                &quot;redis.call(&apos;del&apos;, KEYS[1]); &quot; +</div><div class="line">                &quot;redis.call(&apos;publish&apos;, KEYS[2], ARGV[1]); &quot; +</div><div class="line">                &quot;return 1; &quot;+</div><div class="line">            &quot;end; &quot; +</div><div class="line">            &quot;return nil;&quot;,</div><div class="line">            // 这5个参数分别对应KEYS[1]，KEYS[2]，ARGV[1]，ARGV[2]和ARGV[3]</div><div class="line">            Arrays.&lt;Object&gt;asList(getName(), getChannelName()), LockPubSub.unlockMessage, internalLockLeaseTime, getLockName(threadId));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/PnlPgqfVXqJmN26vvGp5MA" target="_blank" rel="external">https://mp.weixin.qq.com/s/PnlPgqfVXqJmN26vvGp5MA</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Redisson实现分布式锁</title>
    <url>/2017/09/22/Redis-Redisson%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p>使用Redisson实现分布式锁</p>
<a id="more"></a>
<h2 id="可重入锁（Reentrant-Lock）"><a href="#可重入锁（Reentrant-Lock）" class="headerlink" title="可重入锁（Reentrant Lock）"></a>可重入锁（Reentrant Lock）</h2><p>Redisson的分布式可重入锁RLock Java对象实现了java.util.concurrent.locks.Lock接口，同时还支持自动过期解锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void testReentrantLock(RedissonClient redisson)&#123;</div><div class="line">	RLock lock = redisson.getLock(&quot;anyLock&quot;);</div><div class="line">	try&#123;</div><div class="line">		// 1. 最常见的使用方法</div><div class="line">		//lock.lock();</div><div class="line">		// 2. 支持过期解锁功能,10秒钟以后自动解锁, 无需调用unlock方法手动解锁</div><div class="line">		//lock.lock(10, TimeUnit.SECONDS);</div><div class="line">		// 3. 尝试加锁，最多等待3秒，上锁以后10秒自动解锁</div><div class="line">		boolean res = lock.tryLock(3, 10, TimeUnit.SECONDS);</div><div class="line">		if(res)&#123; //成功</div><div class="line">		// do your business</div><div class="line">		&#125;</div><div class="line">	&#125; catch (InterruptedException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125; finally &#123;</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Redisson同时还为分布式锁提供了异步执行的相关方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void testAsyncReentrantLock(RedissonClient redisson)&#123;</div><div class="line">	RLock lock = redisson.getLock(&quot;anyLock&quot;);</div><div class="line">	try&#123;</div><div class="line">		lock.lockAsync();</div><div class="line">		lock.lockAsync(10, TimeUnit.SECONDS);</div><div class="line">		Future&lt;Boolean&gt; res = lock.tryLockAsync(3, 10, TimeUnit.SECONDS);</div><div class="line">		if(res.get())&#123;</div><div class="line">		// do your business</div><div class="line">		&#125;</div><div class="line">	&#125; catch (InterruptedException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125; catch (ExecutionException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125; finally &#123;</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="公平锁（Fair-Lock）"><a href="#公平锁（Fair-Lock）" class="headerlink" title="公平锁（Fair Lock）"></a>公平锁（Fair Lock）</h2><p>Redisson分布式可重入公平锁也是实现了java.util.concurrent.locks.Lock接口的一种RLock对象。在提供了自动过期解锁功能的同时，保证了当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void testFairLock(RedissonClient redisson)&#123;</div><div class="line">	RLock fairLock = redisson.getFairLock(&quot;anyLock&quot;);</div><div class="line">	try&#123;</div><div class="line">		// 最常见的使用方法</div><div class="line">		fairLock.lock();</div><div class="line">		// 支持过期解锁功能, 10秒钟以后自动解锁,无需调用unlock方法手动解锁</div><div class="line">		fairLock.lock(10, TimeUnit.SECONDS);</div><div class="line">		// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</div><div class="line">		boolean res = fairLock.tryLock(100, 10, TimeUnit.SECONDS);</div><div class="line">	&#125; catch (InterruptedException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125; finally &#123;</div><div class="line">		fairLock.unlock();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Redisson同时还为分布式可重入公平锁提供了异步执行的相关方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RLock fairLock = redisson.getFairLock(&quot;anyLock&quot;);</div><div class="line">fairLock.lockAsync();</div><div class="line">fairLock.lockAsync(10, TimeUnit.SECONDS);</div><div class="line">Future&lt;Boolean&gt; res = fairLock.tryLockAsync(100, 10, TimeUnit.SECONDS);</div></pre></td></tr></table></figure>
<h2 id="联锁（MultiLock）"><a href="#联锁（MultiLock）" class="headerlink" title="联锁（MultiLock）"></a>联锁（MultiLock）</h2><p>Redisson的RedissonMultiLock对象可以将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void testMultiLock(RedissonClient redisson1,RedissonClient redisson2, RedissonClient redisson3)&#123;</div><div class="line">	RLock lock1 = redisson1.getLock(&quot;lock1&quot;);</div><div class="line">	RLock lock2 = redisson2.getLock(&quot;lock2&quot;);</div><div class="line">	RLock lock3 = redisson3.getLock(&quot;lock3&quot;);</div><div class="line">	RedissonMultiLock lock = new RedissonMultiLock(lock1, lock2, lock3);</div><div class="line">	try &#123;</div><div class="line">		// 同时加锁：lock1 lock2 lock3, 所有的锁都上锁成功才算成功。</div><div class="line">		lock.lock();</div><div class="line">		// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</div><div class="line">		boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);</div><div class="line">	&#125; catch (InterruptedException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125; finally &#123;</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="红锁（RedLock）"><a href="#红锁（RedLock）" class="headerlink" title="红锁（RedLock）"></a>红锁（RedLock）</h2><p>Redisson的RedissonRedLock对象实现了Redlock介绍的加锁算法。该对象也可以用来将多个RLock对象关联为一个红锁，每个RLock对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public void testRedLock(RedissonClient redisson1,RedissonClient redisson2, RedissonClient redisson3)&#123;</div><div class="line">	RLock lock1 = redisson1.getLock(&quot;lock1&quot;);</div><div class="line">	RLock lock2 = redisson2.getLock(&quot;lock2&quot;);</div><div class="line">	RLock lock3 = redisson3.getLock(&quot;lock3&quot;);</div><div class="line">	RedissonRedLock lock = new RedissonRedLock(lock1, lock2, lock3);</div><div class="line">	try &#123;</div><div class="line">		// 同时加锁：lock1 lock2 lock3, 红锁在大部分节点上加锁成功就算成功。</div><div class="line">		lock.lock();</div><div class="line">		// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</div><div class="line">		boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);</div><div class="line">	&#125; catch (InterruptedException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125; finally &#123;</div><div class="line">		lock.unlock();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="读写锁（ReadWriteLock）"><a href="#读写锁（ReadWriteLock）" class="headerlink" title="读写锁（ReadWriteLock）"></a>读写锁（ReadWriteLock）</h2><p>Redisson的分布式可重入读写锁RReadWriteLock,Java对象实现了java.util.concurrent.locks.ReadWriteLock接口。同时还支持自动过期解锁。该对象允许同时有多个读取锁，但是最多只能有一个写入锁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RReadWriteLock rwlock = redisson.getLock(&quot;anyRWLock&quot;);</div><div class="line">// 最常见的使用方法</div><div class="line">rwlock.readLock().lock();</div><div class="line">// 或</div><div class="line">rwlock.writeLock().lock();</div><div class="line">// 支持过期解锁功能</div><div class="line">// 10秒钟以后自动解锁</div><div class="line">// 无需调用unlock方法手动解锁</div><div class="line">rwlock.readLock().lock(10, TimeUnit.SECONDS);</div><div class="line">// 或</div><div class="line">rwlock.writeLock().lock(10, TimeUnit.SECONDS);</div><div class="line">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</div><div class="line">boolean res = rwlock.readLock().tryLock(100, 10, TimeUnit.SECONDS);</div><div class="line">// 或</div><div class="line">boolean res = rwlock.writeLock().tryLock(100, 10, TimeUnit.SECONDS);</div><div class="line">...</div><div class="line">lock.unlock();</div></pre></td></tr></table></figure>
<h2 id="信号量（Semaphore）"><a href="#信号量（Semaphore）" class="headerlink" title="信号量（Semaphore）"></a>信号量（Semaphore）</h2><p>Redisson的分布式信号量（Semaphore）Java对象RSemaphore采用了与java.util.concurrent.Semaphore相似的接口和用法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RSemaphore semaphore = redisson.getSemaphore(&quot;semaphore&quot;);</div><div class="line">semaphore.acquire();</div><div class="line">//或</div><div class="line">semaphore.acquireAsync();</div><div class="line">semaphore.acquire(23);</div><div class="line">semaphore.tryAcquire();</div><div class="line">//或</div><div class="line">semaphore.tryAcquireAsync();</div><div class="line">semaphore.tryAcquire(23, TimeUnit.SECONDS);</div><div class="line">//或</div><div class="line">semaphore.tryAcquireAsync(23, TimeUnit.SECONDS);</div><div class="line">semaphore.release(10);</div><div class="line">semaphore.release();</div><div class="line">//或</div><div class="line">semaphore.releaseAsync();</div></pre></td></tr></table></figure>
<h2 id="可过期性信号量（PermitExpirableSemaphore）"><a href="#可过期性信号量（PermitExpirableSemaphore）" class="headerlink" title="可过期性信号量（PermitExpirableSemaphore）"></a>可过期性信号量（PermitExpirableSemaphore）</h2><p>Redisson的可过期性信号量（PermitExpirableSemaphore）实在RSemaphore对象的基础上，为每个信号增加了一个过期时间。每个信号可以通过独立的ID来辨识，释放时只能通过提交这个ID才能释放。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RPermitExpirableSemaphore semaphore = redisson.getPermitExpirableSemaphore(&quot;mySemaphore&quot;);</div><div class="line">String permitId = semaphore.acquire();</div><div class="line">// 获取一个信号，有效期只有2秒钟。</div><div class="line">String permitId = semaphore.acquire(2, TimeUnit.SECONDS);</div><div class="line">// ...</div><div class="line">semaphore.release(permitId);</div></pre></td></tr></table></figure>
<h2 id="闭锁（CountDownLatch）"><a href="#闭锁（CountDownLatch）" class="headerlink" title="闭锁（CountDownLatch）"></a>闭锁（CountDownLatch）</h2><p>Redisson的分布式闭锁（CountDownLatch）Java对象RCountDownLatch采用了与java.util.concurrent.CountDownLatch相似的接口和用法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RCountDownLatch latch = redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);</div><div class="line">latch.trySetCount(1);</div><div class="line">latch.await();</div><div class="line">// 在其他线程或其他JVM里</div><div class="line">RCountDownLatch latch = redisson.getCountDownLatch(&quot;anyCountDownLatch&quot;);</div><div class="line">latch.countDown();</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://blog.csdn.net/l1028386804/article/details/73523810" target="_blank" rel="external">https://blog.csdn.net/l1028386804/article/details/73523810</a> </p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-why单线程</title>
    <url>/2017/09/22/Redis-why%E5%8D%95%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>为什么说Redis是单线程或者Redis为什么这么快</p>
<a id="more"></a>
<h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis是一个开源的内存中的数据结构存储系统，它可以用作：数据库、缓存和消息中间件。</p>
<p>它支持多种类型的数据结构，如字符串（Strings），散列（Hash），列表（List），集合（Set），有序集合（Sorted Set或者是ZSet）与范围查询，Bitmaps，Hyperloglogs 和地理空间（Geospatial）索引半径查询。其中常见的数据结构类型有：String、List、Set、Hash、ZSet这5种。</p>
<p>Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p>
<p>Redis也提供了持久化的选项，这些选项可以让用户将自己的数据保存到磁盘上面进行存储。根据实际情况，可以每隔一定时间将数据集导出到磁盘（快照），或者追加到命令日志中（AOF只追加文件），他会在执行写命令时，将被执行的写命令复制到硬盘里面。您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用。</p>
<p>Redis不使用表，他的数据库不会预定义或者强制去要求用户对Redis存储的不同数据进行关联。</p>
<p>数据库的工作模式按存储方式可分为：硬盘数据库和内存数据库。Redis 将数据储存在内存里面，读写数据的时候都不会受到硬盘 I/O 速度的限制，所以速度极快。</p>
<h2 id="Redis到底有多快"><a href="#Redis到底有多快" class="headerlink" title="Redis到底有多快"></a>Redis到底有多快</h2><p>Redis采用的是基于内存的采用的是单进程单线程模型的 KV 数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。这个数据不比采用单进程多线程的同样基于内存的 KV 数据库 Memcached 差！有兴趣的可以参考官方的基准程序测试：<a href="https://redis.io/topics/benchmarks" target="_blank" rel="external">https://redis.io/topics/benchmarks</a></p>
<p><img src="WX20190506_0005372x.png" alt="WX20190506_0005372x.png"></p>
<p>横轴是连接数，纵轴是QPS。此时，这张图反映了一个数量级，希望大家在面试的时候可以正确的描述出来，不要问你的时候，你回答的数量级相差甚远！</p>
<h2 id="Redis为什么这么快"><a href="#Redis为什么这么快" class="headerlink" title="Redis为什么这么快"></a>Redis为什么这么快</h2><ol>
<li>完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；</li>
<li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>
<li>使用多路I/O复用模型，非阻塞IO；</li>
<li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li>
</ol>
<p>以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：</p>
<p>（1）多路 I/O 复用模型</p>
<p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。</p>
<p>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p>
<h2 id="那么为什么Redis是单线程的"><a href="#那么为什么Redis是单线程的" class="headerlink" title="那么为什么Redis是单线程的"></a>那么为什么Redis是单线程的</h2><p>我们首先要明白，上边的种种分析，都是为了营造一个Redis很快的氛围！官方FAQ表示，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）。</p>
<p><img src="WX20190506_0008082x.png" alt="WX20190506_0008082x.png"></p>
<p>可以参考：<a href="https://redis.io/topics/faq" target="_blank" rel="external">https://redis.io/topics/faq</a></p>
<p>看到这里，你可能会气哭！本以为会有什么重大的技术要点才使得Redis使用单线程就可以这么快，没想到就是一句官方看似糊弄我们的回答！但是，我们已经可以很清楚的解释了为什么Redis这么快，并且正是由于在单线程模式的情况下已经很快了，就没有必要在使用多线程了！</p>
<p>但是，我们使用单线程的方式是无法发挥多核CPU 性能，不过我们可以通过在单机开多个Redis 实例来完善！</p>
<p>警告1：这里我们一直在强调的单线程，只是在处理我们的网络请求的时候只有一个线程来处理，一个正式的Redis Server运行的时候肯定是不止一个线程的，这里需要大家明确的注意一下！例如Redis进行持久化的时候会以子进程或者子线程的方式执行（具体是子线程还是子进程待读者深入研究）；例如我在测试服务器上查看Redis进程，然后找到该进程下的线程：</p>
<p><img src="WX20190506_0009082x.png" alt="WX20190506_0009082x.png"></p>
<p>ps命令的“-T”参数表示显示线程（Show threads, possibly with SPID column.）“SID”栏表示线程ID，而“CMD”栏则显示了线程名称。</p>
<p>警告2：在上图中FAQ中的最后一段，表述了从Redis 4.0版本开始会支持多线程的方式，但是，只是在某一些操作上进行多线程的操作！所以该篇文章在以后的版本中是否还是单线程的方式需要读者考证！</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>以下也是你应该知道的几种模型，祝你的面试一臂之力！</p>
<ol>
<li>单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；</li>
<li>多进程模型：Oracle（Linux版本）；</li>
<li>Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：<br>（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。<br>（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。<br>（3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。</li>
</ol>
<p><img src="WX20190506_0011102x.png" alt="WX20190506_0011102x.png"></p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247485424&amp;idx=1&amp;sn=ba52c4e9616605b4093096b43e9a7f0e&amp;chksm=e9c5fe41deb27757cef63bd50ee792a96036444605a21b7a42aad15743b254e0b782ef8d89d0&amp;scene=21#wechat_redirect" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247485424&amp;idx=1&amp;sn=ba52c4e9616605b4093096b43e9a7f0e&amp;chksm=e9c5fe41deb27757cef63bd50ee792a96036444605a21b7a42aad15743b254e0b782ef8d89d0&amp;scene=21#wechat_redirect</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-why那么快-数据存储角度</title>
    <url>/2017/09/22/Redis-why%E9%82%A3%E4%B9%88%E5%BF%AB-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%A7%92%E5%BA%A6/</url>
    <content><![CDATA[<p>Redis-why那么快-数据存储角度</p>
<a id="more"></a>
<h2 id="简介和应用"><a href="#简介和应用" class="headerlink" title="简介和应用"></a>简介和应用</h2><p>Redis是一个由ANSI C语言编写，性能优秀、支持网络、可持久化的K-V内存数据库，并提供多种语言的API。它常用的类型主要是 String、List、Hash、Set、ZSet 这5种</p>
<p><img src="6401.jpeg" alt="6401.jpeg"></p>
<p>Redis在互联网公司一般有以下应用:</p>
<ul>
<li>String：缓存、限流、计数器、分布式锁、分布式Session</li>
<li>Hash：存储用户信息、用户主页访问量、组合查询</li>
<li>List：微博关注人时间轴列表、简单队列</li>
<li>Set：赞、踩、标签、好友关系</li>
<li>Zset：排行榜</li>
</ul>
<h2 id="Redis的对象redisObject"><a href="#Redis的对象redisObject" class="headerlink" title="Redis的对象redisObject"></a>Redis的对象redisObject</h2><p>当我们执行set hello world命令时，会有以下数据模型：</p>
<p><img src="6402.png" alt="6402.png"></p>
<ul>
<li>dictEntry：Redis给每个key-value键值对分配一个dictEntry，里面有着key和val的指针，next指向下一个dictEntry形成链表，这个指针可以将多个哈希值相同的键值对链接在一起，由此来解决哈希冲突问题(链地址法)。</li>
<li>sds：键key“hello”是以SDS（简单动态字符串）存储，后面详细介绍。</li>
<li>redisObject：值val“world”存储在redisObject中。实际上，redis常用5中类型都是以redisObject来存储的；而redisObject中的type字段指明了Value对象的类型，ptr字段则指向对象所在的地址。</li>
</ul>
<p>redisObject对象非常重要，Redis对象的类型、内部编码、内存回收、共享对象等功能，都需要redisObject支持。这样设计的好处是，可以针对不同的使用场景，对5中常用类型设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。</p>
<p>无论是dictEntry对象，还是redisObject、SDS对象，都需要内存分配器（如jemalloc）分配内存进行存储。jemalloc作为Redis的默认内存分配器，在减小内存碎片方面做的相对比较好。比如jemalloc在64位系统中，将内存空间划分为小、大、巨大三个范围；每个范围内又划分了许多小的内存块单位；当Redis存储数据时，会选择大小最合适的内存块进行存储。</p>
<p>前面说过，Redis每个对象由一个redisObject结构表示，它的ptr指针指向底层实现的数据结构，而数据结构由encoding属性决定。比如我们执行以下命令得到存储“hello”对应的编码：</p>
<p><img src="6403.png" alt="6403.png"></p>
<p>redis所有的数据结构类型如下（重要，后面会用）：</p>
<p><img src="6404.jpeg" alt="6404.jpeg"></p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>字符串对象的底层实现可以是int、raw、embstr（上面的表对应有名称介绍）。embstr编码是通过调用一次内存分配函数来分配一块连续的空间，而raw需要调用两次。</p>
<p><img src="6405.png" alt="6405.png"></p>
<p>int编码字符串对象和embstr编码字符串对象在一定条件下会转化为raw编码字符串对象。embstr：&lt;=39字节的字符串。int：8个字节的长整型。raw：大于39个字节的字符串。</p>
<p>简单动态字符串（SDS），这种结构更像C++的String或者Java的ArrayList<character>，长度动态可变：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">struct sdshdr &#123;</div><div class="line">    // buf 中已占用空间的长度</div><div class="line">    int len;</div><div class="line">    // buf 中剩余可用空间的长度</div><div class="line">    int free;</div><div class="line">    // 数据空间</div><div class="line">    char buf[]; // ’\0’空字符结尾</div><div class="line">&#125;;</div></pre></td></tr></table></figure></character></p>
<ul>
<li>get：sdsrange—O(n)</li>
<li>set：sdscpy—O(n)</li>
<li>create：sdsnew—O(1)</li>
<li>len：sdslen—O(1)</li>
</ul>
<p>常数复杂度获取字符串长度：因为SDS在len属性中记录了长度，所以获取一个SDS长度时间复杂度仅为O(1)。</p>
<p>预空间分配：如果对一个SDS进行修改，分为一下两种情况：</p>
<ul>
<li>SDS长度（len的值）小于1MB，那么程序将分配和len属性同样大小的未使用空间，这时free和len属性值相同。举个例子，SDS的len将变成15字节，则程序也会分配15字节的未使用空间，SDS的buf数组的实际长度变成15+15+1=31字节（额外一个字节用户保存空字符）。</li>
<li>SDS长度（len的值）大于等于1MB，程序会分配1MB的未使用空间。比如进行修改之后，SDS的len变成30MB，那么它的实际长度是30MB+1MB+1byte。</li>
</ul>
<p>惰性释放空间：当执行sdstrim（截取字符串）之后，SDS不会立马释放多出来的空间，如果下次再进行拼接字符串操作，且拼接的没有刚才释放的空间大，则那些未使用的空间就会排上用场。通过惰性释放空间避免了特定情况下操作字符串的内存重新分配操作。</p>
<p>杜绝缓冲区溢出：使用C字符串的操作时，如果字符串长度增加（如strcat操作）而忘记重新分配内存，很容易造成缓冲区的溢出；而SDS由于记录了长度，相应的操作在可能造成缓冲区溢出时会自动重新分配内存，杜绝了缓冲区溢出。</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>List对象的底层实现是quicklist（快速列表，是ziplist 压缩列表 和linkedlist 双端链表 的组合）。Redis中的列表支持两端插入和弹出，并可以获得指定位置（或范围）的元素，可以充当数组、队列、栈等<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">typedef struct listNode &#123;</div><div class="line">     // 前置节点</div><div class="line">    struct listNode *prev;</div><div class="line">    // 后置节点</div><div class="line">    struct listNode *next;</div><div class="line">    // 节点的值</div><div class="line">    void *value;</div><div class="line"> &#125; listNode;</div><div class="line"></div><div class="line"> typedef struct list &#123;</div><div class="line">     // 表头节点</div><div class="line">    listNode *head;</div><div class="line">    // 表尾节点</div><div class="line">    listNode *tail;</div><div class="line">    // 节点值复制函数</div><div class="line">    void *(*dup)(void *ptr);</div><div class="line">    // 节点值释放函数</div><div class="line">    void (*free)(void *ptr);</div><div class="line">     // 节点值对比函数</div><div class="line">    int (*match)(void *ptr, void *key);</div><div class="line">     // 链表所包含的节点数量</div><div class="line">    unsigned long len;</div><div class="line"> &#125; list;</div></pre></td></tr></table></figure></p>
<ul>
<li>rpush: listAddNodeHead —O(1)</li>
<li>lpush: listAddNodeTail —O(1)</li>
<li>push:listInsertNode —O(1)</li>
<li>index : listIndex —O(N)</li>
<li>pop:ListFirst/listLast —O(1)</li>
<li>llen:listLength —O(N)</li>
</ul>
<h2 id="linkedlist（双端链表）"><a href="#linkedlist（双端链表）" class="headerlink" title="linkedlist（双端链表）"></a>linkedlist（双端链表）</h2><p>此结构比较像Java的LinkedList，有兴趣可以阅读一下源码</p>
<p><img src="6406.png" alt="6406.png"></p>
<p>从图中可以看出Redis的linkedlist双端链表有以下特性：节点带有prev、next指针、head指针和tail指针，获取前置节点、后置节点、表头节点和表尾节点的复杂度都是O（1）。len属性获取节点数量也为O（1）。</p>
<p>与双端链表相比，压缩列表可以节省内存空间，但是进行修改或增删操作时，复杂度较高；因此当节点数量较少时，可以使用压缩列表；但是节点数量多时，还是使用双端链表划算</p>
<h2 id="ziplist（压缩列表）"><a href="#ziplist（压缩列表）" class="headerlink" title="ziplist（压缩列表）"></a>ziplist（压缩列表）</h2><p>当一个列表键只包含少量列表项，且是小整数值或长度比较短的字符串时，那么redis就使用ziplist（压缩列表）来做列表键的底层实现。</p>
<p><img src="6407.jpeg" alt="6407.jpeg"></p>
<p>ziplist是Redis为了节约内存而开发的，是由一系列特殊编码的连续内存块(而不是像双端链表一样每个节点是指针)组成的顺序型数据结构；具体结构相对比较复杂，有兴趣读者可以看 Redis 哈希结构内存模型剖析。在新版本中list链表使用 quicklist 代替了 ziplist和 linkedlist：</p>
<p><img src="6408.png" alt="6408.png"></p>
<p>quickList 是 zipList 和 linkedList 的混合体。它将 linkedList 按段切分，每一段使用 zipList 来紧凑存储，多个 zipList 之间使用双向指针串接起来。因为链表的附加空间相对太高，prev 和 next 指针就要占去 16 个字节 (64bit 系统的指针是 8 个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。</p>
<p><img src="6409.jpeg" alt="6409.jpeg"></p>
<p>quicklist 默认的压缩深度是 0，也就是不压缩。为了支持快速的 push/pop 操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。为了进一步节约空间，Redis 还会对 ziplist 进行压缩存储，使用 LZF 算法压缩</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Hash对象的底层实现可以是ziplist（压缩列表）或者hashtable（字典或者也叫哈希表）。</p>
<p><img src="64010.jpeg" alt="64010.jpeg"></p>
<p>Hash对象只有同时满足下面两个条件时，才会使用ziplist（压缩列表）：1.哈希中元素数量小于512个；2.哈希中所有键值对的键和值字符串长度都小于64字节。</p>
<p>hashtable哈希表可以实现O(1)复杂度的读写操作，因此效率很高。源码如下：<br><figure class="highlight plain"><figcaption><span>struct dict &#123;</span></figcaption><table><tr><td class="code"><pre><div class="line">    // 类型特定函数</div><div class="line">    dictType *type;</div><div class="line">     // 私有数据</div><div class="line">    void *privdata;</div><div class="line">     // 哈希表</div><div class="line">    dictht ht[2];</div><div class="line">    // rehash 索引</div><div class="line">    // 当 rehash 不在进行时，值为 -1</div><div class="line">    int rehashidx; /* rehashing not in progress if rehashidx == -1 */</div><div class="line">     // 目前正在运行的安全迭代器的数量</div><div class="line">    int iterators; /* number of iterators currently running */</div><div class="line"> &#125; dict;</div><div class="line"> typedef struct dictht &#123;</div><div class="line">    // 哈希表数组</div><div class="line">    dictEntry **table;</div><div class="line">     // 哈希表大小</div><div class="line">    unsigned long size;</div><div class="line">    // 哈希表大小掩码，用于计算索引值</div><div class="line">    // 总是等于 size - 1</div><div class="line">    unsigned long sizemask;</div><div class="line">    // 该哈希表已有节点的数量</div><div class="line">    unsigned long used;</div><div class="line">&#125; dictht;</div><div class="line">typedef struct dictEntry &#123;</div><div class="line">    void *key;</div><div class="line">    union &#123;void *val;uint64_t u64;int64_t s64;&#125; v;</div><div class="line">    // 指向下个哈希表节点，形成链表</div><div class="line">    struct dictEntry *next;</div><div class="line"> &#125; dictEntry;</div><div class="line"> typedef struct dictType &#123;</div><div class="line">     // 计算哈希值的函数</div><div class="line">    unsigned int (*hashFunction)(const void *key);</div><div class="line">     // 复制键的函数</div><div class="line">    void *(*keyDup)(void *privdata, const void *key);</div><div class="line">     // 复制值的函数</div><div class="line">    void *(*valDup)(void *privdata, const void *obj);</div><div class="line">     // 对比键的函数</div><div class="line">    int (*keyCompare)(void *privdata, const void *key1, const void *key2);</div><div class="line">    // 销毁键的函数</div><div class="line">    void (*keyDestructor)(void *privdata, void *key);</div><div class="line">    // 销毁值的函数</div><div class="line">    void (*valDestructor)(void *privdata, void *obj);</div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure></p>
<p>上面源码可以简化成如下结构：</p>
<p><img src="64011.jpeg" alt="64011.jpeg"></p>
<p>这个结构类似于JDK7以前的HashMap<string,object>，当有两个或以上的键被分配到哈希数组的同一个索引上时，会产生哈希冲突。Redis也使用链地址法来解决键冲突。即每个哈希表节点都有一个next指针，多个哈希表节点用next指针构成一个单项链表，链地址法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位。</string,object></p>
<p>Redis中的字典使用hashtable作为底层实现的话，每个字典会带有两个哈希表，一个平时使用，另一个仅在rehash（重新散列）时使用。随着对哈希表的操作，键会逐渐增多或减少。为了让哈希表的负载因子维持在一个合理范围内，Redis会对哈希表的大小进行扩展或收缩（rehash），也就是将ht【0】里面所有的键值对分多次、渐进式的rehash到ht【1】里。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set集合对象的底层实现可以是intset（整数集合）或者hashtable（字典或者也叫哈希表）。</p>
<p><img src="64012.png" alt="64012.png"></p>
<p>intset（整数集合）当一个集合只含有整数，并且元素不多时会使用intset（整数集合）作为Set集合对象的底层实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">typedef struct intset &#123;</div><div class="line">    // 编码方式</div><div class="line">    uint32_t encoding;</div><div class="line">    // 集合包含的元素数量</div><div class="line">    uint32_t length;</div><div class="line">    // 保存元素的数组</div><div class="line">    int8_t contents[];</div><div class="line">&#125; intset;</div></pre></td></tr></table></figure>
<ul>
<li>sadd:intsetAdd—O(1)</li>
<li>smembers:intsetGetO(1)—O(N)</li>
<li>srem:intsetRemove—O(N)</li>
<li>slen:intsetlen —O(1)</li>
</ul>
<p>intset底层实现为有序，无重复数组保存集合元素。 intset这个结构里的整数数组的类型可以是16位的，32位的，64位的。如果数组里所有的整数都是16位长度的，如果新加入一个32位的整数，那么整个16的数组将升级成一个32位的数组。升级可以提升intset的灵活性，又可以节约内存，但不可逆。</p>
<h2 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h2><p>ZSet有序集合对象底层实现可以是ziplist（压缩列表）或者skiplist（跳跃表）。</p>
<p><img src="64013.jpeg" alt="64013.jpeg"></p>
<p>当一个有序集合的元素数量比较多或者成员是比较长的字符串时，Redis就使用skiplist（跳跃表）作为ZSet对象的底层实现。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">typedef struct zskiplist &#123;</div><div class="line">     // 表头节点和表尾节点</div><div class="line">    struct zskiplistNode *header, *tail;</div><div class="line">    // 表中节点的数量</div><div class="line">    unsigned long length;</div><div class="line">    // 表中层数最大的节点的层数</div><div class="line">    int level;</div><div class="line"> &#125; zskiplist;</div><div class="line">typedef struct zskiplistNode &#123;</div><div class="line">    // 成员对象</div><div class="line">    robj *obj;</div><div class="line">    // 分值</div><div class="line">    double score;</div><div class="line">     // 后退指针</div><div class="line">    struct zskiplistNode *backward;</div><div class="line">    // 层</div><div class="line">    struct zskiplistLevel &#123;</div><div class="line">        // 前进指针</div><div class="line">        struct zskiplistNode *forward;</div><div class="line">         // 跨度---前进指针所指向节点与当前节点的距离</div><div class="line">        unsigned int span;</div><div class="line">    &#125; level[];</div><div class="line">&#125; zskiplistNode;</div></pre></td></tr></table></figure></p>
<ul>
<li>zadd—zslinsert—平均O(logN), 最坏O(N)</li>
<li>zrem—zsldelete—平均O(logN), 最坏O(N)</li>
<li>zrank–zslGetRank—平均O(logN), 最坏O(N)</li>
</ul>
<p><img src="64014.jpeg" alt="64014.jpeg"></p>
<p>skiplist的查找时间复杂度是LogN，可以和平衡二叉树相当，但实现起来又比它简单。跳跃表(skiplist)是一种有序数据结构，它通过在某个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/PYlNb_zOuuvwUgdNNCoKWQ" target="_blank" rel="external">https://mp.weixin.qq.com/s/PYlNb_zOuuvwUgdNNCoKWQ</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-事务</title>
    <url>/2017/09/22/Redis-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>Redis-事务<br>推荐看这篇: <a href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html" target="_blank" rel="external">Redis 设计与实现</a></p>
<a id="more"></a>
<h2 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h2><p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：redis事务就是<strong>一次性、顺序性、排他性</strong>的执行一个队列中的一系列命令</p>
<h2 id="Redis事务没有隔离级别的概念"><a href="#Redis事务没有隔离级别的概念" class="headerlink" title="Redis事务没有隔离级别的概念"></a>Redis事务没有隔离级别的概念</h2><p>批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p>
<h2 id="Redis事务不保证原子性"><a href="#Redis事务不保证原子性" class="headerlink" title="Redis事务不保证原子性"></a>Redis事务不保证原子性</h2><p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行</p>
<h2 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h2><ol>
<li>开始事务</li>
<li>命令入队</li>
<li>执行事务</li>
</ol>
<h2 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h2><ul>
<li>watch key1 key2 … : 监视一或多个key,如果在事务执行之前，被监视的key被其他命令改动，则事务被打断 （ 类似乐观锁 ）</li>
<li>multi : 标记一个事务块的开始（ queued ）</li>
<li>exec : 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ）　</li>
<li>discard : 取消事务，放弃事务块中的所有命令</li>
<li>unwatch : 取消watch对所有key的监控</li>
</ul>
<h2 id="Redis事务使用案例"><a href="#Redis事务使用案例" class="headerlink" title="Redis事务使用案例"></a>Redis事务使用案例</h2><h3 id="正常执行"><a href="#正常执行" class="headerlink" title="正常执行"></a>正常执行</h3><p><img src="1659331-20190416204151947-1999193750.png" alt="1659331-20190416204151947-1999193750.png"></p>
<h3 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h3><p><img src="1659331-20190416204558119-2028373874.png" alt="1659331-20190416204558119-2028373874.png"></p>
<h3 id="若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行"><a href="#若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行" class="headerlink" title="若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行"></a>若在事务队列中存在命令性错误（类似于java编译性错误），则执行EXEC命令时，所有命令都不会执行</h3><p><img src="1659331-20190416205137740-1887538258.png" alt="1659331-20190416205137740-1887538258.png"></p>
<h3 id="若在事务队列中存在语法性错误（类似于java的1-0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常"><a href="#若在事务队列中存在语法性错误（类似于java的1-0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常" class="headerlink" title="若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常"></a>若在事务队列中存在语法性错误（类似于java的1/0的运行时异常），则执行EXEC命令时，其他正确命令会被执行，错误命令抛出异常</h3><p><img src="1659331-20190416205714294-77806844.png" alt="1659331-20190416205714294-77806844.png"></p>
<h3 id="使用watch"><a href="#使用watch" class="headerlink" title="使用watch"></a>使用watch</h3><p>案例一：使用watch检测balance，事务期间balance数据未变动，事务执行成功</p>
<p><img src="1659331-20190416210530600-1167641209.png" alt="1659331-20190416210530600-1167641209.png"></p>
<p>案例二：使用watch检测balance，在开启事务后（标注1处），在新窗口执行标注2中的操作，更改balance的值，模拟其他客户端在事务执行期间更改watch监控的数据，然后再执行标注1后命令，执行EXEC后，事务未成功执行。</p>
<p><img src="1659331-20190416211144923-1469436233.png" alt="1659331-20190416211144923-1469436233.png"><br><img src="1659331-20190416211149567-1618751187.png" alt="1659331-20190416211149567-1618751187.png"></p>
<p>一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WATCH 对变量的监控都将被取消。</p>
<p>故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。</p>
<p><strong>总结</strong><br>watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败</p>
<h2 id="为什么Redis不支持回滚"><a href="#为什么Redis不支持回滚" class="headerlink" title="为什么Redis不支持回滚"></a>为什么Redis不支持回滚</h2><p>Redis命令在事务中可能会执行失败，但是Redis事务不会回滚，而是继续会执行余下的命令。如果您有一个关系型数据库的知识，这对您来说可能会感到奇怪，因为关系型数据在这种情况下都是会回滚的。</p>
<p>Redis这样做，主要是因为:</p>
<ul>
<li>只有当发生语法错误(这个问题在命令队列时无法检测到)了，Redis命令才会执行失败, 或对keys赋予了一个类型错误的数据：这意味着这些都是程序性错误，这类错误在开发的过程中就能够发现并解决掉，几乎不会出现在生产环境。</li>
<li>由于不需要回滚，这使得Redis内部更加简单，而且运行速度更快</li>
</ul>
<h2 id="Redis-事务在-SpringBoot-中的应用"><a href="#Redis-事务在-SpringBoot-中的应用" class="headerlink" title="Redis 事务在 SpringBoot 中的应用"></a>Redis 事务在 SpringBoot 中的应用</h2><p>我们在 SpringBoot 中使用 Redis 时，会引入如下的 redis starter<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>首先，看一看当前测试用例的主体代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import com.imooc.ad.Application;</div><div class="line">import org.junit.Test;</div><div class="line">import org.junit.runner.RunWith;</div><div class="line">import org.springframework.beans.factory.annotation.Autowired;</div><div class="line">import org.springframework.boot.test.context.SpringBootTest;</div><div class="line">import org.springframework.dao.DataAccessException;</div><div class="line">import org.springframework.data.redis.core.RedisOperations;</div><div class="line">import org.springframework.data.redis.core.SessionCallback;</div><div class="line">import org.springframework.data.redis.core.StringRedisTemplate;</div><div class="line">import org.springframework.test.context.junit4.SpringRunner;</div><div class="line"></div><div class="line">/**</div><div class="line"> * &lt;h1&gt;Redis 事务测试&lt;/h1&gt;</div><div class="line"> * Created by Qinyi.</div><div class="line"> */</div><div class="line">@RunWith(SpringRunner.class)</div><div class="line">@SpringBootTest(classes = &#123;Application.class&#125;, webEnvironment = SpringBootTest.WebEnvironment.NONE)</div><div class="line">public class RedisTransTest &#123;</div><div class="line"></div><div class="line">    /** 注入 StringRedisTemplate, 使用默认配置 */</div><div class="line">    @Autowired</div><div class="line">    private StringRedisTemplate stringRedisTemplate;</div></pre></td></tr></table></figure>
<p>错误的用法<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * &lt;h2&gt;没有开启事务支持: 事务执行会失败&lt;/h2&gt;</div><div class="line"> * */</div><div class="line">@Test</div><div class="line">public void testMultiFailure() &#123;</div><div class="line"></div><div class="line">  stringRedisTemplate.multi();</div><div class="line">  stringRedisTemplate.opsForValue().set(&quot;name&quot;, &quot;qinyi&quot;);</div><div class="line">  stringRedisTemplate.opsForValue().set(&quot;gender&quot;, &quot;male&quot;);</div><div class="line">  stringRedisTemplate.opsForValue().set(&quot;age&quot;, &quot;19&quot;);</div><div class="line">  System.out.println(stringRedisTemplate.exec());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行以上测试用例，会抛出如下的异常信息：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Error in execution; nested exception is io.lettuce.core.RedisCommandExecutionException: ERR EXEC without MULTI</div></pre></td></tr></table></figure></p>
<p>这里给出的错误信息显示：在执行 EXEC 命令之前，没有执行 MULTI 命令。这很奇怪，我们明明在测试方法的第一句就执行了 MULTI。通过追踪 multi、exec 等方法，我们可以看到如下的执行源码（spring-data-redis）：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public &lt;T&gt; T execute(RedisCallback&lt;T&gt; action, boolean exposeConnection, boolean pipeline) &#123;</div><div class="line"></div><div class="line">  Assert.isTrue(initialized, &quot;template not initialized; call afterPropertiesSet() before using it&quot;);</div><div class="line">  Assert.notNull(action, &quot;Callback object must not be null&quot;);</div><div class="line"></div><div class="line">  RedisConnectionFactory factory = getRequiredConnectionFactory();</div><div class="line">  RedisConnection conn = null;</div><div class="line">  try &#123;</div><div class="line">    // RedisTemplate 的 enableTransactionSupport 属性标识是否开启了事务支持，默认是 false</div><div class="line">	   if (enableTransactionSupport) &#123;</div><div class="line">		     // only bind resources in case of potential transaction synchronization</div><div class="line">		       conn = RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);</div><div class="line">	   &#125; else &#123;</div><div class="line">		     conn = RedisConnectionUtils.getConnection(factory);</div><div class="line">	   &#125;</div><div class="line"></div><div class="line">     boolean existingConnection = TransactionSynchronizationManager.hasResource(factory);</div></pre></td></tr></table></figure></p>
<p>源码中已经给出了答案：由于 enableTransactionSupport 属性的默认值是 false，导致了每一个 RedisConnection 都是重新获取的。所以，我们刚刚执行的 MULTI 和 EXEC 这两个命令不在同一个 Connection 中。</p>
<p>解决上述示例的问题，最简单的办法就是让 RedisTemplate 开启事务支持，即设置 enableTransactionSupport 为 true 就可以了。测试代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * &lt;h2&gt;开启事务支持: 成功执行事务&lt;/h2&gt;</div><div class="line"> * */</div><div class="line">@Test</div><div class="line">public void testMultiSuccess() &#123;</div><div class="line">  // 开启事务支持，在同一个 Connection 中执行命令</div><div class="line">  stringRedisTemplate.setEnableTransactionSupport(true);</div><div class="line"></div><div class="line">  stringRedisTemplate.multi();</div><div class="line">  stringRedisTemplate.opsForValue().set(&quot;name&quot;, &quot;qinyi&quot;);</div><div class="line">  stringRedisTemplate.opsForValue().set(&quot;gender&quot;, &quot;male&quot;);</div><div class="line">  stringRedisTemplate.opsForValue().set(&quot;age&quot;, &quot;19&quot;);</div><div class="line">  System.out.println(stringRedisTemplate.exec());     // [true, true, true]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>更常见的写法仍是采用 RedisTemplate 的默认配置，即不开启事务支持。但是，我们可以通过使用 SessionCallback，该接口保证其内部所有操作都是在同一个Session中。测试代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * &lt;h2&gt;使用 SessionCallback, 在同一个 Redis Connection 中执行事务: 成功执行事务&lt;/h2&gt;</div><div class="line"> * */</div><div class="line">@Test</div><div class="line">@SuppressWarnings(&quot;all&quot;)</div><div class="line">public void testSessionCallback() &#123;</div><div class="line"></div><div class="line">    SessionCallback&lt;Object&gt; callback = new SessionCallback&lt;Object&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public Object execute(RedisOperations operations) throws DataAccessException &#123;</div><div class="line">            operations.multi();</div><div class="line">            operations.opsForValue().set(&quot;name&quot;, &quot;qinyi&quot;);</div><div class="line">            operations.opsForValue().set(&quot;gender&quot;, &quot;male&quot;);</div><div class="line">            operations.opsForValue().set(&quot;age&quot;, &quot;19&quot;);</div><div class="line">            return operations.exec();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    // [true, true, true]</div><div class="line">    System.out.println(stringRedisTemplate.execute(callback));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>总结：我们在 SpringBoot 中操作 Redis 时，使用 RedisTemplate 的默认配置已经能够满足大部分的场景了。如果要执行事务操作，使用 SessionCallback 是比较好，也是比较常用的选择</p>
<p>ref:<br><a href="https://www.cnblogs.com/DeepInThought/p/10720132.html" target="_blank" rel="external">https://www.cnblogs.com/DeepInThought/p/10720132.html</a><br><a href="https://baijiahao.baidu.com/s?id=1613631210471699441&amp;wfr=spider&amp;for=pc" target="_blank" rel="external">https://baijiahao.baidu.com/s?id=1613631210471699441&amp;wfr=spider&amp;for=pc</a><br><a href="http://www.imooc.com/article/28131" target="_blank" rel="external">http://www.imooc.com/article/28131</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-分布式锁的正确实现方式</title>
    <url>/2017/09/22/Redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，本篇博客将详细介绍如何正确地实现Redis分布式锁。<br>注: 本文针对 Redis 单机部署场景</p>
<a id="more"></a>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<ul>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="组件依赖"><a href="#组件依赖" class="headerlink" title="组件依赖"></a>组件依赖</h3><p>首先我们要通过Maven引入Jedis开源组件，在pom.xml文件加入下面的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<h3 id="加锁代码"><a href="#加锁代码" class="headerlink" title="加锁代码"></a>加锁代码</h3><h4 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class RedisTool &#123;</div><div class="line"></div><div class="line">    private static final String LOCK_SUCCESS = &quot;OK&quot;;</div><div class="line">    private static final String SET_IF_NOT_EXIST = &quot;NX&quot;;</div><div class="line">    private static final String SET_WITH_EXPIRE_TIME = &quot;PX&quot;;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 尝试获取分布式锁</div><div class="line">     * @param jedis Redis客户端</div><div class="line">     * @param lockKey 锁</div><div class="line">     * @param requestId 请求标识</div><div class="line">     * @param expireTime 超期时间</div><div class="line">     * @return 是否获取成功</div><div class="line">     */</div><div class="line">    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) &#123;</div><div class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</div><div class="line"></div><div class="line">        if (LOCK_SUCCESS.equals(result)) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：</p>
<ul>
<li>key，我们使用key来当锁，因为key是唯一的。</li>
<li>value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</li>
<li>nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li>
<li>expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li>
<li>time，与第四个参数相呼应，代表key的过期时间。</li>
</ul>
<p>总的来说，执行上面的set()方法就只会导致两种结果：</p>
<ul>
<li>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。</li>
<li>已有锁存在，不做任何操作。</li>
</ul>
<p>心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</p>
<p>最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p>
<h4 id="错误示例1"><a href="#错误示例1" class="headerlink" title="错误示例1"></a>错误示例1</h4><p>比较常见的错误示例就是使用jedis.setnx()和jedis.expire()组合实现加锁，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void wrongGetLock1(Jedis jedis, String lockKey, String requestId, int expireTime) &#123;</div><div class="line">    Long result = jedis.setnx(lockKey, requestId);</div><div class="line">    if (result == 1) &#123;</div><div class="line">        // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</div><div class="line">        jedis.expire(lockKey, expireTime);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。乍一看好像和前面的set()方法结果一样，然而由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。</p>
<h4 id="错误示例2"><a href="#错误示例2" class="headerlink" title="错误示例2"></a>错误示例2</h4><p>这一种错误示例就比较难以发现问题，而且实现也比较复杂。实现思路：使用jedis.setnx()命令实现加锁，其中key是锁，value是锁的过期时间。</p>
<p>执行过程：</p>
<ol>
<li>通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。</li>
<li>如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功。</li>
</ol>
<p>代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static boolean wrongGetLock2(Jedis jedis, String lockKey, int expireTime) &#123;</div><div class="line">    long expires = System.currentTimeMillis() + expireTime;</div><div class="line">    String expiresStr = String.valueOf(expires);</div><div class="line"></div><div class="line">    // 如果当前锁不存在，返回加锁成功</div><div class="line">    if (jedis.setnx(lockKey, expiresStr) == 1) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 如果锁存在，获取锁的过期时间</div><div class="line">    String currentValueStr = jedis.get(lockKey);</div><div class="line">    if (currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</div><div class="line">        // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</div><div class="line">        String oldValueStr = jedis.getSet(lockKey, expiresStr);</div><div class="line">        if (oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</div><div class="line">            // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 其他情况，一律返回加锁失败</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么这段代码问题在哪里？1. 由于是客户端自己生成过期时间，所以需要强制要求分布式下每个客户端的时间必须同步。 2. 当锁过期的时候，如果多个客户端同时执行jedis.getSet()方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。3. 锁不具备拥有者标识，即任何客户端都可以解锁。</p>
<h3 id="解锁代码"><a href="#解锁代码" class="headerlink" title="解锁代码"></a>解锁代码</h3><h4 id="正确姿势-1"><a href="#正确姿势-1" class="headerlink" title="正确姿势"></a>正确姿势</h4><p>还是先展示代码，再带大家慢慢解释为什么这样实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class RedisTool &#123;</div><div class="line"></div><div class="line">    private static final Long RELEASE_SUCCESS = 1L;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 释放分布式锁</div><div class="line">     * @param jedis Redis客户端</div><div class="line">     * @param lockKey 锁</div><div class="line">     * @param requestId 请求标识</div><div class="line">     * @return 是否释放成功</div><div class="line">     */</div><div class="line">    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) &#123;</div><div class="line">        String script = &quot;if redis.call(&apos;get&apos;, KEYS[1]) == ARGV[1] then return redis.call(&apos;del&apos;, KEYS[1]) else return 0 end&quot;;</div><div class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</div><div class="line"></div><div class="line">        if (RELEASE_SUCCESS.equals(result)) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</p>
<p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读【解锁代码-错误示例2】 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：</p>
<p>简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</p>
<h4 id="错误示例1-1"><a href="#错误示例1-1" class="headerlink" title="错误示例1"></a>错误示例1</h4><p>最常见的解锁代码就是直接使用jedis.del()方法删除锁，这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void wrongReleaseLock1(Jedis jedis, String lockKey) &#123;</div><div class="line">    jedis.del(lockKey);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="错误示例2-1"><a href="#错误示例2-1" class="headerlink" title="错误示例2"></a>错误示例2</h4><p>这种解锁代码乍一看也是没问题，甚至我之前也差点这样实现，与正确姿势差不多，唯一区别的是分成两条命令去执行，代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void wrongReleaseLock2(Jedis jedis, String lockKey, String requestId) &#123;</div><div class="line"></div><div class="line">    // 判断加锁与解锁是不是同一个客户端</div><div class="line">    if (requestId.equals(jedis.get(lockKey))) &#123;</div><div class="line">        // 若在此时，这把锁突然不是这个客户端的，则会误解锁</div><div class="line">        jedis.del(lockKey);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如代码注释，问题在于如果调用jedis.del()方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行jedis.del()之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了如何使用Java代码正确实现Redis分布式锁，对于加锁和解锁也分别给出了两个比较经典的错误示例。其实想要通过Redis实现分布式锁并不难，只要保证能满足可靠性里的四个条件。互联网虽然给我们带来了方便，只要有问题就可以google，然而网上的答案一定是对的吗？其实不然，所以我们更应该时刻保持着质疑精神，多想多验证。</p>
<p>如果你的项目中Redis是多机部署的，那么可以尝试使用Redisson实现分布式锁，这是Redis官方提供的Java组件。</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/XoXcqpehhXSQlRxgCBtDcw" target="_blank" rel="external">https://mp.weixin.qq.com/s/XoXcqpehhXSQlRxgCBtDcw</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-危险命令</title>
    <url>/2017/09/22/Redis-%E5%8D%B1%E9%99%A9%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>据云头条报道，某公司技术部发生 2 起本年度 PO 级特大事故，造成公司资金损失 400 万，原因如下：<br>由于 PHP 工程师直接操作上线 redis，执行 keys <em> wxdb（此处省略）cf8</em> 这样的命令，导致redis锁住，导致 CPU 飙升，引起所有支付链路卡住，等十几秒结束后，所有的请求流量全部挤压到了 rds 数据库中，使数据库产生了雪崩效应，发生了数据库宕机事件。</p>
<p>对 Redis 稍微有点使用经验的人都知道线上是不能执行 keys * 相关命令的，虽然其模糊匹配功能使用非常方便也很强大，在小数据量情况下使用没什么问题，数据量大会导致 Redis 锁住及 CPU 飙升，在生产环境建议禁用或者重命名！</p>
<a id="more"></a>
<h2 id="还有哪些危险命令"><a href="#还有哪些危险命令" class="headerlink" title="还有哪些危险命令"></a>还有哪些危险命令</h2><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p>客户端可查询出所有存在的键</p>
<h3 id="flushdb"><a href="#flushdb" class="headerlink" title="flushdb"></a>flushdb</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Delete all the keys of the currently selected DB. This command never fails.</div></pre></td></tr></table></figure>
<p>删除 Redis 中当前所在数据库中的所有记录，并且此命令从不会执行失败</p>
<h3 id="flushall"><a href="#flushall" class="headerlink" title="flushall"></a>flushall</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.</div></pre></td></tr></table></figure>
<p>删除 Redis 中所有数据库中的所有记录，不只是当前所在数据库，并且此命令从不会执行失败。</p>
<h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>客户端可修改 Redis 配置</p>
<h2 id="怎么禁用或重命名危险命令"><a href="#怎么禁用或重命名危险命令" class="headerlink" title="怎么禁用或重命名危险命令"></a>怎么禁用或重命名危险命令</h2><p>看下 redis.conf 默认配置文件，找到 SECURITY 区域，如以下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">################################## SECURITY ###################################</div><div class="line"></div><div class="line"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</div><div class="line"># commands.  This might be useful in environments in which you do not trust</div><div class="line"># others with access to the host running redis-server.</div><div class="line">#</div><div class="line"># This should stay commented out for backward compatibility and because most</div><div class="line"># people do not need auth (e.g. they run their own servers).</div><div class="line">#</div><div class="line"># Warning: since Redis is pretty fast an outside user can try up to</div><div class="line"># 150k passwords per second against a good box. This means that you should</div><div class="line"># use a very strong password otherwise it will be very easy to break.</div><div class="line">#</div><div class="line"># requirepass foobared</div><div class="line"></div><div class="line"># Command renaming.</div><div class="line">#</div><div class="line"># It is possible to change the name of dangerous commands in a shared</div><div class="line"># environment. For instance the CONFIG command may be renamed into something</div><div class="line"># hard to guess so that it will still be available for internal-use tools</div><div class="line"># but not available for general clients.</div><div class="line">#</div><div class="line"># Example:</div><div class="line">#</div><div class="line"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</div><div class="line">#</div><div class="line"># It is also possible to completely kill a command by renaming it into</div><div class="line"># an empty string:</div><div class="line">#</div><div class="line"># rename-command CONFIG &quot;&quot;</div><div class="line">#</div><div class="line"># Please note that changing the name of commands that are logged into the</div><div class="line"># AOF file or transmitted to slaves may cause problems.</div></pre></td></tr></table></figure>
<p>看说明，添加 rename-command 配置即可达到安全目的。</p>
<h3 id="禁用命令"><a href="#禁用命令" class="headerlink" title="禁用命令"></a>禁用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">rename-command KEYS     &quot;&quot;</div><div class="line">rename-command FLUSHALL &quot;&quot;</div><div class="line">rename-command FLUSHDB  &quot;&quot;</div><div class="line">rename-command CONFIG   &quot;&quot;</div></pre></td></tr></table></figure>
<h3 id="重命名命令"><a href="#重命名命令" class="headerlink" title="重命名命令"></a>重命名命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">rename-command KEYS     &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</div><div class="line">rename-command FLUSHALL &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</div><div class="line">rename-command FLUSHDB  &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</div><div class="line">rename-command CONFIG   &quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</div></pre></td></tr></table></figure>
<p>上面的 XX 可以定义新命令名称，或者用随机字符代替。</p>
<p>经过以上的设置之后，危险命令就不会被客户端执行了。</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247487198&amp;idx=2&amp;sn=eea95b2fbad114cabbfbcf1804b8b081&amp;chksm=eb538be8dc2402fee685771deff4852214bc908448ca3cc3644794d66d72d8af843289f0d65d&amp;scene=21#wechat_redirect" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247487198&amp;idx=2&amp;sn=eea95b2fbad114cabbfbcf1804b8b081&amp;chksm=eb538be8dc2402fee685771deff4852214bc908448ca3cc3644794d66d72d8af843289f0d65d&amp;scene=21#wechat_redirect</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-基于SETNX实现分布式锁</title>
    <url>/2017/09/22/Redis-%E5%9F%BA%E4%BA%8ESETNX%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p>基于 Redis SETNX 实现分布式锁</p>
<a id="more"></a>
<h2 id="环境与配置"><a href="#环境与配置" class="headerlink" title="环境与配置"></a>环境与配置</h2><ul>
<li>Redis 任意版本即可</li>
<li>SpringBoot 任意版本即可，但是需要依赖 spring-boot-starter-data-redis<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Redis-社区对-SETNX-的解释"><a href="#Redis-社区对-SETNX-的解释" class="headerlink" title="Redis 社区对 SETNX 的解释"></a>Redis 社区对 SETNX 的解释</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Set key to hold string value if key does not exist. In that case, it is equal to SET. When key already holds a value, no operation is performed. SETNX is short for “SET if Not eXists”.</div></pre></td></tr></table></figure>
<p>Return value: Integer reply, specifically:</p>
<ul>
<li>1 if the key was set</li>
<li>0 if the key was not set</li>
</ul>
<p>由于当某个 key 不存在的时候，SETNX 才会设置该 key。且由于 Redis 采用单进程单线程模型，所以，不需要担心并发的问题。那么，就可以利用 SETNX 的特性维护一个 key，存在的时候，即锁被某个线程持有；不存在的时候，没有线程持有锁。</p>
<h2 id="关于实现的解释"><a href="#关于实现的解释" class="headerlink" title="关于实现的解释"></a>关于实现的解释</h2><p>由于只涉及到 Redis 的操作，所以，代码实现比较简单。只对外提供两个接口：获取锁、释放锁。</p>
<ul>
<li>IDistributedLock: 操作接口定义</li>
<li>RedisLock: IDistributedLock 的实现类</li>
<li>DistributedLockUtil: 分布式锁工具类</li>
<li>SpringContextUtil: 获取当前 classpath 中的 Bean</li>
</ul>
<p>SETNX 命令对应到 StringRedisTemplate 的 api 是 setIfAbsent，如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * Set &#123;@code key&#125; to hold the string &#123;@code value&#125; if &#123;@code key&#125; is absent.</div><div class="line"> *</div><div class="line"> * @param key must not be &#123;@literal null&#125;.</div><div class="line"> * @param value</div><div class="line"> * @see &lt;a href=&quot;http://redis.io/commands/setnx&quot;&gt;Redis Documentation: SETNX&lt;/a&gt;</div><div class="line"> */</div><div class="line">Boolean setIfAbsent(K key, V value);</div></pre></td></tr></table></figure>
<h2 id="源码和注释信息"><a href="#源码和注释信息" class="headerlink" title="源码和注释信息"></a>源码和注释信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * &lt;h1&gt;分布式锁接口&lt;/h1&gt;</div><div class="line"> * 只需要两个接口: 获取锁与释放锁</div><div class="line"> */</div><div class="line">public interface IDistributedLock &#123;</div><div class="line">    /**</div><div class="line">     * &lt;h2&gt;获取锁&lt;/h2&gt;</div><div class="line">     * */</div><div class="line">    boolean acquire();</div><div class="line">    /**</div><div class="line">     * &lt;h2&gt;释放锁&lt;/h2&gt;</div><div class="line">     * */</div><div class="line">    void release();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import SpringContextUtil;</div><div class="line">import lombok.extern.slf4j.Slf4j;</div><div class="line">import org.springframework.data.redis.core.StringRedisTemplate;</div><div class="line"></div><div class="line">/**</div><div class="line"> * &lt;h1&gt;基于 Redis 实现的分布式锁&lt;/h1&gt;</div><div class="line"> */</div><div class="line">@Slf4j</div><div class="line">public class RedisLock implements IDistributedLock &#123;</div><div class="line"></div><div class="line">    /** redis client */</div><div class="line">    private static StringRedisTemplate redisTemplate;</div><div class="line"></div><div class="line">    private String lockKey;                 // 锁的键值</div><div class="line">    private int expireMsecs = 15 * 1000;    // 锁超时, 防止线程得到锁之后, 不去释放锁</div><div class="line">    private int timeoutMsecs = 15 * 1000;   // 锁等待, 防止线程饥饿</div><div class="line">    private boolean locked = false;         // 是否已经获取锁</div><div class="line"></div><div class="line">    RedisLock(String lockKey) &#123;</div><div class="line">        this.lockKey = lockKey;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    RedisLock(String lockKey, int timeoutMsecs) &#123;</div><div class="line">        this.lockKey = lockKey;</div><div class="line">        this.timeoutMsecs = timeoutMsecs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    RedisLock(String lockKey, int expireMsecs, int timeoutMsecs) &#123;</div><div class="line">        this.lockKey = lockKey;</div><div class="line">        this.expireMsecs = expireMsecs;</div><div class="line">        this.timeoutMsecs = timeoutMsecs;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getLockKey() &#123;</div><div class="line">        return this.lockKey;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public synchronized boolean acquire() &#123;</div><div class="line"></div><div class="line">        int timeout = timeoutMsecs;</div><div class="line"></div><div class="line">        if (redisTemplate == null) &#123;</div><div class="line">            redisTemplate = SpringContextUtil.getBean(StringRedisTemplate.class);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line"></div><div class="line">            while (timeout &gt;= 0) &#123;</div><div class="line"></div><div class="line">                long expires = System.currentTimeMillis() + expireMsecs + 1;</div><div class="line">                String expiresStr = String.valueOf(expires); // 锁到期时间</div><div class="line"></div><div class="line">                if (redisTemplate.opsForValue().setIfAbsent(lockKey, expiresStr)) &#123;</div><div class="line">                    locked = true;</div><div class="line">                    log.info(&quot;[1] 成功获取分布式锁!&quot;);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">                String currentValueStr = redisTemplate.opsForValue().get(lockKey); // redis里的时间</div><div class="line"></div><div class="line">                // 判断是否为空, 不为空的情况下, 如果被其他线程设置了值, 则第二个条件判断是过不去的</div><div class="line">                if (currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</div><div class="line"></div><div class="line">                    String oldValueStr = redisTemplate.opsForValue().getAndSet(lockKey, expiresStr);</div><div class="line"></div><div class="line">                    // 获取上一个锁到期时间, 并设置现在的锁到期时间</div><div class="line">                    // 只有一个线程才能获取上一个线程的设置时间</div><div class="line">                    // 如果这个时候, 多个线程恰好都到了这里, 但是只有一个线程的设置值和当前值相同, 它才有权利获取锁</div><div class="line">                    if (oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</div><div class="line">                        locked = true;</div><div class="line">                        log.info(&quot;[2] 成功获取分布式锁!&quot;);</div><div class="line">                        return true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                timeout -= 100;</div><div class="line">                Thread.sleep(100);</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;获取锁出现异常, 必须释放: &#123;&#125;&quot;, e.getMessage());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public synchronized void release() &#123;</div><div class="line"></div><div class="line">        if (redisTemplate == null) &#123;</div><div class="line">            redisTemplate = SpringContextUtil.getBean(StringRedisTemplate.class);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            if (locked) &#123;</div><div class="line"></div><div class="line">                String currentValueStr = redisTemplate.opsForValue().get(lockKey); // redis里的时间</div><div class="line"></div><div class="line">                // 校验是否超过有效期, 如果不在有效期内, 那说明当前锁已经失效, 不能进行删除锁操作</div><div class="line">                if (currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &gt; System.currentTimeMillis()) &#123;</div><div class="line">                    redisTemplate.delete(lockKey);</div><div class="line">                    locked = false;</div><div class="line">                    log.info(&quot;[3] 成功释放分布式锁!&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            log.error(&quot;释放锁出现异常, 必须释放: &#123;&#125;&quot;, e.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * &lt;h1&gt;分布式锁工具类&lt;/h1&gt;</div><div class="line"> */</div><div class="line">public class DistributedLockUtil &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取分布式锁</div><div class="line">     * 默认获取锁15s超时, 锁过期时间15s</div><div class="line">     */</div><div class="line">    public static IDistributedLock getDistributedLock(String lockKey) &#123;</div><div class="line">        lockKey = assembleKey(lockKey);</div><div class="line">        return new RedisLock(lockKey);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取分布式锁</div><div class="line">     */</div><div class="line">    public static IDistributedLock getDistributedLock(String lockKey, int timeoutMsecs) &#123;</div><div class="line">        lockKey = assembleKey(lockKey);</div><div class="line">        return new RedisLock(lockKey, timeoutMsecs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取分布式锁</div><div class="line">     */</div><div class="line">    public static IDistributedLock getDistributedLock(String lockKey, int timeoutMsecs, int expireMsecs) &#123;</div><div class="line">        lockKey = assembleKey(lockKey);</div><div class="line">        return new RedisLock(lockKey, expireMsecs, timeoutMsecs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 对 key 进行拼接</div><div class="line">     */</div><div class="line">    private static String assembleKey(String lockKey) &#123;</div><div class="line">        return String.format(&quot;imooc_analyze_%s&quot;, lockKey);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.springframework.beans.BeansException;</div><div class="line">import org.springframework.context.ApplicationContext;</div><div class="line">import org.springframework.context.ApplicationContextAware;</div><div class="line">import org.springframework.stereotype.Component;</div><div class="line"></div><div class="line">/**</div><div class="line"> * &lt;h1&gt;获取当前 classpath 中的 Bean&lt;/h1&gt;</div><div class="line"> */</div><div class="line">@Component</div><div class="line">public class SpringContextUtil implements ApplicationContextAware &#123;</div><div class="line"></div><div class="line">    private static ApplicationContext applicationContext;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;</div><div class="line">        SpringContextUtil.applicationContext = applicationContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static ApplicationContext getApplicationContext() &#123;</div><div class="line">        return applicationContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    public static &lt;T&gt; T getBean(Class c) throws BeansException &#123;</div><div class="line">        return (T) applicationContext.getBean(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ref:<br><a href="http://www.imooc.com/article/280456" target="_blank" rel="external">http://www.imooc.com/article/280456</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-持久化</title>
    <url>/2017/09/22/Redis-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>Redis-持久化</p>
<a id="more"></a>
<h2 id="Redis高可用概述"><a href="#Redis高可用概述" class="headerlink" title="Redis高可用概述"></a>Redis高可用概述</h2><p>在介绍Redis高可用之前，先说明一下在Redis的语境中高可用的含义。</p>
<p>我们知道，在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务（99.9%、99.99%、99.999% 等等）。但是在Redis语境中，高可用的含义似乎要宽泛一些，除了保证提供正常服务(如主从分离、快速容灾技术)，还需要考虑数据容量的扩展、数据安全不会丢失等。</p>
<p>在Redis中，实现高可用的技术主要包括持久化、复制、哨兵和集群，下面分别说明它们的作用，以及解决了什么样的问题。</p>
<ol>
<li>持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。</li>
<li>复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。</li>
<li>哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。</li>
<li>集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。</li>
</ol>
<h2 id="Redis持久化概述"><a href="#Redis持久化概述" class="headerlink" title="Redis持久化概述"></a>Redis持久化概述</h2><p>持久化的功能：Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘；当下次Redis重启时，利用持久化文件实现数据恢复。除此之外，为了进行灾难备份，可以将持久化文件拷贝到一个远程位置。</p>
<p>Redis持久化分为RDB持久化和AOF持久化：前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘（类似于MySQL的binlog）；由于AOF持久化的实时性更好，即当进程意外退出时丢失的数据更少，因此AOF是目前主流的持久化方式，不过RDB持久化仍然有其用武之地。</p>
<p>下面依次介绍RDB持久化和AOF持久化；由于Redis各个版本之间存在差异，如无特殊说明，以Redis3.0为准。</p>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p>RDB持久化是将当前进程中的数据生成快照保存到硬盘(因此也称作快照持久化)，保存的文件后缀是rdb；当Redis重新启动时，可以读取快照文件恢复数据。</p>
<h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h3><p>RDB持久化的触发分为手动触发和自动触发两种。</p>
<p>1) 手动触发<br>save命令和bgsave命令都可以生成RDB文件。 save命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求。</p>
<p>bgsave命令会创建一个子进程，由子进程来负责创建RDB文件，父进程(即Redis主进程)则继续处理请求. bgsave命令执行过程中，只有fork子进程时会阻塞服务器，而对于save命令，整个过程都会阻塞服务器，因此save已基本被废弃，线上环境要杜绝save的使用；后文中也将只介绍bgsave命令。此外，在自动触发RDB持久化时，Redis也会选择bgsave而不是save来进行持久化；下面介绍自动触发RDB持久化的条件</p>
<p><img src="6401.png" alt="6401.png"><br><img src="6402.png" alt="6402.png"></p>
<p>2) 自动触发<br>save m n</p>
<p>自动触发最常见的情况是在配置文件中通过save m n，指定当m秒内发生n次变化时，会触发bgsave。</p>
<p>例如，查看redis的默认配置文件(Linux下为redis根目录下的redis.conf)，可以看到如下配置信息：</p>
<p><img src="6403.jpeg" alt="6403.jpeg"></p>
<p>其中save 900 1的含义是：当时间到900秒时，如果redis数据发生了至少1次变化，则执行bgsave；save 300 10和save 60 10000同理。当三个save条件满足任意一个时，都会引起bgsave的调用。</p>
<p>save m n的实现原理</p>
<p>Redis的save m n，是通过serverCron函数、dirty计数器、和lastsave时间戳来实现的。</p>
<p>serverCron是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是检查 save m n 配置的条件是否满足，如果满足就执行bgsave。</p>
<p>dirty计数器是Redis服务器维持的一个状态，记录了上一次执行bgsave/save命令后，服务器状态进行了多少次修改(包括增删改)；而当save/bgsave执行完成后，会将dirty重新置为0。</p>
<p>例如，如果Redis执行了set mykey helloworld，则dirty值会+1；如果执行了sadd myset v1 v2 v3，则dirty值会+3；注意dirty记录的是服务器进行了多少次修改，而不是客户端执行了多少修改数据的命令。</p>
<p>lastsave时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行save/bgsave的时间。</p>
<p>save m n的原理如下：每隔100ms，执行serverCron函数；在serverCron函数中，遍历save m n配置的保存条件，只要有一个条件满足，就进行bgsave。对于每一个save m n条件，只有下面两条同时满足时才算满足：</p>
<p>（1）当前时间-lastsave &gt; m<br>（2）dirty &gt;= n</p>
<p>save m n 执行日志</p>
<p>下图是save m n触发bgsave执行时，服务器打印日志的情况：</p>
<p><img src="6404.png" alt="6404.png"></p>
<p>其他自动触发机制</p>
<p>除了save m n 以外，还有一些其他情况会触发bgsave：</p>
<ul>
<li>在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点</li>
<li>执行shutdown命令时，自动执行rdb持久化，如下图所示：</li>
</ul>
<p><img src="6405.png" alt="6405.png"></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>前面介绍了触发bgsave的条件，下面将说明bgsave命令的执行流程，如下图所示：<br><img src="6406.png" alt="6406.png"></p>
<p>图片中的5个步骤所进行的操作如下：</p>
<p>1)  Redis父进程首先判断：当前是否在执行save，或bgsave/bgrewriteaof（后面会详细介绍该命令）的子进程，如果在执行则bgsave命令直接返回。bgsave/bgrewriteaof 的子进程不能同时执行，主要是基于性能方面的考虑：两个并发的子进程同时执行大量的磁盘写操作，可能引起严重的性能问题。<br>2)  父进程执行fork操作创建子进程，这个过程中父进程是阻塞的，Redis不能执行来自客户端的任何命令<br>3)  父进程fork后，bgsave命令返回”Background saving started”信息并不再阻塞父进程，并可以响应其他命令<br>4)  子进程创建RDB文件，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换<br>5)  子进程发送信号给父进程表示完成，父进程更新统计信息</p>
<h3 id="RDB文件"><a href="#RDB文件" class="headerlink" title="RDB文件"></a>RDB文件</h3><p>RDB文件是经过压缩的二进制文件，下面介绍关于RDB文件的一些细节。</p>
<p>存储路径</p>
<p>RDB文件的存储路径既可以在启动前配置，也可以通过命令动态设定。</p>
<p>配置：dir配置指定目录，dbfilename指定文件名。默认是Redis根目录下的dump.rdb文件。</p>
<p>动态设定：Redis启动后也可以动态修改RDB存储路径，在磁盘损害或空间不足时非常有用；执行命令为config set dir {newdir}和config set dbfilename {newFileName}。如下所示(Windows环境)：</p>
<p><img src="6407.png" alt="6407.png"></p>
<p>RDB文件格式</p>
<p>RDB文件格式如下图所示（图片来源：《Redis设计与实现》）：</p>
<p><img src="6408.png" alt="6408.png"></p>
<p>其中各个字段的含义说明如下：</p>
<p>1)  REDIS：常量，保存着”REDIS”5个字符。<br>2)  db_version：RDB文件的版本号，注意不是Redis的版本号。<br>3)  SELECTDB 0 pairs：表示一个完整的数据库(0号数据库)，同理SELECTDB 3 pairs表示完整的3号数据库；只有当数据库中有键值对时，RDB文件中才会有该数据库的信息(上图所示的Redis中只有0号和3号数据库有键值对)；如果Redis中所有的数据库都没有键值对，则这一部分直接省略。其中：SELECTDB是一个常量，代表后面跟着的是数据库号码；0和3是数据库号码；pairs则存储了具体的键值对信息，包括key、value值，及其数据类型、内部编码、过期时间、压缩信息等等。<br>4)  EOF：常量，标志RDB文件正文内容结束。<br>5)  check_sum：前面所有内容的校验和；Redis在载入RBD文件时，会计算前面的校验和并与check_sum值比较，判断文件是否损坏。</p>
<p>压缩</p>
<p>Redis默认采用LZF算法对RDB文件进行压缩。虽然压缩耗时，但是可以大大减小RDB文件的体积，因此压缩默认开启；可以通过命令关闭：<br><img src="6409.png" alt="6409.png"><br>需要注意的是，RDB文件的压缩并不是针对整个文件进行的，而是对数据库中的字符串进行的，且只有在字符串达到一定长度(20字节)时才会进行</p>
<h3 id="启动时加载"><a href="#启动时加载" class="headerlink" title="启动时加载"></a>启动时加载</h3><p>RDB文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。但是由于AOF的优先级更高，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。服务器载入RDB文件期间处于阻塞状态，直到载入完成为止。</p>
<p>Redis启动日志中可以看到自动载入的执行：</p>
<p><img src="64010.png" alt="64010.png"><br>Redis载入RDB文件时，会对RDB文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败</p>
<h3 id="RDB常用配置总结"><a href="#RDB常用配置总结" class="headerlink" title="RDB常用配置总结"></a>RDB常用配置总结</h3><p>下面是RDB常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">save m n  //bgsave自动触发的条件；如果没有save m n配置，相当于自动的RDB持久化关闭，不过此时仍可以通过其他方式触发</div><div class="line">stop-writes-on-bgsave-error yes  //当bgsave出现错误时，Redis是否停止执行写命令；设置为yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；设置为no，则Redis无视bgsave的错误继续执行写命令，当对Redis服务器的系统(尤其是硬盘)使用了监控时，该选项考虑设置为no</div><div class="line">rdbcompression yes  //是否开启RDB文件压缩</div><div class="line">rdbchecksum yes  //是否开启RDB文件的校验，在写入文件和读取文件时都起作用；关闭checksum在写入文件和启动文件时大约能带来10%的性能提升，但是数据损坏时无法发现</div><div class="line">dbfilename dump.rdb  //RDB文件名</div><div class="line">dir ./  //RDB文件和AOF文件所在目录</div></pre></td></tr></table></figure>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>RDB持久化是将进程数据写入文件，而AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中（有点像MySQL的binlog）；当Redis重启时再次执行AOF文件中的命令来恢复数据。</p>
<p>与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案</p>
<h3 id="开启AOF"><a href="#开启AOF" class="headerlink" title="开启AOF"></a>开启AOF</h3><p>Redis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">appendonly yes</div></pre></td></tr></table></figure>
<h3 id="执行流程-1"><a href="#执行流程-1" class="headerlink" title="执行流程"></a>执行流程</h3><p>由于需要记录Redis的每条写命令，因此AOF不需要触发，下面介绍AOF的执行流程。</p>
<p>AOF的执行流程包括：</p>
<ul>
<li>命令追加(append)：将Redis的写命令追加到缓冲区aof_buf；</li>
<li>文件写入(write)和文件同步(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘；</li>
<li>文件重写(rewrite)：定期重写AOF文件，达到压缩的目的。</li>
</ul>
<p>1) 命令追加(append)<br>Redis先将写命令追加到缓冲区，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。</p>
<p>命令追加的格式是Redis命令请求的协议格式，它是一种纯文本格式，具有兼容性好、可读性强、容易处理、操作简单避免二次开销等优点；具体格式略。在AOF文件中，除了用于指定数据库的select命令（如select 0 为选中0号数据库）是由Redis添加的，其他都是客户端发送来的写命令。</p>
<p>2) 文件写入(write)和文件同步(sync)<br>Redis提供了多种AOF缓存区的同步文件策略，策略涉及到操作系统的write函数和fsync函数，说明如下：</p>
<p>为了提高文件写入效率，在现代操作系统中，当用户调用write函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了fsync、fdatasync等同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。</p>
<p>AOF缓存区的同步文件策略由参数appendfsync控制，各个值的含义如下：</p>
<ul>
<li>always：命令写入aof_buf后立即调用系统fsync操作同步到AOF文件，fsync完成后线程返回。这种情况下，每次有写命令都要同步到AOF文件，硬盘IO成为性能瓶颈，Redis只能支持大约几百TPS写入，严重降低了Redis的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低SSD的寿命。</li>
<li>no：命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步；同步由操作系统负责，通常同步周期为30秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。</li>
<li>everysec：命令写入aof_buf后调用系统write操作，write完成后线程返回；fsync同步文件操作由专门的线程每秒调用一次。everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置，也是我们推荐的配置</li>
</ul>
<p>3) 文件重写(rewrite)<br>随着时间流逝，Redis服务器执行的写命令越来越多，AOF文件也会越来越大；过大的AOF文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。</p>
<p>文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作!</p>
<p>关于文件重写需要注意的另一点是：对于AOF持久化来说，文件重写虽然是强烈推荐的，但并不是必须的；即使没有文件重写，数据也可以被持久化并在Redis启动的时候导入；因此在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行。</p>
<p>文件重写之所以能够压缩AOF文件，原因在于：</p>
<ul>
<li>过期的数据不再写入文件</li>
<li>无效的命令不再写入文件：如有些数据被重复设值(set mykey v1, set mykey v2)、有些数据被删除了(sadd myset v1, del myset)等等</li>
<li>多条命令可以合并为一个：如sadd myset v1, sadd myset v2, sadd myset v3可以合并为sadd myset v1 v2 v3。不过为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset类型的key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。这个常量在redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD中定义，不可更改，3.0版本中值是64。</li>
</ul>
<p>通过上述内容可以看出，由于重写后AOF执行的命令减少了，文件重写既可以减少文件占用的空间，也可以加快恢复速度。</p>
<p>文件重写的触发</p>
<p>文件重写的触发，分为手动触发和自动触发：</p>
<p>手动触发：直接调用bgrewriteaof命令，该命令的执行与bgsave有些类似：都是fork子进程进行具体的工作，且都只有在fork时阻塞<br><img src="64011.png" alt="64011.png"></p>
<p>此时服务器执行日志如下：<br><img src="64012.png" alt="64012.png"></p>
<p>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数，以及aof_current_size和aof_base_size状态确定触发时机。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">auto-aof-rewrite-min-size  //执行AOF重写时，文件的最小体积，默认值为64MB。</div><div class="line">auto-aof-rewrite-percentage  //执行AOF重写时，当前AOF大小(即aof_current_size)和上一次重写时AOF大小(aof_base_size)的比值。</div><div class="line">其中，参数可以通过config get命令查看：</div></pre></td></tr></table></figure>
<p><img src="64013.png" alt="64013.png"></p>
<p>状态可以通过info persistence查看</p>
<p><img src="64014.png" alt="64014.png"></p>
<p>只有当auto-aof-rewrite-min-size和auto-aof-rewrite-percentage两个参数同时满足时，才会自动触发AOF重写，即bgrewriteaof操作。</p>
<p>自动触发bgrewriteaof时，可以看到服务器日志如下：<br><img src="64014.jpeg" alt="64014.jpeg"><br>文件重写的流程</p>
<p>文件重写流程如下图所示:<br><img src="64016.png" alt="64016.png"></p>
<p>关于文件重写的流程，有两点需要特别注意：<br>(1)重写由父进程fork子进程进行；<br>(2)重写期间Redis执行的写命令，需要追加到新的AOF文件中，为此Redis引入了aof_rewrite_buf缓存。</p>
<p>对照上图，文件重写的流程如下：</p>
<p>1) Redis父进程首先判断当前是否存在正在执行 bgsave/bgrewriteaof的子进程，如果存在则bgrewriteaof命令直接返回，如果存在bgsave命令则等bgsave执行完成后再执行。前面曾介绍过，这个主要是基于性能方面的考虑。<br>2) 父进程执行fork操作创建子进程，这个过程中父进程是阻塞的。<br>3.1) 父进程fork后，bgrewriteaof命令返回”Background append only file rewrite started”信息并不再阻塞父进程，并可以响应其他命令。Redis的所有写命令依然写入AOF缓冲区，并根据appendfsync策略同步到硬盘，保证原有AOF机制的正确。<br>3.2) 由于fork操作使用写时复制技术，子进程只能共享fork操作时的内存数据。由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区(图中的aof_rewrite_buf)保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区。<br>4) 子进程根据内存快照，按照命令合并规则写入到新的AOF文件。<br>5.1) 子进程写完新的AOF文件后，向父进程发信号，父进程更新统计信息，具体可以通过info persistence查看。<br>5.2) 父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。<br>5.3) 使用新的AOF文件替换老文件，完成AOF重写。</p>
<h3 id="启动时加载-1"><a href="#启动时加载-1" class="headerlink" title="启动时加载"></a>启动时加载</h3><p>前面提到过，当AOF开启时，Redis启动时会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会载入RDB文件恢复数据。</p>
<p>当AOF开启，且AOF文件存在时，Redis启动日志：<br><img src="64017.png" alt="64017.png"></p>
<p>当AOF开启，但AOF文件不存在时，即使RDB文件存在也不会加载(更早的一些版本可能会加载，但3.0不会)</p>
<p>文件校验</p>
<p>与载入RDB文件类似，Redis载入AOF文件时，会对AOF文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。但如果是AOF文件结尾不完整(机器突然宕机等容易导致文件尾部不完整)，且aof-load-truncated参数开启，则日志中会输出警告，Redis忽略掉AOF文件的尾部，启动成功。aof-load-truncated参数默认是开启的：<br><img src="64018.png" alt="64018.png"></p>
<p>伪客户端</p>
<p>因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时命令是直接从文件中读取的，并不是由客户端发送；因此Redis服务器在载入AOF文件之前，会创建一个没有网络连接的客户端，之后用它来执行AOF文件中的命令，命令执行的效果与带网络连接的客户端完全一样。</p>
<p>AOF常用配置总结<br>下面是AOF常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">appendonly no  //是否开启AOF</div><div class="line"></div><div class="line">appendfilename &quot;appendonly.aof&quot;  //AOF文件名</div><div class="line"></div><div class="line">dir ./  //RDB文件和AOF文件所在目录</div><div class="line"></div><div class="line">appendfsync everysec  //fsync持久化策略</div><div class="line"></div><div class="line">no-appendfsync-on-rewrite no  //AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡</div><div class="line"></div><div class="line">auto-aof-rewrite-percentage 100  //文件重写触发条件之一</div><div class="line"></div><div class="line">auto-aof-rewrite-min-size 64mb  //文件重写触发提交之一</div><div class="line"></div><div class="line">aof-load-truncated yes  //如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件</div></pre></td></tr></table></figure></p>
<h2 id="方案选择与常见问题"><a href="#方案选择与常见问题" class="headerlink" title="方案选择与常见问题"></a>方案选择与常见问题</h2><p>前面介绍了RDB和AOF两种持久化方案的细节，下面介绍RDB和AOF的特点、如何选择持久化方案，以及在持久化过程中常遇到的问题等。</p>
<h3 id="RDB和AOF的优缺点"><a href="#RDB和AOF的优缺点" class="headerlink" title="RDB和AOF的优缺点"></a>RDB和AOF的优缺点</h3><p>RDB和AOF各有优缺点：</p>
<p>RDB持久化<br>优点：RDB文件紧凑，体积小，网络传输快，适合全量复制；恢复速度比AOF快很多。当然，与AOF相比，RDB最重要的优点之一是对性能的影响相对较小。</p>
<p>缺点：RDB文件的致命缺点在于其数据快照的持久化方式决定了必然做不到实时持久化，而在数据越来越重要的今天，数据的大量丢失很多时候是无法接受的，因此AOF持久化成为主流。此外，RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</p>
<p>AOF持久化<br>与RDB持久化相对应，AOF的优点在于支持秒级持久化、兼容性好，缺点是文件大、恢复速度慢、对性能影响大。</p>
<p>持久化策略选择<br>在介绍持久化策略之前，首先要明白无论是RDB还是AOF，持久化的开启都是要付出性能方面代价的：对于RDB持久化，一方面是bgsave在进行fork操作时Redis主进程会阻塞，另一方面，子进程向硬盘写数据也会带来IO压力；对于AOF持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题（后面会详细介绍这种阻塞），此外，AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。</p>
<p>在实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用RDB或AOF的一种，或同时开启RDB和AOF持久化等。此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机master和从机slave可以独立的选择持久化方案。</p>
<p>下面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。</p>
<p>（1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。<br>（2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。<br>（3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。</p>
<p>在这种情况下，一种可行的做法是：</p>
<p>master：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好<br>slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调用bgrewriteaof。</p>
<p>这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：</p>
<ul>
<li>master和slave进程同时停止：考虑这样一种场景，如果master和slave在同一栋大楼或同一个机房，则一次停电事故就可能导致master和slave机器同时关机，Redis进程停止；如果没有持久化，则面临的是数据的完全丢失。</li>
<li>master误重启：考虑这样一种场景，master服务因为故障宕掉了，如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将master自动重启，由于没有持久化文件，那么master重启后数据是空的，slave同步数据也变成了空的；如果master和slave都没有持久化，同样会面临数据的完全丢失。需要注意的是，即便是使用了哨兵(关于哨兵后面会有文章介绍)进行自动的主从切换，也有可能在哨兵轮询到master之前，便被自动拉起机制重启了。因此，应尽量避免“自动拉起机制”和“不做持久化”同时出现。</li>
</ul>
<p>（4）异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。例如对于单机的情形，可以定时将RDB文件或重写后的AOF文件，通过scp拷贝到远程机器，如阿里云、AWS等；对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上。一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其他条件来确定，但最好不要低于一天一次</p>
<h3 id="fork阻塞：CPU的阻塞"><a href="#fork阻塞：CPU的阻塞" class="headerlink" title="fork阻塞：CPU的阻塞"></a>fork阻塞：CPU的阻塞</h3><p>在Redis的实践中，众多因素限制了Redis单机的内存不能过大，例如：</p>
<p>当面对请求的暴增，需要从库扩容时，Redis内存过大会导致扩容时间太长；</p>
<p>当主机宕机时，切换主机后需要挂载从库，Redis内存过大导致挂载速度过慢；</p>
<p>以及持久化过程中的fork操作，下面详细说明。</p>
<p>首先说明一下fork操作：</p>
<p>父进程通过fork操作可以创建子进程；子进程创建后，父子进程共享代码段，不共享进程的数据空间，但是子进程会获得父进程的数据空间的副本。在操作系统fork的实际实现中，基本都采用了写时复制技术，即在父/子进程试图修改数据空间之前，父子进程实际上共享数据空间；但是当父/子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分(内存的一页)制作一个副本。</p>
<p>虽然fork时，子进程不会复制父进程的数据空间，但是会复制内存页表（页表相当于内存的索引、目录）；父进程的数据空间越大，内存页表越大，fork时复制耗时也会越多。</p>
<p>在Redis中，无论是RDB持久化的bgsave，还是AOF重写的bgrewriteaof，都需要fork出子进程来进行操作。如果Redis内存过大，会导致fork操作时复制内存页表耗时过多；而Redis主进程在进行fork时，是完全阻塞的，也就意味着无法响应客户端的请求，会造成请求延迟过大。</p>
<p>对于不同的硬件、不同的操作系统，fork操作的耗时会有所差别，一般来说，如果Redis单机内存达到了10GB，fork时耗时可能会达到百毫秒级别（如果使用Xen虚拟机，这个耗时可能达到秒级别）。因此，一般来说Redis单机内存一般要限制在10GB以内；不过这个数据并不是绝对的，可以通过观察线上环境fork的耗时来进行调整。观察的方法如下：执行命令info stats，查看latest_fork_usec的值，单位为微秒。</p>
<p>为了减轻fork操作带来的阻塞问题，除了控制Redis单机内存的大小以外，还可以适度放宽AOF重写的触发条件、选用物理机或高效支持fork操作的虚拟化技术等，例如使用Vmware或KVM虚拟机，不要使用Xen虚拟机</p>
<h3 id="AOF追加阻塞：硬盘的阻塞"><a href="#AOF追加阻塞：硬盘的阻塞" class="headerlink" title="AOF追加阻塞：硬盘的阻塞"></a>AOF追加阻塞：硬盘的阻塞</h3><p>前面提到过，在AOF中，如果AOF缓冲区的文件同步策略为everysec，则：在主线程中，命令写入aof_buf后调用系统write操作，write完成后主线程返回；fsync同步文件操作由专门的文件同步线程每秒调用一次。</p>
<p>这种做法的问题在于，如果硬盘负载过高，那么fsync操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快；如果此时Redis进程异常退出，丢失的数据也会越来越多，可能远超过1s。</p>
<p>为此，Redis的处理策略是这样的：主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。</p>
<p>AOF追加阻塞问题定位的方法：<br>（1）监控info Persistence中的aof_delayed_fsync：当AOF追加阻塞发生时（即主线程等待fsync而阻塞），该指标累加。<br>（2）AOF阻塞时的Redis日志：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.</div></pre></td></tr></table></figure></p>
<p>（3）如果AOF追加阻塞频繁发生，说明系统的硬盘负载太大；可以考虑更换IO速度更快的硬盘，或者通过IO监控分析工具对系统的IO负载进行分析，如iostat（系统级io）、iotop（io版的top）、pidstat等。</p>
<h3 id="info命令与持久化"><a href="#info命令与持久化" class="headerlink" title="info命令与持久化"></a>info命令与持久化</h3><p>前面提到了一些通过info命令查看持久化相关状态的方法，下面来总结一下。</p>
<p>（1）info Persistence</p>
<p>执行结果如下<br><img src="64019.png" alt="64019.png"></p>
<p>其中比较重要的包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">rdb_last_bgsave_status //上次bgsave 执行结果，可以用于发现bgsave错误</div><div class="line"></div><div class="line">rdb_last_bgsave_time_sec  //上次bgsave执行时间（单位是s），可以用于发现bgsave是否耗时过长</div><div class="line"></div><div class="line">aof_enabled  //AOF是否开启</div><div class="line"></div><div class="line">aof_last_rewrite_time_sec  //上次文件重写执行时间（单位是s），可以用于发现文件重写是否耗时过长</div><div class="line"></div><div class="line">aof_last_bgrewrite_status  //上次bgrewrite执行结果，可以用于发现bgrewrite错误</div><div class="line"></div><div class="line">aof_buffer_length和aof_rewrite_buffer_length  //aof缓存区大小和aof重写缓冲区大小</div><div class="line"></div><div class="line">aof_delayed_fsync  //AOF追加阻塞情况的统计</div></pre></td></tr></table></figure>
<p>（2）info stats</p>
<p>其中与持久化关系较大的是：latest_fork_usec，代表上次fork耗时，可以参见前面的讨论</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要内容可以总结如下：</p>
<p>1、持久化在Redis高可用中的作用：数据备份，与主从复制相比强调的是由内存到硬盘的备份。<br>2、RDB持久化：将数据快照备份到硬盘；介绍了其触发条件（包括手动出发和自动触发）、执行流程、RDB文件等，特别需要注意的是文件保存操作由fork出的子进程来进行。<br>3、AOF持久化：将执行的写命令备份到硬盘（类似于MySQL的binlog），介绍了其开启方法、执行流程等，特别需要注意的是文件同步策略的选择（everysec）、文件重写的流程。<br>4、一些现实的问题：包括如何选择持久化策略，以及需要注意的fork阻塞、AOF追加阻塞等。</p>
<p>ref:<br>www.cnblogs.com/kismetv/p/9137897.html</p>
]]></content>
      <categories>
        <category>Reds</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-数据过期策略</title>
    <url>/2017/09/22/Redis-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>Redis中有个设置时间过期的功能，即对存储在Redis数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。这就是我们本文要讲到的Redis过期机制。</p>
<a id="more"></a>
<h2 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h2><p>Redis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。Expires字典保存了所有键的过期时间，Expires也被称为过期字段。</p>
<ul>
<li>_expire key time(以秒为单位)–这是最常用的方式</li>
<li>setex(String key, int seconds, String value)–字符串独有的方式</li>
</ul>
<p>注：</p>
<ol>
<li>除了字符串自己独有设置过期时间的方法外，其他方法都需要依靠expire方法来设置时间</li>
<li>如果没有设置时间，那缓存就是永不过期</li>
<li>如果设置了过期时间，之后又想让缓存永不过期，使用persist key</li>
</ol>
<h3 id="常用方式"><a href="#常用方式" class="headerlink" title="常用方式"></a>常用方式</h3><p>一般主要包括4种处理过期方，其中expire都是以秒为单位，pexpire都是以毫秒为单位的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 EXPIRE key seconds　　//将key的生存时间设置为ttl秒</div><div class="line">2 PEXPIRE key milliseconds　　//将key的生成时间设置为ttl毫秒</div><div class="line">3 EXPIREAT key timestamp　　//将key的过期时间设置为timestamp所代表的的秒数的时间戳</div><div class="line">4 PEXPIREAT key milliseconds-timestamp　　//将key的过期时间设置为timestamp所代表的的毫秒数的时间戳</div></pre></td></tr></table></figure>
<p>备注：timestamp为unix时间戳（例如：timestamp=1499788800 表示将在2017.07.12过期）<br>1、2两种方式是设置一个过期的时间段，就是咱们处理验证码最常用的策略，设置三分钟或五分钟后失效，把分钟数转换成秒或毫秒存储到Redis中。<br>3、4两种方式是指定一个过期的时间 ，比如优惠券的过期时间是某年某月某日，只是单位不一样。</p>
<p>下面我们就以EXPIREAT为例子简单讲解下用法。</p>
<p>返回值</p>
<p>一个整数值1或0，如下：</p>
<ul>
<li>如果成功地为该键设置了超时时间，返回 1</li>
<li>如果键不存在或无法设置超时时间，返回 0</li>
</ul>
<p>语法</p>
<p>以下是以Redis的EXPIREAT命令的基本语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 redis 127.0.0.1:6379&gt; Expireat KEY_NAME TIME_IN_UNIX_TIMESTAMP</div></pre></td></tr></table></figure>
<p>示例</p>
<p>首先，在Redis中创建一个键：akey，并在akey中设置一些值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 redis 127.0.0.1:6379&gt; SET akey redis </div><div class="line">2 OK</div></pre></td></tr></table></figure></p>
<p>现在，为设置创建的键设置超时时间为60 秒。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">127.0.0.1:6379&gt; SET akey redis</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; EXPIREAT akey 1393840000</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; EXISTS akey</div><div class="line">(integer) 0</div><div class="line">127.0.0.1:6379&gt; SET akey redis</div><div class="line">OK</div><div class="line">127.0.0.1:6379&gt; EXPIREAT akey 1493840000</div><div class="line">(integer) 1</div><div class="line">127.0.0.1:6379&gt; EXISTS akey</div><div class="line">(integer) 1</div></pre></td></tr></table></figure>
<p><img src="506829-20170927215838653-1475003989.png" alt="506829-20170927215838653-1475003989.png"></p>
<h3 id="字符串独有方式"><a href="#字符串独有方式" class="headerlink" title="字符串独有方式"></a>字符串独有方式</h3><p>对字符串特殊处理的方式为SETEX命令，SETEX命令为指定的 key 设置值及其过期时间。如果 key 已经存在， SETEX 命令将会替换旧的值。</p>
<p>返回值<br>设置成功时返回 OK 。</p>
<p>语法<br>Redis Setex 命令基本语法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">redis 127.0.0.1:6379&gt; SETEX KEY_NAME TIMEOUT VALUE</div></pre></td></tr></table></figure></p>
<p>示例<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 redis 127.0.0.1:6379&gt; SETEX mykey 60 redis</div><div class="line">2 OK</div><div class="line">3 redis 127.0.0.1:6379&gt; TTL mykey</div><div class="line">4 60</div><div class="line">5 redis 127.0.0.1:6379&gt; GET mykey</div><div class="line">6 &quot;redis</div></pre></td></tr></table></figure></p>
<h2 id="3种过期策略"><a href="#3种过期策略" class="headerlink" title="3种过期策略"></a>3种过期策略</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>含义：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除</p>
<p>优点：保证内存被尽快释放</p>
<p>缺点：</p>
<ul>
<li>若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key</li>
<li>定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重</li>
<li>没人用</li>
</ul>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>含义：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。</p>
<p>优点：删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）</p>
<p>缺点：若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）</p>
<h3 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h3><p>含义：每隔一段时间执行一次删除(在redis.conf配置文件设置hz，1s刷新的频率)过期key操作</p>
<p>优点：</p>
<ul>
<li>通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用–处理”定时删除”的缺点</li>
<li>定期删除过期key–处理”惰性删除”的缺点</li>
</ul>
<p>缺点</p>
<ul>
<li>在内存友好方面，不如”定时删除”</li>
<li>在CPU时间友好方面，不如”惰性删除”</li>
</ul>
<p>难点<br>合理设置删除操作的执行时长（每次删除执行多长时间）和执行频率（每隔多长时间做一次删除）（这个要根据服务器运行情况来定了）</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key</p>
<p>惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除</p>
<p>惰性删除为redis服务器内置策略</p>
<p>定期删除可以通过：</p>
<ul>
<li>配置redis.conf 的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大） </li>
<li>配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略</li>
</ul>
<p>注意：<br>上边所说的数据库指的是内存数据库，默认情况下每一台redis服务器有16个数据库（关于数据库的设置，看下边代码），默认使用0号数据库，所有的操作都是对0号数据库的操作，关于redis数据库的存储结构，查看 第八章 Redis数据库结构与读写原理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># 设置数据库数量。默认为16个库，默认使用DB 0，可以使用&quot;select 1&quot;来选择一号数据库</div><div class="line"># 注意：由于默认使用0号数据库，那么我们所做的所有的缓存操作都存在0号数据库上，</div><div class="line"># 当你在1号数据库上去查找的时候，就查不到之前set过得缓存</div><div class="line"># 若想将0号数据库上的缓存移动到1号数据库，可以使用&quot;move key 1&quot;</div><div class="line">databases 16</div></pre></td></tr></table></figure>
<p>memcached只是用了惰性删除，而Redis同时使用了惰性删除与定期删除，这也是二者的一个不同点（可以看做是redis优于memcached的一点）</p>
<p>对于惰性删除而言，并不是只有获取key的时候才会检查key是否过期，在某些设置key的方法上也会检查（eg.setnx key2 value2：该方法类似于memcached的add方法，如果设置的key2已经存在，那么该方法返回false，什么都不做；如果设置的key2不存在，那么该方法设置缓存key2-value2。假设调用此方法的时候，发现redis中已经存在了key2，但是该key2已经过期了，如果此时不执行删除操作的话，setnx方法将会直接返回false，也就是说此时并没有重新设置key2-value2成功，所以对于一定要在setnx执行之前，对key2进行过期检查）</p>
<h2 id="Redis采用的过期策略"><a href="#Redis采用的过期策略" class="headerlink" title="Redis采用的过期策略"></a>Redis采用的过期策略</h2><p>惰性删除+定期删除</p>
<h3 id="惰性删除流程"><a href="#惰性删除流程" class="headerlink" title="惰性删除流程"></a>惰性删除流程</h3><ol>
<li>在进行get或setnx等操作时，先检查key是否过期，</li>
<li>若过期，删除key，然后执行相应操作；</li>
<li>若没过期，直接执行相应操作</li>
</ol>
<h3 id="定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）"><a href="#定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）" class="headerlink" title="定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）"></a>定期删除流程（简单而言，对指定个数个库的每一个库随机删除小于等于指定个数个过期key）</h3><ol>
<li>遍历每个数据库（就是redis.conf中配置的”database”数量，默认为16）</li>
<li>检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）</li>
<li>如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历</li>
<li>随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key</li>
<li>判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。</li>
</ol>
<h2 id="RDB对过期key的处理"><a href="#RDB对过期key的处理" class="headerlink" title="RDB对过期key的处理"></a>RDB对过期key的处理</h2><p>过期key对RDB没有任何影响</p>
<ul>
<li>从内存数据库持久化数据到RDB文件 持久化key之前，会检查是否过期，过期的key不进入RDB文件</li>
<li>从RDB文件恢复数据到内存数据库 数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）</li>
</ul>
<h2 id="AOF对过期key的处理"><a href="#AOF对过期key的处理" class="headerlink" title="AOF对过期key的处理"></a>AOF对过期key的处理</h2><p>过期key对AOF没有任何影响</p>
<h3 id="从内存数据库持久化数据到AOF文件："><a href="#从内存数据库持久化数据到AOF文件：" class="headerlink" title="从内存数据库持久化数据到AOF文件："></a>从内存数据库持久化数据到AOF文件：</h3><p>当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）<br>当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）</p>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>重写时，会先判断key是否过期，已过期的key不会重写到aof文件 </p>
<p>ref: <a href="http://www.cnblogs.com/xuliangxing/p/7151812.html" target="_blank" rel="external">http://www.cnblogs.com/xuliangxing/p/7151812.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等问题</title>
    <url>/2017/09/22/Redis-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0-%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7%E7%AD%89%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>Redis 缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等概念的入门及简单解决方案</p>
<a id="more"></a>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩我们可以简单的理解为：由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。</p>
<p>缓存正常从Redis中获取，示意图如下：</p>
<p><img src="WX20190505-2336302x.png" alt="WX20190505-2336302x.png"></p>
<p>缓存失效瞬间示意图如下：</p>
<p><img src="WX20190505-2338432x.png" alt="WX20190505-2338432x.png"></p>
<p>缓存失效时的雪崩效应对底层系统的冲击非常可怕！大多数系统设计者考虑用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<p>以下简单介绍两种实现方式的伪代码：</p>
<p>（1）碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是加锁排队，伪代码如下：</p>
<p><img src="WX20190505-2339592x.png" alt="WX20190505-2339592x.png"></p>
<p>加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！</p>
<p>注意：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！</p>
<p>（2）还有一个解决办法解决方案是：给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存，实例伪代码如下：</p>
<p><img src="WX20190505-2341142x.png" alt="WX20190505-2341142x.png"></p>
<p>解释说明：</p>
<p>1、缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；</p>
<p>2、缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</p>
<p>关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间，还有一各被称为“二级缓存”的解决方法，有兴趣的读者可以自行研究。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</p>
<p>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。</p>
<p>另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！</p>
<p><img src="WX20190505-2342282x.png" alt="WX20190505-2342282x.png"></p>
<p>把空结果，也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置个缓存区域存储空值，对要查询的key进行预先校验，然后再放行给后面的正常缓存处理逻辑。</p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><p>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p>
<p>解决思路：</p>
<p>1、直接写个缓存刷新页面，上线时手工操作下；</p>
<p>2、数据量不大，可以在项目启动的时候自动进行加载；</p>
<p>3、定时刷新缓存；</p>
<h2 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h2><p>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p>
<p>（1）定时去清理过期的缓存；</p>
<p>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p>
<p>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p>
<p>五、缓存降级<br>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p>
<p>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<p>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p>
<p>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p>
<p>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p>
<p>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些都是实际项目中，可能碰到的一些问题，也是面试的时候经常会被问到的知识点，实际上还有很多很多各种各样的问题，文中的解决方案，也不可能满足所有的场景，相对来说只是对该问题的入门解决方法。一般正式的业务场景往往要复杂的多，应用场景不同，方法和解决方案也不同，由于上述方案，考虑的问题并不是很全面，因此并不适用于正式的项目开发，但是可以作为概念理解入门，具体解决方案要根据实际情况来确定</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247485464&amp;idx=1&amp;sn=8d690fc6f878aadf75977aa7e76cfd08&amp;chksm=e9c5f1a9deb278bf512d8b40c30240d0168cdf2cf02142ee913bc11ec39637ca380a4dad524b&amp;scene=21#wechat_redirect" target="_blank" rel="external">https://mp.weixin.qq.com/s?__biz=MzI1NDQ3MjQxNA==&amp;mid=2247485464&amp;idx=1&amp;sn=8d690fc6f878aadf75977aa7e76cfd08&amp;chksm=e9c5f1a9deb278bf512d8b40c30240d0168cdf2cf02142ee913bc11ec39637ca380a4dad524b&amp;scene=21#wechat_redirect</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-ApplicationContextAware</title>
    <url>/2017/09/22/Spring-ApplicationContextAware/</url>
    <content><![CDATA[<p>本文主要讲解通过 Spring 的 ApplicationContextAware 的实现类来操作 spring容器及其中的Bean实例</p>
<a id="more"></a>
<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在我们的web程序中，用spring来管理各个实例(bean), 有时在程序中为了使用已被实例化的bean, 通常会用到这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ApplicationContext appContext = new ClassPathXmlApplicationContext(&quot;applicationContext-common.xml&quot;);  </div><div class="line">AbcService abcService = (AbcService)appContext.getBean(&quot;abcService&quot;);</div></pre></td></tr></table></figure>
<p>但是这样就会存在一个问题：因为它会重新装载applicationContext-common.xml并实例化上下文bean，如果有些线程配置类也是在这个配置文件中，那么会造成做相同工作的的线程会被启两次。一次是web容器初始化时启动，另一次是上述代码显示的实例化了一次。当于重新初始化一遍！！！！这样就产生了冗余。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>不用类似new ClassPathXmlApplicationContext()的方式，从已有的spring上下文取得已实例化的bean。通过ApplicationContextAware接口进行实现。</p>
<p>当一个类实现了这个接口（ApplicationContextAware）之后，这个类就可以方便获得ApplicationContext中的所有bean。换句话说，就是这个类可以直接获取spring配置文件中，所有有引用到的bean对象。</p>
<p>下面示例为实现ApplicationContextAware的工具类，可以通过其它类引用它以操作spring容器及其中的Bean实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Component //注册Bean</div><div class="line">public class SpringContextHolder implements ApplicationContextAware &#123;</div><div class="line">    private static ApplicationContext applicationContext = null;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 获取静态变量中的ApplicationContext.</div><div class="line">     */</div><div class="line">    public static ApplicationContext getApplicationContext() &#123;</div><div class="line">        assertContextInjected();</div><div class="line">        return applicationContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 从静态变量applicationContext中得到Bean, 自动转型为所赋值对象的类型.</div><div class="line">     */</div><div class="line">    @SuppressWarnings(&quot;unchecked&quot;)</div><div class="line">    public static &lt;T&gt; T getBean(String name) &#123;</div><div class="line">        assertContextInjected();</div><div class="line">        return (T) applicationContext.getBean(name);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 从静态变量applicationContext中得到Bean, 自动转型为所赋值对象的类型.</div><div class="line">     */</div><div class="line">    public static &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) &#123;</div><div class="line">        assertContextInjected();</div><div class="line">        return applicationContext.getBean(requiredType);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 清除SpringContextHolder中的ApplicationContext为Null.</div><div class="line">     */</div><div class="line">    public static void clearHolder() &#123;</div><div class="line">        applicationContext = null;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 实现ApplicationContextAware接口, 注入Context到静态变量中.</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void setApplicationContext(ApplicationContext applicationContext) &#123;</div><div class="line">        SpringContextHolder.applicationContext = applicationContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 检查ApplicationContext不为空.</div><div class="line">     */</div><div class="line">    private static void assertContextInjected() &#123;</div><div class="line">        Validate.validState(applicationContext != null,</div><div class="line">                &quot;applicaitonContext属性未注入, 请在applicationContext.xml中定义SpringContextHolder.&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Spring容器会检测容器中的所有Bean(@Component来进行注册Bean, 若无它, 则不能被检测到)，如果发现某个Bean实现了ApplicationContextAware接口，Spring容器会在创建该Bean之后，自动调用该Bean的setApplicationContextAware()方法，调用该方法时，会将容器本身作为参数传给该方法——该方法中的实现部分将Spring传入的参数（容器本身）赋给该类对象的applicationContext实例变量，因此接下来可以通过该applicationContext实例变量来访问容器本身。</p>
<p>ref:</p>
<p><a href="https://www.jianshu.com/p/4c0723615a52" target="_blank" rel="external">ApplicationContextAware使用理解</a></p>
<p><a href="https://blog.csdn.net/qw222pzx/article/details/79353204" target="_blank" rel="external">ApplicationContextAware接口的作用</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Bean的生命周期</title>
    <url>/2017/09/22/Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>Spring Bean的生命周期</p>
<a id="more"></a>
<p><img src="1528637-20181105211348802-396856434.png" alt="1528637-20181105211348802-396856434.png"></p>
<p>详解：</p>
<ol>
<li>instantiate bean对象实例化</li>
<li>populate properties 封装属性</li>
<li>如果Bean实现BeanNameAware执行setBeanName</li>
<li>如果Bean实现BeanFactoryAwar或ApplicationContextAwar设置工厂setBeanFactory或上下文对象setApplicationContext</li>
<li>如果存在类实现BeanPostProcessor(后处理Bean),执行postProcessBeforeInitialization</li>
<li>如果Bean实现InitializingBean执行afterPropertiesSet</li>
<li>调用自定义的init-method方法</li>
<li>如果存在类实现BeanPostProcessor(处理Bean),执行postProcessAfterInitialization</li>
<li>执行业务处理</li>
<li>如果Bean实现DisposableBean执行destroy</li>
<li>调用自定义的destroy-method</li>
</ol>
<p>第一步就是对实例化bean，调用构造函数来创建实例，第二步是根据配置，进行相应属性的设置，依赖注入就是在这一步完成的。</p>
<p>第三步和第四步是让spring去了解咱们的spring容器，第五步和第八步可以针对指定的Bean进行功能增强，这时一般是采用的动态代理，（两种动态代理方式：jdk动态代理和cglib动态代理）。第六步和第十步是通过实现指定的接口来完成init（初始化）和destory（销毁）操作。但是我们在通常情况下不会使用这两步，因为我们可以通过第七步和第十一步，在配置文件中设置相应的初始化和销毁方法。</p>
<p>比如：<br><img src="1528637-20181105212114593-1948447418.png" alt="1528637-20181105212114593-1948447418.png"></p>
<p>总结：</p>
<p>对于springbean的生命周期，我们需要关注的主要有两个方法：<br>1.增强bean的功能可以使用后处理Bean，BeanPostProcessor<br>2.如果需要初始化或销毁操作，我们可以使用init-method方法和destory-method方法。</p>
<p>同时还需要注意一点：destory-method方法是只针对于scope=singleton的时候才有效果！</p>
<p>ref:<br><a href="https://www.cnblogs.com/wgl-gdyuan/p/9911653.html" target="_blank" rel="external">https://www.cnblogs.com/wgl-gdyuan/p/9911653.html</a><br><a href="https://blog.csdn.net/w_linux/article/details/80086950" target="_blank" rel="external">Spring 了解Bean的一生(生命周期)</a> //TODO<br><a href="https://blog.csdn.net/programmer_at/article/details/82533396" target="_blank" rel="external">实践出真知：理解Spring Bean生命周期</a> //TODO<br><a href="https://blog.51cto.com/4247649/2118349" target="_blank" rel="external">深入理解spring生命周期与BeanPostProcessor的实现原理</a> //TODO<br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMjY1NTIxNA==&amp;mid=2454441970&amp;idx=1&amp;sn=55a4491608d6f05a5a406b73024bbc6d&amp;chksm=8c11e0f3bb6669e54a1499a2aad09d38ceb68d40a88dfd89bd53de0fbe84238fa45caf768037&amp;scene=21#wechat_redirect" target="_blank" rel="external">三分钟了解spring-bean生命周期之初始化和销毁的三种方式</a> //TODO</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-HandlerInterceptor</title>
    <url>/2017/09/22/Spring-HandlerInterceptor/</url>
    <content><![CDATA[<p>SpringWebMVC的处理器拦截器，类似于Servlet开发中的过滤器Filter，用于处理器进行预处理和后处理。</p>
<a id="more"></a>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>日志记录: 可以记录请求信息的日志，以便进行信息监控、信息统计等。</li>
<li>权限检查: 如登陆检测，进入处理器检测是否登陆，如果没有直接返回到登陆页面。</li>
<li>性能监控: 典型的是慢日志。</li>
</ol>
<h2 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface HandlerInterceptor &#123;</div><div class="line"></div><div class="line">   /**</div><div class="line">     * 预处理回调方法，实现处理器的预处理（如检查登陆），第三个参数为响应的处理器，自定义Controller</div><div class="line">     * 返回值：true表示继续流程（如调用下一个拦截器或处理器）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；</div><div class="line">   */</div><div class="line">    boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</div><div class="line">            throws Exception;</div><div class="line"></div><div class="line">   /**</div><div class="line">     * 后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</div><div class="line">   */</div><div class="line">    void postHandle(</div><div class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</div><div class="line">            throws Exception;</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中</div><div class="line">   */</div><div class="line">    void afterCompletion(</div><div class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</div><div class="line">            throws Exception;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="拦截器适配器HandlerInterceptorAdapter"><a href="#拦截器适配器HandlerInterceptorAdapter" class="headerlink" title="拦截器适配器HandlerInterceptorAdapter"></a>拦截器适配器HandlerInterceptorAdapter</h2><p>有时候我们可能只需要实现三个回调方法中的某一个，如果实现HandlerInterceptor接口的话，三个方法必须实现，不管你需不需要，此时spring提供了一个HandlerInterceptorAdapter适配器（种适配器设计模式的实现），允许我们只实现需要的回调方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public abstract class HandlerInterceptorAdapter implements AsyncHandlerInterceptor &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 默认是true</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</div><div class="line">            throws Exception &#123;</div><div class="line"></div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * This implementation is empty.</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void postHandle(</div><div class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</div><div class="line">            throws Exception &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * This implementation is empty.</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void afterCompletion(</div><div class="line">            HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</div><div class="line">            throws Exception &#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 不是HandlerInterceptor的接口实现，是AsyncHandlerInterceptor的，AsyncHandlerInterceptor实现了HandlerInterceptor</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void afterConcurrentHandlingStarted(</div><div class="line">            HttpServletRequest request, HttpServletResponse response, Object handler)</div><div class="line">            throws Exception &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样在我们业务中比如要记录系统日志，日志肯定是在afterCompletion之后记录的，否则中途失败了，也记录了，那就扯淡了。一定是程序正常跑完后，我们记录下那些对数据库做个增删改的操作日志进数据库。所以我们只需要继承HandlerInterceptorAdapter，并重写afterCompletion一个方法即可，因为preHandle默认是true</p>
<h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><p><img src="4582242-da4b3cb8777704d3.png" alt="4582242-da4b3cb8777704d3.png"></p>
<p>运行流程总结如下：</p>
<ol>
<li>拦截器执行顺序是按照Spring配置文件中定义的顺序而定的。</li>
<li>会先按照顺序执行所有拦截器的preHandle方法，一直遇到return false为止，比如第二个preHandle方法是return false，则第三个以及以后所有拦截器都不会执行。若都是return true，则按顺序加载完preHandle方法。</li>
<li>然后执行主方法（自己的controller接口），若中间抛出异常，则跟return false效果一致，不会继续执行postHandle，只会倒序执行afterCompletion方法。</li>
<li>在主方法执行完业务逻辑（页面还未渲染数据）时，按倒序执行postHandle方法。若第三个拦截器的preHandle方法return false，则会执行第二个和第一个的postHandle方法和afterCompletion（postHandle都执行完才会执行这个，也就是页面渲染完数据后，执行after进行清理工作）方法。（postHandle和afterCompletion都是倒序执行）</li>
</ol>
<h3 id="正常流程Demo"><a href="#正常流程Demo" class="headerlink" title="正常流程Demo"></a>正常流程Demo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.springframework.web.servlet.HandlerInterceptor;</div><div class="line">import org.springframework.web.servlet.ModelAndView;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">public class SyslogInterceptor implements HandlerInterceptor &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 预处理回调方法，实现处理器的预处理（如检查登陆），第三个参数为响应的处理器，自定义Controller</div><div class="line">     * 返回值：true表示继续流程（如调用下一个拦截器或处理器）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</div><div class="line">            throws Exception &#123;</div><div class="line">        System.out.println(&quot;==========================================1================================================&quot;);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,</div><div class="line">            ModelAndView modelAndView) throws Exception &#123;</div><div class="line">        System.out.println(&quot;==========================================post1================================================&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</div><div class="line">            throws Exception &#123;</div><div class="line">        System.out.println(&quot;==========================================after1================================================&quot;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.springframework.web.servlet.HandlerInterceptor;</div><div class="line">import org.springframework.web.servlet.ModelAndView;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">public class SyslogInterceptor2 implements HandlerInterceptor &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 预处理回调方法，实现处理器的预处理（如检查登陆），第三个参数为响应的处理器，自定义Controller</div><div class="line">     * 返回值：true表示继续流程（如调用下一个拦截器或处理器）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</div><div class="line">            throws Exception &#123;</div><div class="line">        System.out.println(&quot;==========================================2================================================&quot;);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,</div><div class="line">            ModelAndView modelAndView) throws Exception &#123;</div><div class="line">        System.out.println(&quot;==========================================post2================================================&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</div><div class="line">            throws Exception &#123;</div><div class="line">        System.out.println(&quot;==========================================after2================================================&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import org.springframework.web.servlet.HandlerInterceptor;</div><div class="line">import org.springframework.web.servlet.ModelAndView;</div><div class="line"></div><div class="line">import javax.servlet.http.HttpServletRequest;</div><div class="line">import javax.servlet.http.HttpServletResponse;</div><div class="line"></div><div class="line">public class SyslogInterceptor3 implements HandlerInterceptor &#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 预处理回调方法，实现处理器的预处理（如检查登陆），第三个参数为响应的处理器，自定义Controller</div><div class="line">     * 返回值：true表示继续流程（如调用下一个拦截器或处理器）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</div><div class="line">            throws Exception &#123;</div><div class="line">        System.out.println(&quot;==========================================3================================================&quot;);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    /**</div><div class="line">     * 后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,</div><div class="line">            ModelAndView modelAndView) throws Exception &#123;</div><div class="line">        System.out.println(&quot;==========================================post3================================================&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</div><div class="line">            throws Exception &#123;</div><div class="line">        System.out.println(&quot;==========================================after3================================================&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;mvc:interceptors&gt;</div><div class="line">        &lt;mvc:interceptor&gt;</div><div class="line">            &lt;mvc:mapping path=&quot;/**&quot;/&gt;</div><div class="line">            &lt;bean class=&quot;com.bshf.recipe.demo.syslog.SyslogInterceptor&quot; /&gt;</div><div class="line">        &lt;/mvc:interceptor&gt;</div><div class="line">        </div><div class="line">        &lt;mvc:interceptor&gt;</div><div class="line">            &lt;mvc:mapping path=&quot;/**&quot;/&gt;</div><div class="line">            &lt;bean class=&quot;com.bshf.recipe.demo.syslog.SyslogInterceptor2&quot; /&gt;</div><div class="line">        &lt;/mvc:interceptor&gt;</div><div class="line">        </div><div class="line">        &lt;mvc:interceptor&gt;</div><div class="line">            &lt;mvc:mapping path=&quot;/**&quot;/&gt;</div><div class="line">            &lt;bean class=&quot;com.bshf.recipe.demo.syslog.SyslogInterceptor3&quot; /&gt;</div><div class="line">        &lt;/mvc:interceptor&gt;</div><div class="line">&lt;/mvc:interceptors&gt;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">==========================================1================================================</div><div class="line">==========================================2================================================</div><div class="line">==========================================3================================================</div><div class="line">==========================================post3================================================</div><div class="line">==========================================post2================================================</div><div class="line">==========================================post1================================================</div><div class="line">==========================================after3================================================</div><div class="line">==========================================after2================================================</div><div class="line">==========================================after1================================================</div></pre></td></tr></table></figure></p>
<p><strong>post和after是倒序的！！！！</strong></p>
<h3 id="中断流程Demo"><a href="#中断流程Demo" class="headerlink" title="中断流程Demo"></a>中断流程Demo</h3><p>将SyslogInterceptor3的preHandle方法返回false。其他不变，再看输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">==========================================1================================================</div><div class="line">==========================================2================================================</div><div class="line">==========================================3================================================</div><div class="line">==========================================after2================================================</div><div class="line">==========================================after1================================================</div></pre></td></tr></table></figure>
<p>发现没有了post，post方法一个都没有输出。不仅如此，你的主程序代码（xxx.controller的一个接口）都不会被执行，所以只要遇到return false，则直接进行after清理工作，post和自己主程序代码都将被略过</p>
<p>ref:<br><a href="https://www.jianshu.com/p/1e8d088c2be9" target="_blank" rel="external">https://www.jianshu.com/p/1e8d088c2be9</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Interceptor</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-IoC</title>
    <url>/2017/09/22/Spring-IoC/</url>
    <content><![CDATA[<p>学习过Spring框架的人一定都会听过Spring的IoC(控制反转) 、DI(依赖注入)这两个概念，对于初学Spring的人来说，总觉得IoC 、DI这两个概念是模糊不清的，是很难理解的，今天和大家分享网上的一些技术大牛们对Spring框架的IOC的理解以及谈谈我对Spring Ioc的理解</p>
<a id="more"></a>
<h2 id="IoC是什么"><a href="#IoC是什么" class="headerlink" title="IoC是什么"></a>IoC是什么</h2><p><strong>Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</strong>如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：</p>
<ul>
<li><strong>*</strong>谁控制谁，控制什么**：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。</li>
<li><strong>*</strong>为何是反转，哪些方面反转了**：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。</li>
</ul>
<p>用图例说明一下，传统程序设计如图，都是主动去创建相关对象然后再组合起来：<br><img src="261421378318292.jpg" alt="261421378318292.jpg"></p>
<p>当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了<br><img src="sdfsafsadsfsfs.png" alt="sdfsafsadsfsfs.png"></p>
<h2 id="IoC能做什么"><a href="#IoC能做什么" class="headerlink" title="IoC能做什么"></a>IoC能做什么</h2><p>IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。</p>
<p>其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。</p>
<p>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找</p>
<h2 id="IoC和DI"><a href="#IoC和DI" class="headerlink" title="IoC和DI"></a>IoC和DI</h2><p>DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<p>理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：</p>
<ul>
<li>谁依赖于谁：当然是应用程序依赖于IoC容器；</li>
<li>为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；</li>
<li>谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；</li>
<li>注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。</li>
</ul>
<p>IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p>
<p>ref:<br><a href="https://jinnianshilongnian.iteye.com/blog/1413846" target="_blank" rel="external">https://jinnianshilongnian.iteye.com/blog/1413846</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IoC</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-SpringMVC请求流程</title>
    <url>/2017/09/22/Spring-SpringMVC%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>SpringMVC框架是一个基于请求驱动的Web框架，并且使用了‘前端控制器’模型来进行设计，再根据‘请求映射规则’分发给相应的页面控制器进行处理。</p>
<a id="more"></a>
<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><p><img src="791227-20161125140123503-1552603846.png" alt="791227-20161125140123503-1552603846.png"></p>
<p>具体步骤：</p>
<ol>
<li>首先用户发送请求到前端控制器，前端控制器根据请求信息（如 URL）来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；图中的 1、2 步骤；</li>
<li>页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，这个对象在 Spring Web MVC 中叫命令对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个 ModelAndView（模型数据和逻辑视图名）；图中的 3、4、5 步骤；</li>
<li>前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；图中的步骤 6、7；</li>
<li>前端控制器再次收回控制权，将响应返回给用户，图中的步骤 8；至此整个结束。</li>
</ol>
<h2 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h2><p><img src="791227-20161125140338768-995727439.png" alt="791227-20161125140338768-995727439.png"></p>
<p>具体步骤：</p>
<p>第一步：发起请求到前端控制器(DispatcherServlet)<br>第二步：前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找）<br>第三步：处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略<br>第四步：前端控制器调用处理器适配器去执行Handler<br>第五步：处理器适配器HandlerAdapter将会根据适配的结果去执行Handler<br>第六步：Handler执行完成给适配器返回ModelAndView<br>第七步：处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view）<br>第八步：前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可<br>第九步：视图解析器向前端控制器返回View<br>第十步：前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域）<br>第十一步：前端控制器向用户响应结果</p>
<h2 id="总结-核心开发步骤"><a href="#总结-核心开发步骤" class="headerlink" title="总结 核心开发步骤"></a>总结 核心开发步骤</h2><ol>
<li>DispatcherServlet 在 web.xml 中的部署描述，从而拦截请求到 Spring Web MVC</li>
<li>HandlerMapping 的配置，从而将请求映射到处理器</li>
<li>HandlerAdapter 的配置，从而支持多种类型的处理器    注：处理器映射求和适配器使用纾解的话包含在了注解驱动中，不需要在单独配置</li>
<li>ViewResolver 的配置，从而将逻辑视图名解析为具体视图技术</li>
<li>处理器（页面控制器）的配置，从而进行功能处理 </li>
</ol>
<p>View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…</p>
<p>ref:<br><a href="https://www.cnblogs.com/leskang/p/6101368.html" target="_blank" rel="external">https://www.cnblogs.com/leskang/p/6101368.html</a><br><a href="https://www.jianshu.com/p/6f841d81ed72" target="_blank" rel="external">你真的了解Spring MVC处理请求流程吗</a> //TODO 待整理<br><a href="https://blog.51cto.com/5880861/1981945" target="_blank" rel="external">SpringMVC请求处理过程</a> //TODO 待整理</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-手动装配和自动装配</title>
    <url>/2017/09/22/SpringBoot-%E6%89%8B%E5%8A%A8%E8%A3%85%E9%85%8D%E5%92%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/</url>
    <content><![CDATA[<p>导图梳理springboot手动、自动装配，让springboot不再难懂</p>
<a id="more"></a>
<h2 id="思维导图梳理"><a href="#思维导图梳理" class="headerlink" title="思维导图梳理"></a>思维导图梳理</h2><p>SpringBoot 基本概念<br><img src="6401.png" alt="6401.png"></p>
<p>SpringBoot 装配方式<br><img src="6402.png" alt="6402.png"></p>
<h2 id="什么是springboot"><a href="#什么是springboot" class="headerlink" title="什么是springboot"></a>什么是springboot</h2><p>在学springboot之前，你必须有spring、spring mvc基础，springboot的诞生其实就是用来简化新Spring应用的初始搭建以及开发过程，该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p>
<p>它集成了大量常用的第三方库配置(例如JDBC, Mongodb, Redis, Mail，rabbitmq等等)，所以在Spring Boot应用中这些第三方库几乎可以零配置的开箱即用(out-of-the-box)，大部分的Spring Boot应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p>
<p>也就是说，以前集成ssm框架需要一大堆的xml配置文件，效率底下，而使用了springboot之后，很多时候我们不需要写任何配置了，有时候直接通过@EnableXXX就能开启某个模块的功能。</p>
<p>现在问题来了，你知道@EnableXXX是什么原理吗？</p>
<h2 id="mvc、boot、cloud"><a href="#mvc、boot、cloud" class="headerlink" title="mvc、boot、cloud"></a>mvc、boot、cloud</h2><p>这里直接引用网友的总结给大家介绍一下：</p>
<p>Spring 是一个“引擎”；springmvc是框架，web项目中实际运行的代码；spring boot只是一个配置工具，整合工具，辅助工具，是一套快速开发整合包。</p>
<p>Spring Boot ：J2EE一站式解决方案<br>Spring Cloud ：分布式整体解决方案</p>
<h2 id="约定大于配置的体现"><a href="#约定大于配置的体现" class="headerlink" title="约定大于配置的体现"></a>约定大于配置的体现</h2><p>在于减少软件开发人员所需要做出的决定的数量，从而获得简单的好处，而又不失去其中的灵活性。</p>
<p>1、Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/static</div><div class="line">/public</div><div class="line">/resources</div><div class="line">/META-INF/resources</div></pre></td></tr></table></figure></p>
<p>优先级：META/resources &gt; resources &gt; static &gt; public</p>
<p>SpringBoot 默认将 /** 所有访问映射到以下目录:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">classpath:/static</div><div class="line">classpath:/public</div><div class="line">classpath:/resources</div><div class="line">classpath:/META-INFO/resources</div></pre></td></tr></table></figure></p>
<p>2、spring boot默认的配置文件必须是，也只能是application或application-xxx命名的yml文件或者properties文件，我推荐尽量使用yml文件~</p>
<p>3、多环境配置。该属性可以根据运行环境自动读取不同的配置文件。例如将该属性定义为dev的话，Spring Boot会额外从 application-dev.yml 文件中读取该环境的配置。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">spring:</div><div class="line">    profiles.active: dev</div></pre></td></tr></table></figure></p>
<p>4、修改端口号、请求路径<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">server:</div><div class="line">    port:8080</div><div class="line">    context-path: /demo</div></pre></td></tr></table></figure></p>
<p>5、starter启动器，开箱即用的Starter依赖让springboot可以实现零配置即可自动完成框架的整合。</p>
<ul>
<li>spring-boot-starter-web         嵌入tomcat和web开发需要servlet与jsp支持</li>
<li>spring-boot-starter-data-jpa    数据库支持</li>
<li>spring-boot-starter-data-redis  redis数据库支持</li>
<li>spring-boot-starter-data-solr   solr支持</li>
<li>mybatis-spring-boot-starter     第三方的mybatis集成starter</li>
</ul>
<p>接下来我们来分析一下springboot注入bean有多少种方式</p>
<h2 id="手动装配"><a href="#手动装配" class="headerlink" title="手动装配"></a>手动装配</h2><p>在学习springboot中，我喜欢把总结springboot的一些特性，以及使用springboot的一些规律，比如：在springboot加载bean的过程我分为了</p>
<ul>
<li>手动装配<ul>
<li>模式注解装配</li>
<li>@Enable模块装配</li>
<li>条件装配</li>
</ul>
</li>
<li>自动装配</li>
</ul>
<p>首先来看下手动装配：</p>
<h3 id="模式注解装配"><a href="#模式注解装配" class="headerlink" title="模式注解装配"></a>模式注解装配</h3><p>其实就是使用@Component注解，或者@Component注解的拓展，比如@Controller、@Service、@Repository、@Configruation等，这也是我们最常用的一种方式，直接通过spring mvc的注解把组件bean注入到spring容器中。</p>
<h3 id="Enable模块装配"><a href="#Enable模块装配" class="headerlink" title="@Enable模块装配"></a>@Enable模块装配</h3><h4 id="基于接口驱动实现"><a href="#基于接口驱动实现" class="headerlink" title="基于接口驱动实现"></a>基于接口驱动实现</h4><p>当我们需要开启springboot项目的缓存功能时候，我们直接打开@EnableCaching注解就可以注入Caching 模块，这时候我们就可以开心使用@Cacheable、@CacheEvict等注解，这是怎么做到的？</p>
<p>其实你打开@EnableCaching的源码你就能看到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Target(&#123;ElementType.TYPE&#125;)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">@Import(&#123;CachingConfigurationSelector.class&#125;)</div><div class="line">public @interface EnableCaching &#123;</div><div class="line">    boolean proxyTargetClass () default false;</div><div class="line"></div><div class="line">    AdviceMode mode () default AdviceMode.PROXY;</div><div class="line"></div><div class="line">    int order () default 2147483647;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面最重要的一句代码就是@Import({CachingConfigurationSelector.class})，你会发现，其实使用@EnableCaching，就是为了导入CachingConfigurationSelector.class这配置类。</p>
<p>而这个CachingConfigurationSelector，其实实现了ImportSelector接口，ImportSelector接口是spring中导入外部配置的核心接口，只有一个方法selectImports，其实就是根据EnableCaching的元数据属性（proxyTargetClass、mode、order），选择出需要转配的Configuration。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public interface ImportSelector &#123;</div><div class="line">    String [] selectImports(AnnotationMetadata var1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结其实是这样子，@EnableCaching其实就是根据元数据属性然后选择性条件判断注入需要的配置，比较灵活。</p>
<h4 id="基于注解驱动实现"><a href="#基于注解驱动实现" class="headerlink" title="基于注解驱动实现"></a>基于注解驱动实现</h4><p>然后我们来看另一种没有元数据属性的@EnableWebMvc<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Target(&#123;ElementType.TYPE&#125;)</div><div class="line">@Documented</div><div class="line">@Import(&#123;DelegatingWebMvcConfiguration.class&#125;)</div><div class="line">public @interface EnableWebMvc &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以很直观看到，其实@EnableWebMvc其实就是为了导入DelegatingWebMvcConfiguration配置类，某种程度上，可以认为@EnableWebMvc其实和@Import({DelegatingWebMvcConfiguration.class})是对等的，只是起了一个有意义的名字而已。</p>
<p>所以我们总结一下@EnableXXX模块注入，基于接口驱动实现是实现ImportSelector接口，通过注解参数选择需要导入的配置，而基于注解驱动实现其实就是@Import的派生注解，直接导入某个配置类。</p>
<p>思维导图总结如下：<br><img src="6403.png" alt="6403.png"></p>
<h3 id="条件装配"><a href="#条件装配" class="headerlink" title="条件装配"></a>条件装配</h3><p>所谓条件装配，其实是Bean装配的前置条件，我们先来看一下例子：</p>
<ul>
<li>@ConditionalOnBean                仅仅在当前上下文中存在某个对象时，才会实例化一个Bean</li>
<li>@ConditionalOnExpression          当表达式为true的时候，才会实例化一个Bean</li>
<li>@ConditionalOnMissingClass        某个class类路径上不存在的时候，才会实例化一个Bean</li>
<li>@ConditionalOnNotWebApplication   不是web应用</li>
</ul>
<p>这就是条件装配，当这些条件注解放在某个bean上面的时候，只有满足了条件才能注入bean，这也是为什么springboot能这么智能，知道哪些模块需要开启，哪些不需要，比如当你导入Freemaker的jar包之后，就自动帮你加载Freemaker的的相关配置，其实你看下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Configuration</div><div class="line">@ConditionalOnClass(&#123;freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class&#125;)</div><div class="line">@EnableConfigurationProperties(&#123;FreeMarkerProperties.class&#125;)</div><div class="line">@Import(&#123;FreeMarkerServletWebConfiguration.class, FreeMarkerReactiveWebConfiguration.class, FreeMarkerNonWebConfiguration.class&#125;)</div><div class="line">public class FreeMarkerAutoConfiguration &#123;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这些springboot的自动配置类上面一般是不是都有@ConditionalOnClass注解，这里是说当发现项目有freemarker.template.Configuration.class, FreeMarkerConfigurationFactory.class这两个Class存在时候，我就加载这个FreeMarkerAutoConfiguration，什么时候才会存在这两个Class？当我们导入jar包时候：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupid&gt;org.springframework.boot&lt;/groupid&gt;</div><div class="line">    &lt;artifactid&gt;spring-boot-starter-freemarker&lt;/artifactid&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>所以，当我们没有导入相关jar包时候，我们不用担心springboot会自动开启某些功能，而是会智能判断哪些需要开启，哪些需要跳过。</p>
<p>我们打开@ConditionalOnClass的源码，发现其实是@Conditional拓展出来的注解。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Target(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</div><div class="line">@Retention(RetentionPolicy.RUNTIME)</div><div class="line">@Documented</div><div class="line">@Conditional(OnClassCondition.class)</div><div class="line">public @interface ConditionalOnClass &#123;</div><div class="line"></div><div class="line">	Class&lt;?&gt;[] value() default &#123;&#125;;</div><div class="line"></div><div class="line">	String[] name() default &#123;&#125;;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现逻辑如下：OnClassCondition.class实现Condition接口，并实现matches()方法，如果matches方法返回true，那么带有@Conditional注解的bean就会装载，false就不会装载。</p>
<p>思维导图总结如下：<br><img src="6405.png" alt="6405.png"></p>
<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>ok，刚才我们已经说了很多关于手动装配部分的东西，现在我们来看下自动装配，其实很多时候自动装配就是手动装配的综合运用，只不过在转配bean或配置类时候，我们不在需要使用@EnableXXX来导入功能，而是通过自动注入方式。</p>
<p>这时候自动注入的条件判断（@Conditional）就显得非常重要了。</p>
<p>我们再用刚才说的Freemaker作为例子，springboot集成freemaker非常简单，只需要导入starter的jar包就会自动实现注入，这个自动集成就是FreeMarkerAutoConfiguration这里配置的。</p>
<p>这里有个问题，你知道为什么springboot会自动去判断和加载FreeMarkerAutoConfiguration这个配置类吗？我没有写类似的@EnableFreemaker，那项目怎么识别的。</p>
<p>其实如果你看过springboot的源码，你就会发现：</p>
<p>org.springframework.boot.autoconfigure.AutoConfigurationImportSelector#getCandidateConfigurations<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">protected List &lt; String &gt; getCandidateConfigurations ( AnnotationMetadata metadata , AnnotationAttributes attributes) &#123;</div><div class="line"></div><div class="line">    List&lt;String&gt;configurations=SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</div><div class="line">    Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); </div><div class="line"></div><div class="line">    return configurations ; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的意思是去扫描项目下所有的META-INF/spring.factories文件，然后把EnableAutoConfiguration.class作为key找出对应的值，这个值是个List。那么我们来看下其中一个spring.factories长什么样子的。<br>spring-boot-autoconfigure/2.1.2.RELEASE/spring-boot-autoconfigure-2.1.2.RELEASE.jar!/META-INF/spring.factories<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Initializers</div><div class="line">org.springframework.context.ApplicationContextInitializer=\</div><div class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</div><div class="line">org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer</div><div class="line"></div><div class="line"># Application Listeners</div><div class="line">org.springframework.context.ApplicationListener=\</div><div class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</div><div class="line"></div><div class="line"># Auto Configure</div><div class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</div><div class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.MessageSourceAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.PropertyPlaceholderAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</div><div class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>可以看到EnableAutoConfiguration作为key有很多个值，比如RabbitMq的自动配置类等，而你认证点看，就能找到FreeMarkerAutoConfiguration这配置类了。</p>
<p>所以情况是这个的，当springboot项目启动时候，项目会去加载所有的spring.factories文件，然后在EnableAutoConfiguration后面的所有配置类其实都是可以实现自动装配的配置，至于需不需要装配，就需要条件装配来判定是否满足特定的条件了。</p>
<p>有了这点基础之后，我们就可以自己去写自动装配了。</p>
<p>第一步、编写需要自动装载的配置类。</p>
<p>说明：@Configuration表示是个配置类<br>@ConditionalOnSystemProperty表示需要满足当前系统是win10系统<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Configuration@ConditionalOnSystemProperty(value=&quot;Windows10&quot;)</div><div class="line">public class SayHelloWorldAutoConfiguration &#123;</div><div class="line"></div><div class="line">    @Bean</div><div class="line">    SayHelloWorld autoSayHelloWorld () &#123;</div><div class="line">        System.out.println(&quot;here to ！！auto！！loading bean autoSayHelloWorld!&quot;);</div><div class="line">        return new SayHelloWorld (); </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二步、在resources目录下新建META-INF文件夹，编写spring.factories。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Auto Configure 自动装配自定义的配置</div><div class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.other.configuration.SayHelloWorldAutoConfiguration</div></pre></td></tr></table></figure></p>
<p>启动springboot之后就会自动加载这个配置类，于是，我们就注入了SayHelloWorld这个业务bean，项目中就可以直接注入使用啦~</p>
<p>有人说，这和直接写个@Configruation有啥区别，区别在于@Configruation的配置必须写在Spring能扫描到的目录下，而自动装配不需要。</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI4OTA3NDQ0Nw==&amp;mid=2455546776&amp;idx=1&amp;sn=55c92feb1b2ada040872726113d48e54&amp;chksm=fb9cb7f8cceb3eee27493ebd18ad3bedb1521b381a9e9c770378c4c6cfa4b24405ace5cc44c5&amp;scene=21#wechat_redirect" target="_blank" rel="external">导图梳理springboot手动、自动装配，让springboot不再难懂</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP-TCP的那些事</title>
    <url>/2017/09/22/TCP-TCP%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<p>TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看W.Richard Stevens的《TCP/IP 详解 卷1：协议》（当然，你也可以去读一下RFC793以及后面N多的RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。</p>
<p>废话少说，首先，我们需要知道TCP在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。</p>
<p>首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<a id="more"></a>
<h2 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h2><p>我们来看一下TCP头的格式</p>
<p><img src="TCP-Header-01.jpg" alt="TCP-Header-01.jpg"></p>
<p>需要注意这么几点：</p>
<ul>
<li>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</li>
<li>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：<ul>
<li><strong>Sequence Number</strong> 是包的序号，用来解决网络包乱序（reordering）问题。</li>
<li><strong>Acknowledgement Number</strong> 就是ACK——用于确认收到，用来解决不丢包的问题。</li>
<li><strong>Window</strong> 又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。</li>
<li><strong>TCP Flag</strong>，也就是包的类型，主要是用于操控TCP的状态机的。</li>
</ul>
</li>
</ul>
<p>关于其它的东西，可以参看下面的图示</p>
<p><img src="TCP-Header-02.jpg" alt="TCP-Header-02.jpg"></p>
<h2 id="TCP的状态机"><a href="#TCP的状态机" class="headerlink" title="TCP的状态机"></a>TCP的状态机</h2><p>其实，<strong>网络上的传输是没有连接的，包括TCP也是一样的</strong>。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。</p>
<p>下面是：“<strong>TCP协议的状态机</strong>” 和 “<strong>TCP建链接</strong>”、“<strong>TCP断链接</strong>”、“<strong>传数据</strong>” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的）</p>
<p><img src="tcpfsm.png" alt="tcpfsm.png"></p>
<p><img src="tcp_open_close.jpg" alt="tcp_open_close.jpg"></p>
<p>很多人会问，为什么建链接要3次握手，断链接需要4次挥手？</p>
<ul>
<li><strong>对于建链接的3次握手</strong>，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</li>
<li><p><strong>对于4次挥手</strong>，其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）：</p>
<p>  <img src="tcpclosesimul.png" alt="tcpclosesimul.png"></p>
</li>
</ul>
<p>另外，有几个事情需要注意一下：</p>
<ul>
<li><strong>关于建连接时SYN超时</strong>。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</li>
<li><strong>关于SYN Flood攻击</strong>。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，<strong>请先千万别用tcp_syncookies来处理正常的大负载的连接的情况</strong>。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</li>
<li><strong>关于ISN的初始化</strong>。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC793</a>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – <a href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime" target="_blank" rel="external">Wikipedia语条</a>），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</li>
<li><strong>关于 MSL 和 TIME_WAIT</strong>。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（RFC793定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章<a href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html" target="_blank" rel="external">《TIME_WAIT and its design implications for protocols and scalable client server systems》</a></li>
<li><strong>关于TIME_WAIT数量太多</strong>。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫tcp_tw_reuse，另一个叫tcp_tw_recycle的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意，打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如<a href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" target="_blank" rel="external">官方文档</a>上说的一样“It should not be changed without advice/request of technical experts”）。<ul>
<li><strong>关于tcp_tw_reuse</strong>。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下<a href="http://lxr.free-electrons.com/ident?i=tcp_twsk_unique" target="_blank" rel="external">tcp_twsk_unique</a>的源码 ）。我个人估计还是有一些场景会有问题。</li>
<li><strong>关于tcp_tw_recycle</strong>。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码 [tcp_timewait_state_process](<a href="http://lxr.free-electrons.com/ident?i=tcp_timewait_state_process" target="_blank" rel="external">http://lxr.free-electrons.com/ident?i=tcp_timewait_state_process</a></li>
<li><strong>关于tcp_max_tw_buckets</strong>。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。</li>
</ul>
</li>
</ul>
<p><strong>Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议</strong>（<a href="http://tools.ietf.org/html/rfc1122" target="_blank" rel="external">RFC 1122</a>）</p>
<p>其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个<a href="http://en.wikipedia.org/wiki/HTTP_persistent_connection" target="_blank" rel="external">HTTP的KeepAlive</a>有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。</p>
<h2 id="数据传输中的Sequence-Number"><a href="#数据传输中的Sequence-Number" class="headerlink" title="数据传输中的Sequence Number"></a>数据传输中的Sequence Number</h2><p>下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics -&gt;Flow Graph… ）</p>
<p><img src="tcp_data_seq_num.jpg" alt="tcp_data_seq_num.jpg"></p>
<p>你可以看到，<strong>SeqNum的增加是和传输的字节数相关的</strong>。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。</p>
<p>注意：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p>
<h2 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h2><p>TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，<strong>SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包</strong>，不然，发送端就以为之前的都收到了。</p>
<h3 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h3><p>一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。</p>
<p>但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p>
<p>对此有两种选择：</p>
<ul>
<li>一种是仅重传timeout的包。也就是第3份数据。</li>
<li>另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。</li>
</ul>
<p>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）</p>
<h3 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h3><p>于是，TCP引入了一种叫Fast Retransmit 的算法，<strong>不以时间驱动，而以数据驱动重传</strong>。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p>
<p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：</p>
<p><img src="FASTIncast021.png" alt="FASTIncast021.png"></p>
<p>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p>
<h3 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h3><p>另外一种更好的方式叫：<strong>Selective Acknowledgment (SACK)</strong>（<a href="http://tools.ietf.org/html/rfc2018" target="_blank" rel="external">参看RFC 2018</a>），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：</p>
<p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过tcp_sack参数打开这个功能（Linux 2.4后默认打开）。</p>
<p>这里还需要注意一个问题——接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</p>
<p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看<a href="http://www.ibm.com/developerworks/cn/linux/l-tcp-sack/" target="_blank" rel="external">《TCP SACK的性能权衡》</a></p>
<h3 id="Duplicate-SACK-–-重复收到数据的问题"><a href="#Duplicate-SACK-–-重复收到数据的问题" class="headerlink" title="Duplicate SACK – 重复收到数据的问题"></a>Duplicate SACK – 重复收到数据的问题</h3><p>Duplicate SACK又称D-SACK，其主要使用了SACK来告诉发送方有哪些数据被重复接收了。RFC-2883 里有详细描述和示例。下面举几个例子（来源于<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank" rel="external">RFC-2883</a>）</p>
<p>D-SACK使用了SACK的第一个段来做标志，</p>
<ul>
<li>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK</li>
<li>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</li>
</ul>
<h4 id="示例一：ACK丢包"><a href="#示例一：ACK丢包" class="headerlink" title="示例一：ACK丢包"></a>示例一：ACK丢包</h4><p>下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Transmitted  Received    ACK Sent</div><div class="line">Segment      Segment     (Including SACK Blocks)</div><div class="line"> </div><div class="line">3000-3499    3000-3499   3500 (ACK dropped)</div><div class="line">3500-3999    3500-3999   4000 (ACK dropped)</div><div class="line">3000-3499    3000-3499   4000, SACK=3000-3500</div><div class="line">                                    ---------</div></pre></td></tr></table></figure>
<h4 id="示例二，网络延误"><a href="#示例二，网络延误" class="headerlink" title="示例二，网络延误"></a>示例二，网络延误</h4><p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。</p>
<p>这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Transmitted    Received    ACK Sent</div><div class="line">Segment        Segment     (Including SACK Blocks)</div><div class="line"> </div><div class="line">500-999        500-999     1000</div><div class="line">1000-1499      (delayed)</div><div class="line">1500-1999      1500-1999   1000, SACK=1500-2000</div><div class="line">2000-2499      2000-2499   1000, SACK=1500-2500</div><div class="line">2500-2999      2500-2999   1000, SACK=1500-3000</div><div class="line">1000-1499      1000-1499   3000</div><div class="line">               1000-1499   3000, SACK=1000-1500</div><div class="line">                                      ---------</div></pre></td></tr></table></figure>
<p>可见，引入了D-SACK，有这么几个好处：</p>
<ol>
<li>可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</li>
<li>是不是自己的timeout太小了，导致重传。</li>
<li>网络上出现了先发的包后到的情况（又称reordering）</li>
<li>网络上是不是把我的数据包给复制了。</li>
</ol>
<p><strong>知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控</strong>。</p>
<p>Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）</p>
<h2 id="TCP的RTT算法"><a href="#TCP的RTT算法" class="headerlink" title="TCP的RTT算法"></a>TCP的RTT算法</h2><p>从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p>
<h3 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h3><p><a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="external">RFC793</a> 中定义的经典算法是这样的：</p>
<ol>
<li>首先，先采样RTT，记下最近好几次的RTT值。</li>
<li>然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）<br> SRTT = ( α <em> SRTT ) + ((1- α) </em> RTT)</li>
<li>开始计算RTO。公式如下：<br> RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</li>
</ol>
<p>其中：</p>
<ul>
<li>UBOUND是最大的timeout时间，上限值</li>
<li>LBOUND是最小的timeout时间，下限值</li>
<li>β 值一般在1.3到2.0之间。</li>
</ul>
<h3 id="Karn-Partridge-算法"><a href="#Karn-Partridge-算法" class="headerlink" title="Karn / Partridge 算法"></a>Karn / Partridge 算法</h3><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？</p>
<p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li>情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。</li>
<li><p>情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。</p>
<p>  <img src="Karn-Partridge-Algorithm.jpg" alt="Karn-Partridge-Algorithm.jpg"></p>
</li>
</ul>
<p>所以1987年的时候，搞了一个叫<a href="http://en.wikipedia.org/wiki/Karn&#39;s_Algorithm" target="_blank" rel="external">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的RTT做采样</strong>（你看，你不需要去解决不存在的问题）。</p>
<p>但是，这样一来，又会引发一个大BUG——如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。</p>
<h3 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h3><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看<a href="http://tools.ietf.org/html/rfc6298" target="_blank" rel="external">RFC6289</a>）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）</p>
<pre><code>SRTT = SRTT + α (RTT – SRTT)  —— 计算平滑RTT
DevRTT = (1-β)*DevRTT + β*(|RTT-SRTT|) ——计算平滑RTT和真实的差距（加权移动平均）
RTO= µ * SRTT + ∂ *DevRTT —— 神一样的公式
</code></pre><p>（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609" target="_blank" rel="external">tcp_rtt_estimator</a>）。</p>
<h2 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h2><p>需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道，<strong>TCP必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过，<strong>TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：</p>
<p><img src="sliding_window.jpg" alt="sliding_window.jpg"></p>
<p>上图中，我们可以看到：</p>
<ul>
<li>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li>
<li>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</li>
</ul>
<p>于是：</p>
<ul>
<li>接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li>
<li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li>
</ul>
<p>下面我们来看一下发送方的滑动窗口示意图：</p>
<p><img src="tcpswwindows.png" alt="tcpswwindows.png"></p>
<p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li>#1已收到ack确认的数据。</li>
<li>#2发还没收到ack的。</li>
<li>#3在窗口中还没有发出的（接收方还有空间）。</li>
<li>#4窗口以外的数据（接收方没空间）</li>
</ul>
<p>下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：</p>
<p><img src="tcpswslide.png" alt="tcpswslide.png"></p>
<p>下面我们来看一个接受端控制发送端的图示：</p>
<p><img src="tcpswflow.png" alt="tcpswflow.png"></p>
<h3 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h3><p>上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？</p>
<p>解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<p>注意：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a href="http://en.wikipedia.org/wiki/Sockstress" target="_blank" rel="external">Wikipedia的SockStress词条</a>）</p>
<p>另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。</p>
<h3 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h3><p>Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。</p>
<p>要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p>
<p>另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为 RFC 791里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。</p>
<p>如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。</p>
<p>所以，Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。</p>
<ul>
<li>如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。</li>
<li>如果这个问题是由Sender端引起的，那么就会使用著名的 <a href="http://en.wikipedia.org/wiki/Nagle%27s_algorithm" target="_blank" rel="external">Nagle’s algorithm</a>。这个算法的思路也是延时处理，他有两个主要的条件：<ol>
<li>要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，</li>
<li>收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。</li>
</ol>
</li>
</ul>
<p>另外，Nagle算法默认是打开的，所以，<strong>对于一些需要小包场景的程序——比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法</strong>。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;value,sizeof(int));</div></pre></td></tr></table></figure>
<p>另外，网上有些文章说TCP_CORK的socket option是也关闭Nagle算法，这不对。TCP_CORK其实是更新激进的Nagle算汉，完全禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送。最好不要两个选项都设置。</p>
<h2 id="TCP的拥塞处理-–-Congestion-Handling"><a href="#TCP的拥塞处理-–-Congestion-Handling" class="headerlink" title="TCP的拥塞处理 – Congestion Handling"></a>TCP的拥塞处理 – Congestion Handling</h2><p>上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p>
<p>具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是，如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。这是一个灾难。</p>
<p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：<strong>TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了</strong>。</p>
<p>关于拥塞控制的论文请参看<a href="http://ee.lbl.gov/papers/congavoid.pdf" target="_blank" rel="external">《Congestion Avoidance and Control》</a>(PDF)</p>
<p>拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。</p>
<h3 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h3><p>首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</p>
<p>慢启动的算法如下(cwnd全称Congestion Window)：</p>
<ol>
<li>连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</li>
<li>每当收到一个ACK，cwnd++; 呈线性上升</li>
<li>每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</li>
<li>还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</li>
</ol>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p>
<p><img src="tcp.slow_.start_.jpg" alt="tcp.slow_.start_.jpg"></p>
<p>这里，我需要提一下的是一篇Google的论文<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf" target="_blank" rel="external">《An Argument for Increasing TCP’s Initial Congestion Window》</a>Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。 而Linux 3.0以前，比如2.6，Linux采用了<a href="http://www.rfc-editor.org/rfc/rfc3390.txt" target="_blank" rel="external">RFC3390</a>，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。</p>
<h3 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h3><p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p>
<ol>
<li>收到一个ACK时，cwnd = cwnd + 1/cwnd</li>
<li>当每过一个RTT时，cwnd = cwnd + 1</li>
</ol>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<h3 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h3><p>前面我们说过，当丢包的时候，会有两种情况：</p>
<ol>
<li><p>等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。</p>
<ul>
<li>sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ul>
</li>
<li><p>Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。</p>
<ul>
<li>TCP Tahoe的实现和RTO超时一样。</li>
<li>TCP Reno的实现是：<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<h3 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h3><h4 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h4><p>这个算法定义在<a href="http://tools.ietf.org/html/rfc5681" target="_blank" rel="external">RFC5681</a>。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：</p>
<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
</ul>
<p>然后，真正的Fast Recovery算法如下：</p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）</li>
<li>重传Duplicated ACKs指定的数据包</li>
<li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li>
<li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
<p>如果你仔细思考一下上面的这个算法，你就会知道，上面这个算法也有问题，那就是——它依赖于3个重复的Acks。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。</p>
<p>通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲）</p>
<h4 id="TCP-New-Reno"><a href="#TCP-New-Reno" class="headerlink" title="TCP New Reno"></a>TCP New Reno</h4><p>于是，1995年，TCP New Reno（参见 RFC 6582 ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——</p>
<ul>
<li>当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。</li>
<li>一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程<br>我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。</li>
</ul>
<h4 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h4><p><img src="tcp.fr_.jpg" alt="tcp.fr_.jpg"></p>
<h3 id="FACK算法"><a href="#FACK算法" class="headerlink" title="FACK算法"></a>FACK算法</h3><p>FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）Forward Acknowledgement: Refining TCP Congestion Control 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。</p>
<ul>
<li>这个算法会把SACK中最大的Sequence Number 保存在snd.fack这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方）</li>
<li>然后定义一个awnd = snd.nxt – snd.fack（snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network）</li>
<li>如果需要重传数据，那么，awnd = snd.nxt – snd.fack + retran_data，也就是说，awnd是传出去的数据 + 重传的数据。</li>
<li>然后触发Fast Recovery 的条件是： ( ( snd.fack – snd.una ) &gt; (3*MSS) ) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。</li>
</ul>
<p>我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。</p>
<h2 id="其它拥塞控制算法简介"><a href="#其它拥塞控制算法简介" class="headerlink" title="其它拥塞控制算法简介"></a>其它拥塞控制算法简介</h2><h3 id="TCP-Vegas-拥塞控制算法"><a href="#TCP-Vegas-拥塞控制算法" class="headerlink" title="TCP Vegas 拥塞控制算法"></a>TCP Vegas 拥塞控制算法</h3><p>这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是<a href="http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf" target="_blank" rel="external">《TCP Vegas: End to End Congestion Avoidance on a Global Internet》</a>这篇论文给了Vegas和 New Reno的对比：</p>
<p><img src="tcp_vegas_newreno.jpg" alt="tcp_vegas_newreno.jpg"></p>
<p>关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h" target="_blank" rel="external">/net/ipv4/tcp_vegas.h</a>， <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c" target="_blank" rel="external">/net/ipv4/tcp_vegas.c</a></p>
<h3 id="HSTCP-High-Speed-TCP-算法"><a href="#HSTCP-High-Speed-TCP-算法" class="headerlink" title="HSTCP(High Speed TCP) 算法"></a>HSTCP(High Speed TCP) 算法</h3><p>这个算法来自RFC 3649（Wikipedia词条）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中：</p>
<ul>
<li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li>
<li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li>
</ul>
<p>注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c" target="_blank" rel="external">/net/ipv4/tcp_highspeed.c</a></p>
<h3 id="TCP-BIC-算法"><a href="#TCP-BIC-算法" class="headerlink" title="TCP BIC 算法"></a>TCP BIC 算法</h3><p>2004年，产内出BIC算法。现在你还可以查得到相关的新闻<a href="https://www.google.com/search?lr=lang_zh-CN%7Clang_zh-TW&amp;newwindow=1&amp;biw=1366&amp;bih=597&amp;tbs=lr%3Alang_1zh-CN%7Clang_1zh-TW&amp;q=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D&amp;oq=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D" target="_blank" rel="external">《Google：美科学家研发BIC-TCP协议 速度是DSL六千倍》</a> BIC全称<a href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic" target="_blank" rel="external">Binary Increase Congestion control</a>，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC-TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c" target="_blank" rel="external">/net/ipv4/tcp_bic.c</a></p>
<h3 id="TCP-WestWood算法"><a href="#TCP-WestWood算法" class="headerlink" title="TCP WestWood算法"></a>TCP WestWood算法</h3><p>westwood采用和Reno相同的慢启动算法、拥塞避免算法。westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X <em> RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD </em> min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd &gt; ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。   关于这个算法实现，你可以参看Linux源码： <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c" target="_blank" rel="external">/net/ipv4/tcp_westwood.c</a></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>更多的算法，你可以从Wikipedia的 <a href="http://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm" target="_blank" rel="external">TCP Congestion Avoidance Algorithm</a> 词条中找到相关的线索</p>
<p>ref:<br><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="external">TCP 的那些事儿（上）</a><br><a href="https://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿（下）</a></p>
]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-JMM</title>
    <url>/2017/09/22/java-concurrency-JMM/</url>
    <content><![CDATA[<p>本文为 JMM 整理和总结</p>
<a id="more"></a>
<h2 id="1-并发编程基础概念"><a href="#1-并发编程基础概念" class="headerlink" title="1. 并发编程基础概念"></a>1. 并发编程基础概念</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">并发——在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行——源自百度百科</div></pre></td></tr></table></figure>
<p>在并发编程中，我们需要处理两个关键问题：线程之间如何通信和线程之间如何同步，后续篇章将围绕这两个问题进行介绍。</p>
<ul>
<li>线程通信：是指线程之间以何种机制来交换信息，在命令式编程中，线程之间的通信机制有两种：共享内存和消息传递。</li>
<li>线程同步：是指程序用于控制不同线程之间操作发生相对顺序的机制。在Java中，可以通过volatile，synchronized, 锁等方式实现同步。</li>
</ul>
<p>本文主要介绍java的通信机制，刚介绍常见通信机制主要包括以下两种方式：</p>
<ul>
<li>共享内存：线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。</li>
<li>消息传递：线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享。</div></pre></td></tr></table></figure>
<p>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</p>
<h2 id="2-JMM内存模型"><a href="#2-JMM内存模型" class="headerlink" title="2. JMM内存模型"></a>2. JMM内存模型</h2><p>JMM（Java Memory Model）是JVM规范中定义的一种Java内存模型，它的目的是屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台上到能达到一致的内存访问效果。<br>Java内存模型的主要定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。首先简单说明几个常用名称定义：</p>
<ul>
<li>变量：这里指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。</li>
<li>主内存：在java中，实例域、静态域和数组元素是线程之间共享的数据，它们存储在主内存中。</li>
<li>_工作内存：每条线程都有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。</li>
</ul>
<p><img src="WX20190429-1819072x.png" alt="WX20190429-1819072x.png"></p>
<p>线程、主内存和工作内存的交互关系如上图所示，和CPU-缓存-内存很类似。<br>不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成。<br>最后注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<h2 id="3-内存间交互操作"><a href="#3-内存间交互操作" class="headerlink" title="3. 内存间交互操作"></a>3. 内存间交互操作</h2><p>关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成：</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
<p>所以变量读写包含以下几个步骤：</p>
<p>1 变量从主内存复制到工作内存——顺序执行read和load操作<br>2 变量从工作内存同步到主内存——顺序执行store和write操作</p>
<p>注意，Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的。<br>除了定义以上8中原子操作，Java内存模型还规定了上述8种基本操作在执行时必须满足一定的操作规则，例如如不允许read和load单独出现（即不允许一个变量从主内存中读取但工作内存不接受），不允许store和write单独出现（即不允许从工作内存中发起了回写单主内存不接受），这里不一一列举，详细网上搜索即可。</p>
<p>ref:<br><a href="https://www.jianshu.com/p/b1f7dce224f7" target="_blank" rel="external">https://www.jianshu.com/p/b1f7dce224f7</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>concurrency</tag>
        <tag>JMM</tag>
      </tags>
  </entry>
  <entry>
    <title>microservices-蓝绿部署-滚动部署-灰度发布-金丝雀发布</title>
    <url>/2017/09/22/mircoservices-%E8%93%9D%E7%BB%BF%E9%83%A8%E7%BD%B2-%E6%BB%9A%E5%8A%A8%E9%83%A8%E7%BD%B2-%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83-%E9%87%91%E4%B8%9D%E9%9B%80%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<p>在项目迭代的过程中，不可避免需要”上线“。上线对应着部署，或者重新部署；部署对应着修改；修改则意味着风险。</p>
<p>目前有很多用于部署的技术，有的简单，有的复杂；有的得停机，有的不需要停机即可完成部署。本文的目的就是将目前常用的布署方案做一个总结</p>
<a id="more"></a>
<h2 id="Blue-Green-Deployment（蓝绿部署）"><a href="#Blue-Green-Deployment（蓝绿部署）" class="headerlink" title="Blue/Green Deployment（蓝绿部署）"></a>Blue/Green Deployment（蓝绿部署）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>蓝绿部署是不停老版本，部署新版本然后进行测试，确认OK，将流量切到新版本，然后老版本同时也升级到新版本。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>蓝绿部署无需停机，并且风险较小。</p>
<h3 id="布署过程"><a href="#布署过程" class="headerlink" title="布署过程"></a>布署过程</h3><p>第一步、部署版本1的应用（一开始的状态）<br>所有外部请求的流量都打到这个版本上。</p>
<p><img src="snipaste_20190821161930.png" alt="snipaste_20190821161930.png"></p>
<p>第二步、部署版本2的应用<br>版本2的代码与版本1不同(新功能、Bug修复等)。</p>
<p>第三步、将流量从版本1切换到版本2。</p>
<p><img src="snipaste_20190821162133.png" alt="snipaste_20190821162133.png"></p>
<p>第四步、如版本2测试正常，就删除版本1正在使用的资源（例如实例），从此正式用版本2。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>从过程不难发现，在部署的过程中，我们的应用始终在线。并且，新版本上线的过程中，并没有修改老版本的任何内容，在部署期间，老版本的状态不受影响。这样风险很小，并且，只要老版本的资源不被删除，理论上，我们可以在任何时间回滚到老版本。</p>
<h3 id="蓝绿发布的注意事项"><a href="#蓝绿发布的注意事项" class="headerlink" title="蓝绿发布的注意事项"></a>蓝绿发布的注意事项</h3><p>当你切换到蓝色环境时，需要妥当处理未完成的业务和新的业务。如果你的数据库后端无法处理，会是一个比较麻烦的问题；</p>
<ul>
<li>可能会出现需要同时处理“微服务架构应用”和“传统架构应用”的情况，如果在蓝绿部署中协调不好这两者，还是有可能会导致服务停止。</li>
<li>需要提前考虑数据库与应用部署同步迁移 /回滚的问题。</li>
<li>蓝绿部署需要有基础设施支持。</li>
<li>在非隔离基础架构（ VM 、 Docker 等）上执行蓝绿部署，蓝色环境和绿色环境有被摧毁的风险。</li>
</ul>
<h3 id="为什么需要蓝绿发布系统"><a href="#为什么需要蓝绿发布系统" class="headerlink" title="为什么需要蓝绿发布系统"></a>为什么需要蓝绿发布系统</h3><ul>
<li>新项目和新需求非常多</li>
<li>新需求的上线过程是，先上线一台服务器然后观察会不会出问题，如果没有问题则全部上线。</li>
<li>分流是关键，但是动态分流是痛点</li>
</ul>
<h4 id="老分流方案"><a href="#老分流方案" class="headerlink" title="老分流方案"></a>老分流方案</h4><p><img src="snipaste_20190821163750.png" alt="snipaste_20190821163750.png"></p>
<p>方案存在的问题点:</p>
<ul>
<li>nginx.conf配置文件里各种if、set和rewrite，并且容易配置出错。</li>
<li>修改完配置文件后，重启或者reload后才能生效。</li>
<li>不能实现太复杂的逻辑。</li>
<li>不能实现一些特殊分流方式</li>
</ul>
<h4 id="新分流方案"><a href="#新分流方案" class="headerlink" title="新分流方案"></a>新分流方案</h4><p><img src="snipaste_20190821163904.png" alt="snipaste_20190821163904.png"></p>
<p>功能说明：</p>
<ul>
<li>采用Redis存放分流策略</li>
<li>分流策略包括按时间来分流，比如每分钟分流多少笔订单，还有按权重分流，比如新老系统之间的比例是1:9</li>
<li>采用OpenResty+lua，整体性能优秀</li>
</ul>
<h2 id="Rolling-update（滚动发布）"><a href="#Rolling-update（滚动发布）" class="headerlink" title="Rolling update（滚动发布）"></a>Rolling update（滚动发布）</h2><h3 id="滚动发布定义"><a href="#滚动发布定义" class="headerlink" title="滚动发布定义"></a>滚动发布定义</h3><p>滚动发布：一般是取出一个或者多个服务器停止服务，执行更新，并重新将其投入使用。周而复始，直到集群中所有的实例都更新成新版本。</p>
<h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>这种部署方式相对于蓝绿部署，更加节约资源——它不需要运行两个集群、两倍的实例数。我们可以部分部署，例如每次只取出集群的20%进行升级。<br>这种方式也有很多缺点，例如：</p>
<p>(1) 没有一个确定OK的环境。使用蓝绿部署，我们能够清晰地知道老版本是OK的，而使用滚动发布，我们无法确定。<br>(2) 修改了现有的环境。<br>(3) 如果需要回滚，很困难。举个例子，在某一次发布中，我们需要更新100个实例，每次更新10个实例，每次部署需要5分钟。当滚动发布到第80个实例时，发现了问题，需要回滚，这个回滚却是一个痛苦，并且漫长的过程。<br>(4) 有的时候，我们还可能对系统进行动态伸缩，如果部署期间，系统自动扩容/缩容了，我们还需判断到底哪个节点使用的是哪个代码。尽管有一些自动化的运维工具，但是依然令人心惊胆战。<br>(5) 因为是逐步更新，那么我们在上线代码的时候，就会短暂出现新老版本不一致的情况，如果对上线要求较高的场景，那么就需要考虑如何做好兼容的问题。</p>
<h2 id="灰度发布-金丝雀部署"><a href="#灰度发布-金丝雀部署" class="headerlink" title="灰度发布/金丝雀部署"></a>灰度发布/金丝雀部署</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>灰度发布是指在黑与白之间，能够平滑过渡的一种发布方式。AB test就是一种灰度发布方式，让一部分用户继续用A，一部分用户开始用B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度，而我们平常所说的金丝雀部署也就是灰度发布的一种方式。</p>
<p><code>注释：矿井中的金丝雀
17世纪，英国矿井工人发现，金丝雀对瓦斯这种气体十分敏感。空气中哪怕有极其微量的瓦斯，金丝雀也会停止歌唱；而当瓦斯含量超过一定限度时，虽然鲁钝的人类毫无察觉，金丝雀却早已毒发身亡。当时在采矿设备相对简陋的条件下，工人们每次下井都会带上一只金丝雀作为“瓦斯检测指标”，以便在危险状况下紧急撤离。</code></p>
<p>灰度发布结构图如下</p>
<p><img src="snipaste_20190821163053.png" alt="snipaste_20190821163053.png"></p>
<h3 id="灰度发布／金丝雀发布由以下几个步骤组成"><a href="#灰度发布／金丝雀发布由以下几个步骤组成" class="headerlink" title="灰度发布／金丝雀发布由以下几个步骤组成"></a>灰度发布／金丝雀发布由以下几个步骤组成</h3><ul>
<li>准备好部署各个阶段的工件，包括：构建工件，测试脚本，配置文件和部署清单文件。</li>
<li>从负载均衡列表中移除掉“金丝雀”服务器。</li>
<li>升级“金丝雀”应用（排掉原有流量并进行部署）。</li>
<li>对应用进行自动化测试。</li>
<li>将“金丝雀”服务器重新添加到负载均衡列表中（连通性和健康检查）。</li>
<li>如果“金丝雀”在线使用测试成功，升级剩余的其他服务器。（否则就回滚）</li>
</ul>
<p>除此之外灰度发布还可以设置路由权重，动态调整不同的权重来进行新老版本的验证</p>
<p>ref:<br><a href="https://www.jianshu.com/p/022685baba7d" target="_blank" rel="external">https://www.jianshu.com/p/022685baba7d</a><br><a href="https://www.jianshu.com/p/e2c4cb323b21" target="_blank" rel="external">https://www.jianshu.com/p/e2c4cb323b21</a></p>
]]></content>
      <categories>
        <category>microservices</category>
      </categories>
      <tags>
        <tag>microservices</tag>
      </tags>
  </entry>
  <entry>
    <title>solution-防止数据重复插入</title>
    <url>/2017/09/22/solution-%E9%98%B2%E6%AD%A2%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5/</url>
    <content><![CDATA[<ol>
<li>为啥要解决数据重复插入？</li>
<li>解决方案实战</li>
<li>可落地小总结</li>
</ol>
<a id="more"></a>
<h2 id="为啥要解决数据重复插入？"><a href="#为啥要解决数据重复插入？" class="headerlink" title="为啥要解决数据重复插入？"></a>为啥要解决数据重复插入？</h2><p>问题起源，微信小程序抽风 wx.request() 重复请求服务器提交数据。后端服务也很简单，伪代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class SignLogService &#123;</div><div class="line">    public void saveSignLog(SignLogDO log) &#123;</div><div class="line">        // 简单插入做记录</div><div class="line">        SignLogDAO.insert(log);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>发现数据库会存在重复数据行，提交时间一模一样。但业务需求是不能有多余的 log 出现，这明显是个问题。</p>
<p>问题是，重复请求导致的数据重复插入。这问题造成的后果很明显：</p>
<ul>
<li>数据冗余，可能不单单多一条</li>
<li>有些业务需求不能有多余数据，造成服务问题</li>
</ul>
<p>问题如图所示：</p>
<p><img src="1483536-35fd247d3ef86b4a.png" alt="1483536-35fd247d3ef86b4a.png"></p>
<p>解决方式：如何将 同请求 A，不执行插入，而是读取前一个请求插入的数据并返回。解决后流程应该如下：</p>
<p><img src="1483536-87128ca56eee0ad7.png" alt="1483536-87128ca56eee0ad7.png"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="单库单表解决方案"><a href="#单库单表解决方案" class="headerlink" title="单库单表解决方案"></a>单库单表解决方案</h3><ul>
<li>唯一索引 + 唯一字段</li>
<li>幂等</li>
</ul>
<p>上面说的那种业务场景：sign_log 表会有 user_id、sign_id、sign_time 等。那么每次签到，每个人每天只有一条签到记录。</p>
<p>数据库层采取唯一索引的形式，保证数据记录唯一性。即 UNIQUE 约束，UNIQUE 约束唯一标识数据库表中的每条记录。另外，user_id,sign_id,sign_time 三个组合适唯一字段。创表的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">CREATE TABLE sign_log</div><div class="line">(</div><div class="line">id int NOT NULL,</div><div class="line">user_id int NOT NULL,</div><div class="line">sign_id int,</div><div class="line">sign_time int,</div><div class="line">CONSTRAINT unique_sign_log UNIQUE (user_id,sign_id,sign_time)</div><div class="line">)</div></pre></td></tr></table></figure>
<p>重点是 CONSTRAINT unique_sign_log UNIQUE (user_id,sign_id,sign_time)。有个小问题，数据量大的时候，每条记录都会有对应的唯一索引，比较耗资源。那么这样就行了吗？</p>
<p>答案是不行，服务不够健壮。第一个请求插入成功，第二个请求直接报错，Java 服务会抛出 DuplicateKeyException 。</p>
<p>简单的幂等写法操作即可，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class SignLogService &#123;</div><div class="line">    public SingLogDO saveSignLog(SignLogDO log) &#123;</div><div class="line">        // 幂等处理</div><div class="line">        SignLogDO insertLog = null;</div><div class="line">        try &#123;</div><div class="line">            insertLog = signLogDAO.insert(log);</div><div class="line">        &#125; catch (DuplicateKeyException e) &#123;</div><div class="line">            insertLog = selectByUniqueKeys(userId,signId,signTime);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        return insertLog;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>的确，流量不是很大，也不算很高并发。重复写问题，这样处理即可。那大流量、高并发场景咋搞</p>
<h3 id="分库分表解决方案"><a href="#分库分表解决方案" class="headerlink" title="分库分表解决方案"></a>分库分表解决方案</h3><p>流量大了后，单库单表会演变成分库分表。那么基于单表的唯一索引形式，在碰到分表就无法保证呢，插入的地方可能是两个分表 A1 和 A2。</p>
<p>解决思路：将数据的唯一性条件放到其他存储，并进行锁控制</p>
<p>还是上面的例子，每天，每次签到，每个人只有一条签到记录。那么使用分布式锁 Redis 的解决方案。大致伪代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class SignLogService &#123;</div><div class="line">    public SingLogDO saveSignLog(SignLogDO log) &#123;</div><div class="line"></div><div class="line">        // 幂等校验</div><div class="line">        SignLogDO existLog = selectByUniqueKeys(userId,signId,signTime);</div><div class="line">        if(Objects.nonNull(existLog)) &#123;</div><div class="line">            return existLog;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 加锁</div><div class="line">        //lockKey 最简单的是 user_id + sign_id + sign_time</div><div class="line">        //expireTime 设置为一天</div><div class="line">        jedis.set(lockKey, requestId, &quot;NX&quot;, &quot;PX&quot;, expireTime);</div><div class="line"></div><div class="line">        SignLogDO insertLog = signLogDAO.insert(log);</div><div class="line"></div><div class="line">        // 解锁</div><div class="line">        jedis.eval(script, lockKey,requestId);</div><div class="line"></div><div class="line">        return insertLog;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方案还是不是很成熟，大家参考下即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决方案实战中，了解具体术。归纳如下：</p>
<ul>
<li>幂等：保证多次同意请求后结果一致</li>
<li>并发控制：单表唯一索引、分布式多表分布式锁</li>
<li>降级兜方案：分布式锁锁失效 - 考虑乐观锁兜底</li>
</ul>
<p>ref:<br><a href="http://www.spring4all.com/article/6912" target="_blank" rel="external">http://www.spring4all.com/article/6912</a></p>
]]></content>
      <categories>
        <category>solution</category>
      </categories>
      <tags>
        <tag>solution</tag>
      </tags>
  </entry>
  <entry>
    <title>架构-库存扣减处理</title>
    <url>/2017/09/22/%E6%9E%B6%E6%9E%84-%E5%BA%93%E5%AD%98%E6%89%A3%E5%87%8F%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>库存扣减处理</p>
<a id="more"></a>
<h2 id="基于数据库的库存扣减方案"><a href="#基于数据库的库存扣减方案" class="headerlink" title="基于数据库的库存扣减方案"></a>基于数据库的库存扣减方案</h2><p><img src="1504949094710147.png" alt="1504949094710147.png"></p>
<p>业务复杂、数据量大、并发量大的业务场景下，典型的互联网架构，一般会分为这么几层：</p>
<ul>
<li>调用层，一般是处于端上的browser或者APP</li>
<li>站点层，一般是拼装html或者json返回的web-server层</li>
<li>服务层，一般是提供RPC调用接口的service层</li>
<li>数据层，提供固化数据存储的db</li>
</ul>
<p>对于库存业务，一般有个库存服务，提供库存的查询、扣减、设置等RPC接口：</p>
<p><img src="1504949326621170.png" alt="1504949326621170.png"></p>
<ul>
<li>库存查询，stock-service本质上执行的是<br>select num from stock where sid=$sid</li>
<li>库存扣减，stock-service本质上执行的是<br>update stock set num=num-$reduce where sid=$sid</li>
<li>库存设置，stock-service本质上执行的是<br>update stock set num=$num_new where sid=$sid</li>
</ul>
<p>用户下单前，一般会对库存进行查询，有足够的存量才允许扣减：</p>
<p><img src="1504949436407521.png" alt="1504949436407521.png"></p>
<p>如上图所示，通过查询接口，得到库存是5。</p>
<p>用户下单时，接着会对库存进行扣减：</p>
<p><img src="1504951134210028.png" alt="1504951134210028.png"></p>
<p>如上图所示，购买3单位的商品，通过扣减接口，最终得到库存是2。</p>
<p>希望设计往往有容错机制，例如“重试”，如果通过扣减接口来修改库存，在重试时，可能会得到错误的数据，导致重复扣减：</p>
<p><img src="1504951225404280.png" alt="1504951225404280.png"></p>
<p>如上图所示，如果数据库层面有重试容错机制，可能导致一次扣减执行两次，最终得到一个负数的错误库存。</p>
<p>重试导致错误的根本原因，是因为“扣减”操作是一个非幂等的操作，不能够重复执行，改成设置操作则不会有这个问题：</p>
<p><img src="1504951269740234.png" alt="1504951269740234.png"></p>
<p>如上图所示，同样是购买3单位的商品，通过设置库存操作，即使有重试容错机制，也不会得到错误的库存，设置库存是一个幂等操作。</p>
<p>在并发量很大的情况下，还会有其他的问题：</p>
<p><img src="1504951419394895.png" alt="1504951419394895.png"></p>
<p>如上图所示，两个并发的操作，查询库存，都得到了库存是5。</p>
<p>接下来用户发生了并发的购买动作（秒杀类业务特别容易出现）</p>
<p><img src="1504951444350576.png" alt="1504951444350576.png"></p>
<p>如上图所示：</p>
<ul>
<li>用户1购买了3个库存，于是库存要设置为2</li>
<li>用户2购买了2个库存，于是库存要设置为3</li>
<li>这两个设置库存的接口并发执行，库存会先变成2，再变成3，导致数据不一致（实际卖出了5件商品，但库存只扣减了2，最后一次设置库存会覆盖和掩盖前一次并发操作）</li>
</ul>
<p>其根本原因是，设置操作发生的时候，没有检查库存与查询出来的库存有没有变化，理论上：</p>
<ul>
<li>库存为5时，用户1的库存设置才能成功</li>
<li>库存为5时，用户2的库存设置才能成功</li>
</ul>
<p>实际执行的时候：</p>
<ul>
<li>库存为5，用户1的set stock 2确实应该成功</li>
<li>库存变为2了，用户2的set stock 3应该失败掉</li>
</ul>
<p>升级修改很容易，将库存设置接口，stock-service上执行的：<br>update stock set num=$y where sid=$sid<br>升级为：<br>update stock set num=$num_new where sid=$sid and num=$num_old<br>这正是大家常说的“Compare And Set”（CAS），是一种常见的降低读写锁冲突，保证数据一致性的方法。</p>
<p>总结<br>在业务复杂，数据量大，并发量大的情况下，库存扣减容易引发数据的不一致，常见的优化方案有两个：</p>
<ul>
<li>调用“设置库存”接口，能够保证数据的幂等性</li>
<li>在实现“设置库存”接口时，需要加上原有库存的比较，才允许设置成功，能解决高并发下库存扣减的一致性问题</li>
</ul>
<p>ref:<br><a href="https://www.w3cschool.cn/architectroad/architectroad-inventory.html" target="_blank" rel="external">架构 库存扣减处理</a></p>
<h2 id="基于缓存的库存扣减方案"><a href="#基于缓存的库存扣减方案" class="headerlink" title="基于缓存的库存扣减方案"></a>基于缓存的库存扣减方案</h2><p>场景基于12306购票</p>
<p>通常订票系统要处理生成订单、减扣库存、用户支付这三个基本的阶段。<br>系统要做的事情是要保证火车票订单不超卖、不少卖，每张售卖的车票都必须支付才有效，还要保证系统承受极高的并发。</p>
<p>这三个阶段的先后顺序如何分配才合理？</p>
<h3 id="下单减库存"><a href="#下单减库存" class="headerlink" title="下单减库存"></a>下单减库存</h3><p><img src="snipaste_20191107144327.jpg" alt="snipaste_20191107144327.jpg"></p>
<p>当用户并发请求到达服务端时，首先创建订单，然后扣除库存，等待用户支付。</p>
<p>这种顺序是一般人首先会想到的解决方案，这种情况下也能保证订单不会超卖，因为创建订单之后就会减库存，这是一个原子操作。</p>
<p>会产生一些问题：</p>
<ul>
<li>在极限并发情况下，任何一个内存操作的细节都至关影响性能，尤其像创建订单这种逻辑，一般都需要存储到磁盘数据库的，对数据库的压力是可想而知的。</li>
<li>如果用户存在恶意下单的情况，只下单不支付这样库存就会变少，会少卖很多订单，虽然服务端可以限制 IP 和用户的购买订单数量，这也不算是一个好方法。</li>
</ul>
<h3 id="支付减库存"><a href="#支付减库存" class="headerlink" title="支付减库存"></a>支付减库存</h3><p><img src="snipaste_20191107144529.jpg" alt="snipaste_20191107144529.jpg"></p>
<p>如果等待用户支付了订单在减库存，第一感觉就是不会少卖。但是这是并发架构的大忌，因为在极限并发情况下，用户可能会创建很多订单。</p>
<p>当库存减为零的时候很多用户发现抢到的订单支付不了了，这也就是所谓的“超卖”。也不能避免并发操作数据库磁盘 IO。</p>
<h3 id="预扣库存"><a href="#预扣库存" class="headerlink" title="预扣库存"></a>预扣库存</h3><p><img src="snipaste_20191107144614.jpg" alt="snipaste_20191107144614.jpg"></p>
<p>从上边两种方案的考虑，我们可以得出结论：只要创建订单，就要频繁操作数据库 IO。</p>
<p>那么有没有一种不需要直接操作数据库 IO 的方案呢，这就是预扣库存。先扣除了库存，保证不超卖，然后异步生成用户订单，这样响应给用户的速度就会快很多；那么怎么保证不少卖呢？用户拿到了订单，不支付怎么办？</p>
<p>我们都知道现在订单都有有效期，比如说用户五分钟内不支付，订单就失效了，订单一旦失效，就会加入新的库存，这也是现在很多网上零售企业保证商品不少卖采用的方案。</p>
<p>订单的生成是异步的，一般都会放到 MQ、Kafka 这样的即时消费队列中处理，订单量比较少的情况下，生成订单非常快，用户几乎不用排队。</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s/rFqU9isMESJPDZak5omzKA" target="_blank" rel="external">每秒100万请求，“12306”的架构到底有多牛？</a></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>架构-细聊分布式ID生成方法</title>
    <url>/2017/09/22/%E6%9E%B6%E6%9E%84-%E7%BB%86%E8%81%8A%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>分布式ID生成方法</p>
<a id="more"></a>
<h1 id="架构-细聊分布式ID生成方法"><a href="#架构-细聊分布式ID生成方法" class="headerlink" title="架构 细聊分布式ID生成方法"></a>架构 细聊分布式ID生成方法</h1><h2 id="需求缘起"><a href="#需求缘起" class="headerlink" title="需求缘起"></a>需求缘起</h2><p>几乎所有的业务系统，都有<strong>生成一个记录标识</strong>的需求，例如：</p>
<ul>
<li>消息标识：message-id</li>
<li>订单标识：order-id</li>
<li>帖子标识：tiezi-id</li>
</ul>
<p>这个记录标识往往就是数据库中的<strong>唯一主键</strong>，数据库上会建立聚集索引（cluster index），即在物理存储上以这个字段排序。</p>
<p>这个记录标识上的查询，往往又有<strong>分页或者排序</strong>的业务需求，例如：</p>
<ul>
<li>拉取最新的一页消息：select message-id/ order by time/ limit 100</li>
<li>拉取最新的一页订单：select order-id/ order by time/ limit 100</li>
<li>拉取最新的一页帖子：select tiezi-id/ order by time/ limit 100</li>
</ul>
<p>所以往往要有一个time字段，并且在time字段上建立普通索引（non-cluster index）。</p>
<p>我们都知道普通索引存储的是实际记录的指针，其访问效率会比聚集索引慢，如果记录标识在生成时能够基本按照时间有序，则可以省去这个time字段的索引查询：<br>select message-id/ (order by message-id)/limit 100</p>
<p>再次强调，能这么做的前提是，message-id的生成基本是<strong>趋势时间递增</strong>的。</p>
<p>这就引出了记录标识生成（也就是上文提到的三个XXX-id）的两大核心需求：</p>
<ul>
<li>全局唯一</li>
<li>趋势有序</li>
</ul>
<p>这也是本文要讨论的核心问题：<strong>如何高效生成趋势有序的全局唯一ID</strong>。</p>
<h2 id="常见方案"><a href="#常见方案" class="headerlink" title="常见方案"></a>常见方案</h2><h3 id="使用数据库的-auto-increment-来生成全局唯一递增ID"><a href="#使用数据库的-auto-increment-来生成全局唯一递增ID" class="headerlink" title="使用数据库的 auto_increment 来生成全局唯一递增ID"></a>使用数据库的 auto_increment 来生成全局唯一递增ID</h3><p>优点：</p>
<ul>
<li>简单，使用数据库已有的功能</li>
<li>能够保证唯一性</li>
<li>能够保证递增性</li>
<li>步长固定</li>
</ul>
<p>缺点：</p>
<ul>
<li>可用性难以保证：数据库常见架构是一主多从+读写分离，生成自增ID是写请求，主库挂了就玩不转了</li>
<li>扩展性差，性能有上限：因为写入是单点，数据库主库的写性能决定ID的生成性能上限，并且难以扩展</li>
</ul>
<p>改进方法：</p>
<ul>
<li>增加主库，避免写入单点</li>
<li>数据水平切分，保证各主库生成的ID不重复</li>
</ul>
<p><img src="1493370664903073.png" alt="1493370664903073.png"></p>
<p>如上图所述，由1个写库变成3个写库，每个写库设置<strong>不同的auto_increment初始值，以及相同的增长步长</strong>，以保证每个数据库生成的ID是不同的（上图中库0生成0,3,6,9…，库1生成1,4,7,10，库2生成2,5,8,11…）</p>
<p>改进后的架构保证了可用性，<br>但缺点是：</p>
<ul>
<li>丧失了ID生成的“绝对递增性”：先访问库0生成0,3，再访问库1生成1，可能导致在非常短的时间内，ID生成不是绝对递增的（这个问题不大，我们的目标是趋势递增，不是绝对递增）</li>
<li>数据库的写压力依然很大，每次生成ID都要访问数据库</li>
</ul>
<p>为了解决上述两个问题，引出了第二个常见的方案</p>
<h3 id="单点批量ID生成服务"><a href="#单点批量ID生成服务" class="headerlink" title="单点批量ID生成服务"></a>单点批量ID生成服务</h3><p>分布式系统之所以难，很重要的原因之一是“没有一个全局时钟，难以保证绝对的时序”，要想保证绝对的时序，还是只能使用单点服务，用本地时钟保证“绝对时序”。数据库写压力大，是因为每次生成ID都访问了数据库，可以使用<strong>批量生成的方式</strong>降低数据库写压力。</p>
<p><img src="1493370800458061.png" alt="1493370800458061.png"></p>
<p>如上图所述，数据库使用双master保证可用性，数据库中只存储当前ID的最大值，例如0。ID生成服务假设每次批量拉取6个ID，服务访问数据库，将当前ID的最大值修改为5，这样应用访问ID生成服务索要ID，ID生成服务不需要每次访问数据库，就能依次派发0,1,2,3,4,5这些ID了，当ID发完后，再将ID的最大值修改为11，就能再次派发6,7,8,9,10,11这些ID了，于是数据库的压力就降低到原来的1/6了.</p>
<p>优点：</p>
<ul>
<li>保证了ID生成的绝对递增有序</li>
<li>大大的降低了数据库的压力，ID生成可以做到每秒生成几万几十万个</li>
</ul>
<p>缺点：</p>
<ul>
<li>服务仍然是单点</li>
<li>如果服务挂了，服务重启起来之后，继续生成ID可能会不连续，中间出现空洞（服务内存是保存着0,1,2,3,4,5，数据库中max-id是5，分配到3时，服务重启了，下次会从6开始分配，4和5就成了空洞，不过这个问题也不大）</li>
<li>虽然每秒可以生成几万几十万个ID，但毕竟还是有性能上限，无法进行水平扩展</li>
</ul>
<p>改进方法：</p>
<p>单点服务的常用高可用优化方案是“备用服务”，也叫“影子服务”，所以我们能用以下方法优化上述缺点</p>
<p><img src="1493370919182595.png" alt="1493370919182595.png"></p>
<p>如上图，对外提供的服务是主服务，有一个影子服务时刻处于备用状态，当主服务挂了的时候影子服务顶上。这个切换的过程对调用方是透明的，可以自动完成，常用的技术是vip+keepalived，具体就不在这里展开</p>
<h3 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h3><p>上述方案来生成ID，虽然性能大增，但由于是单点系统，总还是存在性能上限的。同时，上述两种方案，不管是数据库还是服务来生成ID，业务方Application都需要进行一次远程调用，比较耗时。有没有一种本地生成ID的方法，即高性能，又时延低呢？</p>
<p>uuid是一种常见的方案：string ID =GenUUID();</p>
<p>优点：</p>
<ul>
<li>本地生成ID，不需要进行远程调用，时延低</li>
<li>扩展性好，基本可以认为没有性能上限</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法保证趋势递增</li>
<li>uuid过长，往往用字符串表示，作为主键建立索引查询效率低，常见优化方案为“转化为两个uint64整数存储”或者“折半存储”（折半后不能保证唯一性）</li>
</ul>
<h3 id="取当前毫秒数"><a href="#取当前毫秒数" class="headerlink" title="取当前毫秒数"></a>取当前毫秒数</h3><p>uuid是一个本地算法，生成性能高，但无法保证趋势递增，且作为字符串ID检索效率低，有没有一种能保证递增的本地算法呢？</p>
<p>取当前毫秒数是一种常见方案：uint64 ID = GenTimeMS();</p>
<p>优点：</p>
<ul>
<li>本地生成ID，不需要进行远程调用，时延低</li>
<li>生成的ID趋势递增</li>
<li>生成的ID是整数，建立索引后查询效率高</li>
</ul>
<p>缺点：</p>
<ul>
<li>如果并发量超过1000，会生成重复的ID</li>
</ul>
<p>我去，这个缺点要了命了，不能保证ID的唯一性。当然，使用微秒可以降低冲突概率，但每秒最多只能生成1000000个ID，再多的话就一定会冲突了，所以使用微秒并不从根本上解决问题。</p>
<h2 id="类snowflake算法"><a href="#类snowflake算法" class="headerlink" title="类snowflake算法"></a>类snowflake算法</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中 41bit 作为毫秒数，10bit 作为机器编号，12bit 作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是 400W 的ID，完全能满足业务的需求。</p>
<p>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>
<p>举例，假设某公司ID生成器服务的需求如下：</p>
<ul>
<li>单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W</li>
<li>有2个机房，预计未来5年机房数量小于4个</li>
<li>每个机房机器数小于100台</li>
<li>目前有5个业务线有ID生成需求，预计未来业务线数量小于10个</li>
<li>…</li>
</ul>
<p>分析过程如下：</p>
<ul>
<li>高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数</li>
<li>每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号</li>
<li>5年内机房数小于4个，预留2bit给机房标识</li>
<li>每个机房小于100台机器，预留7bit给每个机房内的服务器标识</li>
<li>业务线小于10个，预留4bit给业务线标识</li>
</ul>
<p><img src="1493371116896750.png" alt="1493371116896750.png"></p>
<p>这样设计的64bit标识，可以保证：</p>
<ol>
<li>每个业务线、每个机房、每个机器生成的ID都是不同的</li>
<li>同一个机器，每个毫秒内生成的ID都是不同的</li>
<li>同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的</li>
<li>将毫秒数放在最高位，保证生成的ID是趋势递增的</li>
</ol>
<p>缺点：</p>
<p>由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）</p>
<p>最后一个容易忽略的问题：</p>
<p>生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。</p>
<p>又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方</p>
<p>ref:<br><a href="https://www.w3cschool.cn/architectroad/architectroad-distributed-id.html" target="_blank" rel="external">架构 细聊分布式ID生成方法</a></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Proxy</title>
    <url>/2017/09/22/Java-Proxy/</url>
    <content><![CDATA[<p>Proxy,也就是“代理”了。意思就是,你不用去做,别人代替你去处理.<br>它在程序开发中起到了非常重要的作用,比如传说中的 AOP(面向切面编程),就是针对代理的一种应用。此外,在设计模式中,还有一个“代理模式”。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理:"></a>什么是代理:</h3><p>代理分为静态代理和动态代理<br>静态代理是在编译时就将接口、实现类、代理类一股脑儿全部手动完成,但如果我们需要很多的代理,每一个都这么手动的去创建实属浪费时间,而且会有大量的重复代码,此时我们就可以采用动态代理<br>动态代理可以在程序运行期间根据需要动态的创建代理类及其实例,来完成具体的功能,主要用的是JAVA的反射机制。</p>
<p>其实方法直接调用就可以完成功能,为什么还要加个代理呢？<br><strong>原因是采用代理模式可以有效的将具体的实现与调用方进行解耦,通过面向接口进行编码完全将具体的实现隐藏在内部。</strong></p>
<p>Proxy代理模式是一种结构型设计模式,主要解决的问题是:在直接访问对象时带来的问题</p>
<p>代理是一种常用的设计模式,其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息,过滤消息并转发消息,以及进行消息被委托类执行后的后续处理。</p>
<p>更通俗的说,代理解决的问题当两个类需要通信时,引入第三方代理类,将两个类的关系解耦,让我们只了解代理类即可,而且代理的出现还可以让我们完成与另一个类之间的关系的统一管理,但是切记,代理类和委托类要实现相同的接口,因为代理真正调用的还是委托类的方法。</p>
<p>按照代理的创建时期,代理类可以分为两种:</p>
<ul>
<li>静态:由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。</li>
<li>动态:在程序运行时运用反射机制动态创建而成。</li>
</ul>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>实代理的一般模式就是静态代理的实现模式:首先创建一个接口(JDK代理都是面向接口的),然后创建具体实现类来实现这个接口,在创建一个代理类同样实现这个接口,不同指出在于,具体实现类的方法中需要将接口中定义的方法的业务逻辑功能实现,而代理类中的方法只要调用具体类中的对应方法即可,这样我们在需要使用接口中的某个方法的功能时直接调用代理类的方法即可,将具体的实现类隐藏在底层。</p>
<p>第一步:定义总接口Iuser.java<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iuser</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二步:创建具体实现类UserImpl.java (被代理人)<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">implements</span> <span class="title">Iuser</span> </span>&#123;</div><div class="line">　　<span class="meta">@Override</span></div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">　　　　System.out.println(<span class="string">"我要吃"</span>+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三步:创建代理类UserProxy.java (代理人)<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">Iuser</span> </span>&#123;</div><div class="line">　　<span class="keyword">private</span> Iuser user = <span class="keyword">new</span> UserImpl();</div><div class="line">　　<span class="meta">@Override</span></div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">　　　　System.out.println(<span class="string">"静态代理前置内容"</span>);</div><div class="line">　　　　user.eat(s);</div><div class="line">　　　　System.out.println(<span class="string">"静态代理后置内容"</span>);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第四步:创建测试类ProxyTest.java<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </div><div class="line">　　　　UserProxy proxy = <span class="keyword">new</span> UserProxy();</div><div class="line">　　　　proxy.eat(<span class="string">"苹果"</span>);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">静态代理前置内容</div><div class="line">我要吃苹果</div><div class="line">静态代理后置内容</div></pre></td></tr></table></figure></p>
<p>综上的代码和输出结果可以看出,静态代理的实现方法还是很简单的。都需要实现总接口,代理人里面持有被代理人的对象。代理人可以根据情况的不同,添加一些操作。</p>
<h2 id="静态代理类优缺点"><a href="#静态代理类优缺点" class="headerlink" title="静态代理类优缺点"></a>静态代理类优缺点</h2><ul>
<li>优点 代理使客户端不需要知道实现类是什么,怎么做的,而客户端只需知道代理即可(解耦合)。</li>
<li><p>缺点:</p>
<ol>
<li>代理类和委托类实现了相同的接口,代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法,除了所有实现类需要实现这个方法外,所有代理类也需要实现此方法。增加了代码维护的复杂度。</li>
<li>代理对象只服务于一种类型的对象,如果要服务多类型的对象。势必要为每一种对象都进行代理,静态代理在程序规模稍大时就无法胜任了</li>
</ol>
</li>
</ul>
<p>举例说明:代理可以对实现类进行统一的管理,如在调用具体实现类之前,需要打印日志等信息,这样我们只需要添加一个代理类,在代理类中添加打印日志的功能,然后调用实现类,这样就避免了修改具体实现类。满足我们所说的开闭原则。但是如果想让每个实现类都添加打印日志的功能的话,就需要添加多个代理类,以及代理类中各个方法都需要添加打印日志功能(如上的代理方法中删除,修改,以及查询都需要添加上打印日志的功能)<br>即静态代理类只能为特定的接口(Service)服务。如想要为多个接口服务则需要建立很多个代理类。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理的思维模式与之前的一般模式是一样的,也是面向接口进行编码,创建代理类将具体类隐藏解耦,不同之处在于代理类的创建时机不同,动态代理需要在运行时因需实时创建。</p>
<p>第一步:定义总接口Iuser.java<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iuser</span> </span>&#123;</div><div class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二步:创建具体实现类UserImpl.java (被代理人)<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">implements</span> <span class="title">Iuser</span> </span>&#123;</div><div class="line">　　<span class="meta">@Override</span></div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">　　　　System.out.println(<span class="string">"我要吃"</span>+s);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三步:创建实现InvocationHandler接口的代理类 (代理人)<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//动态代理类只能代理接口(不支持抽象类),代理类都需要实现InvocationHandler类,实现invoke方法。该invoke方法就是调用被代理接口的所有方法时需要调用的,该invoke方法返回的值是被代理接口的一个实现类  </span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">　　<span class="keyword">private</span> Object object;<span class="comment">//用于接收具体实现类的实例对象</span></div><div class="line">　　<span class="comment">//使用带参数的构造器来传递具体实现类的对象</span></div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">　　　　<span class="keyword">this</span>.object = obj;</div><div class="line">　　&#125;</div><div class="line">　　<span class="meta">@Override</span></div><div class="line">　　<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span><span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">　　　　System.out.println(<span class="string">"前置内容"</span>);</div><div class="line">　　　　method.invoke(object, args);</div><div class="line">　　　　System.out.println(<span class="string">"后置内容"</span>);</div><div class="line">　　　　<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第四步:创建测试类ProxyTest.java<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</div><div class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">　　　　Iuser user = <span class="keyword">new</span> UserImpl();</div><div class="line">　　　　InvocationHandler h = <span class="keyword">new</span> DynamicProxy(user);</div><div class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Iuser.class&#125;, h);</div><div class="line">　　　　proxy.eat(<span class="string">"苹果"</span>);</div><div class="line">　　&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">动态代理前置内容</div><div class="line">我要吃苹果</div><div class="line">动态代理后置内容</div></pre></td></tr></table></figure></p>
<p>第五步:重构</p>
<p>要注意的是,Proxy.newProxyInstance() 方法的参数实在是让人难以忍受</p>
<ul>
<li>参数1:ClassLoader</li>
<li>参数2:该实现类的所有接口</li>
<li>参数3:动态代理对象</li>
</ul>
<p>调用完了还要来一个强制类型转换一下。</p>
<p>一定要想办法封装一下,避免再次发生到处都是 Proxy.newProxyInstance()<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</div><div class="line">            target.getClass().getClassLoader(),</div><div class="line">            target.getClass().getInterfaces(),</div><div class="line">            <span class="keyword">this</span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我在 DynamicProxy 里添加了一个 getProxy() 方法,无需传入任何参数,将刚才所说的那些参数,放在这个方法中,并且该方法返回一个泛型类型,就不会强制类型转换了。方法头上加那个 @SuppressWarnings(“unchecked”) 注解表示忽略编译时的警告(因为 Proxy.newProxyInstance() 方法返回的是一个 Object,这里我强制转换为 T 了,这是向下转型,IDE 中就会有警告,编译时也会出现提示,很烦)。</p>
<p>好了,这下子使用 DynamicProxy 就简单了吧:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> UserImpl());</div><div class="line">    Iuser proxy = dynamicProxy.getProxy();</div><div class="line">    proxy.eat(<span class="string">"苹果"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="代理没有接口的类"><a href="#代理没有接口的类" class="headerlink" title="代理没有接口的类"></a>代理没有接口的类</h2><p>用了这个 DynamicProxy 以后,我觉得它还是非常爽的,爽的地方是,接口变了,这个动态代理类不用动。而静态代理就不一样了,接口变了,实现类还要动,代理类也要动。但我也发现动态代理并不是“万灵丹”,它也有搞不定的时候,比如说,我要代理一个没有任何接口的类,它就没有勇武之地了</p>
<p>能否代理没有接口的类呢？<br>那就是 CGLib 这个类库。虽然它看起来不太起眼,但 Spring、Hibernate 这样牛逼的开源框架都用到了它。它就是一个在运行期间动态生成字节码的工具,也就是动态生成代理类了。说起来好高深,实际用起来一点都不难。我再写一个 CGLibProxy 吧:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (T) Enhancer.create(cls, <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        before();</div><div class="line">        Object result = proxy.invokeSuper(obj, args);</div><div class="line">        after();</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>需要实现 CGLib 给我们提供的 MethodInterceptor 实现类,并填充 intercept() 方法。方法中最后一个 MethodProxy 类型的参数 proxy,值得注意！CGLib 给我们提供的是方法级别的代理,也可以理解为对方法的拦截(这不就是传说中的“方法拦截器”吗？)。我们直接调用 proxy 的 invokeSuper() 方法,将被代理的对象 obj 以及方法参数 args 传入其中即可。</p>
<p>与 DynamicProxy 类似,我在 CGlibProxy 中也添加了一个泛型的 getProxy() 方法,便于我们可以快速地获取自动生成的代理对象。还是用一个 main() 方法来描述吧:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    CGLibProxy cgLibProxy = <span class="keyword">new</span> CGLibProxy();</div><div class="line">    UserImpl proxy = cgLibProxy.getProxy(UserImpl.class);</div><div class="line">    proxy.eat(<span class="string">"苹果"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>与 JDK 动态代理不同的是,这里不需要任何的接口信息,对谁都可以生成动态代理对象</p>
<p>重构:<br>不想总是去 new 这个 CGLibProxy 对象,最好 new 一次,可以使用“单例模式”<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CGLibProxy instance = <span class="keyword">new</span> CGLibProxy();</div><div class="line">    </div><div class="line">    <span class="comment">//private 的构造方法,就是为了限制外界不能再去 new 它了</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CGLibProxy</span><span class="params">()</span> </span>&#123;</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CGLibProxy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    UserImpl userImpl = CGLibProxy.getInstance().getProxy(UserImpl.class);</div><div class="line">    userImpl.eat(<span class="string">"苹果"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="动态代理的实现过程"><a href="#动态代理的实现过程" class="headerlink" title="动态代理的实现过程"></a>动态代理的实现过程</h2><ol>
<li>首先我要说的就是接口，为什么JDK的动态代理是基于接口实现的呢？<br>　　因为通过使用接口指向实现类的实例的多态实现方式，可以有效的将具体的实现与调用之间解耦，便于后期修改与维护。<br>再具体的说就是我们在代理类中创建一个私有成员变量（private修饰），使用接口来指向实现类的对象（纯种的多态体现，向上转型的体现），然后在该代理类中的方法中使用这个创建的实例来调用实现类中的相应方法来完成业务逻辑功能。<br>这么说起来，我之前说的“将具体实现类完全隐藏”就不怎么正确了，可以改成，将具体实现类的细节向调用方完全隐藏（调用方调用的是代理类中的方法，而不是实现类中的方法）。<br>　　这就是面向接口编程，利用java的多态特性，实现程序代码的解耦。</li>
<li>创建代理类的过程<br>　　如果你了解静态代理，那么你会发现动态代理的实现其实与静态代理类似，都需要创建代理类，但是不同之处也很明显，创建方式不同！<br>　　不同之处体现在静态代理我们知根知底，我们知道要对哪个接口、哪个实现类来创建代理类，所以我们在编译前就直接实现与实现类相同的接口，直接在实现的方法中调用实现类中的相应（同名）方法即可；而动态代理不同，我们不知道它什么时候创建，也不知道要创建针对哪个接口、实现类的代理类（因为它是在运行时因需实时创建的）。<br>　　虽然二者创建时机不同，创建方式也不相同，但是原理是相同的，不同之处仅仅是：静态代理可以直接编码创建，而动态代理是利用反射机制来抽象出代理类的创建过程。</li>
</ol>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol>
<li>静态代理需要实现与实现类相同的接口，而动态代理需要实现的是固定的Java提供的内置接口（一种专门提供来创建动态代理的接口）InvocationHandler接口，因为java在接口中提供了一个可以被自动调用的方法invoke，这个之后再说。</li>
<li>先看代码<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">private</span> Object object;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserProxy</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.object = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这几行代码与静态代理之中在代理类中定义的接口指向具体实现类的实例的代码异曲同工，通过这个构造器可以创建代理类的实例，创建的同时还能将具体实现类的实例与之绑定（object指的就是实现类的实例，这个实例需要在测试类中创建并作为参数来创建代理类的实例），实现了静态代理类中private Iuser user = new UserImpl();一行代码的作用相近，这里为什么不是相同，而是相近呢，主要就是因为静态代理的那句代码中包含的实现类的实例的创建，而动态代理中实现类的创建需要在测试类中完成，所以此处是相近。</p>
<ol>
<li>invoke(Object proxy, Method method, Object[] args)方法，该方法是InvocationHandler接口中定义的唯一方法，该方法在调用指定的具体方法时会自动调用。其参数为：代理实例、调用的方法、方法的参数列表<br>　　在这个方法中我们定义了几乎和静态代理相同的内容，仅仅是在方法的调用上不同，不同的原因与之前分析的一样（创建时机的不同，创建的方式的不同，即反射），Method类是反射机制中一个重要的类，用于封装方法，该类中有一个方法那就是invoke(Object object,Object…args)方法，其参数分别表示：所调用方法所属的类的对象和方法的参数列表，这里的参数列表正是从测试类中传递到代理类中的invoke方法三个参数中最后一个参数（调用方法的参数列表）中，在传递到method的invoke方法中的第二个参数中的（此处有点啰嗦）。</li>
<li>测试类中的异同<br>　　静态代理中我们测试类中直接创建代理类的对象，使用代理类的对象来调用其方法即可，若是别的接口（这里指的是别的调用方）要调用Iuser的方法，也可以使用此法<br>动态代理中要复杂的多，首先我们要将之前提到的实现类的实例创建（补充完整），然后利用这个实例作为参数，调用代理来的带参构造器来创建“代理类实例对象”，这里加引号的原因是因为它并不是真正的代理类的实例对象，而是创建真正代理类实例的一个参数，这个实现了InvocationHandler接口的类严格意义上来说并不是代理类，我们可以将其看作是创建代理类的必备中间环节，这是一个调用处理器，也就是处理方法调用的一个类，不是真正意义上的代理类，可以这么说：创建一个方法调用处理器实例。<br>　　下面才是真正的代理类实例的创建，之前创建的”代理类实例对象“仅仅是一个参数<br>　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]{Iuser.class}, h);<br>　　这里使用了动态代理所依赖的第二个重要类Proxy，此处使用了其静态方法来创建一个代理实例，其参数分别是：类加载器（可为父类的类加载器）、接口数组、方法调用处理器实例<br>　　这里同样使用了多态，使用接口指向代理类的实例，最后会用该实例来进行具体方法的调用即可。</li>
</ol>
<h2 id="动态代理优点"><a href="#动态代理优点" class="headerlink" title="动态代理优点"></a>动态代理优点</h2><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强</p>
<p>ref:<br><a href="http://www.daidingkang.cc/2017/07/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" target="_blank" rel="external">http://www.daidingkang.cc/2017/07/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</a><br><a href="https://my.oschina.net/huangyong/blog/159788" target="_blank" rel="external">https://my.oschina.net/huangyong/blog/159788</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>高性能网络IO</title>
    <url>/2017/09/22/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9CIO/</url>
    <content><![CDATA[<p>本文介绍操作系统I/O工作原理，I/O设计，基本使用，开源项目中实现高性能I/O常见方法和实现，彻底搞懂高性能I/O之道。</p>
<a id="more"></a>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>在介绍I/O原理之前，先重温几个基础概念：</p>
<h3 id="操作系统与内核"><a href="#操作系统与内核" class="headerlink" title="操作系统与内核"></a>操作系统与内核</h3><p><img src="snipaste_20191128164447.jpg" alt="snipaste_20191128164447.jpg"></p>
<p><strong>操作系统</strong>：管理计算机硬件与软件资源的系统软件内核：操作系统的核心软件，负责管理系统的进程、内存、设备驱动程序、文件和网络系统等等，为应用程序提供对计算机硬件的安全访问服务</p>
<h3 id="内核空间和用户空间"><a href="#内核空间和用户空间" class="headerlink" title="内核空间和用户空间"></a>内核空间和用户空间</h3><p>为了避免用户进程直接操作内核，保证内核安全，操作系统将内存寻址空间划分为两部分：<strong>内核空间</strong>（Kernel-space），供内核程序使用; <strong>用户空间</strong>（User-space），供用户进程使用 为了安全，内核空间和用户空间是隔离的，即使用户的程序崩溃了，内核也不受影响</p>
<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><img src="snipaste_20191128164709.jpg" alt="snipaste_20191128164709.jpg"></p>
<p>计算机中的数据是基于随着时间变换高低电压信号传输的，这些数据信号连续不断，有着固定的传输方向，类似水管中水的流动，因此抽象数据流(I/O流)的概念：<strong>指一组有顺序的、有起点和终点的字节集合，</strong></p>
<p>抽象出数据流的作用：<strong>实现程序逻辑与底层硬件解耦</strong>，通过引入数据流作为程序与硬件设备之间的抽象层，面向通用的数据流输入输出接口编程，而不是具体硬件特性，程序和底层硬件可以独立灵活替换和扩展</p>
<p><img src="snipaste_20191128164810.jpg" alt="snipaste_20191128164810.jpg"></p>
<h2 id="I-O-工作原理"><a href="#I-O-工作原理" class="headerlink" title="I/O 工作原理"></a>I/O 工作原理</h2><h3 id="磁盘I-O"><a href="#磁盘I-O" class="headerlink" title="磁盘I/O"></a>磁盘I/O</h3><p>典型I/O读写磁盘工作原理如下：</p>
<p><img src="snipaste_20191128164922.jpg" alt="snipaste_20191128164922.jpg"></p>
<p><strong>tips</strong>: DMA：全称叫直接内存存取（Direct Memory Access），是一种允许外围设备（硬件子系统）直接访问系统主内存的机制。基于 DMA 访问方式，系统主内存与硬件设备的数据传输可以省去CPU 的全程调度</p>
<p>值得注意的是：</p>
<ul>
<li>读写操作基于系统调用实现</li>
<li>读写操作经过用户缓冲区，内核缓冲区，应用进程并不能直接操作磁盘</li>
<li>应用进程读操作时需阻塞直到读取到数据</li>
</ul>
<h3 id="网络I-O"><a href="#网络I-O" class="headerlink" title="网络I/O"></a>网络I/O</h3><p>这里先以最经典的阻塞式I/O模型介绍：</p>
<p><img src="snipaste_20191128165259.jpg" alt="snipaste_20191128165259.jpg"></p>
<p><img src="snipaste_20191128165332.jpg" alt="snipaste_20191128165332.jpg"></p>
<p>tips:recvfrom，经socket接收数据的函数</p>
<p>值得注意的是：</p>
<ul>
<li>网络I/O读写操作经过用户缓冲区，Sokcet缓冲区</li>
<li>服务端线程在从调用recvfrom开始到它返回有数据报准备好这段时间是阻塞的，recvfrom返回成功后，线程开始处理数据报</li>
</ul>
<h2 id="Java-I-O设计"><a href="#Java-I-O设计" class="headerlink" title="Java I/O设计"></a>Java I/O设计</h2><h3 id="I-O分类"><a href="#I-O分类" class="headerlink" title="I/O分类"></a>I/O分类</h3><p>Java中对数据流进行具体化和实现，关于Java数据流一般关注以下几个点：</p>
<ul>
<li>流的方向从外部到程序，称为输入流；从程序到外部，称为输出流</li>
<li>流的数据单位程序以字节作为最小读写数据单元，称为字节流，以字符作为最小读写数据单元，称为字符流</li>
<li>流的功能角色</li>
</ul>
<p><img src="snipaste_20191128165647.jpg" alt="snipaste_20191128165647.jpg"></p>
<p>从/向一个特定的IO设备（如磁盘，网络）或者存储对象(如内存数组)读/写数据的流，称为<strong>节点流</strong>；</p>
<p>对一个已有流进行连接和封装，通过封装后的流来实现数据的读/写功能，称为<strong>处理流</strong>(或称为过滤流)；</p>
<h3 id="I-O操作接口"><a href="#I-O操作接口" class="headerlink" title="I/O操作接口"></a>I/O操作接口</h3><p>java.io包下有一堆I/O操作类，初学时看了容易搞不懂，其实仔细观察其中还是有规律：这些I/O操作类都是在<strong>继承4个基本抽象流的基础上，要么是节点流，要么是处理流</strong></p>
<h4 id="四个基本抽象流"><a href="#四个基本抽象流" class="headerlink" title="四个基本抽象流"></a>四个基本抽象流</h4><p>java.io包中包含了流式I/O所需要的所有类，java.io包中有四个基本抽象流，分别处理字节流和字符流：</p>
<ul>
<li>InputStream</li>
<li>OutputStream</li>
<li>Reader</li>
<li>Writer</li>
</ul>
<p><img src="snipaste_20191128165905.jpg" alt="snipaste_20191128165905.jpg"></p>
<h4 id="节点流"><a href="#节点流" class="headerlink" title="节点流"></a>节点流</h4><p><img src="snipaste_20191128165943.jpg" alt="snipaste_20191128165943.jpg"></p>
<p>节点流I/O类名由节点流类型 + 抽象流类型组成，常见节点类型有：</p>
<ul>
<li>File文件</li>
<li>Piped 进程内线程通信管道</li>
<li>ByteArray / CharArray (字节数组 / 字符数组)</li>
<li>StringBuffer / String (字符串缓冲区 / 字符串)</li>
</ul>
<p>节点流的创建通常是在构造函数传入数据源，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">FileReader reader = new FileReader(new File(&quot;file.txt&quot;));</div><div class="line">FileWriter writer = new FileWriter(new File(&quot;file.txt&quot;));</div></pre></td></tr></table></figure>
<h4 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h4><p><img src="snipaste_20191128170127.jpg" alt="snipaste_20191128170127.jpg"></p>
<p>处理流I/O类名由对已有流封装的功能 + 抽象流类型组成，常见功能有：</p>
<ul>
<li><strong>缓冲</strong>：对节点流读写的数据提供了缓冲的功能，数据可以基于缓冲批量读写，提高效率。常见有BufferedInputStream、BufferedOutputStream</li>
<li><strong>字节流转换为字符流</strong>：由InputStreamReader、OutputStreamWriter实现</li>
<li><strong>字节流与基本类型数据相互转换</strong>：这里基本数据类型数据如int、long、short，由DataInputStream、DataOutputStream实现</li>
<li><strong>字节流与对象实例相互转换</strong>：用于实现对象序列化，由ObjectInputStream、ObjectOutputStream实现</li>
</ul>
<p>处理流的应用了适配器/装饰模式，转换/扩展已有流，处理流的创建通常是在构造函数传入已有的节点流或处理流：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">FileOutputStream fileOutputStream = new FileOutputStream(&quot;file.txt&quot;);</div><div class="line">// 扩展提供缓冲写</div><div class="line">BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(fileOutputStream);</div><div class="line"> // 扩展提供提供基本数据类型写</div><div class="line">DataOutputStream out = new DataOutputStream(bufferedOutputStream);</div></pre></td></tr></table></figure>
<h3 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h3><h4 id="标准I-O存在问题"><a href="#标准I-O存在问题" class="headerlink" title="标准I/O存在问题"></a>标准I/O存在问题</h4><p>Java NIO(New I/O)是一个可以替代标准Java I/O API的IO API(从Java 1.4开始)，Java NIO提供了与标准I/O不同的I/O工作方式，目的是为了解决标准 I/O存在的以下问题：</p>
<p><strong>数据多次拷贝</strong></p>
<p>标准I/O处理，完成一次完整的数据读写，至少需要从底层硬件读到内核空间，再读到用户文件，又从用户空间写入内核空间，再写入底层硬件</p>
<p>此外，底层通过write、read等函数进行I/O系统调用时，需要传入数据所在缓冲区起始地址和长度由于JVM GC的存在，导致对象在堆中的位置往往会发生移动，移动后传入系统函数的地址参数就不是真正的缓冲区地址了</p>
<p>可能导致读写出错，为了解决上面的问题，使用标准I/O进行系统调用时，还会额外导致一次数据拷贝：把数据从JVM的堆内拷贝到堆外的连续空间内存(堆外内存)</p>
<p>所以总共经历6次数据拷贝，执行效率较低</p>
<p><img src="snipaste_20191128170510.jpg" alt="snipaste_20191128170510.jpg"></p>
<p><strong>操作阻塞</strong></p>
<p>传统的网络I/O处理中，由于请求建立连接(connect)，读取网络I/O数据(read)，发送数据(send)等操作是线程阻塞的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 等待连接</div><div class="line">Socket socket = serverSocket.accept();</div><div class="line"></div><div class="line">// 连接已建立，读取请求消息</div><div class="line">StringBuilder req = new StringBuilder();</div><div class="line">byte[] recvByteBuf = new byte[1024];</div><div class="line">int len;</div><div class="line">while ((len = socket.getInputStream().read(recvByteBuf)) != -1) &#123;</div><div class="line">	req.append(new String(recvByteBuf, 0, len, StandardCharsets.UTF_8));</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 写入返回消息</div><div class="line">socket.getOutputStream().write((&quot;server response msg&quot;.getBytes()));</div><div class="line">socket.shutdownOutput();</div></pre></td></tr></table></figure>
<p>以上面服务端程序为例，当请求连接已建立，读取请求消息，服务端调用read方法时，客户端数据可能还没就绪(例如客户端数据还在写入中或者传输中)，线程需要在read方法阻塞等待直到数据就绪</p>
<p>为了实现服务端并发响应，每个连接需要独立的线程单独处理，当并发请求量大时为了维护连接，内存、线程切换开销过大</p>
<p><img src="snipaste_20191128170636.jpg" alt="snipaste_20191128170636.jpg"></p>
<h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p><strong>Java NIO核心三大核心组件是Buffer(缓冲区)、Channel(通道)、Selector</strong></p>
<p>Buffer提供了常用于I/O操作的字节缓冲区，常见的缓存区有ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short，下面介绍主要以最常用的ByteBuffer为例，Buffer底层支持Java堆外内存和堆内内存</p>
<p><strong>堆外内存</strong>是指与堆内存相对应的，把内存对象分配在JVM堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机，相比堆内内存，I/O操作中使用堆外内存的优势在于：</p>
<ul>
<li>不用被JVM GC线回收，减少GC线程资源占有</li>
<li>在I/O系统调用时，直接操作堆外内存，可以节省一次堆外内存和堆内内存的复制</li>
</ul>
<p>ByteBuffer底层基于堆外内存的分配和释放基于malloc和free函数，对外allocateDirect方法可以申请分配堆外内存，并返回继承ByteBuffer类的DirectByteBuffer对象：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static ByteBuffer allocateDirect(int capacity) &#123;</div><div class="line">    return new DirectByteBuffer(capacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>堆外内存的回收基于DirectByteBuffer的成员变量Cleaner类，提供clean方法可以用于主动回收，Netty中大部分堆外内存通过记录定位Cleaner的存在，主动调用clean方法来回收；另外，当DirectByteBuffer对象被GC时，关联的堆外内存也会被回收</p>
<p>tips: JVM参数不建议设置-XX:+DisableExplicitGC，因为部分依赖Java NIO的框架(例如Netty)在内存异常耗尽时，会主动调用System.gc()，触发Full GC，回收DirectByteBuffer对象，作为回收堆外内存的最后保障机制，设置该参数之后会导致在该情况下堆外内存得不到清理</p>
<p>堆外内存基于基础ByteBuffer类的DirectByteBuffer类成员变量：Cleaner对象，这个Cleaner对象会在合适的时候执行unsafe.freeMemory(address)，从而回收这块堆外内存</p>
<p>Buffer可以见到理解为一组基本数据类型，存储地址连续的的数组，支持读写操作，对应读模式和写模式，通过几个变量来保存这个数据的当前位置状态：capacity、 position、 limit：</p>
<ul>
<li>capacity 缓冲区数组的总长度</li>
<li>position 下一个要操作的数据元素的位置</li>
<li>limit 缓冲区数组中不可操作的下一个元素的位置：limit &lt;= capacity</li>
</ul>
<p><img src="snipaste_20191128170941.jpg" alt="snipaste_20191128170941.jpg"></p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><p>Channel(通道)的概念可以类比I/O流对象，NIO中I/O操作主要基于Channel：从Channel进行数据读取 ：创建一个缓冲区，然后请求Channel读取数据 从Channel进行数据写入 ：创建一个缓冲区，填充数据，请求Channel写入数据</p>
<p>Channel和流非常相似，主要有以下几点区别：</p>
<ul>
<li>Channel可以读和写，而标准I/O流是单向的</li>
<li>Channel可以异步读写，标准I/O流需要线程阻塞等待直到读写操作完成</li>
<li>Channel总是基于缓冲区Buffer读写</li>
</ul>
<p>Java NIO中最重要的几个Channel的实现：</p>
<ul>
<li>FileChannel：用于文件的数据读写，基于FileChannel提供的方法能减少读写文件数据拷贝次数，后面会介绍</li>
<li>DatagramChannel：用于UDP的数据读写</li>
<li>SocketChannel：用于TCP的数据读写，代表客户端连接</li>
<li>ServerSocketChannel: 监听TCP连接请求，每个请求会创建会一个SocketChannel，一般用于服务端</li>
</ul>
<p>基于标准I/O中，我们第一步可能要像下面这样获取输入流，按字节把磁盘上的数据读取到程序中，再进行下一步操作，而在NIO编程中，需要先获取Channel，再进行读写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">FileInputStream fileInputStream = new FileInputStream(&quot;test.txt&quot;);</div><div class="line">FileChannel channel = fileInputStream.channel();</div></pre></td></tr></table></figure>
<p><strong>tips</strong>: FileChannel仅能运行在阻塞模式下，文件异步处理的 I/O 是在JDK 1.7 才被加入的 java.nio.channels.AsynchronousFileChannel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// server socket channel:</div><div class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div><div class="line">serverSocketChannel.bind(new InetSocketAddress(InetAddress.getLocalHost(), 9091));</div><div class="line"></div><div class="line">while (true) &#123;</div><div class="line">	SocketChannel socketChannel = serverSocketChannel.accept();</div><div class="line">	ByteBuffer buffer = ByteBuffer.allocateDirect(1024);</div><div class="line">	int readBytes = socketChannel.read(buffer);</div><div class="line">	if (readBytes &gt; 0) &#123;</div><div class="line">		// 从写数据到buffer翻转为从buffer读数据</div><div class="line">		buffer.flip();</div><div class="line">		byte[] bytes = new byte[buffer.remaining()];</div><div class="line">		buffer.get(bytes);</div><div class="line">		String body = new String(bytes, StandardCharsets.UTF_8);</div><div class="line">		System.out.println(&quot;server 收到：&quot; + body);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h4><p>Selector(选择器) ，它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。实现单线程管理多个Channel，也就是可以管理多个网络连接</p>
<p>Selector核心在于基于操作系统提供的I/O复用功能，单个线程可以同时监视多个连接描述符，一旦某个连接就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作，常见有select、poll、epoll等不同实现</p>
<p><img src="snipaste_20191128171347.jpg" alt="snipaste_20191128171347.jpg"></p>
<p><img src="snipaste_20191128171430.jpg" alt="snipaste_20191128171430.jpg"></p>
<p>Java NIO Selector基本工作原理如下：</p>
<ol>
<li>初始化Selector对象，服务端ServerSocketChannel对象</li>
<li>向Selector注册ServerSocketChannel的socket-accept事件</li>
<li>线程阻塞于selector.select.，当有客户端请求服务端，线程退出阻塞</li>
<li>基于selector获取所有就绪事件，此时先获取到socket-accept事件，向Selector注册客户端SocketChannel的数据就绪可读事件事件</li>
<li>线程再次阻塞于selector.select.，当有客户端连接数据就绪，可读</li>
<li>基于ByteBuffer读取客户端请求数据，然后写入响应数据，关闭channel</li>
</ol>
<p>示例如下，完整可运行代码已经上传<a href="https://github.com/caison/caison-blog-demo" target="_blank" rel="external">github</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Selector selector = Selector.open();</div><div class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</div><div class="line">serverSocketChannel.bind(new InetSocketAddress(9091));</div><div class="line">// 配置通道为非阻塞模式</div><div class="line">serverSocketChannel.configureBlocking(false);</div><div class="line">// 注册服务端的socket-accept事件</div><div class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line"></div><div class="line">while (true) &#123;</div><div class="line">	// selector.select()会一直阻塞，直到有channel相关操作就绪</div><div class="line">	selector.select();</div><div class="line">	// SelectionKey关联的channel都有就绪事件</div><div class="line">	Iterator&lt;SelectionKey&gt; keyIterator = selector.selectedKeys().iterator();</div><div class="line"></div><div class="line">	while (keyIterator.hasNext()) &#123;</div><div class="line">		SelectionKey key = keyIterator.next();</div><div class="line">		// 服务端socket-accept</div><div class="line">		if (key.isAcceptable()) &#123;</div><div class="line">			// 获取客户端连接的channel</div><div class="line">			SocketChannel clientSocketChannel = serverSocketChannel.accept();</div><div class="line">			// 设置为非阻塞模式</div><div class="line">			clientSocketChannel.configureBlocking(false);</div><div class="line">			// 注册监听该客户端channel可读事件，并为channel关联新分配的buffer</div><div class="line">			clientSocketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocateDirect(1024));</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		// channel可读</div><div class="line">		if (key.isReadable()) &#123;</div><div class="line">			SocketChannel socketChannel = (SocketChannel) key.channel();</div><div class="line">			ByteBuffer buf = (ByteBuffer) key.attachment();</div><div class="line"></div><div class="line">			int bytesRead;</div><div class="line">			StringBuilder reqMsg = new StringBuilder();</div><div class="line">			while ((bytesRead = socketChannel.read(buf)) &gt; 0) &#123;</div><div class="line">				// 从buf写模式切换为读模式</div><div class="line">				buf.flip();</div><div class="line">				int bufRemain = buf.remaining();</div><div class="line">				byte[] bytes = new byte[bufRemain];</div><div class="line">				buf.get(bytes, 0, bytesRead);</div><div class="line">				// 这里当数据包大于byteBuffer长度，有可能有粘包/拆包问题</div><div class="line">				reqMsg.append(new String(bytes, StandardCharsets.UTF_8));</div><div class="line">				buf.clear();</div><div class="line">			&#125;</div><div class="line">			System.out.println(&quot;服务端收到报文：&quot; + reqMsg.toString());</div><div class="line">			if (bytesRead == -1) &#123;</div><div class="line">				byte[] bytes = &quot;[这是服务回的报文的报文]&quot;.getBytes(StandardCharsets.UTF_8);</div><div class="line"></div><div class="line">				int length;</div><div class="line">				for (int offset = 0; offset &lt; bytes.length; offset += length) &#123;</div><div class="line">					length = Math.min(buf.capacity(), bytes.length - offset);</div><div class="line">					buf.clear();</div><div class="line">					buf.put(bytes, offset, length);</div><div class="line">					buf.flip();</div><div class="line">					socketChannel.write(buf);</div><div class="line">				&#125;</div><div class="line">				socketChannel.close();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		// Selector不会自己从已selectedKeys中移除SelectionKey实例</div><div class="line">		// 必须在处理完通道时自己移除 下次该channel变成就绪时，Selector会再次将其放入selectedKeys中</div><div class="line">		keyIterator.remove();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>tips: Java NIO基于Selector实现高性能网络I/O这块使用起来比较繁琐，使用不友好，一般业界使用基于Java NIO进行封装优化，扩展丰富功能的Netty框架来优雅实现</p>
<h2 id="高性能I-O优化"><a href="#高性能I-O优化" class="headerlink" title="高性能I/O优化"></a>高性能I/O优化</h2><p>下面结合业界热门开源项目介绍高性能I/O的优化</p>
<h3 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h3><p>零拷贝(zero copy)技术，用于在数据读写中减少甚至完全避免不必要的CPU拷贝，减少内存带宽的占用，提高执行效率，零拷贝有几种不同的实现原理，下面介绍常见开源项目中零拷贝实现</p>
<h4 id="Kafka零拷贝"><a href="#Kafka零拷贝" class="headerlink" title="Kafka零拷贝"></a>Kafka零拷贝</h4><p>Kafka基于Linux 2.1内核提供，并在2.4 内核改进的的sendfile函数 + 硬件提供的DMA Gather Copy实现零拷贝，将文件通过socket传送</p>
<p>函数通过一次系统调用完成了文件的传送，减少了原来read/write方式的模式切换。同时减少了数据的copy, sendfile的详细过程如下：</p>
<p><img src="snipaste_20191128172025.jpg" alt="snipaste_20191128172025.jpg"></p>
<p>基本流程如下：</p>
<ol>
<li>用户进程发起sendfile系统调用</li>
<li>内核基于DMA Copy将文件数据从磁盘拷贝到内核缓冲区</li>
<li>内核将内核缓冲区中的文件描述信息文件描述符，数据长度.拷贝到Socket缓冲区</li>
<li>内核基于Socket缓冲区中的文件描述信息和DMA硬件提供的Gather Copy功能将内核缓冲区数据复制到网卡</li>
<li>用户进程sendfile系统调用完成并返回</li>
</ol>
<p>相比传统的I/O方式，sendfile + DMA Gather Copy方式实现的零拷贝，数据拷贝次数从4次降为2次，系统调用从2次降为1次，用户进程上下文切换次数从4次变成2次DMA Copy，大大提高处理效率</p>
<p>Kafka底层基于java.nio包下的FileChannel的transferTo：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public abstract long transferTo(long position, long count, WritableByteChannel target)</div></pre></td></tr></table></figure></p>
<p>transferTo将FileChannel关联的文件发送到指定channel，当Comsumer消费数据，Kafka Server基于FileChannel将文件中的消息数据发送到SocketChannel</p>
<h4 id="RocketMQ零拷贝"><a href="#RocketMQ零拷贝" class="headerlink" title="RocketMQ零拷贝"></a>RocketMQ零拷贝</h4><p>RocketMQ基于mmap + write的方式实现零拷贝：mmap() 可以将内核中缓冲区的地址与用户空间的缓冲区进行映射，实现数据共享，省去了将数据从内核缓冲区拷贝到用户缓冲区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tmp_buf = mmap(file, len);</div><div class="line">write(socket, tmp_buf, len);</div></pre></td></tr></table></figure>
<p><img src="snipaste_20191128172334.jpg" alt="snipaste_20191128172334.jpg"></p>
<p>mmap + write 实现零拷贝的基本流程如下：</p>
<ol>
<li>用户进程向内核发起系统mmap调用</li>
<li>将用户进程的内核空间的读缓冲区与用户空间的缓存区进行内存地址映射</li>
<li>内核基于DMA Copy将文件数据从磁盘复制到内核缓冲区</li>
<li>用户进程mmap系统调用完成并返回</li>
<li>用户进程向内核发起write系统调用</li>
<li>内核基于CPU Copy将数据从内核缓冲区拷贝到Socket缓冲区</li>
<li>内核基于DMA Copy将数据从Socket缓冲区拷贝到网卡</li>
<li>用户进程write系统调用完成并返回</li>
</ol>
<p>RocketMQ中消息基于mmap实现存储和加载的逻辑写在org.apache.rocketmq.store.MappedFile中，内部实现基于nio提供的java.nio.MappedByteBuffer，基于FileChannel的map方法得到mmap的缓冲区：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 初始化</div><div class="line">this.fileChannel = new RandomAccessFile(this.file, &quot;rw&quot;).getChannel();</div><div class="line">this.mappedByteBuffer = this.fileChannel.map(MapMode.READ_WRITE, 0, fileSize);</div></pre></td></tr></table></figure>
<p>查询CommitLog的消息时，基于mappedByteBuffer偏移量pos，数据大小size查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public SelectMappedBufferResult selectMappedBuffer(int pos, int size) &#123;</div><div class="line">	int readPosition = getReadPosition();</div><div class="line">	// ...各种安全校验</div><div class="line">    </div><div class="line">	// 返回mappedByteBuffer视图</div><div class="line">	ByteBuffer byteBuffer = this.mappedByteBuffer.slice();</div><div class="line">	byteBuffer.position(pos);</div><div class="line">	ByteBuffer byteBufferNew = byteBuffer.slice();</div><div class="line">	byteBufferNew.limit(size);</div><div class="line">	return new SelectMappedBufferResult(this.fileFromOffset + pos, byteBufferNew, size, this);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>tips: transientStorePoolEnable机制Java NIO mmap的部分内存并不是常驻内存，可以被置换到交换内存(虚拟内存)，RocketMQ为了提高消息发送的性能，引入了内存锁定机制，即将最近需要操作的CommitLog文件映射到内存，并提供内存锁定功能，确保这些文件始终存在内存中，该机制的控制参数就是transientStorePoolEnable</p>
<p>因此，MappedFile数据保存CommitLog刷盘有2种方式：</p>
<ul>
<li>开启transientStorePoolEnable：写入内存字节缓冲区(writeBuffer)  -&gt; 从内存字节缓冲区(writeBuffer)提交(commit)到文件通道(fileChannel)  -&gt; 文件通道(fileChannel) -&gt; flush到磁盘</li>
<li>未开启transientStorePoolEnable：写入映射文件字节缓冲区(mappedByteBuffer) -&gt; 映射文件字节缓冲区(mappedByteBuffer) -&gt; flush到磁盘</li>
</ul>
<p>RocketMQ 基于 mmap+write 实现零拷贝，适用于业务级消息这种小块文件的数据持久化和传输 Kafka 基于 sendfile 这种零拷贝方式，适用于系统日志消息这种高吞吐量的大块文件的数据持久化和传输</p>
<h4 id="Netty零拷贝"><a href="#Netty零拷贝" class="headerlink" title="Netty零拷贝"></a>Netty零拷贝</h4><p>Netty 的零拷贝分为两种：</p>
<ul>
<li>基于操作系统实现的零拷贝，底层基于FileChannel的transferTo方法</li>
<li>基于Java 层操作优化，对数组缓存对象(ByteBuf )进行封装优化，通过对ByteBuf数据建立数据视图，支持ByteBuf 对象合并，切分，当底层仅保留一份数据存储，减少不必要拷贝</li>
</ul>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>Netty中对Java NIO功能封装优化之后，实现I/O多路复用代码优雅了很多：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// 创建mainReactor</div><div class="line">NioEventLoopGroup boosGroup = new NioEventLoopGroup();</div><div class="line">// 创建工作线程组</div><div class="line">NioEventLoopGroup workerGroup = new NioEventLoopGroup();</div><div class="line"></div><div class="line">final ServerBootstrap serverBootstrap = new ServerBootstrap();</div><div class="line">serverBootstrap</div><div class="line">	 // 组装NioEventLoopGroup</div><div class="line">	.group(boosGroup, workerGroup)</div><div class="line">	 // 设置channel类型为NIO类型</div><div class="line">	.channel(NioServerSocketChannel.class)</div><div class="line">	// 设置连接配置参数</div><div class="line">	.option(ChannelOption.SO_BACKLOG, 1024)</div><div class="line">	.childOption(ChannelOption.SO_KEEPALIVE, true)</div><div class="line">	.childOption(ChannelOption.TCP_NODELAY, true)</div><div class="line">	// 配置入站、出站事件handler</div><div class="line">	.childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</div><div class="line">		@Override</div><div class="line">		protected void initChannel(NioSocketChannel ch) &#123;</div><div class="line">			// 配置入站、出站事件channel</div><div class="line">			ch.pipeline().addLast(...);</div><div class="line">			ch.pipeline().addLast(...);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">// 绑定端口</div><div class="line">int port = 8080;</div><div class="line">serverBootstrap.bind(port).addListener(future -&gt; &#123;</div><div class="line">    if (future.isSuccess()) &#123;</div><div class="line">        System.out.println(new Date() + &quot;: 端口[&quot; + port + &quot;]绑定成功!&quot;);</div><div class="line">    &#125; else &#123;</div><div class="line">        System.err.println(&quot;端口[&quot; + port + &quot;]绑定失败!&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="页缓存-PageCache"><a href="#页缓存-PageCache" class="headerlink" title="页缓存(PageCache)"></a>页缓存(PageCache)</h3><p>页缓存（PageCache)是操作系统对文件的缓存，用来减少对磁盘的 I/O 操作，以页为单位的，内容就是磁盘上的物理块，页缓存能帮助<strong>程序对文件进行顺序读写的速度几乎接近于内存的读写速度</strong>，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化：</p>
<p>页缓存读取策略：当进程发起一个读操作 （比如，进程发起一个 read() 系统调用），它首先会检查需要的数据是否在页缓存中：</p>
<ul>
<li>如果在，则放弃访问磁盘，而直接从页缓存中读取</li>
<li>如果不在，则内核调度块 I/O 操作从磁盘去读取数据，并读入紧随其后的少数几个页面（不少于一个页面，通常是三个页面），然后将数据放入页缓存中</li>
</ul>
<p><img src="snipaste_20191128173051.jpg" alt="snipaste_20191128173051.jpg"></p>
<p><strong>页缓存写策略</strong>：当进程发起write系统调用写数据到文件中，先写到页缓存，然后方法返回。此时数据还没有真正的保存到文件中去，Linux 仅仅将页缓存中的这一页数据标记为“脏”，并且被加入到脏页链表中</p>
<p>然后，由flusher 回写线程周期性将脏页链表中的页写到磁盘，让磁盘中的数据和内存中保持一致，最后清理“脏”标识。在以下三种情况下，脏页会被写回磁盘:</p>
<ul>
<li>空闲内存低于一个特定阈值</li>
<li>脏页在内存中驻留超过一个特定的阈值时</li>
<li>当用户进程调用 sync() 和 fsync() 系统调用时</li>
</ul>
<p>RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能，提供了2种消息刷盘策略：</p>
<ul>
<li>同步刷盘：在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应</li>
<li>异步刷盘，能充分利用操作系统的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量<br>Kafka实现消息高性能读写也利用了页缓存，这里不再展开</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解Linux内核 —— Daniel P.Bovet》</p>
<p>Netty之Java堆外内存扫盲贴 ——江南白衣</p>
<p>Java NIO？看这一篇就够了！——朱小厮</p>
<p>RocketMQ 消息存储流程 ——  Zhao Kun(赵坤)</p>
<p>一文理解Netty模型架构 ——caison</p>
<p>ref:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI1OTY2MzMxOQ==&amp;mid=2247487075&amp;idx=1&amp;sn=890a6ea1c4b562d55ecc798312f6500b&amp;chksm=ea743adbdd03b3cd33c2cdf894ef46105649cb9d8446236a6cbf704b8c7d5a6d6f535ee454c8&amp;scene=21#wechat_redirect" target="_blank" rel="external">一文彻底搞懂高性能网络 I/O 之道</a></p>
]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Concurrent用户指南</title>
    <url>/2017/09/22/Java-Concurrent%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>本指南根据 Jakob Jenkov 最新博客翻译,请随时关注博客更新:<a href="http://tutorials.jenkov.com/java-util-concurrent/index.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-util-concurrent/index.html</a>。<br>本指南已做成中英文对照阅读版的 pdf 文档,有兴趣的朋友可以去 <a href="http://download.csdn.net/detail/defonds/8469189" target="_blank" rel="external">Java并发工具包java.util.concurrent用户指南中英文对照阅读版.pdf</a> 进行下载。</p>
<a id="more"></a>
<h2 id="1-java-util-concurrent-Java-并发工具包"><a href="#1-java-util-concurrent-Java-并发工具包" class="headerlink" title="1. java.util.concurrent - Java 并发工具包"></a>1. java.util.concurrent - Java 并发工具包</h2><p>Java 5 添加了一个新的包到 Java 平台,java.util.concurrent 包。这个包包含有一系列能够让 Java 的并发编程变得更加简单轻松的类。在这个包被添加以前,你需要自己去动手实现自己的相关工具类。</p>
<p>本文我将带你一一认识 java.util.concurrent 包里的这些类,然后你可以尝试着如何在项目中使用它们。本文中我将使用 Java 6 版本,我不确定这和 Java 5 版本里的是否有一些差异。我不会去解释关于 Java 并发的核心问题 - 其背后的原理,也就是说,如果你对那些东西感兴趣,参考《<a href="http://tutorials.jenkov.com/java-concurrency/index.html" target="_blank" rel="external">Java 并发指南</a>》。</p>
<p>半成品<br>本文很大程度上还是个 “半成品”,所以当你发现一些被漏掉的类或接口时,请耐心等待。在我空闲的时候会把它们加进来的。</p>
<h2 id="2-阻塞队列-BlockingQueue"><a href="#2-阻塞队列-BlockingQueue" class="headerlink" title="2. 阻塞队列 BlockingQueue"></a>2. 阻塞队列 BlockingQueue</h2><p>java.util.concurrent 包里的 BlockingQueue 接口表示一个线程安放入和提取实例的队列。本小节我将给你演示如何使用这个 BlockingQueue。本节不会讨论如何在 Java 中实现一个你自己的 BlockingQueue。如果你对那个感兴趣,参考《Java 并发指南》</p>
<h3 id="BlockingQueue-用法"><a href="#BlockingQueue-用法" class="headerlink" title="BlockingQueue 用法"></a>BlockingQueue 用法</h3><p>BlockingQueue 通常用于一个线程生产对象,而另外一个线程消费这些对象的场景。下图是对这个原理的阐述:<br><img src="/2017/09/22/Java-Concurrent用户指南/5401760-27d2be9af3d08a19.png" alt="5401760-27d2be9af3d08a19.png" title=""></p>
<p><strong>一个线程往里边放,另外一个线程从里边取的一个 BlockingQueue。</strong></p>
<p>一个线程将会持续生产新对象并将其插入到队列之中,直到队列达到它所能容纳的临界点。也就是说,它是有限的。如果该阻塞队列到达了其临界点,负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中,直到负责消费的线程从队列中拿走一个对象。负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话,这个消费线程将会处于阻塞之中,直到一个生产线程把一个对象丢进队列。</p>
<h3 id="BlockingQueue-的方法"><a href="#BlockingQueue-的方法" class="headerlink" title="BlockingQueue 的方法"></a>BlockingQueue 的方法</h3><p>BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话,每个方法的表现也不同。这些方法如下:</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">抛异常</th>
<th style="text-align:left">特定值</th>
<th style="text-align:left">阻塞</th>
<th style="text-align:left">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">插入</td>
<td style="text-align:left">add(o)</td>
<td style="text-align:left">offer(o)</td>
<td style="text-align:left">put(o)</td>
<td style="text-align:left">offer(o, timeout, timeunit)</td>
</tr>
<tr>
<td style="text-align:left">移除</td>
<td style="text-align:left">remove(o)</td>
<td style="text-align:left">poll(o)</td>
<td style="text-align:left">take(o)</td>
<td style="text-align:left">poll(timeout, timeunit)</td>
</tr>
<tr>
<td style="text-align:left">检查</td>
<td style="text-align:left">element(o)</td>
<td style="text-align:left">peek(o)</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>四组不同的行为方式解释:</p>
<p>抛异常:如果试图的操作无法立即执行,抛一个异常。<br>特定值:如果试图的操作无法立即执行,返回一个特定的值(常常是 true / false)。<br>阻塞:如果试图的操作无法立即执行,该方法调用将会发生阻塞,直到能够执行。<br>超时:如果试图的操作无法立即执行,该方法调用将会发生阻塞,直到能够执行,但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</p>
<p>无法向一个 BlockingQueue 中插入 null。如果你试图插入 null,BlockingQueue 将会抛出一个 NullPointerException。<br>可以访问到 BlockingQueue 中的所有元素,而不仅仅是开始和结束的元素。比如说,你将一个对象放入队列之中以等待处理,但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注:基于队列的数据结构,获取除开始或结束位置的其他对象的效率不会太高),因此你尽量不要用这一类的方法,除非你确实不得不那么做。</p>
<h3 id="BlockingQueue-的实现"><a href="#BlockingQueue-的实现" class="headerlink" title="BlockingQueue 的实现"></a>BlockingQueue 的实现</h3><p>BlockingQueue 是个接口,你需要使用它的实现之一来使用 BlockingQueue。java.util.concurrent 具有以下 BlockingQueue 接口的实现(Java 6):</p>
<ul>
<li><a href="http://blog.csdn.net/defonds/article/details/44021605#t7" target="_blank" rel="external">ArrayBlockingQueue</a></li>
<li><a href="http://blog.csdn.net/defonds/article/details/44021605#t8" target="_blank" rel="external">DelayQueue</a></li>
<li><a href="http://blog.csdn.net/defonds/article/details/44021605#t9" target="_blank" rel="external">LinkedBlockingQueue</a></li>
<li><a href="http://blog.csdn.net/defonds/article/details/44021605#t10" target="_blank" rel="external">PriorityBlockingQueue</a></li>
<li><a href="http://blog.csdn.net/defonds/article/details/44021605#t11" target="_blank" rel="external">SynchronousQueue</a></li>
</ul>
<h3 id="Java-中使用-BlockingQueue-的例子"><a href="#Java-中使用-BlockingQueue-的例子" class="headerlink" title="Java 中使用 BlockingQueue 的例子"></a>Java 中使用 BlockingQueue 的例子</h3><p>这里是一个 Java 中使用 BlockingQueue 的示例。本示例使用的是 BlockingQueue 接口的 ArrayBlockingQueue 实现。</p>
<p>首先,BlockingQueueExample 类分别在两个独立的线程中启动了一个 Producer 和 一个 Consumer。</p>
<p>Producer 向一个共享的 BlockingQueue 中注入字符串,而 Consumer 则会从中把它们拿出来。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueExample</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line"></div><div class="line">        BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1024</span>);  </div><div class="line"></div><div class="line">        Producer producer = <span class="keyword">new</span> Producer(queue);  </div><div class="line">        Consumer consumer = <span class="keyword">new</span> Consumer(queue);  </div><div class="line"></div><div class="line">        <span class="keyword">new</span> Thread(producer).start();  </div><div class="line">        <span class="keyword">new</span> Thread(consumer).start();  </div><div class="line"></div><div class="line">        Thread.sleep(<span class="number">4000</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下是 Producer 类。注意它在每次 put() 调用时是如何休眠一秒钟的。这将导致 Consumer 在等待队列中对象的时候发生阻塞。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </div><div class="line"></div><div class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.queue = queue;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            queue.put(<span class="string">"1"</span>);  </div><div class="line">            Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            queue.put(<span class="string">"2"</span>);  </div><div class="line">            Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            queue.put(<span class="string">"3"</span>);  </div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以下是 Consumer 类。它只是把对象从队列中抽取出来,然后将它们打印到 System.out。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </div><div class="line"></div><div class="line">    <span class="keyword">protected</span> BlockingQueue queue = <span class="keyword">null</span>;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue queue)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.queue = queue;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            System.out.println(queue.take());  </div><div class="line">            System.out.println(queue.take());  </div><div class="line">            System.out.println(queue.take());  </div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3-数组阻塞队列-ArrayBlockingQueue"><a href="#3-数组阻塞队列-ArrayBlockingQueue" class="headerlink" title="3. 数组阻塞队列 ArrayBlockingQueue"></a>3. 数组阻塞队列 ArrayBlockingQueue</h2><p>ArrayBlockingQueue 类实现了 BlockingQueue 接口。<br>ArrayBlockingQueue 是一个有界的阻塞队列,其内部实现是将对象放到一个数组里。有界也就意味着,它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限,但之后就无法对这个上限进行修改了(译者注:因为它是基于数组实现的,也就具有数组的特性:一旦初始化,大小就无法修改)。<br>‘ArrayBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个,而尾元素则是最短的那个。<br>以下是在使用 ArrayBlockingQueue 的时候对其初始化的一个示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">1024</span>);  </div><div class="line">queue.put(<span class="string">"1"</span>);  </div><div class="line">Object object = queue.take();</div></pre></td></tr></table></figure></p>
<p>以下是使用了 Java 泛型的一个 BlockingQueue 示例。注意其中是如何对 String 元素放入和提取的:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;String&gt;(<span class="number">1024</span>);  </div><div class="line">queue.put(<span class="string">"1"</span>);  </div><div class="line">String string = queue.take();</div></pre></td></tr></table></figure></p>
<h2 id="4-延迟队列-DelayQueue"><a href="#4-延迟队列-DelayQueue" class="headerlink" title="4. 延迟队列 DelayQueue"></a>4. 延迟队列 DelayQueue</h2><p>DelayQueue 实现了 BlockingQueue 接口。DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口,该接口定义:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&lt; </span>&#123;  </div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit timeUnit)</span></span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DelayQueue 将会在每个元素的 getDelay() 方法返回的值的时间段之后才释放掉该元素。如果返回的是 0 或者负值,延迟将被认为过期,该元素将会在 DelayQueue 的下一次 take 被调用的时候被释放掉。传递给 getDelay 方法的 getDelay 实例是一个枚举类型,它表明了将要延迟的时间段。</p>
<p>TimeUnit 枚举将会取以下值:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">DAYS  </div><div class="line">HOURS  </div><div class="line">MINUTES  </div><div class="line">SECONDS  </div><div class="line">MILLISECONDS  </div><div class="line">MICROSECONDS  </div><div class="line">NANOSECONDS</div></pre></td></tr></table></figure></p>
<p>正如你所看到的,Delayed 接口也继承了 java.lang.Comparable 接口,这也就意味着 Delayed 对象之间可以进行对比。这个可能在对 DelayQueue 队列中的元素进行排序时有用,因此它们可以根据过期时间进行有序释放。以下是使用 DelayQueue 的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueExample</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        DelayQueue queue = <span class="keyword">new</span> DelayQueue();  </div><div class="line">        Delayed element1 = <span class="keyword">new</span> DelayedElement();  </div><div class="line">        queue.put(element1);  </div><div class="line">        Delayed element2 = queue.take();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>DelayedElement 是我所创建的一个 Delayed 接口的实现类,它不在 Java.util.concurrent 包里。你需要自行创建你自己的 Delayed 接口的实现以使用 DelayQueue 类。</p>
<h2 id="5-链阻塞队列-LinkedBlockingQueue"><a href="#5-链阻塞队列-LinkedBlockingQueue" class="headerlink" title="5. 链阻塞队列 LinkedBlockingQueue"></a>5. 链阻塞队列 LinkedBlockingQueue</h2><p>LinkedBlockingQueue 类实现了 BlockingQueue 接口。</p>
<p>LinkedBlockingQueue 内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话,这一链式结构可以选择一个上限。如果没有定义上限,将使用 Integer.MAX_VALUE 作为上限。</p>
<p>LinkedBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个,而尾元素则是最短的那个。</p>
<p>以下是 LinkedBlockingQueue 的初始化和使用示例代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BlockingQueue&lt;String&gt; unbounded = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;();  </div><div class="line">BlockingQueue&lt;String&gt; bounded   = <span class="keyword">new</span> LinkedBlockingQueue&lt;String&gt;(<span class="number">1024</span>);  </div><div class="line"></div><div class="line">bounded.put(<span class="string">"Value"</span>);  </div><div class="line"></div><div class="line">String value = bounded.take();</div></pre></td></tr></table></figure></p>
<h2 id="6-具有优先级的阻塞队列-PriorityBlockingQueue"><a href="#6-具有优先级的阻塞队列-PriorityBlockingQueue" class="headerlink" title="6. 具有优先级的阻塞队列 PriorityBlockingQueue"></a>6. 具有优先级的阻塞队列 PriorityBlockingQueue</h2><p>PriorityBlockingQueue 类实现了 BlockingQueue 接口。</p>
<p>PriorityBlockingQueue 是一个无界的并发队列。它使用了和类 java.util.PriorityQueue 一样的排序规则。你无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。注意 PriorityBlockingQueue 对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。</p>
<p>同时注意,如果你从一个 PriorityBlockingQueue 获得一个 Iterator 的话,该 Iterator 并不能保证它对元素的遍历是以优先级为序的。</p>
<p>以下是使用 PriorityBlockingQueue 的示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BlockingQueue queue   = <span class="keyword">new</span> PriorityBlockingQueue();  </div><div class="line"></div><div class="line">    <span class="comment">//String implements java.lang.Comparable  </span></div><div class="line">    queue.put(<span class="string">"Value"</span>);  </div><div class="line"></div><div class="line">    String value = queue.take();</div></pre></td></tr></table></figure></p>
<ol>
<li>同步队列 SynchronousQueue</li>
</ol>
<p>SynchronousQueue 类实现了 BlockingQueue 接口。</p>
<p>SynchronousQueue 是一个特殊的队列,它的内部同时只能够容纳单个元素。如果该队列已有一元素的话,试图向队列中插入一个新元素的线程将会阻塞,直到另一个线程将该元素从队列中抽走。同样,如果该队列为空,试图向队列中抽取一个元素的线程将会阻塞,直到另一个线程向队列中插入了一条新的元素。</p>
<p>据此,把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</p>
<h2 id="8-阻塞双端队列-BlockingDeque"><a href="#8-阻塞双端队列-BlockingDeque" class="headerlink" title="8. 阻塞双端队列 BlockingDeque"></a>8. 阻塞双端队列 BlockingDeque</h2><p>java.util.concurrent 包里的 BlockingDeque 接口表示一个线程安放入和提取实例的双端队列。本小节我将给你演示如何使用 BlockingDeque。BlockingDeque 类是一个双端队列,在不能够插入元素时,它将阻塞住试图插入元素的线程；在不能够抽取元素时,它将阻塞住试图抽取的线程。deque(双端队列) 是 “Double Ended Queue” 的缩写。因此,双端队列是一个你可以从任意一端插入或者抽取元素的队列。</p>
<h3 id="BlockingDeque-的使用"><a href="#BlockingDeque-的使用" class="headerlink" title="BlockingDeque 的使用"></a>BlockingDeque 的使用</h3><p>在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 BlockingDeque。如果生产者线程需要在队列的两端都可以插入数据,消费者线程需要在队列的两端都可以移除数据,这个时候也可以使用 BlockingDeque。<br><img src="/2017/09/22/Java-Concurrent用户指南/5401760-157e5d6759d43eff.png" alt="5401760-157e5d6759d43eff.png" title=""></p>
<p><strong>一个 BlockingDeque - 线程在双端队列的两端都可以插入和提取元素。</strong></p>
<p>一个线程生产元素,并把它们插入到队列的任意一端。如果双端队列已满,插入线程将被阻塞,直到一个移除线程从该队列中移出了一个元素。如果双端队列为空,移除线程将被阻塞,直到一个插入线程向该队列插入了一个新元素。</p>
<h3 id="BlockingDeque-的方法"><a href="#BlockingDeque-的方法" class="headerlink" title="BlockingDeque 的方法"></a>BlockingDeque 的方法</h3><p>BlockingDeque 具有 4 组不同的方法用于插入、移除以及对双端队列中的元素进行检查。如果请求的操作不能得到立即执行的话,每个方法的表现也不同。这些方法如下:</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">抛异常</th>
<th style="text-align:left">特定值</th>
<th style="text-align:left">阻塞</th>
<th style="text-align:left">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">插入</td>
<td style="text-align:left">addFirst(o)</td>
<td style="text-align:left">offerFirst(o)</td>
<td style="text-align:left">putFirst(o)</td>
<td style="text-align:left">offerFirst(o, timeout, timeunit)</td>
</tr>
<tr>
<td style="text-align:left">移除</td>
<td style="text-align:left">removeFirst(o)</td>
<td style="text-align:left">pollFirst(o)</td>
<td style="text-align:left">takeFirst(o)</td>
<td style="text-align:left">pollFirst(timeout, timeunit)</td>
</tr>
<tr>
<td style="text-align:left">检查</td>
<td style="text-align:left">getFirst(o)</td>
<td style="text-align:left">peekFirst(o)</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">抛异常</th>
<th style="text-align:left">特定值</th>
<th style="text-align:left">阻塞</th>
<th style="text-align:left">超时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">插入</td>
<td style="text-align:left">addLast(o)</td>
<td style="text-align:left">offerLast(o)</td>
<td style="text-align:left">putLast(o)</td>
<td style="text-align:left">offerLast(o, timeout, timeunit)</td>
</tr>
<tr>
<td style="text-align:left">移除</td>
<td style="text-align:left">removeLast(o)</td>
<td style="text-align:left">pollLast(o)</td>
<td style="text-align:left">takeLast(o)</td>
<td style="text-align:left">pollLast(timeout, timeunit)</td>
</tr>
<tr>
<td style="text-align:left">检查</td>
<td style="text-align:left">getLast(o)</td>
<td style="text-align:left">peekLast(o)</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>四组不同的行为方式解释:<br>抛异常:如果试图的操作无法立即执行,抛一个异常。<br>特定值:如果试图的操作无法立即执行,返回一个特定的值(常常是 true / false)。<br>阻塞:如果试图的操作无法立即执行,该方法调用将会发生阻塞,直到能够执行。<br>超时:如果试图的操作无法立即执行,该方法调用将会发生阻塞,直到能够执行,但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</p>
<h3 id="BlockingDeque-继承自-BlockingQueue"><a href="#BlockingDeque-继承自-BlockingQueue" class="headerlink" title="BlockingDeque 继承自 BlockingQueue"></a>BlockingDeque 继承自 BlockingQueue</h3><p>BlockingDeque 接口继承自 BlockingQueue 接口。</p>
<p>这就意味着你可以像使用一个 BlockingQueue 那样使用 BlockingDeque。如果你这么干的话,各种插入方法将会把新元素添加到双端队列的尾端,而移除方法将会把双端队列的首端的元素移除。正如 BlockingQueue 接口的插入和移除方法一样。</p>
<h3 id="BlockingDeque-的实现"><a href="#BlockingDeque-的实现" class="headerlink" title="BlockingDeque 的实现"></a>BlockingDeque 的实现</h3><p>既然 BlockingDeque 是一个接口,那么你想要使用它的话就得使用它的众多的实现类的其中一个。java.util.concurrent 包提供了以下 BlockingDeque 接口的实现类:</p>
<p>LinkedBlockingDeque</p>
<p>以下是如何使用 BlockingDeque 方法的一个简短代码示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BlockingDeque&lt;String&gt; deque = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();  </div><div class="line"></div><div class="line">deque.addFirst(<span class="string">"1"</span>);  </div><div class="line">deque.addLast(<span class="string">"2"</span>);  </div><div class="line"></div><div class="line">String two = deque.takeLast();  </div><div class="line">String one = deque.takeFirst();</div></pre></td></tr></table></figure></p>
<h2 id="9-链阻塞双端队列-LinkedBlockingDeque"><a href="#9-链阻塞双端队列-LinkedBlockingDeque" class="headerlink" title="9. 链阻塞双端队列 LinkedBlockingDeque"></a>9. 链阻塞双端队列 LinkedBlockingDeque</h2><p>LinkedBlockingDeque 类实现了 BlockingDeque 接口。</p>
<p>deque(双端队列) 是 “Double Ended Queue” 的缩写。因此,双端队列是一个你可以从任意一端插入或者抽取元素的队列。(译者注:唐僧啊,受不了。)LinkedBlockingDeque 是一个双端队列,在它为空的时候,一个试图从中抽取数据的线程将会阻塞,无论该线程是试图从哪一端抽取数据。以下是 LinkedBlockingDeque 实例化以及使用的示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">BlockingDeque&lt;String&gt; deque = <span class="keyword">new</span> LinkedBlockingDeque&lt;String&gt;();  </div><div class="line"></div><div class="line">deque.addFirst(<span class="string">"1"</span>);  </div><div class="line">deque.addLast(<span class="string">"2"</span>);  </div><div class="line"></div><div class="line">String two = deque.takeLast();  </div><div class="line">String one = deque.takeFirst();</div></pre></td></tr></table></figure></p>
<h3 id="10-并发-Map-映射-ConcurrentMap"><a href="#10-并发-Map-映射-ConcurrentMap" class="headerlink" title="10. 并发 Map(映射) ConcurrentMap"></a>10. 并发 Map(映射) ConcurrentMap</h3><p>java.util.concurrent.ConcurrentMap</p>
<p>java.util.concurrent.ConcurrentMap 接口表示了一个能够对别人的访问(插入和提取)进行并发处理的 java.util.Map。ConcurrentMap 除了从其父接口 java.util.Map 继承来的方法之外还有一些额外的原子性方法。</p>
<h3 id="ConcurrentMap-的实现"><a href="#ConcurrentMap-的实现" class="headerlink" title="ConcurrentMap 的实现"></a>ConcurrentMap 的实现</h3><p>既然 ConcurrentMap 是个接口,你想要使用它的话就得使用它的实现类之一。java.util.concurrent 包具备 ConcurrentMap 接口的以下实现类:</p>
<ul>
<li>ConcurrentHashMap</li>
</ul>
<p>ConcurrentHashMap 和 java.util.HashTable 类很相似,但 ConcurrentHashMap 能够提供比 HashTable 更好的并发性能。在你从中读取对象的时候 ConcurrentHashMap 并不会把整个 Map 锁住。</p>
<p>此外,在你向其中写入对象的时候,ConcurrentHashMap 也不会锁住整个 Map。它的内部只是把 Map 中正在被写入的部分进行锁定。</p>
<p>另外一个不同点是,在被遍历的时候,即使是 ConcurrentHashMap 被改动,它也不会抛 ConcurrentModificationException。尽管 Iterator 的设计不是为多个线程的同时使用。更多关于 ConcurrentMap 和 ConcurrentHashMap 的细节请参考官方文档。</p>
<p>以下是如何使用 ConcurrentMap 接口的一个例子。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ConcurrentMap concurrentMap = <span class="keyword">new</span> ConcurrentHashMap();  </div><div class="line">concurrentMap.put(<span class="string">"key"</span>, <span class="string">"value"</span>);  </div><div class="line">Object value = concurrentMap.get(<span class="string">"key"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="11-并发导航映射-ConcurrentNavigableMap"><a href="#11-并发导航映射-ConcurrentNavigableMap" class="headerlink" title="11. 并发导航映射 ConcurrentNavigableMap"></a>11. 并发导航映射 ConcurrentNavigableMap</h2><p>java.util.concurrent.ConcurrentNavigableMap 是一个支持并发访问的 java.util.NavigableMap,它还能让它的子 map 具备并发访问的能力。所谓的 “子 map” 指的是诸如 headMap(),subMap(),tailMap() 之类的方法返回的 map。</p>
<p>NavigableMap 中的方法不再赘述,本小节我们来看一下 ConcurrentNavigableMap 添加的方法。</p>
<h3 id="headMap"><a href="#headMap" class="headerlink" title="headMap()"></a>headMap()</h3><p>headMap(T toKey) 方法返回一个包含了小于给定 toKey 的 key 的子 map。如果你对原始 map 里的元素做了改动,这些改动将影响到子 map 中的元素(译者注:map 集合持有的其实只是对象的引用)。以下示例演示了对 headMap() 方法的使用:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ConcurrentNavigableMap map = <span class="keyword">new</span> ConcurrentSkipListMap();  </div><div class="line"></div><div class="line">map.put(<span class="string">"1"</span>, <span class="string">"one"</span>);  </div><div class="line">map.put(<span class="string">"2"</span>, <span class="string">"two"</span>);  </div><div class="line">map.put(<span class="string">"3"</span>, <span class="string">"three"</span>);  </div><div class="line"></div><div class="line">ConcurrentNavigableMap headMap = map.headMap(<span class="string">"2"</span>);</div></pre></td></tr></table></figure></p>
<p>headMap 将指向一个只含有键 “1” 的 ConcurrentNavigableMap,因为只有这一个键小于 “2”。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。</p>
<h3 id="tailMap"><a href="#tailMap" class="headerlink" title="tailMap()"></a>tailMap()</h3><p>tailMap(T fromKey) 方法返回一个包含了不小于给定 fromKey 的 key 的子 map。</p>
<p>如果你对原始 map 里的元素做了改动,这些改动将影响到子 map 中的元素(译者注:map 集合持有的其实只是对象的引用)。</p>
<p>以下示例演示了对 tailMap() 方法的使用:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ConcurrentNavigableMap map = <span class="keyword">new</span> ConcurrentSkipListMap();  </div><div class="line"></div><div class="line">map.put(<span class="string">"1"</span>, <span class="string">"one"</span>);  </div><div class="line">map.put(<span class="string">"2"</span>, <span class="string">"two"</span>);  </div><div class="line">map.put(<span class="string">"3"</span>, <span class="string">"three"</span>);  </div><div class="line"></div><div class="line">ConcurrentNavigableMap tailMap = map.tailMap(<span class="string">"2"</span>);</div></pre></td></tr></table></figure></p>
<p>tailMap 将拥有键 “2” 和 “3”,因为它们不小于给定键 “2”。关于这个方法及其重载版本具体是怎么工作的细节请参考 Java 文档。</p>
<h3 id="subMap"><a href="#subMap" class="headerlink" title="subMap()"></a>subMap()</h3><p>subMap() 方法返回原始 map 中,键介于 from(包含) 和 to (不包含) 之间的子 map。</p>
<p>示例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ConcurrentNavigableMap map = <span class="keyword">new</span> ConcurrentSkipListMap();  </div><div class="line"></div><div class="line">map.put(<span class="string">"1"</span>, <span class="string">"one"</span>);  </div><div class="line">map.put(<span class="string">"2"</span>, <span class="string">"two"</span>);  </div><div class="line">map.put(<span class="string">"3"</span>, <span class="string">"three"</span>);  </div><div class="line"></div><div class="line">ConcurrentNavigableMap subMap = map.subMap(<span class="string">"2"</span>, <span class="string">"3"</span>);</div></pre></td></tr></table></figure></p>
<p>返回的 submap 只包含键 “2”,因为只有它满足不小于 “2”,比 “3” 小。</p>
<p>更多方法</p>
<p>ConcurrentNavigableMap 接口还有其他一些方法可供使用,<br>比如:</p>
<p>descendingKeySet()<br>descendingMap()<br>navigableKeySet()<br>关于这些方法更多信息参考官方 Java 文档。</p>
<h2 id="12-闭锁-CountDownLatch"><a href="#12-闭锁-CountDownLatch" class="headerlink" title="12. 闭锁 CountDownLatch"></a>12. 闭锁 CountDownLatch</h2><p>java.util.concurrent.CountDownLatch 是一个并发构造,它允许一个或多个线程等待一系列指定操作的完成。</p>
<p>CountDownLatch 以一个给定的数量初始化。countDown() 每被调用一次,这一数量就减一。通过调用 await() 方法之一,线程可以阻塞等待这一数量到达零。以下是一个简单示例。</p>
<p>Decrementer 三次调用 countDown() 之后,等待中的 Waiter 才会从 await() 调用中释放出来。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);  </div><div class="line"></div><div class="line">Waiter waiter = <span class="keyword">new</span> Waiter(latch);  </div><div class="line">Decrementer decrementer = <span class="keyword">new</span> Decrementer(latch);  </div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(waiter).start();  </div><div class="line"><span class="keyword">new</span> Thread(decrementer).start();  </div><div class="line"></div><div class="line">Thread.sleep(<span class="number">4000</span>);  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </div><div class="line"></div><div class="line">    CountDownLatch latch = <span class="keyword">null</span>;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Waiter</span><span class="params">(CountDownLatch latch)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.latch = latch;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            latch.await();  </div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line"></div><div class="line">        System.out.println(<span class="string">"Waiter Released"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decrementer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;  </div><div class="line"></div><div class="line">    CountDownLatch latch = <span class="keyword">null</span>;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decrementer</span><span class="params">(CountDownLatch latch)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.latch = latch;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            <span class="keyword">this</span>.latch.countDown();  </div><div class="line"></div><div class="line">            Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            <span class="keyword">this</span>.latch.countDown();  </div><div class="line"></div><div class="line">            Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            <span class="keyword">this</span>.latch.countDown();  </div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="13-栅栏-CyclicBarrier"><a href="#13-栅栏-CyclicBarrier" class="headerlink" title="13. 栅栏 CyclicBarrier"></a>13. 栅栏 CyclicBarrier</h2><p>java.util.concurrent.CyclicBarrier 类是一种同步机制,它能够对处理一些算法的线程实现同步。换句话讲,它就是一个所有线程必须等待的一个栅栏,直到所有线程都到达这里,然后所有线程才可以继续做其他事情。</p>
<p>图示如下:<br><img src="/2017/09/22/Java-Concurrent用户指南/5401760-e86f6cf9f744a024.png" alt="5401760-e86f6cf9f744a024.png" title=""></p>
<p><strong>两个线程在栅栏旁等待对方。</strong></p>
<p>通过调用 CyclicBarrier 对象的 await() 方法,两个线程可以实现互相等待。一旦 N 个线程在等待 CyclicBarrier 达成,所有线程将被释放掉去继续运行。</p>
<h3 id="创建一个-CyclicBarrier"><a href="#创建一个-CyclicBarrier" class="headerlink" title="创建一个 CyclicBarrier"></a>创建一个 CyclicBarrier</h3><p>在创建一个 CyclicBarrier 的时候你需要定义有多少线程在被释放之前等待栅栏。</p>
<p>创建 CyclicBarrier 示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<h3 id="等待一个-CyclicBarrier"><a href="#等待一个-CyclicBarrier" class="headerlink" title="等待一个 CyclicBarrier"></a>等待一个 CyclicBarrier</h3><p>以下演示了如何让一个线程等待一个 CyclicBarrier:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">barrier.await();</div></pre></td></tr></table></figure></p>
<p>当然,你也可以为等待线程设定一个超时时间。等待超过了超时时间之后,即便还没有达成 N 个线程等待 CyclicBarrier 的条件,该线程也会被释放出来。以下是定义超时时间示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">barrier.await(<span class="number">10</span>, TimeUnit.SECONDS);</div></pre></td></tr></table></figure></p>
<p>满足以下任何条件都可以让等待 CyclicBarrier 的线程释放:</p>
<ul>
<li>最后一个线程也到达 CyclicBarrier(调用 await())</li>
<li>当前线程被其他线程打断(其他线程调用了这个线程的 interrupt() 方法)</li>
<li>其他等待栅栏的线程被打断</li>
<li>其他等待栅栏的线程因超时而被释放</li>
<li>外部线程调用了栅栏的 CyclicBarrier.reset() 方法</li>
</ul>
<h3 id="CyclicBarrier-行动"><a href="#CyclicBarrier-行动" class="headerlink" title="CyclicBarrier 行动"></a>CyclicBarrier 行动</h3><p>CyclicBarrier 支持一个栅栏行动,栅栏行动是一个 Runnable 实例,一旦最后等待栅栏的线程抵达,该实例将被执行。你可以在 CyclicBarrier 的构造方法中将 Runnable 栅栏行动传给它:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Runnable      barrierAction = ... ;  </div><div class="line">CyclicBarrier barrier       = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, barrierAction);</div></pre></td></tr></table></figure></p>
<p>CyclicBarrier 示例<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Runnable barrier1Action = <span class="keyword">new</span> Runnable() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"BarrierAction 1 executed "</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line">Runnable barrier2Action = <span class="keyword">new</span> Runnable() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"BarrierAction 2 executed "</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;;  </div><div class="line"></div><div class="line">CyclicBarrier barrier1 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, barrier1Action);  </div><div class="line">CyclicBarrier barrier2 = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, barrier2Action);  </div><div class="line"></div><div class="line">CyclicBarrierRunnable barrierRunnable1 = <span class="keyword">new</span> CyclicBarrierRunnable(barrier1, barrier2);  </div><div class="line">CyclicBarrierRunnable barrierRunnable2 = <span class="keyword">new</span> CyclicBarrierRunnable(barrier1, barrier2);  </div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(barrierRunnable1).start();  </div><div class="line"><span class="keyword">new</span> Thread(barrierRunnable2).start();</div></pre></td></tr></table></figure></p>
<p>CyclicBarrierRunnable 类:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </div><div class="line"></div><div class="line">    CyclicBarrier barrier1 = <span class="keyword">null</span>;  </div><div class="line">    CyclicBarrier barrier2 = <span class="keyword">null</span>;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrierRunnable</span><span class="params">(  CyclicBarrier barrier1,  CyclicBarrier barrier2)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.barrier1 = barrier1;  </div><div class="line">        <span class="keyword">this</span>.barrier2 = barrier2;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            System.out.println(Thread.currentThread().getName() +  <span class="string">" waiting at barrier 1"</span>);  </div><div class="line">            <span class="keyword">this</span>.barrier1.await();  </div><div class="line"></div><div class="line">            Thread.sleep(<span class="number">1000</span>);  </div><div class="line">            System.out.println(Thread.currentThread().getName() +  <span class="string">" waiting at barrier 2"</span>);  </div><div class="line">            <span class="keyword">this</span>.barrier2.await();  </div><div class="line"></div><div class="line">            System.out.println(Thread.currentThread().getName() +  <span class="string">" done!"</span>);  </div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>result:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Thread-0 waiting at barrier 1</div><div class="line">Thread-1 waiting at barrier 1</div><div class="line">BarrierAction 1 executed</div><div class="line">Thread-1 waiting at barrier 2</div><div class="line">Thread-0 waiting at barrier 2</div><div class="line">BarrierAction 2 executed</div><div class="line">Thread-0 done!</div><div class="line">Thread-1 done!</div></pre></td></tr></table></figure></p>
<h2 id="14-交换机-Exchanger"><a href="#14-交换机-Exchanger" class="headerlink" title="14. 交换机 Exchanger"></a>14. 交换机 Exchanger</h2><p>java.util.concurrent.Exchanger 类表示一种两个线程可以进行互相交换对象的会和点。这种机制图示如下:<br><img src="/2017/09/22/Java-Concurrent用户指南/5401760-e6a0b41e04e51a52.png" alt="5401760-e6a0b41e04e51a52.png" title=""><br><strong>两个线程通过一个 Exchanger 交换对象。</strong><br>交换对象的动作由 Exchanger 的两个 exchange() 方法的其中一个完成。</p>
<p>以下是一个示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Exchanger exchanger = <span class="keyword">new</span> Exchanger();  </div><div class="line"></div><div class="line">ExchangerRunnable exchangerRunnable1 = <span class="keyword">new</span> ExchangerRunnable(exchanger, <span class="string">"A"</span>);  </div><div class="line">ExchangerRunnable exchangerRunnable2 = <span class="keyword">new</span> ExchangerRunnable(exchanger, <span class="string">"B"</span>);  </div><div class="line"></div><div class="line"><span class="keyword">new</span> Thread(exchangerRunnable1).start();  </div><div class="line"><span class="keyword">new</span> Thread(exchangerRunnable2).start();</div></pre></td></tr></table></figure></p>
<p>ExchangerRunnable 代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;  </div><div class="line"></div><div class="line">    Exchanger exchanger = <span class="keyword">null</span>;  </div><div class="line">    Object    object    = <span class="keyword">null</span>;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExchangerRunnable</span><span class="params">(Exchanger exchanger, Object object)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.exchanger = exchanger;  </div><div class="line">        <span class="keyword">this</span>.object = object;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">try</span> &#123;  </div><div class="line">            Object previous = <span class="keyword">this</span>.object;  </div><div class="line">            <span class="keyword">this</span>.object = <span class="keyword">this</span>.exchanger.exchange(<span class="keyword">this</span>.object);  </div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" exchanged "</span> + previous + <span class="string">" for "</span> + <span class="keyword">this</span>.object);  </div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;  </div><div class="line">            e.printStackTrace();  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上程序输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Thread-0 exchanged A for B</div><div class="line">Thread-1 exchanged B for A</div></pre></td></tr></table></figure></p>
<h2 id="15-信号量-Semaphore"><a href="#15-信号量-Semaphore" class="headerlink" title="15. 信号量 Semaphore"></a>15. 信号量 Semaphore</h2><p>java.util.concurrent.Semaphore 类是一个计数信号量。这就意味着它具备两个主要方法:</p>
<ul>
<li>acquire()</li>
<li>release()</li>
</ul>
<p>计数信号量由一个指定数量的 “许可” 初始化。每调用一次 acquire(),一个许可会被调用线程取走。每调用一次 release(),一个许可会被返还给信号量。因此,在没有任何 release() 调用时,最多有 N 个线程能够通过 acquire() 方法,N 是该信号量初始化时的许可的指定数量。这些许可只是一个简单的计数器。这里没啥奇特的地方。</p>
<p>信号量主要有<strong>两种用途</strong>:</p>
<ul>
<li>保护一个重要(代码)部分防止一次超过 N 个线程进入。</li>
<li>在两个线程之间发送信号。</li>
</ul>
<h3 id="保护重要部分"><a href="#保护重要部分" class="headerlink" title="保护重要部分"></a>保护重要部分</h3><p>如果你将信号量用于保护一个重要部分,试图进入这一部分的代码通常会首先尝试获得一个许可,然后才能进入重要部分(代码块),执行完之后,再把许可释放掉。<br>比如这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);  </div><div class="line"></div><div class="line"><span class="comment">//critical section  </span></div><div class="line">semaphore.acquire();  </div><div class="line"></div><div class="line">...  </div><div class="line"></div><div class="line">semaphore.release();</div></pre></td></tr></table></figure></p>
<h3 id="在线程之间发送信号"><a href="#在线程之间发送信号" class="headerlink" title="在线程之间发送信号"></a>在线程之间发送信号</h3><p>如果你将一个信号量用于在两个线程之间传送信号,通常你应该用一个线程调用 acquire() 方法,而另一个线程调用 release() 方法。如果没有可用的许可,acquire() 调用将会阻塞,直到一个许可被另一个线程释放出来。同理,如果无法往信号量释放更多许可时,一个 release() 调用也会阻塞。</p>
<p>通过这个可以对多个线程进行协调。比如,如果线程 1 将一个对象插入到了一个共享列表(list)之后之后调用了 acquire(),而线程 2 则在从该列表中获取一个对象之前调用了 release(),这时你其实已经创建了一个阻塞队列。信号量中可用的许可的数量也就等同于该阻塞队列能够持有的元素个数。</p>
<p>公平</p>
<p>没有办法保证线程能够公平地可从信号量中获得许可。也就是说,无法担保掉第一个调用 acquire() 的线程会是第一个获得一个许可的线程。如果第一个线程在等待一个许可时发生阻塞,而第二个线程前来索要一个许可的时候刚好有一个许可被释放出来,那么它就可能会在第一个线程之前获得许可。如果你想要强制公平,Semaphore 类有一个具有一个布尔类型的参数的构造子,通过这个参数以告知 Semaphore 是否要强制公平。强制公平会影响到并发性能,所以除非你确实需要它否则不要启用它。</p>
<p>以下是如何在公平模式创建一个 Semaphore 的示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>, <span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<h3 id="更多方法"><a href="#更多方法" class="headerlink" title="更多方法"></a>更多方法</h3><p>java.util.concurrent.Semaphore 类还有很多方法,比如:</p>
<ul>
<li>availablePermits()</li>
<li>acquireUninterruptibly()</li>
<li>drainPermits()</li>
<li>hasQueuedThreads()</li>
<li>getQueuedThreads()</li>
<li>tryAcquire()</li>
<li>等等</li>
</ul>
<p>这些方法的细节请参考 Java 文档。</p>
<h2 id="16-执行器服务-ExecutorService"><a href="#16-执行器服务-ExecutorService" class="headerlink" title="16. 执行器服务 ExecutorService"></a>16. 执行器服务 ExecutorService</h2><p>java.util.concurrent.ExecutorService 接口表示一个异步执行机制,使我们能够在后台执行任务。因此一个 ExecutorService 很类似于一个线程池。实际上,存在于 java.util.concurrent 包里的 ExecutorService 实现就是一个线程池实现。</p>
<p>以下是一个简单的 ExecutorService 例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);  </div><div class="line"></div><div class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Asynchronous task"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line"></div><div class="line">executorService.shutdown();</div></pre></td></tr></table></figure></p>
<p>首先使用 newFixedThreadPool() 工厂方法创建一个 ExecutorService。这里创建了一个十个线程执行任务的线程池。然后,将一个 Runnable 接口的匿名实现类传递给 execute() 方法。这将导致 ExecutorService 中的某个线程执行该 Runnable。</p>
<h3 id="任务委派"><a href="#任务委派" class="headerlink" title="任务委派"></a>任务委派</h3><p>下图说明了一个线程是如何将一个任务委托给一个 ExecutorService 去异步执行的:<br><img src="/2017/09/22/Java-Concurrent用户指南/5401760-38c1aa97e5108e84.png" alt="5401760-38c1aa97e5108e84.png" title=""><br>一个线程将一个任务委派给一个 ExecutorService 去异步执行。</p>
<p>一旦该线程将任务委派给 ExecutorService,该线程将继续它自己的执行,独立于该任务的执行。</p>
<h3 id="ExecutorService-实现"><a href="#ExecutorService-实现" class="headerlink" title="ExecutorService 实现"></a>ExecutorService 实现</h3><p>既然 ExecutorService 是个接口,如果你想用它的话就得去使用它的实现类之一。</p>
<p>java.util.concurrent 包提供了 ExecutorService 接口的以下实现类:</p>
<ul>
<li><a href="http://blog.csdn.net/defonds/article/details/44021605#t53" target="_blank" rel="external">ThreadPoolExecutor</a></li>
<li><a href="http://blog.csdn.net/defonds/article/details/44021605#t55" target="_blank" rel="external">ScheduledThreadPoolExecutor</a></li>
</ul>
<h3 id="创建一个-ExecutorService"><a href="#创建一个-ExecutorService" class="headerlink" title="创建一个 ExecutorService"></a>创建一个 ExecutorService</h3><p>ExecutorService 的创建依赖于你使用的具体实现。但是你也可以使用 Executors 工厂类来创建 ExecutorService 实例。</p>
<p>以下是几个创建 ExecutorService 实例的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ExecutorService executorService1 = Executors.newSingleThreadExecutor();  </div><div class="line">ExecutorService executorService2 = Executors.newFixedThreadPool(<span class="number">10</span>);  </div><div class="line">ExecutorService executorService3 = Executors.newScheduledThreadPool(<span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<h3 id="ExecutorService-使用"><a href="#ExecutorService-使用" class="headerlink" title="ExecutorService 使用"></a>ExecutorService 使用</h3><p>有几种不同的方式来将任务委托给 ExecutorService 去执行:</p>
<ul>
<li>execute(Runnable)</li>
<li>submit(Runnable)</li>
<li>submit(Callable)</li>
<li>invokeAny(…)</li>
<li>invokeAll(…)<br>接下来我们挨个看一下这些方法。</li>
</ul>
<h4 id="execute-Runnable"><a href="#execute-Runnable" class="headerlink" title="execute(Runnable)"></a>execute(Runnable)</h4><p>execute(Runnable) 方法要求一个 java.lang.Runnable 对象,然后对它进行异步执行。以下是使用 ExecutorService 执行一个 Runnable 的示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();  </div><div class="line"></div><div class="line">executorService.execute(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Asynchronous task"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line"></div><div class="line">executorService.shutdown();</div></pre></td></tr></table></figure></p>
<p>没有办法得知被执行的 Runnable 的执行结果。如果有需要的话你得使用一个 Callable(以下将做介绍)。</p>
<h4 id="submit-Runnable"><a href="#submit-Runnable" class="headerlink" title="submit(Runnable)"></a>submit(Runnable)</h4><p>submit(Runnable) 方法也要求一个 Runnable 实现类,但它返回一个 Future 对象。这个 Future 对象可以用来检查 Runnable 是否已经执行完毕。以下是 ExecutorService submit() 示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Future future = executorService.submit(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Asynchronous task"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line"></div><div class="line">future.get();  <span class="comment">//returns null if the task has finished correctly.</span></div></pre></td></tr></table></figure></p>
<h4 id="submit-Callable"><a href="#submit-Callable" class="headerlink" title="submit(Callable)"></a>submit(Callable)</h4><p>submit(Callable) 方法类似于 submit(Runnable) 方法,除了它所要求的参数类型之外。Callable 实例除了它的 call() 方法能够返回一个结果之外和一个 Runnable 很相像。Runnable.run() 不能够返回一个结果。Callable 的结果可以通过 submit(Callable) 方法返回的 Future 对象进行获取。</p>
<p>以下是一个 ExecutorService Callable 示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Future future = executorService.submit(<span class="keyword">new</span> Callable()&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Asynchronous Callable"</span>);  </div><div class="line">        <span class="keyword">return</span> <span class="string">"Callable Result"</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line"></div><div class="line">System.out.println(<span class="string">"future.get() = "</span> + future.get());</div></pre></td></tr></table></figure></p>
<p>以上代码输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Asynchronous Callable</div><div class="line">future.get() = Callable Result</div></pre></td></tr></table></figure></p>
<h4 id="invokeAny"><a href="#invokeAny" class="headerlink" title="invokeAny()"></a>invokeAny()</h4><p>invokeAny() 方法要求一系列的 Callable 或者其子接口的实例对象。调用这个方法并不会返回一个 Future,但它返回其中一个 Callable 对象的结果。无法保证返回的是哪个 Callable 的结果 - 只能表明其中一个已执行结束。</p>
<p>如果其中一个任务执行结束(或者抛了一个异常),其他 Callable 将被取消。以下是示例代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();  </div><div class="line"></div><div class="line">Set&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();  </div><div class="line"></div><div class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"Task 1"</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"Task 2"</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"Task 3"</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line"></div><div class="line">String result = executorService.invokeAny(callables);  </div><div class="line"></div><div class="line">System.out.println(<span class="string">"result = "</span> + result);  </div><div class="line"></div><div class="line">executorService.shutdown();</div></pre></td></tr></table></figure></p>
<p>上述代码将会打印出给定 Callable 集合中的一个的执行结果。我自己试着执行了它几次,结果始终在变。有时是 “Task 1”,有时是 “Task 2” 等等。</p>
<h4 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll()"></a>invokeAll()</h4><p>invokeAll() 方法将调用你在集合中传给 ExecutorService 的所有 Callable 对象。invokeAll() 返回一系列的 Future 对象,通过它们你可以获取每个 Callable 的执行结果。记住,一个任务可能会由于一个异常而结束,因此它可能没有 “成功”。</p>
<p>无法通过一个 Future 对象来告知我们是两种结束中的哪一种。以下是一个代码示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ExecutorService executorService = Executors.newSingleThreadExecutor();  </div><div class="line"></div><div class="line">Set&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();  </div><div class="line"></div><div class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"Task 1"</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"Task 2"</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line">callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="string">"Task 3"</span>;  </div><div class="line">    &#125;  </div><div class="line">&#125;);  </div><div class="line"></div><div class="line">List&lt;Future&lt;String&gt;&gt; futures = executorService.invokeAll(callables);  </div><div class="line"></div><div class="line"><span class="keyword">for</span>(Future&lt;String&gt; future : futures)&#123;  </div><div class="line">    System.out.println(<span class="string">"future.get = "</span> + future.get());  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">executorService.shutdown();</div></pre></td></tr></table></figure></p>
<h3 id="ExecutorService-关闭"><a href="#ExecutorService-关闭" class="headerlink" title="ExecutorService 关闭"></a>ExecutorService 关闭</h3><p>使用完 ExecutorService 之后你应该将其关闭,以使其中的线程不再运行。</p>
<p>比如,如果你的应用是通过一个 main() 方法启动的,之后 main 方法退出了你的应用,如果你的应用有一个活动的 ExexutorService 它将还会保持运行。ExecutorService 里的活动线程阻止了 JVM 的关闭。</p>
<p>要终止 ExecutorService 里的线程你需要调用 ExecutorService 的 shutdown() 方法。ExecutorService 并不会立即关闭,但它将不再接受新的任务,而且一旦所有线程都完成了当前任务的时候,ExecutorService 将会关闭。在 shutdown() 被调用之前所有提交给 ExecutorService 的任务都被执行。如果你想要立即关闭 ExecutorService,你可以调用 shutdownNow() 方法。这样会立即尝试停止所有执行中的任务,并忽略掉那些已提交但尚未开始处理的任务。无法担保执行任务的正确执行。可能它们被停止了,也可能已经执行结束。</p>
<h2 id="17-线程池执行者-ThreadPoolExecutor"><a href="#17-线程池执行者-ThreadPoolExecutor" class="headerlink" title="17. 线程池执行者 ThreadPoolExecutor"></a>17. 线程池执行者 ThreadPoolExecutor</h2><p>java.util.concurrent.ThreadPoolExecutor 是 ExecutorService 接口的一个实现。ThreadPoolExecutor 使用其内部池中的线程执行给定任务(Callable 或者 Runnable)。</p>
<p>ThreadPoolExecutor 包含的线程池能够包含不同数量的线程。池中线程的数量由以下变量决定:</p>
<ul>
<li>corePoolSize</li>
<li>maximumPoolSize<br>当一个任务委托给线程池时,如果池中线程数量低于 corePoolSize,一个新的线程将被创建,即使池中可能尚有空闲线程。如果内部任务队列已满,而且有至少 corePoolSize 正在运行,但是运行线程的数量低于 maximumPoolSize,一个新的线程将被创建去执行该任务。</li>
</ul>
<p>ThreadPoolExecutor 图解:<br><img src="/2017/09/22/Java-Concurrent用户指南/5401760-64bc059cafc4f417.png" alt="5401760-64bc059cafc4f417.png" title=""></p>
<h3 id="创建一个-ThreadPoolExecutor"><a href="#创建一个-ThreadPoolExecutor" class="headerlink" title="创建一个 ThreadPoolExecutor"></a>创建一个 ThreadPoolExecutor</h3><p>ThreadPoolExecutor 有若干个可用构造子。比如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span>  corePoolSize  =    <span class="number">5</span>;  </div><div class="line"><span class="keyword">int</span>  maxPoolSize   =   <span class="number">10</span>;  </div><div class="line"><span class="keyword">long</span> keepAliveTime = <span class="number">5000</span>;  </div><div class="line"></div><div class="line">ExecutorService threadPoolExecutor =  </div><div class="line">        <span class="keyword">new</span> ThreadPoolExecutor(  </div><div class="line">                corePoolSize,  </div><div class="line">                maxPoolSize,  </div><div class="line">                keepAliveTime,  </div><div class="line">                TimeUnit.MILLISECONDS,  </div><div class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()  </div><div class="line">                );</div></pre></td></tr></table></figure></p>
<p>但是,除非你确实需要显式为 ThreadPoolExecutor 定义所有参数,使用 java.util.concurrent.Executors 类中的工厂方法之一会更加方便,正如 <a href="http://blog.csdn.net/defonds/article/details/44021605#t41" target="_blank" rel="external">ExecutorService</a> 小节所述。</p>
<h2 id="18-定时执行者服务-ScheduledExecutorService"><a href="#18-定时执行者服务-ScheduledExecutorService" class="headerlink" title="18. 定时执行者服务 ScheduledExecutorService"></a>18. 定时执行者服务 ScheduledExecutorService</h2><p>java.util.concurrent.ScheduledExecutorService 是一个 ExecutorService, 它能够将任务延后执行,或者间隔固定时间多次执行。 任务由一个工作者线程异步执行,而不是由提交任务给 ScheduledExecutorService 的那个线程执行。</p>
<h3 id="ScheduledExecutorService-例子"><a href="#ScheduledExecutorService-例子" class="headerlink" title="ScheduledExecutorService 例子"></a>ScheduledExecutorService 例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ScheduledExecutorService scheduledExecutorService =  </div><div class="line">        Executors.newScheduledThreadPool(<span class="number">5</span>);  </div><div class="line"></div><div class="line">ScheduledFuture scheduledFuture =  </div><div class="line">    scheduledExecutorService.schedule(<span class="keyword">new</span> Callable() &#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">            System.out.println(<span class="string">"Executed!"</span>);  </div><div class="line">            <span class="keyword">return</span> <span class="string">"Called!"</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;,  </div><div class="line">    <span class="number">5</span>,  </div><div class="line">    TimeUnit.SECONDS);</div></pre></td></tr></table></figure>
<p>首先一个内置 5 个线程的 ScheduledExecutorService 被创建。之后一个 Callable 接口的匿名类示例被创建然后传递给 schedule() 方法。后边的俩参数定义了 Callable 将在 5 秒钟之后被执行。</p>
<h3 id="ScheduledExecutorService-实现"><a href="#ScheduledExecutorService-实现" class="headerlink" title="ScheduledExecutorService 实现"></a>ScheduledExecutorService 实现</h3><p>既然 ScheduledExecutorService 是一个接口,你要用它的话就得使用 java.util.concurrent 包里对它的某个实现类。ScheduledExecutorService 具有以下实现类:ScheduledThreadPoolExecutor</p>
<p>创建一个 ScheduledExecutorService<br>如何创建一个 ScheduledExecutorService 取决于你采用的它的实现类。但是你也可以使用 Executors 工厂类来创建一个 ScheduledExecutorService 实例。比如:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</div></pre></td></tr></table></figure></p>
<h3 id="ScheduledExecutorService-使用"><a href="#ScheduledExecutorService-使用" class="headerlink" title="ScheduledExecutorService 使用"></a>ScheduledExecutorService 使用</h3><p>一旦你创建了一个 ScheduledExecutorService,你可以通过调用它的以下方法:</p>
<ul>
<li>schedule (Callable task, long delay, TimeUnit timeunit)</li>
<li>schedule (Runnable task, long delay, TimeUnit timeunit)</li>
<li>scheduleAtFixedRate (Runnable, long initialDelay, long period, TimeUnit timeunit)</li>
<li>scheduleWithFixedDelay (Runnable, long initialDelay, long period, TimeUnit timeunit)<br>下面我们就简单看一下这些方法。</li>
</ul>
<h4 id="schedule-Callable-task-long-delay-TimeUnit-timeunit"><a href="#schedule-Callable-task-long-delay-TimeUnit-timeunit" class="headerlink" title="schedule (Callable task, long delay, TimeUnit timeunit)"></a>schedule (Callable task, long delay, TimeUnit timeunit)</h4><p>这个方法计划指定的 Callable 在给定的延迟之后执行。这个方法返回一个 ScheduledFuture,通过它你可以在它被执行之前对它进行取消,或者在它执行之后获取结果。以下是一个示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">5</span>);  </div><div class="line"></div><div class="line">ScheduledFuture scheduledFuture =  </div><div class="line">    scheduledExecutorService.schedule(<span class="keyword">new</span> Callable() &#123;  </div><div class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">            System.out.println(<span class="string">"Executed!"</span>);  </div><div class="line">            <span class="keyword">return</span> <span class="string">"Called!"</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;,  </div><div class="line">    <span class="number">5</span>,  </div><div class="line">    TimeUnit.SECONDS);  </div><div class="line"></div><div class="line">System.out.println(<span class="string">"result = "</span> + scheduledFuture.get());  </div><div class="line"></div><div class="line">scheduledExecutorService.shutdown();</div></pre></td></tr></table></figure></p>
<p>示例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Executed!</div><div class="line">result = Called!</div></pre></td></tr></table></figure></p>
<h4 id="schedule-Runnable-task-long-delay-TimeUnit-timeunit"><a href="#schedule-Runnable-task-long-delay-TimeUnit-timeunit" class="headerlink" title="schedule (Runnable task, long delay, TimeUnit timeunit)"></a>schedule (Runnable task, long delay, TimeUnit timeunit)</h4><p>除了 Runnable 无法返回一个结果之外,这一方法工作起来就像以一个 Callable 作为一个参数的那个版本的方法一样,因此 ScheduledFuture.get() 在任务执行结束之后返回 null。</p>
<h4 id="scheduleAtFixedRate-Runnable-long-initialDelay-long-period-TimeUnit-timeunit"><a href="#scheduleAtFixedRate-Runnable-long-initialDelay-long-period-TimeUnit-timeunit" class="headerlink" title="scheduleAtFixedRate (Runnable, long initialDelay, long period, TimeUnit timeunit)"></a>scheduleAtFixedRate (Runnable, long initialDelay, long period, TimeUnit timeunit)</h4><p>这一方法规划一个任务将被定期执行。该任务将会在首个 initialDelay 之后得到执行,然后每个 period 时间之后重复执行。如果给定任务的执行抛出了异常,该任务将不再执行。如果没有任何异常的话,这个任务将会持续循环执行到 ScheduledExecutorService 被关闭。如果一个任务占用了比计划的时间间隔更长的时候,下一次执行将在当前执行结束执行才开始。计划任务在同一时间不会有多个线程同时执行。</p>
<h4 id="scheduleWithFixedDelay-Runnable-long-initialDelay-long-period-TimeUnit-timeunit"><a href="#scheduleWithFixedDelay-Runnable-long-initialDelay-long-period-TimeUnit-timeunit" class="headerlink" title="scheduleWithFixedDelay (Runnable, long initialDelay, long period, TimeUnit timeunit)"></a>scheduleWithFixedDelay (Runnable, long initialDelay, long period, TimeUnit timeunit)</h4><p>除了 period 有不同的解释之外这个方法和 scheduleAtFixedRate() 非常像。</p>
<p>scheduleAtFixedRate() 方法中,period 被解释为前一个执行的开始和下一个执行的开始之间的间隔时间。而在本方法中,period 则被解释为前一个执行的结束和下一个执行的结束之间的间隔。因此这个延迟是执行结束之间的间隔,而不是执行开始之间的间隔。</p>
<h3 id="ScheduledExecutorService-关闭"><a href="#ScheduledExecutorService-关闭" class="headerlink" title="ScheduledExecutorService 关闭"></a>ScheduledExecutorService 关闭</h3><p>正如 ExecutorService,在你使用结束之后你需要把 ScheduledExecutorService 关闭掉。否则他将导致 JVM 继续运行,即使所有其他线程已经全被关闭。</p>
<p>你可以使用从 ExecutorService 接口继承来的 shutdown() 或 shutdownNow() 方法将 ScheduledExecutorService 关闭。参见 ExecutorService 关闭部分以获取更多信息。</p>
<h2 id="19-使用-ForkJoinPool-进行分叉和合并"><a href="#19-使用-ForkJoinPool-进行分叉和合并" class="headerlink" title="19. 使用 ForkJoinPool 进行分叉和合并"></a>19. 使用 ForkJoinPool 进行分叉和合并</h2><p>ForkJoinPool 在 Java 7 中被引入。它和 ExecutorService 很相似,除了一点不同。ForkJoinPool 让我们可以很方便地把任务分裂成几个更小的任务,这些分裂出来的任务也将会提交给 ForkJoinPool。任务可以继续分割成更小的子任务,只要它还能分割。可能听起来有些抽象,因此本节中我们将会解释 ForkJoinPool 是如何工作的,还有任务分割是如何进行的。</p>
<h3 id="分叉和合并解释"><a href="#分叉和合并解释" class="headerlink" title="分叉和合并解释"></a>分叉和合并解释</h3><p>在我们开始看 ForkJoinPool 之前我们先来简要解释一下分叉和合并的原理。<br>分叉和合并原理包含两个递归进行的步骤。两个步骤分别是分叉步骤和合并步骤。</p>
<h4 id="分叉"><a href="#分叉" class="headerlink" title="分叉"></a>分叉</h4><p>一个使用了分叉和合并原理的任务可以将自己分叉(分割)为更小的子任务,这些子任务可以被并发执行。如下图所示:<br><img src="/2017/09/22/Java-Concurrent用户指南/5401760-e4d6b0523bfc5936.png" alt="5401760-e4d6b0523bfc5936.png" title=""><br>通过把自己分割成多个子任务,每个子任务可以由不同的 CPU 并行执行,或者被同一个 CPU 上的不同线程执行。只有当给的任务过大,把它分割成几个子任务才有意义。把任务分割成子任务有一定开销,因此对于小型任务,这个分割的消耗可能比每个子任务并发执行的消耗还要大。</p>
<p>什么时候把一个任务分割成子任务是有意义的,这个界限也称作一个阀值。这要看每个任务对有意义阀值的决定。很大程度上取决于它要做的工作的种类。</p>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><p>当一个任务将自己分割成若干子任务之后,该任务将进入等待所有子任务的结束之中。一旦子任务执行结束,该任务可以把所有结果合并到同一个结果。图示如下:<br><img src="/2017/09/22/Java-Concurrent用户指南/5401760-d3f822dbc4045bb9.png" alt="5401760-d3f822dbc4045bb9.png" title=""><br>当然,并非所有类型的任务都会返回一个结果。如果这个任务并不返回一个结果,它只需等待所有子任务执行完毕。也就不需要结果的合并啦。</p>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><p>ForkJoinPool 是一个特殊的线程池,它的设计是为了更好的配合 分叉-和-合并 任务分割的工作。ForkJoinPool 也在 java.util.concurrent 包中,其完整类名为 java.util.concurrent.ForkJoinPool。</p>
<h4 id="创建一个-ForkJoinPool"><a href="#创建一个-ForkJoinPool" class="headerlink" title="创建一个 ForkJoinPool"></a>创建一个 ForkJoinPool</h4><p>你可以通过其构造子创建一个 ForkJoinPool。作为传递给 ForkJoinPool 构造子的一个参数,你可以定义你期望的并行级别。并行级别表示你想要传递给 ForkJoinPool 的任务所需的线程或 CPU 数量。以下是一个 ForkJoinPool 示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool(<span class="number">4</span>);</div></pre></td></tr></table></figure></p>
<p>这个示例创建了一个并行级别为 4 的 ForkJoinPool。</p>
<h4 id="提交任务到-ForkJoinPool"><a href="#提交任务到-ForkJoinPool" class="headerlink" title="提交任务到 ForkJoinPool"></a>提交任务到 ForkJoinPool</h4><p>就像提交任务到 ExecutorService 那样,把任务提交到 ForkJoinPool。你可以提交两种类型的任务。一种是没有任何返回值的(一个 “行动”),另一种是有返回值的(一个”任务”)。这两种类型分别由 RecursiveAction 和 RecursiveTask 表示。接下来介绍如何使用这两种类型的任务,以及如何对它们进行提交。</p>
<p><strong>RecursiveAction</strong></p>
<p>RecursiveAction 是一种没有任何返回值的任务。它只是做一些工作,比如写数据到磁盘,然后就退出了。一个 RecursiveAction 可以把自己的工作分割成更小的几块,这样它们可以由独立的线程或者 CPU 执行。你可以通过继承来实现一个 RecursiveAction。示例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;  </div><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveAction;  </div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRecursiveAction</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;  </div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workLoad = <span class="number">0</span>;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecursiveAction</span><span class="params">(<span class="keyword">long</span> workLoad)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.workLoad = workLoad;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="comment">//if work is above threshold, break tasks up into smaller tasks  </span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.workLoad &gt; <span class="number">16</span>) &#123;  </div><div class="line">            System.out.println(<span class="string">"Splitting workLoad : "</span> + <span class="keyword">this</span>.workLoad);  </div><div class="line">            List&lt;MyRecursiveAction&gt; subtasks = <span class="keyword">new</span> ArrayList&lt;MyRecursiveAction&gt;();  </div><div class="line">            subtasks.addAll(createSubtasks());  </div><div class="line">            <span class="keyword">for</span>(RecursiveAction subtask : subtasks)&#123;  </div><div class="line">                subtask.fork();  </div><div class="line">            &#125;  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            System.out.println(<span class="string">"Doing workLoad myself: "</span> + <span class="keyword">this</span>.workLoad);  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> List&lt;MyRecursiveAction&gt; <span class="title">createSubtasks</span><span class="params">()</span> </span>&#123;  </div><div class="line">        List&lt;MyRecursiveAction&gt; subtasks = <span class="keyword">new</span> ArrayList&lt;MyRecursiveAction&gt;();  </div><div class="line"></div><div class="line">        MyRecursiveAction subtask1 = <span class="keyword">new</span> MyRecursiveAction(<span class="keyword">this</span>.workLoad / <span class="number">2</span>);  </div><div class="line">        MyRecursiveAction subtask2 = <span class="keyword">new</span> MyRecursiveAction(<span class="keyword">this</span>.workLoad / <span class="number">2</span>);  </div><div class="line"></div><div class="line">        subtasks.add(subtask1);  </div><div class="line">        subtasks.add(subtask2);  </div><div class="line"></div><div class="line">        <span class="keyword">return</span> subtasks;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例子很简单。MyRecursiveAction 将一个虚构的 workLoad 作为参数传给自己的构造子。如果 workLoad 高于一个特定阀值,该工作将被分割为几个子工作,子工作继续分割。如果 workLoad 低于特定阀值,该工作将由 MyRecursiveAction 自己执行。你可以这样规划一个 MyRecursiveAction 的执行:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">MyRecursiveAction myRecursiveAction = <span class="keyword">new</span> MyRecursiveAction(<span class="number">24</span>);  </div><div class="line">forkJoinPool.invoke(myRecursiveAction);</div></pre></td></tr></table></figure></p>
<p><strong>RecursiveTask</strong></p>
<p>RecursiveTask 是一种会返回结果的任务。它可以将自己的工作分割为若干更小任务,并将这些子任务的执行结果合并到一个集体结果。可以有几个水平的分割和合并。以下是一个 RecursiveTask 示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;  </div><div class="line"><span class="keyword">import</span> java.util.List;  </div><div class="line"><span class="keyword">import</span> java.util.concurrent.RecursiveTask;  </div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;  </div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> workLoad = <span class="number">0</span>;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRecursiveTask</span><span class="params">(<span class="keyword">long</span> workLoad)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.workLoad = workLoad;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;  </div><div class="line"></div><div class="line">        <span class="comment">//if work is above threshold, break tasks up into smaller tasks  </span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.workLoad &gt; <span class="number">16</span>) &#123;  </div><div class="line">            System.out.println(<span class="string">"Splitting workLoad : "</span> + <span class="keyword">this</span>.workLoad);  </div><div class="line">            List&lt;MyRecursiveTask&gt; subtasks = <span class="keyword">new</span> ArrayList&lt;MyRecursiveTask&gt;();  </div><div class="line">            subtasks.addAll(createSubtasks());  </div><div class="line">            <span class="keyword">for</span>(MyRecursiveTask subtask : subtasks)&#123;  </div><div class="line">                subtask.fork();  </div><div class="line">            &#125;  </div><div class="line"></div><div class="line">            <span class="keyword">long</span> result = <span class="number">0</span>;  </div><div class="line">            <span class="keyword">for</span>(MyRecursiveTask subtask : subtasks) &#123;  </div><div class="line">                result += subtask.join();  </div><div class="line">            &#125;  </div><div class="line">            <span class="keyword">return</span> result;  </div><div class="line">        &#125; <span class="keyword">else</span> &#123;  </div><div class="line">            System.out.println(<span class="string">"Doing workLoad myself: "</span> + <span class="keyword">this</span>.workLoad);  </div><div class="line">            <span class="keyword">return</span> workLoad * <span class="number">3</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> List&lt;MyRecursiveTask&gt; <span class="title">createSubtasks</span><span class="params">()</span> </span>&#123;  </div><div class="line">        List&lt;MyRecursiveTask&gt; subtasks = <span class="keyword">new</span> ArrayList&lt;MyRecursiveTask&gt;();  </div><div class="line"></div><div class="line">        MyRecursiveTask subtask1 = <span class="keyword">new</span> MyRecursiveTask(<span class="keyword">this</span>.workLoad / <span class="number">2</span>);  </div><div class="line">        MyRecursiveTask subtask2 = <span class="keyword">new</span> MyRecursiveTask(<span class="keyword">this</span>.workLoad / <span class="number">2</span>);  </div><div class="line"></div><div class="line">        subtasks.add(subtask1);  </div><div class="line">        subtasks.add(subtask2);  </div><div class="line"></div><div class="line">        <span class="keyword">return</span> subtasks;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了有一个结果返回之外,这个示例和 RecursiveAction 的例子很像。MyRecursiveTask 类继承自 RecursiveTask<long>,这也就意味着它将返回一个 Long 类型的结果。</long></p>
<p>MyRecursiveTask 示例也会将工作分割为子任务,并通过 fork() 方法对这些子任务计划执行。</p>
<p>此外,本示例还通过调用每个子任务的 join() 方法收集它们返回的结果。子任务的结果随后被合并到一个更大的结果,并最终将其返回。对于不同级别的递归,这种子任务的结果合并可能会发生递归。</p>
<p>你可以这样规划一个 RecursiveTask:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">MyRecursiveTask myRecursiveTask = <span class="keyword">new</span> MyRecursiveTask(<span class="number">128</span>);  </div><div class="line"><span class="keyword">long</span> mergedResult = forkJoinPool.invoke(myRecursiveTask);  </div><div class="line">System.out.println(<span class="string">"mergedResult = "</span> + mergedResult);</div></pre></td></tr></table></figure></p>
<p>注意是如何通过 ForkJoinPool.invoke() 方法的调用来获取最终执行结果的。</p>
<h3 id="ForkJoinPool-评论"><a href="#ForkJoinPool-评论" class="headerlink" title="ForkJoinPool 评论"></a>ForkJoinPool 评论</h3><p>貌似并非每个人都对 Java 7 里的 ForkJoinPool 满意:《<a href="http://coopsoft.com/ar/CalamityArticle.html" target="_blank" rel="external">一个 Java 分叉-合并 带来的灾祸</a>》。</p>
<p>在你计划在自己的项目里使用 ForkJoinPool 之前最好读一下该篇文章。</p>
<h2 id="20-锁-Lock"><a href="#20-锁-Lock" class="headerlink" title="20. 锁 Lock"></a>20. 锁 Lock</h2><p>java.util.concurrent.locks.Lock 是一个类似于 synchronized 块的线程同步机制。但是 Lock 比 synchronized 块更加灵活、精细。顺便说一下,在《<a href="http://tutorials.jenkov.com/java-concurrency/index.html" target="_blank" rel="external">Java 并发指南</a>》中我对如何实现你自己的锁进行了描述。</p>
<h3 id="Java-Lock-例子"><a href="#Java-Lock-例子" class="headerlink" title="Java Lock 例子"></a>Java Lock 例子</h3><p>既然 Lock 是一个接口,在你的程序里需要使用它的实现类之一来使用它。以下是一个简单示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();  </div><div class="line">lock.lock();  </div><div class="line"><span class="comment">//critical section  </span></div><div class="line">lock.unlock();</div></pre></td></tr></table></figure></p>
<p>首先创建了一个 Lock 对象。之后调用了它的 lock() 方法。这时候这个 lock 实例就被锁住啦。任何其他再过来调用 lock() 方法的线程将会被阻塞住,直到锁定 lock 实例的线程调用了 unlock() 方法。最后 unlock() 被调用了,lock 对象解锁了,其他线程可以对它进行锁定了。</p>
<h3 id="Java-Lock-实现"><a href="#Java-Lock-实现" class="headerlink" title="Java Lock 实现"></a>Java Lock 实现</h3><p>java.util.concurrent.locks 包提供了以下对 Lock 接口的实现类:</p>
<ul>
<li>ReentrantLock</li>
</ul>
<h3 id="Lock-和-synchronized-代码块的主要不同点"><a href="#Lock-和-synchronized-代码块的主要不同点" class="headerlink" title="Lock 和 synchronized 代码块的主要不同点"></a>Lock 和 synchronized 代码块的主要不同点</h3><p>一个 Lock 对象和一个 synchronized 代码块之间的主要不同点是:</p>
<ul>
<li>synchronized 代码块不能够保证进入访问等待的线程的先后顺序。</li>
<li>你不能够传递任何参数给一个 synchronized 代码块的入口。因此,对于 synchronized 代码块的访问等待设置超时时间是不可能的事情。</li>
<li>synchronized 块必须被完整地包含在单个方法里。而一个 Lock 对象可以把它的 lock() 和 unlock() 方法的调用放在不同的方法里。</li>
</ul>
<h3 id="Lock-的方法"><a href="#Lock-的方法" class="headerlink" title="Lock 的方法"></a>Lock 的方法</h3><p>Lock 接口具有以下主要方法:</p>
<ul>
<li>lock()</li>
<li>lockInterruptibly()</li>
<li>tryLock()</li>
<li>tryLock(long timeout, TimeUnit timeUnit)</li>
<li>unlock()</li>
</ul>
<p>lock() 将 Lock 实例锁定。如果该 Lock 实例已被锁定,调用 lock() 方法的线程将会阻塞,直到 Lock 实例解锁。</p>
<p>lockInterruptibly() 方法将会被调用线程锁定,除非该线程被打断。此外,如果一个线程在通过这个方法来锁定 Lock 对象时进入阻塞等待,而它被打断了的话,该线程将会退出这个方法调用。</p>
<p>tryLock() 方法试图立即锁定 Lock 实例。如果锁定成功,它将返回 true,如果 Lock 实例已被锁定该方法返回 false。这一方法永不阻塞。tryLock(long timeout, TimeUnit timeUnit) 的工作类似于 tryLock() 方法,除了它在放弃锁定 Lock 之前等待一个给定的超时时间之外。</p>
<p>unlock() 方法对 Lock 实例解锁。一个 Lock 实现将只允许锁定了该对象的线程来调用此方法。其他(没有锁定该 Lock 对象的线程)线程对 unlock() 方法的调用将会抛一个未检查异常(RuntimeException)。</p>
<h2 id="21-读写锁-ReadWriteLock"><a href="#21-读写锁-ReadWriteLock" class="headerlink" title="21. 读写锁 ReadWriteLock"></a>21. 读写锁 ReadWriteLock</h2><p>java.util.concurrent.locks.ReadWriteLock 读写锁是一种先进的线程锁机制。它能够允许多个线程在同一时间对某特定资源进行读取,但同一时间内只能有一个线程对其进行写入。</p>
<p>读写锁的理念在于多个线程能够对一个共享资源进行读取,而不会导致并发问题。并发问题的发生场景在于对一个共享资源的读和写操作的同时进行,或者多个写操作并发进行。</p>
<p>本节只讨论 Java 内置 ReadWriteLock。如果你想了解 ReadWriteLock 背后的实现原理,请参考我的《Java 并发指南》主题中的《<a href="http://tutorials.jenkov.com/java-concurrency/read-write-locks.html" target="_blank" rel="external">读写锁</a>》小节。</p>
<h3 id="ReadWriteLock-锁规则"><a href="#ReadWriteLock-锁规则" class="headerlink" title="ReadWriteLock 锁规则"></a>ReadWriteLock 锁规则</h3><p>一个线程在对受保护资源在读或者写之前对 ReadWriteLock 锁定的规则如下:</p>
<ul>
<li>读锁:如果没有任何写操作线程锁定 ReadWriteLock,并且没有任何写操作线程要求一个写锁(但还没有获得该锁)。因此,可以有多个读操作线程对该锁进行锁定。</li>
<li>写锁:如果没有任何读操作或者写操作。因此,在写操作的时候,只能有一个线程对该锁进行锁定。</li>
</ul>
<h3 id="ReadWriteLock-实现"><a href="#ReadWriteLock-实现" class="headerlink" title="ReadWriteLock 实现"></a>ReadWriteLock 实现</h3><p>ReadWriteLock 是个接口,如果你想用它的话就得去使用它的实现类之一。java.util.concurrent.locks 包提供了 ReadWriteLock 接口的以下实现类:</p>
<ul>
<li>ReentrantReadWriteLock</li>
</ul>
<p>以下是 ReadWriteLock 的创建以及如何使用它进行读、写锁定的简单示例代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();  </div><div class="line"></div><div class="line">readWriteLock.readLock().lock();  </div><div class="line"></div><div class="line">    <span class="comment">// multiple readers can enter this section  </span></div><div class="line">    <span class="comment">// if not locked for writing, and not writers waiting  </span></div><div class="line">    <span class="comment">// to lock for writing.  </span></div><div class="line"></div><div class="line">readWriteLock.readLock().unlock();  </div><div class="line"></div><div class="line">readWriteLock.writeLock().lock();  </div><div class="line"></div><div class="line">    <span class="comment">// only one writer can enter this section,  </span></div><div class="line">    <span class="comment">// and only if no threads are currently reading.  </span></div><div class="line"></div><div class="line">readWriteLock.writeLock().unlock();</div></pre></td></tr></table></figure></p>
<p>注意如何使用 ReadWriteLock 对两种锁实例的持有。一个对读访问进行保护,一个队写访问进行保护。</p>
<h2 id="22-原子性布尔-AtomicBoolean"><a href="#22-原子性布尔-AtomicBoolean" class="headerlink" title="22. 原子性布尔 AtomicBoolean"></a>22. 原子性布尔 AtomicBoolean</h2><p>AtomicBoolean 类为我们提供了一个可以用原子方式进行读和写的布尔值,它还拥有一些先进的原子性操作,比如 compareAndSet()。AtomicBoolean 类位于 java.util.concurrent.atomic 包,完整类名是为 java.util.concurrent.atomic.AtomicBoolean。本小节描述的 AtomicBoolean 是 Java 8 版本里的,而不是它第一次被引入的 Java 5 版本。</p>
<p>AtomicBoolean 背后的设计理念在我的《Java 并发指南》主题的《<a href="http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html" target="_blank" rel="external">比较和交换</a>》小节有解释。</p>
<h3 id="创建一个-AtomicBoolean"><a href="#创建一个-AtomicBoolean" class="headerlink" title="创建一个 AtomicBoolean"></a>创建一个 AtomicBoolean</h3><p>你可以这样创建一个 AtomicBoolean:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean();</div></pre></td></tr></table></figure></p>
<p>以上示例新建了一个默认值为 false 的 AtomicBoolean。如果你想要为 AtomicBoolean 实例设置一个显式的初始值,那么你可以将初始值传给 AtomicBoolean 的构造子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);</div></pre></td></tr></table></figure></p>
<h3 id="获取-AtomicBoolean-的值"><a href="#获取-AtomicBoolean-的值" class="headerlink" title="获取 AtomicBoolean 的值"></a>获取 AtomicBoolean 的值</h3><p>你可以通过使用 get() 方法来获取一个 AtomicBoolean 的值。示例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </div><div class="line"><span class="keyword">boolean</span> value = atomicBoolean.get();</div></pre></td></tr></table></figure></p>
<p>以上代码执行后 value 变量的值将为 true。</p>
<h3 id="设置-AtomicBoolean-的值"><a href="#设置-AtomicBoolean-的值" class="headerlink" title="设置 AtomicBoolean 的值"></a>设置 AtomicBoolean 的值</h3><p>你可以通过使用 set() 方法来设置一个 AtomicBoolean 的值。<br>示例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </div><div class="line">atomicBoolean.set(<span class="keyword">false</span>);</div></pre></td></tr></table></figure></p>
<p>以上代码执行后 AtomicBoolean 的值为 false。</p>
<h3 id="交换-AtomicBoolean-的值"><a href="#交换-AtomicBoolean-的值" class="headerlink" title="交换 AtomicBoolean 的值"></a>交换 AtomicBoolean 的值</h3><p>你可以通过 getAndSet() 方法来交换一个 AtomicBoolean 实例的值。getAndSet() 方法将返回 AtomicBoolean 当前的值,并将为 AtomicBoolean 设置一个新值。示例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </div><div class="line"><span class="keyword">boolean</span> oldValue = atomicBoolean.getAndSet(<span class="keyword">false</span>);</div></pre></td></tr></table></figure></p>
<p>以上代码执行后 oldValue 变量的值为 true,atomicBoolean 实例将持有 false 值。代码成功将 AtomicBoolean 当前值 ture 交换为 false。</p>
<h3 id="比较并设置-AtomicBoolean-的值"><a href="#比较并设置-AtomicBoolean-的值" class="headerlink" title="比较并设置 AtomicBoolean 的值"></a>比较并设置 AtomicBoolean 的值</h3><p>compareAndSet() 方法允许你对 AtomicBoolean 的当前值与一个期望值进行比较,如果当前值等于期望值的话,将会对 AtomicBoolean 设定一个新值。compareAndSet() 方法是原子性的,因此在同一时间之内有单个线程执行它。因此 compareAndSet() 方法可被用于一些类似于锁的同步的简单实现。以下是一个 compareAndSet() 示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicBoolean atomicBoolean = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">true</span>);  </div><div class="line"></div><div class="line"><span class="keyword">boolean</span> expectedValue = <span class="keyword">true</span>;  </div><div class="line"><span class="keyword">boolean</span> newValue      = <span class="keyword">false</span>;  </div><div class="line"></div><div class="line"><span class="keyword">boolean</span> wasNewValueSet = atomicBoolean.compareAndSet(expectedValue, newValue);</div></pre></td></tr></table></figure></p>
<p>本示例对 AtomicBoolean 的当前值与 true 值进行比较,如果相等,将 AtomicBoolean 的值更新为 false。</p>
<h2 id="23-原子性整型-AtomicInteger"><a href="#23-原子性整型-AtomicInteger" class="headerlink" title="23. 原子性整型 AtomicInteger"></a>23. 原子性整型 AtomicInteger</h2><p>AtomicInteger 类为我们提供了一个可以进行原子性读和写操作的 int 变量,它还包含一系列先进的原子性操作,比如 compareAndSet()。AtomicInteger 类位于 java.util.concurrent.atomic 包,因此其完整类名为 java.util.concurrent.atomic.AtomicInteger。本小节描述的 AtomicInteger 是 Java 8 版本里的,而不是它第一次被引入的 Java 5 版本。</p>
<p>AtomicInteger 背后的设计理念在我的《Java 并发指南》主题的《<a href="http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html" target="_blank" rel="external">比较和交换</a>》小节有解释。</p>
<h3 id="创建一个-AtomicInteger"><a href="#创建一个-AtomicInteger" class="headerlink" title="创建一个 AtomicInteger"></a>创建一个 AtomicInteger</h3><p>创建一个 AtomicInteger 示例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</div></pre></td></tr></table></figure></p>
<p>本示例将创建一个初始值为 0 的 AtomicInteger。如果你想要创建一个给定初始值的 AtomicInteger,你可以这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);</div></pre></td></tr></table></figure></p>
<p>本示例将 123 作为参数传给 AtomicInteger 的构造子,它将设置 AtomicInteger 实例的初始值为 123。</p>
<h3 id="获取-AtomicInteger-的值"><a href="#获取-AtomicInteger-的值" class="headerlink" title="获取 AtomicInteger 的值"></a>获取 AtomicInteger 的值</h3><p>你可以使用 get() 方法获取 AtomicInteger 实例的值。示例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);  </div><div class="line"><span class="keyword">int</span> theValue = atomicInteger.get();</div></pre></td></tr></table></figure></p>
<h3 id="设置-AtomicInteger-的值"><a href="#设置-AtomicInteger-的值" class="headerlink" title="设置 AtomicInteger 的值"></a>设置 AtomicInteger 的值</h3><p>你可以通过 set() 方法对 AtomicInteger 的值进行重新设置。以下是 AtomicInteger.set() 示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);  </div><div class="line">atomicInteger.set(<span class="number">234</span>);</div></pre></td></tr></table></figure></p>
<p>以上示例创建了一个初始值为 123 的 AtomicInteger,而在第二行将其值更新为 234。</p>
<h3 id="比较并设置-AtomicInteger-的值"><a href="#比较并设置-AtomicInteger-的值" class="headerlink" title="比较并设置 AtomicInteger 的值"></a>比较并设置 AtomicInteger 的值</h3><p>AtomicInteger 类也通过了一个原子性的 compareAndSet() 方法。这一方法将 AtomicInteger 实例的当前值与期望值进行比较,如果二者相等,为 AtomicInteger 实例设置一个新值。AtomicInteger.compareAndSet() 代码示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">123</span>);  </div><div class="line"><span class="keyword">int</span> expectedValue = <span class="number">123</span>;  </div><div class="line"><span class="keyword">int</span> newValue      = <span class="number">234</span>;  </div><div class="line">atomicInteger.compareAndSet(expectedValue, newValue);</div></pre></td></tr></table></figure></p>
<p>本示例首先新建一个初始值为 123 的 AtomicInteger 实例。然后将 AtomicInteger 与期望值 123 进行比较,如果相等,将 AtomicInteger 的值更新为 234。</p>
<h3 id="增加-AtomicInteger-值"><a href="#增加-AtomicInteger-值" class="headerlink" title="增加 AtomicInteger 值"></a>增加 AtomicInteger 值</h3><p>AtomicInteger 类包含有一些方法,通过它们你可以增加 AtomicInteger 的值,并获取其值。这些方法如下:</p>
<ul>
<li>addAndGet()</li>
<li>getAndAdd()</li>
<li>getAndIncrement()</li>
<li>incrementAndGet()</li>
</ul>
<p>第一个 addAndGet() 方法给 AtomicInteger 增加了一个值,然后返回增加后的值。getAndAdd() 方法为 AtomicInteger 增加了一个值,但返回的是增加以前的 AtomicInteger 的值。具体使用哪一个取决于你的应用场景。以下是这两种方法的示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  </div><div class="line">System.out.println(atomicInteger.getAndAdd(<span class="number">10</span>));  </div><div class="line">System.out.println(atomicInteger.addAndGet(<span class="number">10</span>));</div></pre></td></tr></table></figure></p>
<p>本示例将打印出 0 和 20。例子中,第二行拿到的是加 10 之前的 AtomicInteger 的值。加 10 之前的值是 0。第三行将 AtomicInteger 的值再加 10,并返回加操作之后的值。该值现在是为 20。你当然也可以使用这俩方法为 AtomicInteger 添加负值。结果实际是一个减法操作。getAndIncrement() 和 incrementAndGet() 方法类似于 getAndAdd() 和 addAndGet(),但每次只将 AtomicInteger 的值加 1。</p>
<h3 id="减小-AtomicInteger-的值"><a href="#减小-AtomicInteger-的值" class="headerlink" title="减小 AtomicInteger 的值"></a>减小 AtomicInteger 的值</h3><p>AtomicInteger 类还提供了一些减小 AtomicInteger 的值的原子性方法。这些方法是:</p>
<ul>
<li>decrementAndGet()</li>
<li>getAndDecrement()</li>
</ul>
<p>decrementAndGet() 将 AtomicInteger 的值减一,并返回减一后的值。getAndDecrement() 也将 AtomicInteger 的值减一,但它返回的是减一之前的值。</p>
<h2 id="24-原子性长整型-AtomicLong"><a href="#24-原子性长整型-AtomicLong" class="headerlink" title="24. 原子性长整型 AtomicLong"></a>24. 原子性长整型 AtomicLong</h2><p>AtomicLong 类为我们提供了一个可以进行原子性读和写操作的 long 变量,它还包含一系列先进的原子性操作,比如 compareAndSet()AtomicLong 类位于 java.util.concurrent.atomic 包,因此其完整类名为 java.util.concurrent.atomic.AtomicLong。本小节描述的 AtomicLong 是 Java 8 版本里的,而不是它第一次被引入的 Java 5 版本。</p>
<p>AtomicLong 背后的设计理念在我的《Java 并发指南》主题的《比较和交换》小节有解释。</p>
<h3 id="创建一个-AtomicLong"><a href="#创建一个-AtomicLong" class="headerlink" title="创建一个 AtomicLong"></a>创建一个 AtomicLong</h3><p>创建一个 AtomicLong 如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();</div></pre></td></tr></table></figure></p>
<p>将创建一个初始值为 0 的 AtomicLong。如果你想创建一个指定初始值的 AtomicLong,可以:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);</div></pre></td></tr></table></figure></p>
<p>本示例将 123 作为参数传递给 AtomicLong 的构造子,后者将 AtomicLong 实例的初始值设置为 123。</p>
<h3 id="获取-AtomicLong-的值"><a href="#获取-AtomicLong-的值" class="headerlink" title="获取 AtomicLong 的值"></a>获取 AtomicLong 的值</h3><p>你可以通过 get() 方法获取 AtomicLong 的值。AtomicLong.get() 示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);  </div><div class="line"><span class="keyword">long</span> theValue = atomicLong.get();</div></pre></td></tr></table></figure></p>
<h3 id="设置-AtomicLong-的值"><a href="#设置-AtomicLong-的值" class="headerlink" title="设置 AtomicLong 的值"></a>设置 AtomicLong 的值</h3><p>你可以通过 set() 方法设置 AtomicLong 实例的值。一个 AtomicLong.set() 的示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);  </div><div class="line">atomicLong.set(<span class="number">234</span>);</div></pre></td></tr></table></figure></p>
<p>本示例新建了一个初始值为 123 的 AtomicLong,第二行将其值设置为 234。</p>
<h3 id="比较并设置-AtomicLong-的值"><a href="#比较并设置-AtomicLong-的值" class="headerlink" title="比较并设置 AtomicLong 的值"></a>比较并设置 AtomicLong 的值</h3><p>AtomicLong 类也有一个原子性的 compareAndSet() 方法。这一方法将 AtomicLong 实例的当前值与一个期望值进行比较,如果两种相等,为 AtomicLong 实例设置一个新值。AtomicLong.compareAndSet() 使用示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong(<span class="number">123</span>);  </div><div class="line"><span class="keyword">long</span> expectedValue = <span class="number">123</span>;  </div><div class="line"><span class="keyword">long</span> newValue      = <span class="number">234</span>;  </div><div class="line">atomicLong.compareAndSet(expectedValue, newValue);</div></pre></td></tr></table></figure></p>
<p>本示例新建了一个初始值为 123 的 AtomicLong。然后将 AtomicLong 的当前值与期望值 123 进行比较,如果相等的话,AtomicLong 的新值将变为 234。</p>
<h3 id="增加-AtomicLong-值"><a href="#增加-AtomicLong-值" class="headerlink" title="增加 AtomicLong 值"></a>增加 AtomicLong 值</h3><p>AtomicLong 具备一些能够增加 AtomicLong 的值并返回自身值的方法。这些方法如下:</p>
<ul>
<li>addAndGet()</li>
<li>getAndAdd()</li>
<li>getAndIncrement()</li>
<li>incrementAndGet()</li>
</ul>
<p>第一个方法 addAndGet() 将 AtomicLong 的值加一个数字,并返回增加后的值。第二个方法 getAndAdd() 也将 AtomicLong 的值加一个数字,但返回的是增加前的 AtomicLong 的值。具体使用哪一个取决于你自己的场景。示例如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicLong atomicLong = <span class="keyword">new</span> AtomicLong();  </div><div class="line">System.out.println(atomicLong.getAndAdd(<span class="number">10</span>));  </div><div class="line">System.out.println(atomicLong.addAndGet(<span class="number">10</span>));</div></pre></td></tr></table></figure></p>
<p>本示例将打印出 0 和 20。例子中,第二行拿到的是加 10 之前的 AtomicLong 的值。加 10 之前的值是 0。第三行将 AtomicLong 的值再加 10,并返回加操作之后的值。该值现在是为 20。你当然也可以使用这俩方法为 AtomicLong 添加负值。结果实际是一个减法操作。getAndIncrement() 和 incrementAndGet() 方法类似于 getAndAdd() 和 addAndGet(),但每次只将 AtomicLong 的值加 1。</p>
<h3 id="减小-AtomicLong-的值"><a href="#减小-AtomicLong-的值" class="headerlink" title="减小 AtomicLong 的值"></a>减小 AtomicLong 的值</h3><p>AtomicLong 类还提供了一些减小 AtomicLong 的值的原子性方法。这些方法是:</p>
<ul>
<li>decrementAndGet()</li>
<li>getAndDecrement()<br>decrementAndGet() 将 AtomicLong 的值减一,并返回减一后的值。getAndDecrement() 也将 AtomicLong 的值减一,但它返回的是减一之前的值。</li>
</ul>
<h2 id="25-原子性引用型-AtomicReference"><a href="#25-原子性引用型-AtomicReference" class="headerlink" title="25. 原子性引用型 AtomicReference"></a>25. 原子性引用型 AtomicReference</h2><p>AtomicReference 提供了一个可以被原子性读和写的对象引用变量。原子性的意思是多个想要改变同一个 AtomicReference 的线程不会导致 AtomicReference 处于不一致的状态。AtomicReference 还有一个 compareAndSet() 方法,通过它你可以将当前引用于一个期望值(引用)进行比较,如果相等,在该 AtomicReference 对象内部设置一个新的引用。</p>
<h3 id="创建一个-AtomicReference"><a href="#创建一个-AtomicReference" class="headerlink" title="创建一个 AtomicReference"></a>创建一个 AtomicReference</h3><p>创建 AtomicReference 如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicReference atomicReference = <span class="keyword">new</span> AtomicReference();</div></pre></td></tr></table></figure></p>
<p>如果你需要使用一个指定引用创建 AtomicReference,可以:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String initialReference = <span class="string">"the initially referenced string"</span>;  </div><div class="line">AtomicReference atomicReference = <span class="keyword">new</span> AtomicReference(initialReference);</div></pre></td></tr></table></figure></p>
<h3 id="创建泛型-AtomicReference"><a href="#创建泛型-AtomicReference" class="headerlink" title="创建泛型 AtomicReference"></a>创建泛型 AtomicReference</h3><p>你可以使用 Java 泛型来创建一个泛型 AtomicReference。示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicReference&lt;String&gt; atomicStringReference = <span class="keyword">new</span> AtomicReference&lt;String&gt;();</div></pre></td></tr></table></figure></p>
<p>你也可以为泛型 AtomicReference 设置一个初始值。示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">String initialReference = <span class="string">"the initially referenced string"</span>;  </div><div class="line">AtomicReference&lt;String&gt; atomicStringReference = <span class="keyword">new</span> AtomicReference&lt;String&gt;(initialReference);</div></pre></td></tr></table></figure></p>
<h3 id="获取-AtomicReference-引用"><a href="#获取-AtomicReference-引用" class="headerlink" title="获取 AtomicReference 引用"></a>获取 AtomicReference 引用</h3><p>你可以通过 AtomicReference 的 get() 方法来获取保存在 AtomicReference 里的引用。如果你的 AtomicReference 是非泛型的,get() 方法将返回一个 Object 类型的引用。如果是泛型化的,get() 将返回你创建 AtomicReference 时声明的那个类型。先来看一个非泛型的 AtomicReference get() 示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicReference atomicReference = <span class="keyword">new</span> AtomicReference(<span class="string">"first value referenced"</span>);  </div><div class="line">String reference = (String) atomicReference.get();</div></pre></td></tr></table></figure></p>
<p>注意如何对 get() 方法返回的引用强制转换为 String。泛型化的 AtomicReference 示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicReference&lt;String&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;String&gt;(<span class="string">"first value referenced"</span>);  </div><div class="line">String reference = atomicReference.get();</div></pre></td></tr></table></figure></p>
<p>编译器知道了引用的类型,所以我们无需再对 get() 返回的引用进行强制转换了。<br>这个看起来非泛型和泛型化的没啥区别。真正的区别在于编译器将对你能够设置给一个泛型化的 AtomicReference 参数类型进行限制。</p>
<h3 id="设置-AtomicReference-引用"><a href="#设置-AtomicReference-引用" class="headerlink" title="设置 AtomicReference 引用"></a>设置 AtomicReference 引用</h3><p>你可以使用 get() 方法对 AtomicReference 里边保存的引用进行设置。如果你定义的是一个非泛型 AtomicReference,set() 将会以一个 Object 引用作为参数。如果是泛型化的 AtomicReference,set() 方法将只接受你定义给的类型。AtomicReference set() 示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">AtomicReference atomicReference = <span class="keyword">new</span> AtomicReference();  </div><div class="line">atomicReference.set(<span class="string">"New object referenced"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="比较并设置-AtomicReference-引用"><a href="#比较并设置-AtomicReference-引用" class="headerlink" title="比较并设置 AtomicReference 引用"></a>比较并设置 AtomicReference 引用</h3><p>AtomicReference 类具备了一个很有用的方法:compareAndSet()。compareAndSet() 可以将保存在 AtomicReference 里的引用于一个期望引用进行比较,如果两个引用是一样的(并非 equals() 的相等,而是 == 的一样),将会给 AtomicReference 实例设置一个新的引用。</p>
<p>如果 compareAndSet() 为 AtomicReference 设置了一个新的引用,compareAndSet() 将返回 true。否则 compareAndSet() 返回 false。AtomicReference compareAndSet() 示例:<br>```java<br>String initialReference = “initial value referenced”;<br>AtomicReference<string> atomicStringReference = new AtomicReference<string>(initialReference);  </string></string></p>
<p>String newReference = “new value referenced”;<br>boolean exchanged = atomicStringReference.compareAndSet(initialReference, newReference);<br>System.out.println(“exchanged: “ + exchanged);  </p>
<p>exchanged = atomicStringReference.compareAndSet(initialReference, newReference);<br>System.out.println(“exchanged: “ + exchanged);<br>本示例创建了一个带有一个初始引用的泛型化的 AtomicReference。之后两次调用 comparesAndSet()来对存储值和期望值进行对比,如果二者一致,为 AtomicReference 设置一个新的引用。第一次比较,存储的引用(initialReference)和期望的引用(initialReference)一致,所以一个新的引用(newReference)被设置给 AtomicReference,compareAndSet() 方法返回 true。第二次比较时,存储的引用(newReference)和期望的引用(initialReference)不一致,因此新的引用没有被设置给 AtomicReference,compareAndSet() 方法返回 false。</p>
<p>ref: <a href="http://tutorials.jenkov.com/java-util-concurrent/index.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-util-concurrent/index.html</a>。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Java8-系列之重新认识HashMap</title>
    <url>/2017/09/21/Java-Java8-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HashMap/</url>
    <content><![CDATA[<p>HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK(Java Developmet Kit)版本的更新,JDK1.8对HashMap底层的实现进行了优化,例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别,深入探讨HashMap的结构实现和功能原理。</p>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java为数据结构中的映射定义了一个接口java.util.Map,此接口主要有四个常用的实现类,分别是HashMap、Hashtable、LinkedHashMap和TreeMap,类继承关系如下图所示:<br><img src="/2017/09/21/Java-Java8-重新认识HashMap/java.util.map类图.png" alt="java.util.map类图.png" title=""></p>
<p>下面针对各个实现类的特点做一些说明:</p>
<ul>
<li>HashMap:它根据键的hashCode值存储数据,大多数情况下可以直接定位到它的值,因而具有很快的访问速度,但遍历顺序却是不确定的。 HashMap最多只允许一条记录的键为null,允许多条记录的值为null。HashMap非线程安全,即任一时刻可以有多个线程同时写HashMap,可能会导致数据的不一致。如果需要满足线程安全,可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力,或者使用ConcurrentHashMap。</li>
<li>Hashtable:Hashtable是遗留类,很多映射的常用功能与HashMap类似,不同的是它承自Dictionary类,并且是线程安全的,任一时间只有一个线程能写Hashtable,并发性不如ConcurrentHashMap,因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用,不需要线程安全的场合可以用HashMap替换,需要线程安全的场合可以用ConcurrentHashMap替换。</li>
<li>LinkedHashMap:LinkedHashMap是HashMap的一个子类,保存了记录的插入顺序,在用Iterator遍历LinkedHashMap时,先得到的记录肯定是先插入的,也可以在构造时带参数,按照访问次序排序。</li>
<li>TreeMap:TreeMap实现SortedMap接口,能够把它保存的记录根据键排序,默认是按键值的升序排序,也可以指定排序的比较器,当用Iterator遍历TreeMap时,得到的记录是排过序的。如果使用排序的映射,建议使用TreeMap。在使用TreeMap时,key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator,否则会在运行时抛出java.lang.ClassCastException类型的异常。</li>
</ul>
<p>对于上述四种Map类型的类,要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化,Map对象很可能就定位不到映射的位置了。</p>
<p>通过上面的比较,我们知道了HashMap是Java的Map家族中一个普通成员,鉴于它可以满足大多数场景的使用条件,所以是使用频度最高的一个。下文我们主要结合源码,从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。</p>
<h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>搞清楚HashMap,首先需要知道HashMap是什么,即它的存储结构-字段；其次弄明白它能干什么,即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。</p>
<h3 id="存储结构-字段"><a href="#存储结构-字段" class="headerlink" title="存储结构-字段"></a>存储结构-字段</h3><p>从结构实现来讲,HashMap是数组+链表+红黑树(JDK1.8增加了红黑树部分)实现的,如下如所示。<br><img src="/2017/09/21/Java-Java8-重新认识HashMap/hashMap内存结构图.png" alt="hashMap内存结构图.png" title=""><br>这里需要讲明白两个问题:数据底层具体存储的是什么？这样的存储方式有什么优点呢？</p>
<p>(1) 从源码可知,HashMap类中有一个非常重要的字段,就是 Node[] table,即哈希桶数组,明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next;   <span class="comment">//链表的下一个node</span></div><div class="line"></div><div class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ... &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Node是HashMap的一个内部类,实现了Map.Entry接口,本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。</p>
<p>(2) HashMap就是使用哈希表来存储的。哈希表为解决冲突,可以采用开放地址法和链地址法等来解决问题,Java中HashMap采用了链地址法。链地址法,简单来说,就是数组加链表的结合。在每个数组元素上都一个链表结构,当数据被Hash后,得到数组下标,把数据放在对应下标元素的链表上。例如程序执行下面代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">map.put(<span class="string">"美团"</span>,<span class="string">"小美"</span>);</div></pre></td></tr></table></figure></p>
<p>系统将调用”美团”这个key的hashCode()方法得到其hashCode 值(该方法适用于每个Java对象),然后再通过Hash算法的后两步运算(高位运算和取模运算,下文有介绍)来定位该键值对的存储位置,有时两个key会定位到相同的位置,表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀,Hash碰撞的概率就越小,map的存取效率就会越高。</p>
<p>如果哈希桶数组很大,即使较差的Hash算法也会比较分散,如果哈希桶数组数组很小,即使好的Hash算法也会出现较多碰撞,所以就需要在空间成本和时间成本之间权衡,其实就是在根据实际情况确定哈希桶数组的大小,并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小,哈希桶数组(Node[] table)占用空间又少呢？答案就是好的Hash算法和扩容机制。</p>
<p>在理解Hash和扩容流程之前,我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知,构造函数就是对下面几个字段进行初始化,源码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></div><div class="line"><span class="keyword">int</span> modCount;  </div><div class="line"><span class="keyword">int</span> size;</div></pre></td></tr></table></figure></p>
<p>首先,Node[] table的初始化长度length(默认值是16),Load factor为负载因子(默认值是0.75),threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说,在数组定义好长度之后,负载因子越大,所能容纳的键值对个数越多。</p>
<p>结合负载因子的定义公式可知,threshold就是在此Load factor和length(数组长度)对应下允许的最大元素数目,超过这个数目就重新resize(扩容),扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择,建议大家不要修改,除非在时间和空间比较特殊的情况下,如果内存空间很多而又对时间效率要求很高,可以降低负载因子Load factor的值；相反,如果内存空间紧张而对时间效率要求不高,可以增加负载因子loadFactor的值,这个值可以大于1。</p>
<p>size这个字段其实很好理解,就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数,主要用于迭代的快速失败。强调一点,内部结构发生变化指的是结构发生变化,例如put新键值对,但是某个key对应的value值被覆盖不属于结构变化。</p>
<p>在HashMap中,哈希桶数组table的长度length大小必须为2的n次方(一定是合数),这是一种非常规的设计,常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数,具体证明可以参考<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="external">为什么一般hashtable的桶数会取一个素数</a>,Hashtable初始化桶大小为11,就是桶大小设计为素数的应用(Hashtable扩容后不能保证还是素数)。HashMap采用这种非常规设计,主要是为了在取模和扩容时做优化,同时为了减少冲突,HashMap定位哈希桶索引位置时,也加入了高位参与运算的过程。</p>
<p>这里存在一个问题,即使负载因子和Hash算法设计的再合理,也免不了会出现拉链过长的情况,一旦出现拉链过长,则会严重影响HashMap的性能。于是,在JDK1.8版本中,对数据结构做了进一步的优化,引入了红黑树。而当链表长度太长(默认超过8)时,链表就转换为红黑树,利用红黑树快速增删改查的特点提高HashMap的性能,其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论,想了解更多红黑树数据结构的工作原理可以参考<a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">教你初步了解红黑树</a>。</p>
<h3 id="功能实现-方法"><a href="#功能实现-方法" class="headerlink" title="功能实现-方法"></a>功能实现-方法</h3><p>HashMap的内部功能实现很多,本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。</p>
<h4 id="1-确定哈希桶数组索引位置"><a href="#1-确定哈希桶数组索引位置" class="headerlink" title="1. 确定哈希桶数组索引位置"></a>1. 确定哈希桶数组索引位置</h4><p>不管增加、删除、查找键值对,定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合,所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些,尽量使得每个位置上的元素数量只有一个,那么当我们用hash算法求得这个位置的时候,马上就可以知道对应位置的元素就是我们要的,不用遍历链表,大大优化了查询的效率。HashMap定位数组索引位置,直接决定了hash方法的离散性能。先看看源码的实现(方法一+方法二):<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//方法一:</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;   <span class="comment">//jdk1.8 &amp; jdk1.7</span></div><div class="line">     <span class="keyword">int</span> h;</div><div class="line">     <span class="comment">// h = key.hashCode() 为第一步 取hashCode值</span></div><div class="line">     <span class="comment">// h ^ (h &gt;&gt;&gt; 16)  为第二步 高位参与运算</span></div><div class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">//方法二:</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;  <span class="comment">//jdk1.7的源码,jdk1.8没有这个方法,但是实现原理一样的</span></div><div class="line">     <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);  <span class="comment">//第三步 取模运算</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的Hash算法本质上就是三步:<strong>取key的hashCode值、高位运算、取模运算</strong>。</p>
<p>对于任意给定的对象,只要它的hashCode()返回值相同,那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算,这样一来,元素的分布相对来说是比较均匀的。但是,模运算的消耗还是比较大的,在HashMap中是这样做的:调用方法二来计算该对象应该保存在table数组的哪个索引处。</p>
<p>这个方法非常巧妙,它通过h &amp; (table.length -1)来得到该对象的保存位,而HashMap底层数组的长度总是2的n次方,这是HashMap在速度上的优化。当length总是2的n次方时,h&amp; (length-1)运算等价于对length取模,也就是h%length,但是&amp;比%具有更高的效率。</p>
<p>在JDK1.8的实现中,优化了高位运算的算法,通过hashCode()的高16位异或低16位实现的:(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16),主要是从速度、功效、质量来考虑的,这么做可以在数组table的length比较小的时候,也能保证考虑到高低Bit都参与到Hash的计算中,同时不会有太大的开销。</p>
<p>下面举例说明下,n为table的长度。<br><img src="/2017/09/21/Java-Java8-重新认识HashMap/hashMap哈希算法例图.png" alt="hashMap哈希算法例图.png" title=""></p>
<h4 id="2-分析HashMap的put方法"><a href="#2-分析HashMap的put方法" class="headerlink" title="2. 分析HashMap的put方法"></a>2. 分析HashMap的put方法</h4><p>HashMap的put方法执行过程可以通过下图来理解,自己有兴趣可以去对比源码更清楚地研究学习。<br>JDK1.8HashMap的put方法源码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Associates the specified value with the specified key in this map.</div><div class="line"> * If the map previously contained a mapping for the key, the old</div><div class="line"> * value is replaced.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</div><div class="line"> * <span class="doctag">@param</span> value value to be associated with the specified key</div><div class="line"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</div><div class="line"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</div><div class="line"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</div><div class="line"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// 对key的hashCode()做hash</span></div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Implements Map.put and related methods</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> hash hash for key</div><div class="line"> * <span class="doctag">@param</span> key the key</div><div class="line"> * <span class="doctag">@param</span> value the value to put</div><div class="line"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</div><div class="line"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</div><div class="line"> * <span class="doctag">@return</span> previous value, or null if none</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line">               <span class="keyword">boolean</span> evict) &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="comment">// 步骤①:tab为空则创建</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">// 步骤②:计算index,并对null做处理</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="comment">// 步骤③:节点key存在,直接覆盖value</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="comment">// 步骤④:判断该链为红黑树</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="comment">// 步骤⑤:该链为链表</span></div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">//链表长度大于8转换为红黑树进行处理</span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// key已经存在直接覆盖value</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">// 步骤⑥:超过最大容量 就扩容</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<img src="/2017/09/21/Java-Java8-重新认识HashMap/hashMap_put方法执行流程图.png" alt="hashMap_put方法执行流程图.png" title="">
<p>①.判断键值对数组table[i]是否为空或为null,否则执行resize()进行扩容；</p>
<p>②.根据键值key计算hash值得到插入的数组索引i,如果table[i]==null,直接新建节点添加,转向⑥,如果table[i]不为空,转向③；</p>
<p>③.判断table[i]的首个元素是否和key一样,如果相同直接覆盖value,否则转向④,这里的相同指的是hashCode以及equals；</p>
<p>④.判断table[i] 是否为treeNode,即table[i] 是否是红黑树,如果是红黑树,则直接在树中插入键值对,否则转向⑤；</p>
<p>⑤.遍历table[i],判断链表长度是否大于8,大于8的话把链表转换为红黑树,在红黑树中执行插入操作,否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p>
<p>⑥.插入成功后,判断实际存在的键值对数量size是否超多了最大容量threshold,如果超过,进行扩容。</p>
<h4 id="3-扩容机制"><a href="#3-扩容机制" class="headerlink" title="3. 扩容机制"></a>3. 扩容机制</h4><p>扩容(resize)就是重新计算容量,向HashMap对象里不停的添加元素,而HashMap对象内部的数组无法装载更多的元素时,对象就需要扩大数组的长度,以便能装入更多的元素。当然Java里的数组是无法自动扩容的,方法是使用一个新的数组代替已有的容量小的数组,就像我们用一个小桶装水,如果想装更多的水,就得换大水桶。</p>
<p>我们分析下resize的源码,鉴于JDK1.8融入了红黑树,较复杂,为了便于理解我们仍然使用JDK1.7的代码,好理解一些,本质上区别不大,具体区别后文再说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;   <span class="comment">//传入新的容量</span></div><div class="line">    Entry[] oldTable = table;    <span class="comment">//引用扩容前的Entry数组</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;         </div><div class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;  <span class="comment">//扩容前的数组大小如果已经达到最大(2^30)了</span></div><div class="line">        threshold = Integer.MAX_VALUE; <span class="comment">//修改阈值为int的最大值(2^31-1),这样以后就不会扩容了</span></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];  <span class="comment">//初始化一个新的Entry数组</span></div><div class="line">    transfer(newTable);                         <span class="comment">//!!将数据转移到新的Entry数组里</span></div><div class="line">    table = newTable;                           <span class="comment">//HashMap的table属性引用新的Entry数组</span></div><div class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);<span class="comment">//修改阈值</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里就是使用一个容量更大的数组来代替已有的容量小的数组,transfer()方法将原有Entry数组的元素拷贝到新的Entry数组里。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</div><div class="line">    Entry[] src = table;                   <span class="comment">//src引用了旧的Entry数组</span></div><div class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123; <span class="comment">//遍历旧的Entry数组</span></div><div class="line">        Entry&lt;K,V&gt; e = src[j];             <span class="comment">//取得旧Entry数组的每个元素</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</div><div class="line">            src[j] = <span class="keyword">null</span>;<span class="comment">//释放旧Entry数组的对象引用(for循环后,旧的Entry数组不再引用任何对象)</span></div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                Entry&lt;K,V&gt; next = e.next;</div><div class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="comment">//!!重新计算每个元素在数组中的位置</span></div><div class="line">                e.next = newTable[i]; <span class="comment">//标记[1]</span></div><div class="line">                newTable[i] = e;      <span class="comment">//将元素放在数组上</span></div><div class="line">                e = next;             <span class="comment">//访问下一个Entry链上的元素</span></div><div class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>newTable[i]的引用赋给了e.next,也就是使用了单链表的头插入方式,同一位置上新元素总会被放在链表的头部位置；这样先放在一个索引上的元素终会被放到Entry链的尾部(如果发生了hash冲突的话),这一点和Jdk1.8有区别,下文详解。在旧数组中同一条Entry链上的元素,通过重新计算索引位置后,有可能被放到了新数组的不同位置上。</p>
<p>下面举个例子说明下扩容过程。假设了我们的hash算法就是简单的用key mod 一下表的大小(也就是数组的长度)。其中的哈希桶数组table的size=2, 所以key = 3、7、5,put顺序依次为 5、7、3。在mod 2以后都冲突在table[1]这里了。这里假设负载因子 loadFactor=1,即当键值对的实际大小size 大于 table的实际大小时进行扩容。接下来的三个步骤是哈希桶数组 resize成4,然后所有的Node重新rehash的过程。<br><img src="/2017/09/21/Java-Java8-重新认识HashMap/jdk1.7扩容例图.png" alt="jdk1.7扩容例图.png" title=""></p>
<p>下面我们讲解下JDK1.8做了哪些优化。经过观测可以发现,我们使用的是2次幂的扩展(指长度扩为原来2倍),所以,元素的位置要么是在原位置,要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思,n为table的长度,图(a)表示扩容前的key1和key2两种key确定索引位置的示例,图(b)表示扩容后key1和key2两种key确定索引位置的示例,其中hash1是key1对应的哈希与高位运算结果。<br><img src="/2017/09/21/Java-Java8-重新认识HashMap/hashMap_1.8_哈希算法例图1.png" alt="hashMap_1.8_哈希算法例图1.png" title=""><br>元素在重新计算hash之后,因为n变为2倍,那么n-1的mask范围在高位多1bit(红色),因此新的index就会发生这样的变化:<br><img src="/2017/09/21/Java-Java8-重新认识HashMap/hashMap_1.8_哈希算法例图2.png" alt="hashMap_1.8_哈希算法例图2.png" title=""><br>因此,我们在扩充HashMap的时候,不需要像JDK1.7的实现那样重新计算hash,只需要看看原来的hash值新增的那个bit是1还是0就好了,是0的话索引没变,是1的话索引变成“原索引+oldCap”,可以看看下图为16扩充为32的resize示意图:<br></p>
<p>这个设计确实非常的巧妙,既省去了重新计算hash值的时间,而且同时,由于新增的1bit是0还是1可以认为是随机的,因此resize的过程,均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别,JDK1.7中rehash的时候,旧链表迁移新链表的时候,如果在新表的数组索引位置相同,则链表元素会倒置,但是从上图可以看出,JDK1.8不会倒置。有兴趣的同学可以研究下JDK1.8的resize源码,写的很赞,如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// 超过最大值就不再扩充了,就只好随你碰撞去吧</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没超过最大值,就扩充为原来的2倍</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 计算新的resize上限</span></div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 链表优化重hash的代码块</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="comment">// 原索引</span></div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">// 原索引+oldCap</span></div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">// 原索引放到bucket里</span></div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>在多线程使用场景中,应该尽量避免使用线程不安全的HashMap,而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的,下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解,仍然使用JDK1.7的环境):<br><figure class="highlight"><table><tr><td class="code"><pre><div class="line">public class HashMapInfiniteLoop &#123;  </div><div class="line"></div><div class="line">    private static HashMap&lt;Integer,String&gt; map = new HashMap&lt;Integer,String&gt;(2,0.75f);  </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        map.put(5, "C");  </div><div class="line"></div><div class="line">        new Thread("Thread1") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(7, "B");  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();  </div><div class="line">        new Thread("Thread2") &#123;  </div><div class="line">            public void run() &#123;  </div><div class="line">                map.put(3, "A);  </div><div class="line">                System.out.println(map);  </div><div class="line">            &#125;;  </div><div class="line">        &#125;.start();        </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中,map初始化为一个长度为2的数组,loadFactor=0.75,threshold=2*0.75,也就是说当put第二个key的时候,map就需要进行resize。</p>
<p>通过设置断点让线程1和线程2同时debug到transfer方法(3.3小节代码块)的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点,让线程2进行resize。结果如下图。<br><img src="/2017/09/21/Java-Java8-重新认识HashMap/jdk1.7_hashMap死循环例图1.png" alt="jdk1.7_hashMap死循环例图1.png" title=""><br>注意,Thread1的 e 指向了key(3),而next指向了key(7),其在线程二rehash后,指向了线程二重组后的链表。</p>
<p>线程一被调度回来执行,先是执行 newTalbe[i] = e, 然后是e = next,导致了e指向了key(7),而下一次循环的next = e.next导致了next指向了key(3)。<br><img src="/2017/09/21/Java-Java8-重新认识HashMap/jdk1.7_hashMap死循环例图2.png" alt="jdk1.7_hashMap死循环例图2.png" title=""><br><img src="/2017/09/21/Java-Java8-重新认识HashMap/jdk1.7_hashMap死循环例图3.png" alt="jdk1.7_hashMap死循环例图3.png" title=""><br>e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意:此时的key(7).next 已经指向了key(3), 环形链表就这样出现了。<br><img src="/2017/09/21/Java-Java8-重新认识HashMap/jdk1.7_hashMap死循环例图4.png" alt="jdk1.7_hashMap死循环例图4.png" title=""><br>于是,当我们用线程一调用map.get(11)时,悲剧就出现了——Infinite Loop。</p>
<h3 id="JDK1-8与JDK1-7的性能对比"><a href="#JDK1-8与JDK1-7的性能对比" class="headerlink" title="JDK1.8与JDK1.7的性能对比"></a>JDK1.8与JDK1.7的性能对比</h3><p>HashMap中,如果key经过hash算法得出的数组索引位置全部不相同,即Hash算法非常好,那样的话,getKey方法的时间复杂度就是O(1),如果Hash算法技术的结果碰撞非常多,假如Hash算极其差,所有的Hash算法结果得出的索引位置一样,那样所有的键值对都集中到一个桶中,或者在一个链表中,或者在一个红黑树中,时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化,总体性能优于JDK1.7,下面我们从两个方面用例子证明这一点。</p>
<h4 id="Hash较均匀的情况"><a href="#Hash较均匀的情况" class="headerlink" title="Hash较均匀的情况"></a>Hash较均匀的情况</h4><p>为了便于测试,我们先写一个类Key,如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</div><div class="line"></div><div class="line">    Key(<span class="keyword">int</span> value) &#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Key o)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.value, o.value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Key key = (Key) o;</div><div class="line">        <span class="keyword">return</span> value == key.value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个类复写了equals方法,并且提供了相当好的hashCode函数,任何一个值的hashCode都不会相同,因为直接使用value当做hashcode。为了避免频繁的GC,我将不变的Key实例缓存了起来,而不是一遍一遍的创建它们。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Keys</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_KEY = <span class="number">10_000_000</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Key[] KEYS_CACHE = <span class="keyword">new</span> Key[MAX_KEY];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_KEY; ++i) &#123;</div><div class="line">            KEYS_CACHE[i] = <span class="keyword">new</span> Key(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Key <span class="title">of</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> KEYS_CACHE[value];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在开始我们的试验,测试需要做的仅仅是,创建不同size的HashMap(1、10、100、……10000000),屏蔽了扩容的情况,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> mapSize)</span> </span>&#123;</div><div class="line"></div><div class="line">     HashMap&lt;Key, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Key,Integer&gt;(mapSize);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; ++i) &#123;</div><div class="line">         map.put(Keys.of(i), i);</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">long</span> beginTime = System.nanoTime(); <span class="comment">//获取纳秒</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mapSize; i++) &#123;</div><div class="line">         map.get(Keys.of(i));</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">long</span> endTime = System.nanoTime();</div><div class="line">     System.out.println(endTime - beginTime);</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&lt;= <span class="number">1000</span> <span class="number">0000</span>;i*= <span class="number">10</span>)&#123;</div><div class="line">         test(i);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>在测试中会查找不同的值,然后度量花费的时间,为了计算getKey的平均时间,我们遍历所有的get方法,计算总的时间,除以key的数量,计算一个平均值,主要用来比较,绝对值可能会受很多环境因素的影响。结果如下:<br><img src="/2017/09/21/Java-Java8-重新认识HashMap/性能比较表1.png" alt="性能比较表1.png" title=""><br>通过观测测试结果可知,JDK1.8的性能要高于JDK1.7 15%以上,在某些size的区域上,甚至高于100%。由于Hash算法较均匀,JDK1.8引入的红黑树效果不明显,下面我们看看Hash不均匀的的情况。</p>
<h4 id="Hash极不均匀的情况"><a href="#Hash极不均匀的情况" class="headerlink" title="Hash极不均匀的情况"></a>Hash极不均匀的情况</h4><p>假设我们又一个非常差的Key,它们所有的实例都返回相同的hashCode值。这是使用HashMap最坏的情况。代码修改如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Key</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//...</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仍然执行main方法,得出的结果如下表所示:<br><img src="/2017/09/21/Java-Java8-重新认识HashMap/性能比较表2.png" alt="性能比较表2.png" title=""><br>从表中结果中可知,随着size的变大,JDK1.7的花费时间是增长的趋势,而JDK1.8是明显的降低趋势,并且呈现对数增长稳定。当一个链表太长的时候,HashMap会动态的将它替换成一个红黑树,这话的话会将时间复杂度从O(n)降为O(logn)。hash算法均匀和不均匀所花费的时间明显也不相同,这两种情况的相对比较,可以说明一个好的hash算法的重要性。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>(1) 扩容是一个特别耗性能的操作,所以当程序员在使用HashMap的时候,估算map的大小,初始化的时候给一个大致的数值,避免map进行频繁的扩容。<br>(2) 负载因子是可以修改的,也可以大于1,但是建议不要轻易修改,除非情况非常特殊。<br>(3) HashMap是线程不安全的,不要在并发的环境中同时操作HashMap,建议使用ConcurrentHashMap。<br>(4) JDK1.8引入红黑树大程度优化了HashMap的性能。<br>(5) 还没升级JDK1.8的,现在开始升级吧。HashMap的性能提升仅仅是JDK1.8的冰山一角。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">https://tech.meituan.com/java-hashmap.html</a><br>JDK1.7&amp;JDK1.8 源码。<br>CSDN博客频道,<a href="http://blog.csdn.net/xuefeng0707/article/details/40797085" target="_blank" rel="external">HashMap多线程死循环问题</a>,2014。<br>红黑联盟,<a href="http://www.2cto.com/kf/201505/401433.html" target="_blank" rel="external">Java类集框架之HashMap(JDK1.8)源码剖析</a>,2015。<br>CSDN博客频道, <a href="http://blog.csdn.net/v_july_v/article/details/6105630" target="_blank" rel="external">教你初步了解红黑树</a>,2010。<br>Java Code Geeks,<a href="http://www.javacodegeeks.com/2014/04/hashmap-performance-improvements-in-java-8.html" target="_blank" rel="external">HashMap performance improvements in Java 8</a>,2014。<br>Importnew,<a href="http://www.importnew.com/13384.html" target="_blank" rel="external">危险!在HashMap中将可变对象用作Key</a>,2014。<br>CSDN博客频道,<a href="http://blog.csdn.net/liuqiyao_01/article/details/14475159" target="_blank" rel="external">为什么一般hashtable的桶数会取一个素数</a>,2013。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache-缓存更新的套路</title>
    <url>/2017/09/21/Cache-%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%9A%84%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<p>看到好些人在写更新缓存数据代码时,先删除缓存,然后再更新数据库,而后续的操作会把数据再装载的缓存中。然而,这个是逻辑是错误的。试想,两个并发操作,一个是更新操作,另一个是查询操作,更新操作删除缓存后,查询操作没有命中缓存,先把老数据读出来后放到缓存中,然后更新操作更新了数据库。于是,在缓存中的数据还是老的数据,导致缓存中的数据是脏的,而且还一直这样脏下去了。</p>
<p>我不知道为什么这么多人用的都是这个逻辑,当我在微博上发了这个贴以后,我发现好些人给了好多非常复杂和诡异的方案,所以,我想写这篇文章说一下几个缓存更新的Design Pattern(让我们多一些套路吧)。</p>
<p>这里,我们先不讨论更新缓存和更新数据这两个事是一个事务的事,或是会有失败的可能,我们先假设更新数据库和更新缓存都可以成功的情况(我们先把成功的代码逻辑先写对)。</p>
<p>更新缓存的的Design Pattern有四种:Cache aside, Read through, Write through, Write behind caching,我们下面一一来看一下这四种Pattern。</p>
<a id="more"></a>
<h2 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h2><p>这是最常用最常用的pattern了。其具体逻辑如下:</p>
<ul>
<li>失效:应用程序先从cache取数据,没有得到,则从数据库中取数据,成功后,放到缓存中。</li>
<li>命中:应用程序从cache中取数据,取到后返回。</li>
<li>更新:先把数据存到数据库中,成功后,再让缓存失效。</li>
</ul>
<img src="/2017/09/21/Cache-缓存更新的套路/Cache-Aside-Design-Pattern-Flow-Diagram-e1470471723210.png" alt="Cache-Aside-Design-Pattern-Flow-Diagram-e1470471723210.png" title="">
<p>注意,我们的更新是先更新数据库,成功后,让缓存失效。那么,这种方式是否可以没有文章前面提到过的那个问题呢？我们可以脑补一下。</p>
<p>一个是查询操作,一个是更新操作的并发,首先,没有了删除cache数据的操作了,而是先更新了数据库中的数据,此时,缓存依然有效,所以,并发的查询操作拿的是没有更新的数据,但是,更新操作马上让缓存的失效了,后续的查询操作再把数据从数据库中拉出来。而不会像文章开头的那个逻辑产生的问题,后续的查询操作一直都在取老的数据。</p>
<p>这是标准的design pattern,包括Facebook的论文《<a href="https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf" target="_blank" rel="external">Scaling Memcache at Facebook</a>》也使用了这个策略。为什么不是写完数据库后更新缓存？你可以看一下Quora上的这个问答《<a href="https://www.quora.com/Why-does-Facebook-use-delete-to-remove-the-key-value-pair-in-Memcached-instead-of-updating-the-Memcached-during-write-request-to-the-backend" target="_blank" rel="external">Why does Facebook use delete to remove the key-value pair in Memcached instead of updating the Memcached during write request to the backend?</a>》,主要是怕两个并发的写操作导致脏数据。</p>
<p>那么,是不是Cache Aside这个就不会有并发问题了？不是的,比如,一个是读操作,但是没有命中缓存,然后就到数据库中取数据,此时来了一个写操作,写完数据库后,让缓存失效,然后,之前的那个读操作再把老的数据放进去,所以,会造成脏数据。</p>
<p>但,这个case理论上会出现,不过,实际上出现的概率可能非常低,因为这个条件需要发生在读缓存时缓存失效,而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多,而且还要锁表,而读操作必需在写操作前进入数据库操作,而又要晚于写操作更新缓存,所有的这些条件都具备的概率基本并不大。</p>
<p><strong>所以,这也就是Quora上的那个答案里说的,要么通过2PC或是Paxos协议保证一致性,要么就是拼命的降低并发时脏数据的概率,而Facebook使用了这个降低概率的玩法,因为2PC太慢,而Paxos太复杂。当然,最好还是为缓存设置上过期时间。</strong></p>
<h2 id="Read-Write-Through-Pattern"><a href="#Read-Write-Through-Pattern" class="headerlink" title="Read/Write Through Pattern"></a>Read/Write Through Pattern</h2><p>我们可以看到,在上面的Cache Aside套路中,我们的应用代码需要维护两个数据存储,一个是缓存(Cache),一个是数据库(Repository)。所以,应用程序比较啰嗦。而Read/Write Through套路是把更新数据库(Repository)的操作由缓存自己代理了,所以,对于应用层来说,就简单很多了。<strong>可以理解为,应用认为后端就是一个单一的存储,而存储自己维护自己的Cache</strong>。</p>
<h3 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read Through"></a>Read Through</h3><p>Read Through 套路就是在查询操作中更新缓存,也就是说,当缓存失效的时候(过期或LRU换出),Cache Aside是由调用方负责把数据加载入缓存,而Read Through则用缓存服务自己来加载,从而对应用方是透明的。</p>
<h3 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h3><p>Write Through 套路和Read Through相仿,不过是在更新数据时发生。当有数据更新的时候,如果没有命中缓存,直接更新数据库,然后返回。如果命中了缓存,则更新缓存,然后再由Cache自己更新数据库(这是一个同步操作)</p>
<p>下图自来Wikipedia的<a href="https://en.wikipedia.org/wiki/Cache_(computing" target="_blank" rel="external">Cache</a>)词条。其中的Memory你可以理解为就是我们例子里的数据库。<br><img src="/2017/09/21/Cache-缓存更新的套路/460px-Write-through_with_no-write-allocation.svg_.png" alt="460px-Write-through_with_no-write-allocation.svg_.png" title=""></p>
<h2 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h2><p>Write Behind 又叫 Write Back。一些了解Linux操作系统内核的同学对write back应该非常熟悉,这不就是Linux文件系统的Page Cache的算法吗？是的,你看基础这玩意全都是相通的。所以,基础很重要,我已经不是一次说过基础很重要这事了。</p>
<p>Write Back套路,一句说就是,在更新数据的时候,只更新缓存,不更新数据库,而我们的缓存会异步地批量更新数据库。这个设计的好处就是让数据的I/O操作飞快无比(因为直接操作内存嘛 ),因为异步,write backg还可以合并对同一个数据的多次操作,所以性能的提高是相当可观的。</p>
<p>但是,其带来的问题是,数据不是强一致性的,而且可能会丢失(我们知道Unix/Linux非正常关机会导致数据丢失,就是因为这个事)。在软件设计上,我们基本上不可能做出一个没有缺陷的设计,就像算法设计中的时间换空间,空间换时间一个道理,有时候,强一致性和高性能,高可用和高性性是有冲突的。软件设计从来都是取舍Trade-Off。</p>
<p>另外,Write Back实现逻辑比较复杂,因为他需要track有哪数据是被更新了的,需要刷到持久层上。操作系统的write back会在仅当这个cache需要失效的时候,才会被真正持久起来,比如,内存不够了,或是进程退出了等情况,这又叫lazy write。</p>
<p>在wikipedia上有一张write back的流程图,基本逻辑如下:<br><img src="/2017/09/21/Cache-缓存更新的套路/Write-back_with_write-allocation.png" alt="Write-back_with_write-allocation.png" title=""></p>
<h2 id="再多唠叨一些"><a href="#再多唠叨一些" class="headerlink" title="再多唠叨一些"></a>再多唠叨一些</h2><ol>
<li><p>上面讲的这些Design Pattern,其实并不是软件架构里的mysql数据库和memcache/redis的更新策略,这些东西都是计算机体系结构里的设计,比如CPU的缓存,硬盘文件系统中的缓存,硬盘上的缓存,数据库中的缓存。基本上来说,这些缓存更新的设计模式都是非常老古董的,而且历经长时间考验的策略,所以这也就是,工程学上所谓的Best Practice,遵从就好了。</p>
</li>
<li><p>有时候,我们觉得能做宏观的系统架构的人一定是很有经验的,其实,宏观系统架构中的很多设计都来源于这些微观的东西。比如,云计算中的很多虚拟化技术的原理,和传统的虚拟内存不是很像么？Unix下的那些I/O模型,也放大到了架构里的同步异步的模型,还有Unix发明的管道不就是数据流式计算架构吗？TCP的好些设计也用在不同系统间的通讯中,仔细看看这些微观层面,你会发现有很多设计都非常精妙……所以,请允许我在这里放句观点鲜明的话——如果你要做好架构,首先你得把计算机体系结构以及很多老古董的基础技术吃透了。</p>
</li>
<li><p>在软件开发或设计中,我非常建议在之前先去参考一下已有的设计和思路,看看相应的guideline,best practice或design pattern,吃透了已有的这些东西,再决定是否要重新发明轮子。千万不要似是而非地,想当然的做软件设计。</p>
</li>
<li><p>上面,我们没有考虑缓存(Cache)和持久层(Repository)的整体事务的问题。比如,更新Cache成功,更新数据库失败了怎么吗？或是反过来。关于这个事,如果你需要强一致性,你需要使用“两阶段提交协议”——prepare, commit/rollback,比如Java 7 的<a href="http://docs.oracle.com/javaee/7/api/javax/transaction/xa/XAResource.html" target="_blank" rel="external">XAResource</a>,还有MySQL 5.7的 <a href="http://dev.mysql.com/doc/refman/5.7/en/xa.html" target="_blank" rel="external">XA Transaction</a>,有些cache也支持XA,比如EhCache。当然,XA这样的强一致性的玩法会导致性能下降,关于分布式的事务的相关话题,你可以看看《<a href="https://coolshell.cn/articles/10910.html" target="_blank" rel="external">分布式系统的事务处理</a>》一文。</p>
</li>
</ol>
<p>ref:<br><a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="external">https://coolshell.cn/articles/17416.html</a></p>
]]></content>
      <categories>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Cache-缓存那些事</title>
    <url>/2017/09/21/Cache-%E7%BC%93%E5%AD%98%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<p>Thinking, design, and sth else about Cache.</p>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般而言，现在互联网应用（网站或App）的整体流程，可以概括如图1所示，用户请求从界面（浏览器或App界面）到网络转发、应用服务再到存储（数据库或文件系统），然后返回到界面呈现内容。</p>
<p>随着互联网的普及，内容信息越来越复杂，用户数和访问量越来越大，我们的应用需要支撑更多的并发量，同时我们的应用服务器和数据库服务器所做的计算也越来越多。但是往往我们的应用服务器资源是有限的，且技术变革是缓慢的，数据库每秒能接受的请求次数也是有限的（或者文件的读写也是有限的），如何能够有效利用有限的资源来提供尽可能大的吞吐量？一个有效的办法就是引入缓存，打破标准流程，每个环节中请求可以从缓存中直接获取目标数据并返回，从而减少计算量，有效提升响应速度，让有限的资源服务更多的用户。</p>
<p>如图1所示，缓存的使用可以出现在1～4的各个环节中，每个环节的缓存方案与使用各有特点。<br><img src="/2017/09/21/Cache-缓存那些事/网络应用一般流程.png" alt="网络应用一般流程.png" title=""><br>图1 互联网应用一般流程</p>
<h2 id="缓存特征"><a href="#缓存特征" class="headerlink" title="缓存特征"></a>缓存特征</h2><p>缓存也是一个数据模型对象，那么必然有它的一些特征：</p>
<h3 id="命中率"><a href="#命中率" class="headerlink" title="命中率"></a>命中率</h3><p>命中率=返回正确结果数/请求缓存次数，命中率问题是缓存中的一个非常重要的问题，它是衡量缓存有效性的重要指标。命中率越高，表明缓存的使用率越高。</p>
<h3 id="最大元素（或最大空间）"><a href="#最大元素（或最大空间）" class="headerlink" title="最大元素（或最大空间）"></a>最大元素（或最大空间）</h3><p>缓存中可以存放的最大元素的数量，一旦缓存中元素数量超过这个值（或者缓存数据所占空间超过其最大支持空间），那么将会触发缓存启动清空策略根据不同的场景合理的设置最大元素值往往可以一定程度上提高缓存的命中率，从而更有效的时候缓存。</p>
<h3 id="清空策略"><a href="#清空策略" class="headerlink" title="清空策略"></a>清空策略</h3><p>如上描述，缓存的存储空间有限制，当缓存空间被用满时，如何保证在稳定服务的同时有效提升命中率？这就由缓存清空策略来处理，设计适合自身数据特征的清空策略能有效提升命中率。常见的一般策略有：</p>
<ul>
<li>FIFO(first in first out)<br>先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，以腾出新的空间接受新的数据。策略算法主要比较缓存元素的创建时间。在数据实效性要求场景下可选择该类策略，优先保障最新数据可用。</li>
<li>LFU(less frequently used)<br>最少使用策略，无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。策略算法主要比较元素的hitCount（命中次数）。在保证高频数据有效性场景下，可选择这类策略。</li>
<li>LRU(least recently used)<br>最近最少使用策略，无论是否过期，根据元素最后一次被使用的时间戳，清除最远使用时间戳的元素释放空间。策略算法主要比较元素最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。</li>
</ul>
<p>除此之外，还有一些简单策略比如：</p>
<ul>
<li>根据过期时间判断，清理过期时间最长的元素；</li>
<li>根据过期时间判断，清理最近要过期的元素；</li>
<li>随机清理；</li>
<li>根据关键字（或元素内容）长短清理等。</li>
</ul>
<h2 id="缓存介质"><a href="#缓存介质" class="headerlink" title="缓存介质"></a>缓存介质</h2><p>虽然从硬件介质上来看，无非就是内存和硬盘两种，但从技术上，可以分成内存、硬盘文件、数据库。</p>
<ul>
<li><strong>内存</strong>：将缓存存储于内存中是最快的选择，无需额外的I/O开销，但是内存的缺点是没有持久化落地物理磁盘，一旦应用异常break down而重新启动，数据很难或者无法复原。</li>
<li><strong>硬盘</strong>：一般来说，很多缓存框架会结合使用内存和硬盘，在内存分配空间满了或是在异常的情况下，可以被动或主动的将内存空间数据持久化到硬盘中，达到释放空间或备份数据的目的。</li>
<li><strong>数据库</strong>：前面有提到，增加缓存的策略的目的之一就是为了减少数据库的I/O压力。现在使用数据库做缓存介质是不是又回到了老问题上了？其实，数据库也有很多种类型，像那些不支持SQL，只是简单的key-value存储结构的特殊数据库（如BerkeleyDB和Redis），响应速度和吞吐量都远远高于我们常用的关系型数据库等。</li>
</ul>
<h2 id="缓存分类和应用场景"><a href="#缓存分类和应用场景" class="headerlink" title="缓存分类和应用场景"></a>缓存分类和应用场景</h2><p>缓存有各类特征，而且有不同介质的区别，那么实际工程中我们怎么去对缓存分类呢？在目前的应用服务框架中，比较常见的，时根据缓存雨应用的藕合度，分为local cache（本地缓存）和remote cache（分布式缓存）：</p>
<ul>
<li><strong>本地缓存</strong>：指的是在应用中的缓存组件，其最大的优点是应用和cache是在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适；同时，它的缺点也是应为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费。</li>
<li><strong>分布式缓存</strong>：指的是与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接的共享缓存。<br>目前各种类型的缓存都活跃在成千上万的应用服务中，还没有一种缓存方案可以解决一切的业务场景或数据类型，我们需要根据自身的特殊场景和背景，选择最适合的缓存方案。缓存的使用是程序员、架构师的必备技能，好的程序员能根据数据类型、业务场景来准确判断使用何种类型的缓存，如何使用这种缓存，以最小的成本最快的效率达到最优的目的。</li>
</ul>
<h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><h3 id="编程直接实现缓存"><a href="#编程直接实现缓存" class="headerlink" title="编程直接实现缓存"></a>编程直接实现缓存</h3><p>个别场景下，我们只需要简单的缓存数据的功能，而无需关注更多存取、清空策略等深入的特性时，直接编程实现缓存则是最便捷和高效的。</p>
<p>a. 成员变量或局部变量实现<br>简单代码示例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">    public void UseLocalCache()&#123;</div><div class="line">     //一个本地的缓存变量</div><div class="line">     Map&lt;String, Object&gt; localCacheStoreMap = new HashMap&lt;String, Object&gt;();</div><div class="line"></div><div class="line">    List&lt;Object&gt; infosList = this.getInfoList();</div><div class="line">    for(Object item:infosList)&#123;</div><div class="line">        if(localCacheStoreMap.containsKey(item))&#123; //缓存命中 使用缓存数据</div><div class="line">            // todo</div><div class="line">        &#125; else &#123; // 缓存未命中  IO获取数据，结果存入缓存</div><div class="line">            Object valueObject = this.getInfoFromDB();</div><div class="line">            localCacheStoreMap.put(valueObject.toString(), valueObject);</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">//示例</div><div class="line">private List&lt;Object&gt; getInfoList()&#123;</div><div class="line">    return new ArrayList&lt;Object&gt;();</div><div class="line">&#125;</div><div class="line">//示例数据库IO获取</div><div class="line">private Object getInfoFromDB()&#123;</div><div class="line">    return new Object();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以局部变量map结构缓存部分业务数据，减少频繁的重复数据库I/O操作。缺点仅限于类的自身作用域内，类间无法共享缓存。</p>
<p>b. 静态变量实现</p>
<p>最常用的单例实现静态资源缓存，代码示例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class CityUtils &#123;</div><div class="line">      private static final HttpClient httpClient = ServerHolder.createClientWithPool(); </div><div class="line">      private static Map&lt;Integer, String&gt; cityIdNameMap = new HashMap&lt;Integer, String&gt;();</div><div class="line">      private static Map&lt;Integer, String&gt; districtIdNameMap = new HashMap&lt;Integer, String&gt;();</div><div class="line"></div><div class="line">  static &#123;</div><div class="line">    HttpGet get = new HttpGet(&quot;http://gis-in.sankuai.com/api/location/city/all&quot;);</div><div class="line">    BaseAuthorizationUtils.generateAuthAndDateHeader(get,</div><div class="line">            BaseAuthorizationUtils.CLIENT_TO_REQUEST_MDC,</div><div class="line">            BaseAuthorizationUtils.SECRET_TO_REQUEST_MDC);</div><div class="line">    try &#123;</div><div class="line">        String resultStr = httpClient.execute(get, new BasicResponseHandler());</div><div class="line">        JSONObject resultJo = new JSONObject(resultStr);</div><div class="line">        JSONArray dataJa = resultJo.getJSONArray(&quot;data&quot;);</div><div class="line">        for (int i = 0; i &lt; dataJa.length(); i++) &#123;</div><div class="line">            JSONObject itemJo = dataJa.getJSONObject(i);</div><div class="line">            cityIdNameMap.put(itemJo.getInt(&quot;id&quot;), itemJo.getString(&quot;name&quot;));</div><div class="line">        &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        throw new RuntimeException(&quot;Init City List Error!&quot;, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    static &#123;</div><div class="line">    HttpGet get = new HttpGet(&quot;http://gis-in.sankuai.com/api/location/district/all&quot;);</div><div class="line">    BaseAuthorizationUtils.generateAuthAndDateHeader(get,</div><div class="line">            BaseAuthorizationUtils.CLIENT_TO_REQUEST_MDC,</div><div class="line">            BaseAuthorizationUtils.SECRET_TO_REQUEST_MDC);</div><div class="line">    try &#123;</div><div class="line">        String resultStr = httpClient.execute(get, new BasicResponseHandler());</div><div class="line">        JSONObject resultJo = new JSONObject(resultStr);</div><div class="line">        JSONArray dataJa = resultJo.getJSONArray(&quot;data&quot;);</div><div class="line">        for (int i = 0; i &lt; dataJa.length(); i++) &#123;</div><div class="line">            JSONObject itemJo = dataJa.getJSONObject(i);</div><div class="line">            districtIdNameMap.put(itemJo.getInt(&quot;id&quot;), itemJo.getString(&quot;name&quot;));</div><div class="line">        &#125;</div><div class="line">    &#125; catch (Exception e) &#123;</div><div class="line">        throw new RuntimeException(&quot;Init District List Error!&quot;, e);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">    public static String getCityName(int cityId) &#123;</div><div class="line">      String name = cityIdNameMap.get(cityId);</div><div class="line">      if (name == null) &#123;</div><div class="line">        name = &quot;未知&quot;;</div><div class="line">      &#125;</div><div class="line">       return name;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">    public static String getDistrictName(int districtId) &#123;</div><div class="line">      String name = districtIdNameMap.get(districtId);</div><div class="line">       if (name == null) &#123;</div><div class="line">         name = &quot;未知&quot;;</div><div class="line">        &#125;</div><div class="line">       return name;</div><div class="line">     &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>O2O业务中常用的城市基础基本信息判断，通过静态变量一次获取缓存内存中，减少频繁的I/O读取，静态变量实现类间可共享，进程内可共享，缓存的实时性稍差。</p>
<p>为了解决本地缓存数据的实时性问题，目前大量使用的是结合ZooKeeper的自动发现机制，实时变更本地静态变量缓存：</p>
<p>美团点评内部的基础配置组件MtConfig，采用的就是类似原理，使用静态变量缓存，结合ZooKeeper的统一管理，做到自动动态更新缓存，如图2所示。</p>
<img src="/2017/09/21/Cache-缓存那些事/mtconfig实现图.png" alt="mtconfig实现图.png" title="">
<p>图2 Mtconfig实现图<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">这类缓存实现，优点是能直接在heap区内读写，最快也最方便；</div><div class="line">缺点同样是受heap区域影响，缓存的数据量非常有限，同时缓存时间受GC影响。</div><div class="line">主要满足单机场景下的小数据量缓存需求，同时对缓存数据的变更无需太敏感感知，如上一般配置管理、基础静态数据等场景。</div></pre></td></tr></table></figure></p>
<h3 id="Ehcache"><a href="#Ehcache" class="headerlink" title="Ehcache"></a>Ehcache</h3><p>Ehcache是现在最流行的纯Java开源缓存框架，配置简单、结构清晰、功能强大，是一个非常轻量级的缓存实现，我们常用的Hibernate里面就集成了相关缓存功能。</p>
<img src="/2017/09/21/Cache-缓存那些事/ehcach框架图.png" alt="ehcach框架图.png" title="">
<p>图3 Ehcache框架图</p>
<p>从图3中我们可以了解到，Ehcache的核心定义主要包括：</p>
<ul>
<li>cache manager：缓存管理器，以前是只允许单例的，不过现在也可以多实例了。</li>
<li>cache：缓存管理器内可以放置若干cache，存放数据的实质，所有cache都实现了Ehcache接口，这是一个真正使用的缓存实例；通过缓存管理器的模式，可以在单个应用中轻松隔离多个缓存实例，独立服务于不同业务场景需求，缓存数据物理隔离，同时需要时又可共享使用。</li>
<li>element：单条缓存数据的组成单位。</li>
<li>system of record（SOR）：可以取到真实数据的组件，可以是真正的业务逻辑、外部接口调用、存放真实数据的数据库等，缓存就是从SOR中读取或者写入到SOR中去的。</li>
</ul>
<p>在上层可以看到，整个Ehcache提供了对JSR、JMX等的标准支持，能够较好的兼容和移植，同时对各类对象有较完善的监控管理机制。它的缓存介质涵盖堆内存（heap）、堆外内存（BigMemory商用版本支持）和磁盘，各介质可独立设置属性和策略。Ehcache最初是独立的本地缓存框架组件，在后期的发展中，结合Terracotta服务阵列模型，可以支持分布式缓存集群，主要有RMI、JGroups、JMS和Cache Server等传播方式进行节点间通信，如图3的左侧部分描述。</p>
<p>整体数据流转包括这样几类行为:</p>
<ul>
<li>Flush：缓存条目向低层次移动。</li>
<li>Fault：从低层拷贝一个对象到高层。在获取缓存的过程中，某一层发现自己的该缓存条目已经失效，就触发了Fault行为。</li>
<li>Eviction：把缓存条目除去。</li>
<li>Expiration：失效状态。</li>
<li>Pinning：强制缓存条目保持在某一层。</li>
</ul>
<p>图4反映了数据在各个层之间的流转，同时也体现了各层数据的一个生命周期。<br><img src="/2017/09/21/Cache-缓存那些事/ehcach缓存数据流转图.png" alt="ehcach缓存数据流转图.png" title=""><br>图4 缓存数据流转图（L1:本地内存层；L2:Terracotta服务节点层)<br>Ehcache的配置使用如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;ehcache&gt;</div><div class="line">&lt;!-- 指定一个文件目录，当Ehcache把数据写到硬盘上时，将把数据写到这个文件目录下 --&gt;</div><div class="line">&lt;diskStore path=&quot;java.io.tmpdir&quot;/&gt;</div><div class="line"></div><div class="line">&lt;!-- 设定缓存的默认数据过期策略 --&gt;</div><div class="line">&lt;defaultCache</div><div class="line">        maxElementsInMemory=&quot;10000&quot;</div><div class="line">        eternal=&quot;false&quot;</div><div class="line">        overflowToDisk=&quot;true&quot;</div><div class="line">        timeToIdleSeconds=&quot;0&quot;</div><div class="line">        timeToLiveSeconds=&quot;0&quot;</div><div class="line">        diskPersistent=&quot;false&quot;</div><div class="line">        diskExpiryThreadIntervalSeconds=&quot;120&quot;/&gt;</div><div class="line"></div><div class="line">&lt;!--  </div><div class="line">    设定具体的命名缓存的数据过期策略</div><div class="line"></div><div class="line">    cache元素的属性：</div><div class="line">        name：缓存名称</div><div class="line"></div><div class="line">        maxElementsInMemory：内存中最大缓存对象数</div><div class="line"></div><div class="line">        maxElementsOnDisk：硬盘中最大缓存对象数，若是0表示无穷大</div><div class="line"></div><div class="line">        eternal：true表示对象永不过期，此时会忽略timeToIdleSeconds和timeToLiveSeconds属性，默认为false</div><div class="line"></div><div class="line">        overflowToDisk：true表示当内存缓存的对象数目达到了maxElementsInMemory界限后，会把溢出的对象写到硬盘缓存中。注意：如果缓存的对象要写入到硬盘中的话，则该对象必须实现了Serializable接口才行。</div><div class="line"></div><div class="line">        diskSpoolBufferSizeMB：磁盘缓存区大小，默认为30MB。每个Cache都应该有自己的一个缓存区。</div><div class="line"></div><div class="line">        diskPersistent：是否缓存虚拟机重启期数据</div><div class="line"></div><div class="line">        diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认为120秒</div><div class="line"></div><div class="line">        timeToIdleSeconds： 设定允许对象处于空闲状态的最长时间，以秒为单位。当对象自从最近一次被访问后，如果处于空闲状态的时间超过了timeToIdleSeconds属性值，这个对象就会过期，EHCache将把它从缓存中清空。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地处于空闲状态</div><div class="line"></div><div class="line">        timeToLiveSeconds：设定对象允许存在于缓存中的最长时间，以秒为单位。当对象自从被存放到缓存中后，如果处于缓存中的时间超过了 timeToLiveSeconds属性值，这个对象就会过期，Ehcache将把它从缓存中清除。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地存在于缓存中。timeToLiveSeconds必须大于timeToIdleSeconds属性，才有意义</div><div class="line"></div><div class="line">        memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。</div><div class="line">--&gt;</div><div class="line">&lt;cache name=&quot;CACHE1&quot;</div><div class="line">       maxElementsInMemory=&quot;1000&quot;</div><div class="line">       eternal=&quot;true&quot;</div><div class="line">       overflowToDisk=&quot;true&quot;/&gt;  </div><div class="line"></div><div class="line">&lt;cache name=&quot;CACHE2&quot;</div><div class="line">    maxElementsInMemory=&quot;1000&quot;</div><div class="line">    eternal=&quot;false&quot;</div><div class="line">    timeToIdleSeconds=&quot;200&quot;</div><div class="line">    timeToLiveSeconds=&quot;4000&quot;</div><div class="line">    overflowToDisk=&quot;true&quot;/&gt;</div><div class="line">&lt;/ehcache&gt;</div></pre></td></tr></table></figure></p>
<p>整体上看，Ehcache的使用还是相对简单便捷的，提供了完整的各类API接口。需要注意的是，虽然Ehcache支持磁盘的持久化，但是由于存在两级缓存介质，在一级内存中的缓存，如果没有主动的刷入磁盘持久化的话，在应用异常down机等情形下，依然会出现缓存数据丢失，为此可以根据需要将缓存刷到磁盘，将缓存条目刷到磁盘的操作可以通过cache.flush()方法来执行，需要注意的是，对于对象的磁盘写入，前提是要将对象进行序列化。</p>
<p>主要特性：</p>
<ul>
<li>快速，针对大型高并发系统场景，Ehcache的多线程机制有相应的优化改善。</li>
<li>简单，很小的jar包，简单配置就可直接使用，单机场景下无需过多的其他服务依赖。</li>
<li>支持多种的缓存策略，灵活。</li>
<li>缓存数据有两级：内存和磁盘，与一般的本地内存缓存相比，有了磁盘的存储空间，将可以支持更大量的数据缓存需求。</li>
<li>具有缓存和缓存管理器的侦听接口，能更简单方便的进行缓存实例的监控管理。</li>
<li>支持多缓存管理器实例，以及一个实例的多个缓存区域。</li>
</ul>
<p>注意：Ehcache的超时设置主要是针对整个cache实例设置整体的超时策略，而没有较好的处理针对单独的key的个性的超时设置（有策略设置，但是比较复杂，就不描述了），因此，在使用中要注意过期失效的缓存元素无法被GC回收，时间越长缓存越多，内存占用也就越大，内存泄露的概率也越大。</p>
<h3 id="Guava-Cache"><a href="#Guava-Cache" class="headerlink" title="Guava Cache"></a>Guava Cache</h3><p>Guava Cache是Google开源的Java重用工具集库Guava里的一款缓存工具，其主要实现的缓存功能有：</p>
<ul>
<li>自动将entry节点加载进缓存结构中；</li>
<li>当缓存的数据超过设置的最大值时，使用LRU算法移除；</li>
<li>具备根据entry节点上次被访问或者写入时间计算它的过期机制；</li>
<li>缓存的key被封装在WeakReference引用内；</li>
<li>缓存的Value被封装在WeakReference或SoftReference引用内；</li>
<li>统计缓存使用过程中命中率、异常率、未命中率等统计数据。<br>Guava Cache的架构设计灵感来源于ConcurrentHashMap，我们前面也提到过，简单场景下可以自行编码通过hashmap来做少量数据的缓存，但是，如果结果可能随时间改变或者是希望存储的数据空间可控的话，自己实现这种数据结构还是有必要的。</li>
</ul>
<p>Guava Cache继承了ConcurrentHashMap的思路，使用多个segments方式的细粒度锁，在保证线程安全的同时，支持高并发场景需求。Cache类似于Map，它是存储键值对的集合，不同的是它还需要处理evict、expire、dynamic load等算法逻辑，需要一些额外信息来实现这些操作。对此，根据面向对象思想，需要做方法与数据的关联封装。如图5所示cache的内存数据模型，可以看到，使用ReferenceEntry接口来封装一个键值对，而用ValueReference来封装Value值，之所以用Reference命令，是因为Cache要支持WeakReference Key和SoftReference、WeakReference value。<br><img src="/2017/09/21/Cache-缓存那些事/guavacache数据结构图.png" alt="guavacache数据结构图.png" title=""><br>图5 Guava Cache数据结构图</p>
<p><strong>ReferenceEntry</strong>是对一个键值对节点的抽象，它包含了key和值的ValueReference抽象类，Cache由多个Segment组成，而每个Segment包含一个ReferenceEntry数组，每个ReferenceEntry数组项都是一条ReferenceEntry链，且一个ReferenceEntry包含key、hash、valueReference、next字段。除了在ReferenceEntry数组项中组成的链，在一个Segment中，所有ReferenceEntry还组成access链（accessQueue）和write链（writeQueue）（后面会介绍链的作用）。ReferenceEntry可以是强引用类型的key，也可以WeakReference类型的key，为了减少内存使用量，还可以根据是否配置了expireAfterWrite、expireAfterAccess、maximumSize来决定是否需要write链和access链确定要创建的具体Reference：StrongEntry、StrongWriteEntry、StrongAccessEntry、StrongWriteAccessEntry等。</p>
<p>对于<strong>ValueReference</strong>，因为Cache支持强引用的Value、SoftReference Value以及WeakReference Value，因而它对应三个实现类：StrongValueReference、SoftValueReference、WeakValueReference。为了支持动态加载机制，它还有一个LoadingValueReference，在需要动态加载一个key的值时，先把该值封装在LoadingValueReference中，以表达该key对应的值已经在加载了，如果其他线程也要查询该key对应的值，就能得到该引用，并且等待改值加载完成，从而保证该值只被加载一次，在该值加载完成后，将LoadingValueReference替换成其他ValueReference类型。ValueReference对象中会保留对ReferenceEntry的引用，这是因为在Value因为WeakReference、SoftReference被回收时，需要使用其key将对应的项从Segment的table中移除。</p>
<p><strong>WriteQueue和AccessQueue</strong> ：为了实现最近最少使用算法，Guava Cache在Segment中添加了两条链：write链（writeQueue）和access链（accessQueue），这两条链都是一个双向链表，通过ReferenceEntry中的previousInWriteQueue、nextInWriteQueue和previousInAccessQueue、nextInAccessQueue链接而成，但是以Queue的形式表达。WriteQueue和AccessQueue都是自定义了offer、add（直接调用offer）、remove、poll等操作的逻辑，对offer（add）操作，如果是新加的节点，则直接加入到该链的结尾，如果是已存在的节点，则将该节点链接的链尾；对remove操作，直接从该链中移除该节点；对poll操作，将头节点的下一个节点移除，并返回。</p>
<p>了解了cache的整体数据结构后，再来看下针对缓存的相关操作就简单多了：</p>
<ul>
<li>Segment中的evict清除策略操作，是在每一次调用操作的开始和结束时触发清理工作，这样比一般的缓存另起线程监控清理相比，可以减少开销，但如果长时间没有调用方法的话，会导致不能及时的清理释放内存空间的问题。evict主要处理四个Queue：1. keyReferenceQueue；2. valueReferenceQueue；3. writeQueue；4. accessQueue。前两个queue是因为WeakReference、SoftReference被垃圾回收时加入的，清理时只需要遍历整个queue，将对应的项从LocalCache中移除即可，这里keyReferenceQueue存放ReferenceEntry，而valueReferenceQueue存放的是ValueReference，要从Cache中移除需要有key，因而ValueReference需要有对ReferenceEntry的引用，这个前面也提到过了。而对后面两个Queue，只需要检查是否配置了相应的expire时间，然后从头开始查找已经expire的Entry，将它们移除即可。</li>
<li>Segment中的put操作：put操作相对比较简单，首先它需要获得锁，然后尝试做一些清理工作，接下来的逻辑类似ConcurrentHashMap中的rehash，查找位置并注入数据。需要说明的是当找到一个已存在的Entry时，需要先判断当前的ValueRefernece中的值事实上已经被回收了，因为它们可以是WeakReference、SoftReference类型，如果已经被回收了，则将新值写入。并且在每次更新时注册当前操作引起的移除事件，指定相应的原因：COLLECTED、REPLACED等，这些注册的事件在退出的时候统一调用Cache注册的RemovalListener，由于事件处理可能会有很长时间，因而这里将事件处理的逻辑在退出锁以后才做。最后，在更新已存在的Entry结束后都尝试着将那些已经expire的Entry移除。另外put操作中还需要更新writeQueue和accessQueue的语义正确性。</li>
<li>Segment带CacheLoader的get操作：1. 先查找table中是否已存在没有被回收、也没有expire的entry，如果找到，并在CacheBuilder中配置了refreshAfterWrite，并且当前时间间隔已经操作这个事件，则重新加载值，否则，直接返回原有的值；2. 如果查找到的ValueReference是LoadingValueReference，则等待该LoadingValueReference加载结束，并返回加载的值；3. 如果没有找到entry，或者找到的entry的值为null，则加锁后，继续在table中查找已存在key对应的entry，如果找到并且对应的entry.isLoading()为true，则表示有另一个线程正在加载，因而等待那个线程加载完成，如果找到一个非null值，返回该值，否则创建一个LoadingValueReference，并调用loadSync加载相应的值，在加载完成后，将新加载的值更新到table中，即大部分情况下替换原来的LoadingValueReference。</li>
</ul>
<p>Guava Cache提供Builder模式的CacheBuilder生成器来创建缓存的方式，十分方便，并且各个缓存参数的配置设置，类似于函数式编程的写法，可自行设置各类参数选型。它提供三种方式加载到缓存中。分别是：</p>
<ul>
<li>在构建缓存的时候，使用build方法内部调用CacheLoader方法加载数据；</li>
<li>callable 、callback方式加载数据；</li>
<li>使用粗暴直接的方式，直接Cache.put 加载数据，但自动加载是首选的，因为它可以更容易的推断所有缓存内容的一致性。</li>
</ul>
<p>build生成器的两种方式都实现了一种逻辑：从缓存中取key的值，如果该值已经缓存过了则返回缓存中的值，如果没有缓存过可以通过某个方法来获取这个值，不同的地方在于cacheloader的定义比较宽泛，是针对整个cache定义的，可以认为是统一的根据key值load value的方法，而callable的方式较为灵活，允许你在get的时候指定load方法。使用示例如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">    * CacheLoader</div><div class="line">   */</div><div class="line">   public void loadingCache()</div><div class="line">   &#123;</div><div class="line">     LoadingCache&lt;String, String&gt; graphs =CacheBuilder.newBuilder()</div><div class="line">        .maximumSize(1000).build(new CacheLoader&lt;String, String&gt;()</div><div class="line">        &#123;</div><div class="line">            @Override</div><div class="line">            public String load(String key) throws Exception</div><div class="line">            &#123;</div><div class="line">                System.out.println(&quot;key:&quot;+key);</div><div class="line">                if(&quot;key&quot;.equals(key))&#123;</div><div class="line">                    return &quot;key return result&quot;;</div><div class="line">                &#125;else&#123;</div><div class="line">                    return &quot;get-if-absent-compute&quot;;</div><div class="line">                &#125;                   </div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">   String resultVal = null;</div><div class="line">   try &#123;</div><div class="line">       resultVal = graphs.get(&quot;key&quot;);</div><div class="line">       &#125; catch (ExecutionException e) &#123;</div><div class="line">         e.printStackTrace();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">    System.out.println(resultVal);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   /**</div><div class="line">    *</div><div class="line">    * Callable</div><div class="line">   */</div><div class="line">   public void callablex() throws ExecutionException</div><div class="line">    &#123;</div><div class="line">      Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder()</div><div class="line">        .maximumSize(1000).build();</div><div class="line">      String result = cache.get(&quot;key&quot;, new Callable&lt;String&gt;()</div><div class="line">       &#123;</div><div class="line">         public String call()</div><div class="line">         &#123;</div><div class="line">          return &quot;result&quot;;</div><div class="line">         &#125;</div><div class="line">       &#125;);</div><div class="line">     System.out.println(result);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>总体来看，Guava Cache基于ConcurrentHashMap的优秀设计借鉴，在高并发场景支持和线程安全上都有相应的改进策略，使用Reference引用命令，提升高并发下的数据……访问速度并保持了GC的可回收，有效节省空间；同时，write链和access链的设计，能更灵活、高效的实现多种类型的缓存清理策略，包括基于容量的清理、基于时间的清理、基于引用的清理等；编程式的build生成器管理，让使用者有更多的自由度，能够根据不同场景设置合适的模式。</p>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="memcached缓存"><a href="#memcached缓存" class="headerlink" title="memcached缓存"></a>memcached缓存</h3><p>memcached是应用较广的开源分布式缓存产品之一，它本身其实不提供分布式解决方案。在服务端，memcached集群环境实际就是一个个memcached服务器的堆积，环境搭建较为简单；cache的分布式主要是在客户端实现，通过客户端的路由处理来达到分布式解决方案的目的。客户端做路由的原理非常简单，应用服务器在每次存取某key的value时，通过某种算法把key映射到某台memcached服务器nodeA上，因此这个key所有操作都在nodeA上，结构图如图6、图7所示。<br><img src="/2017/09/21/Cache-缓存那些事/memcached客户端路由图.png" alt="memcached客户端路由图.png" title=""><br>图6 memcached客户端路由图<br><img src="/2017/09/21/Cache-缓存那些事/memcached一致性hash示例图.png" alt="memcached一致性hash示例图.png" title=""><br>图7 memcached一致性hash示例图</p>
<p>memcached客户端采用一致性hash算法作为路由策略，如图7，相对于一般hash（如简单取模）的算法，一致性hash算法除了计算key的hash值外，还会计算每个server对应的hash值，然后将这些hash值映射到一个有限的值域上（比如0~2^32）。通过寻找hash值大于hash(key)的最小server作为存储该key数据的目标server。如果找不到，则直接把具有最小hash值的server作为目标server。同时，一定程度上，解决了扩容问题，增加或删除单个节点，对于整个集群来说，不会有大的影响。最近版本，增加了虚拟节点的设计，进一步提升了可用性。</p>
<p>memcached是一个高效的分布式内存cache，了解memcached的内存管理机制，才能更好的掌握memcached，让我们可以针对我们数据特点进行调优，让其更好的为我所用。我们知道memcached仅支持基础的key-value键值对类型数据存储。在memcached内存结构中有两个非常重要的概念：slab和chunk。如图8所示。</p>
<img src="/2017/09/21/Cache-缓存那些事/memcached内存结构图.png" alt="memcached内存结构图.png" title="">
<p>图8 memcached内存结构图</p>
<p>slab是一个内存块，它是memcached一次申请内存的最小单位。在启动memcached的时候一般会使用参数-m指定其可用内存，但是并不是在启动的那一刻所有的内存就全部分配出去了，只有在需要的时候才会去申请，而且每次申请一定是一个slab。Slab的大小固定为1M（1048576 Byte），一个slab由若干个大小相等的chunk组成。每个chunk中都保存了一个item结构体、一对key和value。</p>
<p>虽然在同一个slab中chunk的大小相等的，但是在不同的slab中chunk的大小并不一定相等，在memcached中按照chunk的大小不同，可以把slab分为很多种类（class），默认情况下memcached把slab分为40类（class1～class40），在class 1中，chunk的大小为80字节，由于一个slab的大小是固定的1048576字节（1M），因此在class1中最多可以有13107个chunk（也就是这个slab能存最多13107个小于80字节的key-value数据）。</p>
<p>memcached内存管理采取预分配、分组管理的方式，分组管理就是我们上面提到的slab class，按照chunk的大小slab被分为很多种类。内存预分配过程是怎样的呢？向memcached添加一个item时候，memcached首先会根据item的大小，来选择最合适的slab class：例如item的大小为190字节，默认情况下class 4的chunk大小为160字节显然不合适，class 5的chunk大小为200字节，大于190字节，因此该item将放在class 5中（显然这里会有10字节的浪费是不可避免的），计算好所要放入的chunk之后，memcached会去检查该类大小的chunk还有没有空闲的，如果没有，将会申请1M（1个slab）的空间并划分为该种类chunk。例如我们第一次向memcached中放入一个190字节的item时，memcached会产生一个slab class 2（也叫一个page），并会用去一个chunk，剩余5241个chunk供下次有适合大小item时使用，当我们用完这所有的5242个chunk之后，下次再有一个在160～200字节之间的item添加进来时，memcached会再次产生一个class 5的slab（这样就存在了2个pages）。</p>
<p>总结来看，memcached内存管理需要注意的几个方面：</p>
<ul>
<li>chunk是在page里面划分的，而page固定为1m，所以chunk最大不能超过1m。</li>
<li>chunk实际占用内存要加48B，因为chunk数据结构本身需要占用48B。</li>
<li>如果用户数据大于1m，则memcached会将其切割，放到多个chunk内。</li>
<li>已分配出去的page不能回收。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">对于key-value信息，最好不要超过1m的大小；</div><div class="line">同时信息长度最好相对是比较均衡稳定的，这样能够保障最大限度的使用内存</div><div class="line">同时，memcached采用的LRU清理策略，合理甚至过期时间，提高命中率。</div></pre></td></tr></table></figure>
<p>无特殊场景下，key-value能满足需求的前提下，使用memcached分布式集群是较好的选择，搭建与操作使用都比较简单；分布式集群在单点故障时，只影响小部分数据异常，目前还可以通过Magent缓存代理模式，做单点备份，提升高可用；整个缓存都是基于内存的，因此响应时间是很快，不需要额外的序列化、反序列化的程序，但同时由于基于内存，数据没有持久化，集群故障重启数据无法恢复。高版本的memcached已经支持CAS模式的原子操作，可以低成本的解决并发控制问题。</p>
<h3 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h3><p>Redis是一个远程内存数据库（非关系型数据库），性能强劲，具有复制特性以及解决问题而生的独一无二的数据模型。它可以存储键值对与5种不同类型的值之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能，还可以使用客户端分片来扩展写性能。</p>
<img src="/2017/09/21/Cache-缓存那些事/redis数据模型图.png" alt="redis数据模型图.png" title="">
<p>图9 Redis数据模型图</p>
<p>如图9，Redis内部使用一个redisObject对象来标识所有的key和value数据，redisObject最主要的信息如图所示：type代表一个value对象具体是何种数据类型，encoding是不同数据类型在Redis内部的存储方式，比如——type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或是int，如果是int则代表世界Redis内部是按数值类型存储和表示这个字符串。</p>
<p>图9左边的raw列为对象的编码方式：字符串可以被编码为raw（一般字符串）或Rint（为了节约内存，Redis会将字符串表示的64位有符号整数编码为整数来进行储存）；列表可以被编码为ziplist或linkedlist，ziplist是为节约大小较小的列表空间而作的特殊表示；集合可以被编码为intset或者hashtable，intset是只储存数字的小集合的特殊表示；hash表可以编码为zipmap或者hashtable，zipmap是小hash表的特殊表示；有序集合可以被编码为ziplist或者skiplist格式，ziplist用于表示小的有序集合，而skiplist则用于表示任何大小的有序集合。</p>
<p>从网络I/O模型上看，Redis使用单线程的I/O复用模型，自己封装了一个简单的AeEvent事件处理框架，主要实现了epoll、kqueue和select。对于单纯只有I/O操作来说，单线程可以将速度优势发挥到最大，但是Redis也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型实际会严重影响整体吞吐量，CPU计算过程中，整个I/O调度都是被阻塞住的，在这些特殊场景的使用中，需要额外的考虑。相较于memcached的预分配内存管理，Redis使用现场申请内存的方式来存储数据，并且很少使用free-list等方式来优化内存分配，会在一定程度上存在内存碎片。Redis跟据存储命令参数，会把带过期时间的数据单独存放在一起，并把它们称为临时数据，非临时数据是永远不会被剔除的，即便物理内存不够，导致swap也不会剔除任何非临时数据（但会尝试剔除部分临时数据）。</p>
<p>我们描述Redis为内存数据库，作为缓存服务，大量使用内存间的数据快速读写，支持高并发大吞吐；而作为数据库，则是指Redis对缓存的持久化支持。Redis由于支持了非常丰富的内存数据库结构类型，如何把这些复杂的内存组织方式持久化到磁盘上？Redis的持久化与传统数据库的方式差异较大，Redis一共支持四种持久化方式，主要使用的两种：</p>
<ul>
<li><strong>定时快照方式(snapshot)</strong>：该持久化方式实际是在Redis内部一个定时器事件，每隔固定时间去检查当前数据发生的改变次数与时间是否满足配置的持久化触发的条件，如果满足则通过操作系统fork调用来创建出一个子进程，这个子进程默认会与父进程共享相同的地址空间，这时就可以通过子进程来遍历整个内存来进行存储操作，而主进程则仍然可以提供服务，当有写入时由操作系统按照内存页（page）为单位来进行copy-on-write保证父子进程之间不会互相影响。它的缺点是快照只是代表一段时间内的内存映像，所以系统重启会丢失上次快照与重启之间所有的数据。</li>
<li><strong>基于语句追加文件的方式(aof)</strong>：aof方式实际类似MySQl的基于语句的binlog方式，即每条会使Redis内存数据发生改变的命令都会追加到一个log文件中，也就是说这个log文件就是Redis的持久化数据。<br>aof的方式的<strong>主要缺点</strong>是追加log文件可能导致体积过大，当系统重启恢复数据时如果是aof的方式则加载数据会非常慢，几十G的数据可能需要几小时才能加载完，当然这个耗时并不是因为磁盘文件读取速度慢，而是由于读取的所有命令都要在内存中执行一遍。另外由于每条命令都要写log，所以使用aof的方式，Redis的读写性能也会有所下降。</li>
</ul>
<p>Redis的持久化使用了Buffer I/O，所谓Buffer I/O是指Redis对持久化文件的写入和读取操作都会使用物理内存的Page Cache，而大多数数据库系统会使用Direct I/O来绕过这层Page Cache并自行维护一个数据的Cache。而当Redis的持久化文件过大（尤其是快照文件），并对其进行读写时，磁盘文件中的数据都会被加载到物理内存中作为操作系统对该文件的一层Cache，而这层Cache的数据与Redis内存中管理的数据实际是重复存储的。虽然内核在物理内存紧张时会做Page Cache的剔除工作，但内核很可能认为某块Page Cache更重要，而让你的进程开始Swap，这时你的系统就会开始出现不稳定或者崩溃了，因此在持久化配置后，针对内存使用需要实时监控观察。</p>
<p>与memcached客户端支持分布式方案不同，Redis更倾向于在服务端构建分布式存储，如图10、11。<br><img src="/2017/09/21/Cache-缓存那些事/redis分布式集群图1.png" alt="redis分布式集群图1.png" title=""><br>图10 Redis分布式集群图1<br><img src="/2017/09/21/Cache-缓存那些事/redis分布式集群图2.png" alt="redis分布式集群图2.png" title=""><br>图11 Redis分布式集群图2</p>
<p>Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，具有线性可伸缩的功能。如图11，其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个key的数值域分成4096个hash槽，每个节点上可以存储一个或多个hash槽，也就是说当前Redis Cluster支持的最大节点数就是4096。Redis Cluster使用的分布式算法也很简单：crc16( key ) % HASH_SLOTS_NUMBER。整体设计可总结为：</p>
<ul>
<li>数据hash分布在不同的Redis节点实例上；</li>
<li>M/S的切换采用Sentinel；</li>
<li>写：只会写master Instance，从sentinel获取当前的master Instance；</li>
<li>读：从Redis Node中基于权重选取一个Redis Instance读取，失败/超时则轮询其他Instance；Redis本身就很好的支持读写分离，在单进程的I/O场景下，可以有效的避免主库的阻塞风险；</li>
<li>通过RPC服务访问，RPC server端封装了Redis客户端，客户端基于Jedis开发。</li>
</ul>
<p>可以看到，通过集群+主从结合的设计，Redis在扩展和稳定高可用性能方面都是比较成熟的。但是，在数据一致性问题上，Redis没有提供CAS操作命令来保障高并发场景下的数据一致性问题，不过它却提供了事务的功能，Redis的Transactions提供的并不是严格的ACID的事务（比如一串用EXEC提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行）。但是这个Transactions还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行）。Redis还提供了一个Watch功能，你可以对一个key进行Watch，然后再执行Transactions，在这过程中，如果这个Watched的值进行了修改，那么这个Transactions会发现并拒绝执行。在失效策略上，Redis支持多大6种的数据<strong>淘汰策略</strong>：</p>
<ul>
<li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰；</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰；</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 ；</li>
<li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰；</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰；</li>
<li>no-enviction（驱逐）：禁止驱逐数据。</li>
</ul>
<p>个人总结了以下多种<strong>Web应用场景</strong>，在这些场景下可以充分的利用Redis的特性，大大提高效率。</p>
<ul>
<li>在主页中显示最新的项目列表：Redis使用的是常驻内存的缓存，速度非常快。LPUSH用来插入一个内容ID，作为关键字存储在列表头部。LTRIM用来限制列表中的项目数最多为5000。如果用户需要的检索的数据量超越这个缓存容量，这时才需要把请求发送到数据库。</li>
<li>删除和过滤：如果一篇文章被删除，可以使用LREM从缓存中彻底清除掉。</li>
<li>排行榜及相关问题：排行榜（leader board）按照得分进行排序。ZADD命令可以直接实现这个功能，而ZREVRANGE命令可以用来按照得分来获取前100名的用户，ZRANK可以用来获取用户排名，非常直接而且操作容易。</li>
<li>按照用户投票和时间排序：排行榜，得分会随着时间变化。LPUSH和LTRIM命令结合运用，把文章添加到一个列表中。一项后台任务用来获取列表，并重新计算列表的排序，ZADD命令用来按照新的顺序填充生成列表。列表可以实现非常快速的检索，即使是负载很重的站点。</li>
<li>过期项目处理：使用Unix时间作为关键字，用来保持列表能够按时间排序。对current_time和time_to_live进行检索，完成查找过期项目的艰巨任务。另一项后台任务使用ZRANGE…WITHSCORES进行查询，删除过期的条目。</li>
<li>计数：进行各种数据统计的用途是非常广泛的，比如想知道什么时候封锁一个IP地址。INCRBY命令让这些变得很容易，通过原子递增保持计数；GETSET用来重置计数器；过期属性用来确认一个关键字什么时候应该删除。</li>
<li>特定时间内的特定项目：这是特定访问者的问题，可以通过给每次页面浏览使用SADD命令来解决。SADD不会将已经存在的成员添加到一个集合。</li>
<li>Pub/Sub：在更新中保持用户对数据的映射是系统中的一个普遍任务。Redis的pub/sub功能使用了SUBSCRIBE、UNSUBSCRIBE和PUBLISH命令，让这个变得更加容易。</li>
<li>队列：在当前的编程中队列随处可见。除了push和pop类型的命令之外，Redis还有阻塞队列的命令，能够让一个程序在执行时被另一个程序添加到队列。</li>
</ul>
<h2 id="缓存实战"><a href="#缓存实战" class="headerlink" title="缓存实战"></a>缓存实战</h2><p>实际工程中，对于缓存的应用可以有多种的实战方式，包括侵入式硬编码，抽象服务化应用，以及轻量的注解式使用等。本文将主要介绍下注解式方式。</p>
<h3 id="Spring注解缓存"><a href="#Spring注解缓存" class="headerlink" title="Spring注解缓存"></a>Spring注解缓存</h3><p>Spring 3.1之后，引入了注解缓存技术，其本质上不是一个具体的缓存实现方案，而是一个对缓存使用的抽象，通过在既有代码中添加少量自定义的各种annotation，即能够达到使用缓存对象和缓存方法的返回对象的效果。Spring的缓存技术具备相当的灵活性，不仅能够使用SpEL（Spring Expression Language）来定义缓存的key和各种condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存集成。其特点总结如下：</p>
<ul>
<li>少量的配置annotation注释即可使得既有代码支持缓存；</li>
<li>支持开箱即用，不用安装和部署额外的第三方组件即可使用缓存；</li>
<li>支持Spring Express Language（SpEL），能使用对象的任何属性或者方法来定义缓存的key和使用规则条件；</li>
<li>支持自定义key和自定义缓存管理者，具有相当的灵活性和可扩展性。</li>
</ul>
<p>和Spring的事务管理类似，Spring Cache的关键原理就是Spring AOP，通过Spring AOP实现了在方法调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。而Spring Cache利用了Spring AOP的动态代理技术，即当客户端尝试调用pojo的foo()方法的时候，给它的不是pojo自身的引用，而是一个动态生成的代理类。</p>
<img src="/2017/09/21/Cache-缓存那些事/spring动态代理调用图.png" alt="spring动态代理调用图.png" title="">
<p>图12 Spring动态代理调用图</p>
<p>如图12所示，实际客户端获取的是一个代理的引用，在调用foo()方法的时候，会首先调用proxy的foo()方法，这个时候proxy可以整体控制实际的pojo.foo()方法的入参和返回值，比如缓存结果，比如直接略过执行实际的foo()方法等，都是可以轻松做到的。Spring Cache主要使用三个注释标签，即@Cacheable、@CachePut和@CacheEvict，主要针对方法上注解使用，部分场景也可以直接类上注解使用，当在类上使用时，该类所有方法都将受影响。我们总结一下其作用和配置方法，如表1所示。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th style="text-align:left">标签类型</th>
<th style="text-align:left">作用</th>
<th style="text-align:left">主要配置参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">@Cacheable</td>
<td style="text-align:left">主要针对方法配置，能够根据方法的请求参数对其结果进行缓存</td>
<td style="text-align:left">value：缓存的名称，在 Spring 配置文件中定义，必须指定至少一个； key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合； condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存</td>
</tr>
<tr>
<td style="text-align:left">@CachePut</td>
<td style="text-align:left">主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用</td>
<td style="text-align:left">value：缓存的名称，在 spring 配置文件中定义，必须指定至少一个; key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合； condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存</td>
</tr>
<tr>
<td style="text-align:left">@CacheEvict</td>
<td style="text-align:left">主要针对方法配置，能够根据一定的条件对缓存进行清空</td>
<td style="text-align:left">value：缓存的名称，在 Spring 配置文件中定义，必须指定至少一个； key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合； condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存； allEntries：是否清空所有缓存内容，默认为 false，如果指定为 true，则方法调用后将立即清空所有缓存； beforeInvocation：是否在方法执行前就清空，默认为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，默认情况下，如果方法执行抛出异常，则不会清空缓存</td>
</tr>
</tbody>
</table>
<p>可扩展支持：Spring注解cache能够满足一般应用对缓存的需求，但随着应用服务的复杂化，大并发高可用性能要求下，需要进行一定的扩展，这时对其自身集成的缓存方案可能不太适用，该怎么办？Spring预先有考虑到这点，那么怎样利用Spring提供的扩展点实现我们自己的缓存，且在不改变原来已有代码的情况下进行扩展？是否在方法执行前就清空，默认为false，如果指定为true，则在方法还没有执行的时候就清空缓存，默认情况下，如果方法执行抛出异常，则不会清空缓存。</p>
<p>这基本能够满足一般应用对缓存的需求，但现实总是很复杂，当你的用户量上去或者性能跟不上，总需要进行扩展，这个时候你或许对其提供的内存缓存不满意了，因为其不支持高可用性，也不具备持久化数据能力，这个时候，你就需要自定义你的缓存方案了，还好，Spring也想到了这一点。</p>
<p>我们先不考虑如何持久化缓存，毕竟这种第三方的实现方案很多，我们要考虑的是，怎么利用Spring提供的扩展点实现我们自己的缓存，且在不改原来已有代码的情况下进行扩展。这需要简单的三步骤，首先需要提供一个CacheManager接口的实现（继承至AbstractCacheManager），管理自身的cache实例；其次，实现自己的cache实例MyCache(继承至Cache)，在这里面引入我们需要的第三方cache或自定义cache；最后就是对配置项进行声明，将MyCache实例注入CacheManager进行统一管理。</p>
<p>ref:<br><a href="https://tech.meituan.com/cache_about.html" target="_blank" rel="external">https://tech.meituan.com/cache_about.html</a></p>
]]></content>
      <categories>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Transaction-分布式系统的事务处理</title>
    <url>/2017/09/21/Transaction-%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>分布式事务中的问题及相应的解决方案和算法</p>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>当我们在生产线上用一台服务器来提供数据服务的时候,我会遇到如下的两个问题:</p>
<ol>
<li>一台服务器的性能不足以提供足够的能力服务于所有的网络请求。</li>
<li>我们总是害怕我们的这台服务器停机,造成服务不可用或是数据丢失。</li>
</ol>
<p>于是我们不得不对我们的服务器进行扩展,加入更多的机器来分担性能上的问题,以及来解决单点故障问题。 通常,我们会通过两种手段来扩展我们的数据服务:</p>
<ol>
<li><strong>数据分区</strong>:就是把数据分块放在不同的服务器上(如:uid % 16,一致性哈希等)。</li>
<li><strong>数据镜像</strong>:让所有的服务器都有相同的数据,提供相当的服务。</li>
</ol>
<p>对于第一种情况,我们无法解决数据丢失的问题,单台服务器出问题时,会有部分数据丢失。所以,<strong>数据服务的高可用性只能通过第二种方法来完成——数据的冗余存储</strong>(一般工业界认为比较安全的备份数应该是3份,如:Hadoop和Dynamo)。 但是,<strong>加入更多的机器,会让我们的数据服务变得很复杂,尤其是跨服务器的事务处理,也就是跨服务器的数据一致性</strong>。这个是一个很难的问题。 让我们用最经典的Use Case:“A帐号向B帐号汇钱”来说明一下,熟悉RDBMS事务的都知道从帐号A到帐号B需要6个操作:</p>
<ol>
<li>从A帐号中把余额读出来。</li>
<li>对A帐号做减法操作。</li>
<li>把结果写回A帐号中。</li>
<li>从B帐号中把余额读出来。</li>
<li>对B帐号做加法操作。</li>
<li>把结果写回B帐号中。</li>
</ol>
<p>为了数据的一致性,这6件事,要么都成功做完,要么都不成功,而且这个操作的过程中,对A、B帐号的其它访问必需锁死,所谓锁死就是要排除其它的读写操作,不然会有脏数据的问题,这就是事务。那么,我们在加入了更多的机器后,这个事情会变得复杂起来:</p>
<ol>
<li>在<strong>数据分区</strong>的方案中:如果A帐号和B帐号的数据不在同一台服务器上怎么办？我们需要一个跨机器的事务处理。也就是说,如果A的扣钱成功了,但B的加钱不成功,我们还要把A的操作给回滚回去。这在跨机器的情况下,就变得比较复杂了。</li>
<li>在<strong>数据镜像</strong>的方案中:A帐号和B帐号间的汇款是可以在一台机器上完成的,但是别忘了我们有多台机器存在A帐号和B帐号的副本。如果对A帐号的汇钱有两个并发操作(要汇给B和C),这两个操作发生在不同的两台服务器上怎么办？也就是说,在数据镜像中,在不同的服务器上对同一个数据的写操作怎么保证其一致性,保证数据不冲突？</li>
</ol>
<p>同时,我们还要考虑性能的因素,如果不考虑性能的话,事务得到保证并不困难,系统慢一点就行了。除了考虑性能外,我们还要考虑可用性,也就是说,一台机器没了,数据不丢失,服务可由别的机器继续提供。 于是,我们需要重点考虑下面的这么几个情况:</p>
<ul>
<li><strong>容灾</strong>:数据不丢、结点的Failover</li>
<li><strong>数据的一致性</strong>:事务处理</li>
<li><strong>性能</strong>:吞吐量 、 响应时间</li>
</ul>
<p>前面说过,要解决数据不丢,只能通过数据冗余的方法,就算是数据分区,每个区也需要进行数据冗余处理。这就是数据副本:当出现某个节点的数据丢失时可以从副本读到,数据副本是分布式系统解决数据丢失异常的唯一手段。所以,在这篇文章中,简单起见,我们只讨论在数据冗余情况下考虑数据的一致性和性能的问题。简单说来:</p>
<ol>
<li>要想让数据有高可用性,就得写多份数据。</li>
<li>写多份的问题会导致数据一致性的问题。</li>
<li>数据一致性的问题又会引发性能问题</li>
</ol>
<p>这就是软件开发,按下了葫芦起了瓢。</p>
<h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><p>说起数据一致性来说,简单说有三种类型(当然,如果细分的话,还有很多一致性模型,如:顺序一致性,FIFO一致性,会话一致性,单读一致性,单写一致性,但为了本文的简单易读,我只说下面三种):</p>
<ol>
<li>Weak 弱一致性:当你写入一个新值后,读操作在数据副本上可能读出来,也可能读不出来。比如:某些cache系统,网络游戏其它玩家的数据和你没什么关系,VOIP这样的系统,或是百度搜索引擎(呵呵)。</li>
<li>Eventually 最终一致性:当你写入一个新值后,有可能读不出来,但在某个时间窗口之后保证最终能读出来。比如:DNS,电子邮件、Amazon S3,Google搜索引擎这样的系统。</li>
<li>Strong 强一致性:新的数据一旦写入,在任意副本任意时刻都能读到新值。比如:文件系统,RDBMS,Azure Table都是强一致性的。</li>
</ol>
<p>从这三种一致型的模型上来说,我们可以看到,Weak和Eventually一般来说是异步冗余的,而Strong一般来说是同步冗余的,异步的通常意味着更好的性能,但也意味着更复杂的状态控制。同步意味着简单,但也意味着性能下降。 好,让我们由浅入深,一步一步地来看有哪些技术</p>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="Master-Slave"><a href="#Master-Slave" class="headerlink" title="Master-Slave"></a>Master-Slave</h3><p>首先是Master-Slave结构,对于这种加构,Slave一般是Master的备份。在这样的系统中,一般是如下设计的:</p>
<ol>
<li>读写请求都由Master负责。</li>
<li>写请求写到Master上后,由Master同步到Slave上。</li>
</ol>
<p>从Master同步到Slave上,你可以使用异步,也可以使用同步,可以使用Master来push,也可以使用Slave来pull。 通常来说是Slave来周期性的pull,所以,是最终一致性。这个设计的问题是,如果Master在pull周期内垮掉了,那么会导致这个时间片内的数据丢失。如果你不想让数据丢掉,Slave只能成为Read-Only的方式等Master恢复。</p>
<p>当然,如果你可以容忍数据丢掉的话,你可以马上让Slave代替Master工作(对于只负责计算的结点来说,没有数据一致性和数据丢失的问题,Master-Slave的方式就可以解决单点问题了) 当然,Master Slave也可以是强一致性的, 比如:当我们写Master的时候,Master负责先写自己,等成功后,再写Slave,两者都成功后返回成功,整个过程是同步的,如果写Slave失败了,那么两种方法,一种是标记Slave不可用报错并继续服务(等Slave恢复后同步Master的数据,可以有多个Slave,这样少一个,还有备份,就像前面说的写三份那样),另一种是回滚自己并返回写失败。(注:一般不先写Slave,因为如果写Master自己失败后,还要回滚Slave,此时如果回滚Slave失败,就得手工订正数据了)你可以看到,如果Master-Slave需要做成强一致性有多复杂。</p>
<h3 id="Master-Master"><a href="#Master-Master" class="headerlink" title="Master-Master"></a>Master-Master</h3><p>Master-Master,又叫<a href="http://en.wikipedia.org/wiki/Multi-master_replication" target="_blank" rel="external">Multi-master</a>,是指一个系统存在两个或多个Master,每个Master都提供read-write服务。这个模型是Master-Slave的加强版,数据间同步一般是通过Master间的异步完成,所以是最终一致性。 Master-Master的好处是,一台Master挂了,别的Master可以正常做读写服务,他和Master-Slave一样,当数据没有被复制到别的Master上时,数据会丢失。很多数据库都支持Master-Master的Replication的机制。</p>
<p>另外,如果多个Master对同一个数据进行修改的时候,这个模型的恶梦就出现了——对数据间的冲突合并,这并不是一件容易的事情。看看Dynamo的Vector Clock的设计(记录数据的版本号和修改者)就知道这个事并不那么简单,而且Dynamo对数据冲突这个事是交给用户自己搞的。就像我们的SVN源码冲突一样,对于同一行代码的冲突,只能交给开发者自己来处理。(在本文后后面会讨论一下Dynamo的Vector Clock)</p>
<h3 id="Two-Three-Phase-Commit"><a href="#Two-Three-Phase-Commit" class="headerlink" title="Two/Three Phase Commit"></a>Two/Three Phase Commit</h3><p>这个协议的缩写又叫2PC,中文叫两阶段提交。在分布式系统中,每个节点虽然可以知晓自己的操作时成功或者失败,却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时,为了保持事务的ACID特性,需要引入一个作为<strong>协调者</strong>的组件来统一掌控所有节点(称作<strong>参与者</strong>)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。 两阶段提交的算法如下:</p>
<h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段:"></a>第一阶段:</h4><ol>
<li>协调者会问所有的参与者结点,是否可以执行提交操作。</li>
<li>各个参与者开始事务执行的准备工作:如:为资源上锁,预留资源,写undo/redo log……</li>
<li>参与者响应协调者,如果事务的准备工作成功,则回应“可以提交”,否则回应“拒绝提交”。</li>
</ol>
<h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段:"></a>第二阶段:</h4><ul>
<li>如果所有的参与者都回应“可以提交”,那么,协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交,并释放所有资源,然后回应“完成”,协调者收集各结点的“完成”回应后结束这个Global Transaction。</li>
<li>如果有一个参与者回应“拒绝提交”,那么,协调者向所有的参与者发送“回滚操作”,并释放所有资源,然后回应“回滚完成”,协调者收集各结点的“回滚”回应后,取消这个Global Transaction。</li>
</ul>
<img src="/2017/09/21/Transaction-分布式系统的事务处理/Two-phase_commit.png" alt="Two-phase_commit.png" title="">
<p>我们可以看到,<strong>2PC说白了就是第一阶段做Vote,第二阶段做决定的一个算法</strong>,也可以看到2PC这个事是强一致性的算法。在前面我们讨论过Master-Slave的强一致性策略,和2PC有点相似,只不过2PC更为保守一些——先尝试再提交。 2PC用的是比较多的,在一些系统设计中,会串联一系列的调用,比如:A -&gt; B -&gt; C -&gt; D,每一步都会分配一些资源或改写一些数据。比如我们B2C网上购物的下单操作在后台会有一系列的流程需要做。如果我们一步一步地做,就会出现这样的问题,如果某一步做不下去了,那么前面每一次所分配的资源需要做反向操作把他们都回收掉,所以,操作起来比较复杂。现在很多处理流程(Workflow)都会借鉴2PC这个算法,使用 try -&gt; confirm的流程来确保整个流程的能够成功完成。 举个通俗的例子,西方教堂结婚的时候,都有这样的桥段:</p>
<ol>
<li>牧师分别问新郎和新娘:你是否愿意……不管生老病死……(询问阶段)</li>
<li>当新郎和新娘都回答愿意后(锁定一生的资源),牧师就会说:我宣布你们……(事务提交)</li>
</ol>
<p>这是多么经典的一个两阶段提交的事务处理。 另外,我们也可以看到其中的一些问题, A)其中一个是同步阻塞操作,这个事情必然会非常大地影响性能。 B)另一个主要的问题是在TimeOut上,比如,</p>
<ol>
<li>如果第一阶段中,参与者没有收到询问请求,或是参与者的回应没有到达协调者。那么,需要协调者做超时处理,一旦超时,可以当作失败,也可以重试。</li>
<li>如果第二阶段中,正式提交发出后,如果有的参与者没有收到,或是参与者提交/回滚后的确认信息没有返回,一旦参与者的回应超时,要么重试,要么把那个参与者标记为问题结点剔除整个集群,这样可以保证服务结点都是数据一致性的。</li>
<li>糟糕的情况是,第二阶段中,如果参与者收不到协调者的commit/fallback指令,参与者将处于“状态未知”阶段,参与者完全不知道要怎么办,比如:如果所有的参与者完成第一阶段的回复后(可能全部yes,可能全部no,可能部分yes部分no),如果协调者在这个时候挂掉了。那么所有的结点完全不知道怎么办(问别的参与者都不行)。为了一致性,要么死等协调者,要么重发第一阶段的yes/no命令。</li>
</ol>
<p>两段提交最大的问题就是第3)项,<strong>如果第一阶段完成后,参与者在第二阶没有收到决策,那么数据结点会进入“不知所措”的状态,这个状态会block住整个事务</strong>。也就是说,协调者Coordinator对于事务的完成非常重要,Coordinator的可用性是个关键。 因些,我们引入三段提交,三段提交在<a href="http://en.wikipedia.org/wiki/Three-phase_commit_protocol" target="_blank" rel="external">Wikipedia</a>上的描述如下,他把二段提交的第一个段break成了两段:询问,然后再锁资源。最后真正提交。三段提交的示意图如下:<br><img src="/2017/09/21/Transaction-分布式系统的事务处理/Three-phase_commit_diagram.png" alt="Three-phase_commit_diagram.png" title=""><br>三段提交的核心理念是:<strong>在询问的时候并不锁定资源,除非所有人都同意了,才开始锁资源</strong>。</p>
<p>理论上来说,如果第一阶段所有的结点返回成功,那么有理由相信成功提交的概率很大。这样一来,可以降低参与者Cohorts的状态未知的概率。也就是说,一旦参与者收到了PreCommit,意味他知道大家其实都同意修改了。这一点很重要。下面我们来看一下3PC的状态迁移图:(注意图中的虚线,那些F,T是Failuer或Timeout,其中的:状态含义是 q – Query,a – Abort,w – Wait,p – PreCommit,c – Commit)</p>
<img src="/2017/09/21/Transaction-分布式系统的事务处理/Three-phase_commit_status.png" alt="Three-phase_commit_status.png" title="">
<p>从上图的状态变化图我们可以从虚线(那些F,T是Failuer或Timeout)看到——<strong>如果结点处在P状态(PreCommit)的时候发生了F/T的问题,三段提交比两段提交的好处是,三段提交可以继续直接把状态变成C状态(Commit),而两段提交则不知所措</strong>。</p>
<p>其实,三段提交是一个很复杂的事情,实现起来相当难,而且也有一些问题。</p>
<p>看到这里,我相信你有很多很多的问题,你一定在思考2PC/3PC中各种各样的失败场景,你会发现Timeout是个非常难处理的事情,因为网络上的Timeout在很多时候让你无所事从,你也不知道对方是做了还是没有做。于是你好好的一个状态机就因为Timeout成了个摆设。</p>
<p><strong>一个网络服务会有三种状态:1)Success,2)Failure,3)Timeout,第三个绝对是恶梦,尤其在你需要维护状态的时候</strong>。</p>
<h3 id="Two-Generals-Problem-两将军问题"><a href="#Two-Generals-Problem-两将军问题" class="headerlink" title="Two Generals Problem(两将军问题)"></a>Two Generals Problem(两将军问题)</h3><p><a href="http://en.wikipedia.org/wiki/Two_Generals&#39;_Problem" target="_blank" rel="external">Two Generals Problem</a> 两将军问题是这么一个思维性实验问题: 有两支军队,它们分别有一位将军领导,现在准备攻击一座修筑了防御工事的城市。这两支军队都驻扎在那座城市的附近,分占一座山头。一道山谷把两座山分隔开来,并且两位将军唯一的通信方式就是派各自的信使来往于山谷两边。不幸的是,这个山谷已经被那座城市的保卫者占领,并且存在一种可能,那就是任何被派出的信使通过山谷是会被捕。 请注意,虽然两位将军已经就攻击那座城市达成共识,但在他们各自占领山头阵地之前,并没有就进攻时间达成共识。两位将军必须让自己的军队同时进攻城市才能取得成功。因此,他们必须互相沟通,以确定一个时间来攻击,并同意就在那时攻击。如果只有一个将军进行攻击,那么这将是一个灾难性的失败。 这个思维实验就包括考虑他们如何去做这件事情。下面是我们的思考:</p>
<ol>
<li>第一位将军先发送一段消息“让我们在上午9点开始进攻”。然而,一旦信使被派遣,他是否通过了山谷,第一位将军就不得而知了。任何一点的不确定性都会使得第一位将军攻击犹豫,因为如果第二位将军不能在同一时刻发动攻击,那座城市的驻军就会击退他的军队的进攻,导致他的军对被摧毁。</li>
<li>知道了这一点,第二位将军就需要发送一个确认回条:“我收到您的邮件,并会在9点的攻击。”但是,如果带着确认消息的信使被抓怎么办？所以第二位将军会犹豫自己的确认消息是否能到达。</li>
<li>于是,似乎我们还要让第一位将军再发送一条确认消息——“我收到了你的确认”。然而,如果这位信使被抓怎么办呢？</li>
<li>这样一来,是不是我们还要第二位将军发送一个“确认收到你的确认”的信息。</li>
</ol>
<p>靠,于是你会发现,这事情很快就发展成为不管发送多少个确认消息,都没有办法来保证两位将军有足够的自信自己的信使没有被敌军捕获。<br><img src="/2017/09/21/Transaction-分布式系统的事务处理/two-generals-problems.jpg" alt="two-generals-problems.jpg" title=""></p>
<p>这个问题是无解的。两个将军问题和它的无解证明首先由E.A.Akkoyunlu,K.Ekanadham和R.V.Huber于1975年在《一些限制与折衷的网络通信设计》一文中发表,就在这篇文章的第73页中一段描述两个黑帮之间的通信中被阐明。 1978年,在Jim Gray的《数据库操作系统注意事项》一书中(从第465页开始)被命名为两个将军悖论。作为两个将军问题的定义和无解性的证明的来源,这一参考被广泛提及。</p>
<p>这个实验意在阐明:试图通过建立在一个不可靠的连接上的交流来协调一项行动的隐患和设计上的巨大挑战。</p>
<p>从工程上来说,一个解决两个将军问题的实际方法是使用一个能够承受通信信道不可靠性的方案,并不试图去消除这个不可靠性,但要将不可靠性削减到一个可以接受的程度。比如,第一位将军排出了100位信使并预计他们都被捕的可能性很小。在这种情况下,不管第二位将军是否会攻击或者受到任何消息,第一位将军都会进行攻击。另外,第一位将军可以发送一个消息流,而第二位将军可以对其中的每一条消息发送一个确认消息,这样如果每条消息都被接收到,两位将军会感觉更好。然而我们可以从证明中看出,他们俩都不能肯定这个攻击是可以协调的。他们没有算法可用(比如,收到4条以上的消息就攻击)能够确保防止仅有一方攻击。再者,第一位将军还可以为每条消息编号,说这是1号,2号……直到n号。这种方法能让第二位将军知道通信信道到底有多可靠,并且返回合适的数量的消息来确保最后一条消息被接收到。如果信道是可靠的话,只要一条消息就行了,其余的就帮不上什么忙了。最后一条和第一条消息丢失的概率是相等的。</p>
<p> 两将军问题可以扩展成更变态的<strong>拜占庭将军问题 (Byzantine Generals Problem)</strong>,其故事背景是这样的:拜占庭位于现在土耳其的伊斯坦布尔,是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔,为了防御目的,因此每个军队都分隔很远,将军与将军之间只能靠信差传消息。 在战争的时候,拜占庭军队内所有将军必需达成一致的共识,决定是否有赢的机会才去攻打敌人的阵营。但是,军队可能有叛徒和敌军间谍,这些叛徒将军们会扰乱或左右决策的过程。这时候,在已知有成员谋反的情况下,其余忠诚的将军在不受叛徒的影响下如何达成一致的协议,这就是拜占庭将军问题。</p>
<h3 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h3><p><a href="http://en.wikipedia.org/wiki/Paxos_(computer_science" target="_blank" rel="external">Wikipedia上的各种Paxos算法</a>)的描述非常详细,大家可以去围观一下。</p>
<p>Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致,保证不论发生以上任何异常,都不会破坏决议的一致性。一个典型的场景是,在一个分布式数据库系统中,如果各节点的初始状态一致,每个节点都执行相同的操作序列,那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列,需要在每一条指令上执行一个「一致性算法」以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在许多场景中,是分布式计算中的重要问题。从20世纪80年代起对于一致性算法的研究就没有停止过。</p>
<p><strong>Notes</strong>:Paxos算法是莱斯利·兰伯特(Leslie Lamport,就是 LaTeX 中的”La”,此人现在在微软研究院)于1990年提出的一种基于消息传递的一致性算法。由于算法难以理解起初并没有引起人们的重视,使Lamport在八年后1998年重新发表到ACM Transactions on Computer Systems上(<a href="http://research.microsoft.com/users/lamport/pubs/lamport-paxos.pdf" target="_blank" rel="external">The Part-Time Parliament</a>)。即便如此paxos算法还是没有得到重视,2001年Lamport 觉得同行无法接受他的幽默感,于是用容易接受的方法重新表述了一遍(<a href="http://research.microsoft.com/users/lamport/pubs/paxos-simple.pdf" target="_blank" rel="external">Paxos Made Simple</a>)。可见Lamport对Paxos算法情有独钟。近几年Paxos算法的普遍使用也证明它在分布式一致性算法中的重要地位。2006年Google的三篇论文初现“云”的端倪,其中的Chubby Lock服务使用Paxos作为Chubby Cell中的一致性算法,Paxos的人气从此一路狂飙。(Lamport 本人在 <a href="http://research.microsoft.com/users/lamport/pubs/pubs.html#lamport-paxos" target="_blank" rel="external">他的blog</a> 中描写了他用9年时间发表这个算法的前前后后)</p>
<p>注:Amazon的AWS中,所有的云服务都基于一个ALF(Async Lock Framework)的框架实现的,这个ALF用的就是Paxos算法。我在Amazon的时候,看内部的分享视频时,设计者在内部的Principle Talk里说他参考了ZooKeeper的方法,但他用了另一种比ZooKeeper更易读的方式实现了这个算法。</p>
<p>简单说来,Paxos的目的是让整个集群的结点对某个值的变更达成一致。Paxos算法基本上来说是个民主选举的算法——大多数的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案,是否通过这个提案取决于这个集群中是否有超过半数的结点同意(所以Paxos算法需要集群中的结点是单数)。</p>
<p>这个算法有两个阶段(假设这个有三个结点:A,B,C):</p>
<p>第一阶段:Prepare阶段</p>
<p>A把申请修改的请求Prepare Request发给所有的结点A,B,C。注意,Paxos算法会有一个Sequence Number(你可以认为是一个提案号,这个数不断递增,而且是唯一的,也就是说A和B不可能有相同的提案号),这个提案号会和修改请求一同发出,任何结点在“Prepare阶段”时都会拒绝其值小于当前提案号的请求。所以,结点A在向所有结点申请修改请求的时候,需要带一个提案号,越新的提案,这个提案号就越是是最大的。</p>
<p>如果接收结点收到的提案号n大于其它结点发过来的提案号,这个结点会回应Yes(本结点上最新的被批准提案号),并保证不接收其它 &lt; n的提案。这样一来,结点上在Prepare阶段里总是会对最新的提案做承诺。</p>
<p>优化:在上述 prepare 过程中,如果任何一个结点发现存在一个更高编号的提案,则需要通知 提案人,提醒其中断这次提案。</p>
<p>第二阶段:Accept阶段</p>
<p>如果提案者A收到了超过半数的结点返回的Yes,然后他就会向所有的结点发布Accept Request(同样,需要带上提案号n),如果没有超过半数的话,那就返回失败。</p>
<p>当结点们收到了Accept Request后,如果对于接收的结点来说,n是最大的了,那么,它就会修改这个值,如果发现自己有一个更大的提案号,那么,结点就会拒绝修改。</p>
<p>我们可以看以,这似乎就是一个“两段提交”的优化。其实,2PC/3PC都是分布式一致性算法的残次版本,Google Chubby的作者Mike Burrows说过这个世界上只有一种一致性算法,那就是Paxos,其它的算法都是残次品。</p>
<p>我们还可以看到:对于同一个值的在不同结点的修改提案就算是在接收方被乱序收到也是没有问题的。</p>
<p>关于一些实例,你可以看一下Wikipedia中文中的“Paxos样例”一节,我在这里就不再多说了。对于Paxos算法中的一些异常示例,大家可以自己推导一下。你会发现基本上来说只要保证有半数以上的结点存活,就没有什么问题。</p>
<p>多说一下,自从Lamport在1998年发表Paxos算法后,对Paxos的各种改进工作就从未停止,其中动作最大的莫过于2005年发表的<a href="http://research.microsoft.com/apps/pubs/default.aspx?id=64624" target="_blank" rel="external">Fast Paxos</a>。无论何种改进,其重点依然是在消息延迟与性能、吞吐量之间作出各种权衡。为了容易地从概念上区分二者,称前者Classic Paxos,改进后的后者为Fast Paxos。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下图来自:Google App Engine的co-founder Ryan Barrett在2009年的google i/o上的演讲《<a href="http://snarfed.org/transactions_across_datacenters_io.html" target="_blank" rel="external">Transaction Across DataCenter</a>》(视频: <a href="http://www.youtube.com/watch?v=srOgpXECblk" target="_blank" rel="external">http://www.youtube.com/watch?v=srOgpXECblk</a>)<br><img src="/2017/09/21/Transaction-分布式系统的事务处理/Transaction-Across-DataCenter.jpg" alt="Transaction-Across-DataCenter.jpg" title=""><br>前面,我们说过,要想让数据有高可用性,就需要冗余数据写多份。写多份的问题会带来一致性的问题,而一致性的问题又会带来性能问题。从上图我们可以看到,我们基本上来说不可以让所有的项都绿起来,这就是著名的CAP理论:一致性,可用性,分区容忍性,你只可能要其中的两个。</p>
<h2 id="NWR模型"><a href="#NWR模型" class="headerlink" title="NWR模型"></a>NWR模型</h2><p><strong>最后我还想提一下Amazon Dynamo的NWR模型。这个NWR模型把CAP的选择权交给了用户,让用户自己的选择你的CAP中的哪两个</strong>。</p>
<p>所谓NWR模型。N代表N个备份,W代表要写入至少W份才认为成功,R表示至少读取R个备份。<strong>配置的时候要求W+R &gt; N</strong>。 因为W+R &gt; N, 所以 R &gt; N-W 这个是什么意思呢？就是读取的份数一定要比总备份数减去确保写成功的倍数的差值要大。</p>
<p>也就是说,每次读取,都至少读取到一个最新的版本。从而不会读到一份旧数据。当我们需要高可写的环境的时候,我们可以配置W = 1 如果N=3 那么R = 3。 这个时候只要写任何节点成功就认为成功,但是读的时候必须从所有的节点都读出数据。如果我们要求读的高效率,我们可以配置 W=N R=1。这个时候任何一个节点读成功就认为成功,但是写的时候必须写所有三个节点成功才认为成功。</p>
<p>NWR模型的一些设置会造成脏数据的问题,因为这很明显不是像Paxos一样是一个强一致的东西,所以,可能每次的读写操作都不在同一个结点上,于是会出现一些结点上的数据并不是最新版本,但却进行了最新的操作。</p>
<p>所以,Amazon Dynamo引了数据版本的设计。也就是说,如果你读出来数据的版本是v1,当你计算完成后要回填数据后,却发现数据的版本号已经被人更新成了v2,那么服务器就会拒绝你。版本这个事就像“乐观锁”一样。</p>
<p>但是,对于分布式和NWR模型来说,版本也会有恶梦的时候——就是版本冲的问题,比如:我们设置了N=3 W=1,如果A结点上接受了一个值,版本由v1 -&gt; v2,但还没有来得及同步到结点B上(异步的,应该W=1,写一份就算成功),B结点上还是v1版本,此时,B结点接到写请求,按道理来说,他需要拒绝掉,但是他一方面并不知道别的结点已经被更新到v2,另一方面他也无法拒绝,因为W=1,所以写一分就成功了。于是,出现了严重的版本冲突。</p>
<p>Amazon的Dynamo把版本冲突这个问题巧妙地回避掉了——版本冲这个事交给用户自己来处理。</p>
<p>于是,Dynamo引入了Vector Clock(矢量钟？!)这个设计。这个设计让每个结点各自记录自己的版本信息,也就是说,对于同一个数据,需要记录两个事:1)谁更新的我,2)我的版本号是什么。</p>
<p>下面,我们来看一个操作序列:<br>1)一个写请求,第一次被节点A处理了。节点A会增加一个版本信息(A,1)。我们把这个时候的数据记做D1(A,1)。 然后另外一个对同样key的请求还是被A处理了于是有D2(A,2)。这个时候,D2是可以覆盖D1的,不会有冲突产生。<br>2)现在我们假设D2传播到了所有节点(B和C),B和C收到的数据不是从客户产生的,而是别人复制给他们的,所以他们不产生新的版本信息,所以现在B和C所持有的数据还是D2(A,2)。于是A,B,C上的数据及其版本号都是一样的。<br>3)如果我们有一个新的写请求到了B结点上,于是B结点生成数据D3(A,2; B,1),意思是:数据D全局版本号为3,A升了两新,B升了一次。这不就是所谓的代码版本的log么？<br>4)如果D3没有传播到C的时候又一个请求被C处理了,于是,以C结点上的数据是D4(A,2; C,1)。<br>5)好,最精彩的事情来了:如果这个时候来了一个读请求,我们要记得,我们的W=1 那么R=N=3,所以R会从所有三个节点上读,此时,他会读到三个版本:</p>
<ul>
<li>A结点:D2(A,2)</li>
<li>B结点:D3(A,2;  B,1);</li>
<li>C结点:D4(A,2;  C,1)<br>6)这个时候可以判断出,D2已经是旧版本(已经包含在D3/D4中),可以舍弃。</li>
</ul>
<p>7)但是D3和D4是明显的版本冲突。于是,交给调用方自己去做版本冲突处理。就像源代码版本管理一样。</p>
<p>很明显,上述的Dynamo的配置用的是CAP里的A和P。</p>
<p>我非常推大家都去看看这篇论文:《<a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/decandia07dynamo.pdf" target="_blank" rel="external">Dynamo:Amazon’s Highly Available Key-Value Store</a>》,如果英文痛苦,你可以看看<a href="http://vdisk.weibo.com/s/AKRQZMLLc1ol" target="_blank" rel="external">译文</a>(译者不详)。</p>
<p>ref:<br><a href="https://coolshell.cn/articles/17416.html" target="_blank" rel="external">https://coolshell.cn/articles/17416.html</a></p>
]]></content>
      <categories>
        <category>Transaction</category>
      </categories>
      <tags>
        <tag>Transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-markdown-plugin-install</title>
    <url>/2017/09/21/Vim-markdown-plugin-install/</url>
    <content><![CDATA[<p>自从用了vim自后恨不得所有文字相关的写作都用vim来解决,最近开始接触markdown,所以网上搜了一圈markdown相关的插件,发现三个插件不错,语法高亮插件<a href="https://github.com/plasticboy/vim-markdown" target="_blank" rel="external">vim-markdown</a>,实时预览插件<a href="https://github.com/suan/vim-instant-markdown" target="_blank" rel="external">vim-instant-markdown</a>和<a href="https://github.com/isnowfy/python-vim-instant-markdown" target="_blank" rel="external">python-vim-instant-markdown</a>.</p>
<a id="more"></a>
<h2 id="vim-markdown插件"><a href="#vim-markdown插件" class="headerlink" title="vim-markdown插件"></a>vim-markdown插件</h2><p>我用的是vundle管理插件,所以修改vim配置文件,添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Plugin &apos;godlygeek/tabular&apos;</div><div class="line">Plugin &apos;plasticboy/vim-markdown&apos;</div></pre></td></tr></table></figure></p>
<p>之后执行<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:PluginInstall</div></pre></td></tr></table></figure></p>
<p>这里作者提到如用vundle管理插件,那么godlygeek/tabular这个插件必须在plasticboy/vim-markdown之前</p>
<p>安装好之后就可以看到语法高亮了(写这篇文章的时候用的是windows的gvim)<br><img src="/2017/09/21/Vim-markdown-plugin-install/1488218-9edc5fd3ca93295f.png" alt="1488218-9edc5fd3ca93295f.png" title=""></p>
<h2 id="vim-instant-markdown插件"><a href="#vim-instant-markdown插件" class="headerlink" title="vim-instant-markdown插件"></a>vim-instant-markdown插件</h2><p>这是一个实时预览的插件,当你用vim打开markdown文档的时候,会自动打开一个浏览器窗口,并且可以实时预览。此插件目前只支持OSX 和 Unix/Linuxes操作系统。</p>
<p>安装之前需要先安装node.js和并且安装了npm,这是作者的原文:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">You first need to have node.js with npm installed.</div><div class="line">[sudo] npm -g install instant-markdown-d</div><div class="line">If you&apos;re on Linux, the xdg-utils package needs to be installed (is installed by default on Ubuntu).</div><div class="line">Copy the after/ftplugin/markdown/instant-markdown.vim file from this repo into your ~/.vim/after/ftplugin/markdown/ (creating directories as necessary), or follow your vim package manager&apos;s instructions.</div><div class="line">Ensure you have the line filetype plugin on in your .vimrc</div><div class="line">Open a markdown file in vim and enjoy!</div></pre></td></tr></table></figure></p>
<p>安装新版的node.js:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo add-apt-repository ppa:chris-lea/node.js</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install nodejs</div></pre></td></tr></table></figure></p>
<p>安装完node.js之后安装instant-markdown-d<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo npm -g install instant-markdown-d</div></pre></td></tr></table></figure></p>
<p>安装vim-instant-markdown插件:</p>
<p>在vim配置文件中添加:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Plugin &apos;suan/vim-instant-markdown&apos;</div></pre></td></tr></table></figure></p>
<p>vim里面执行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:PluginInstall</div></pre></td></tr></table></figure></p>
<p>安装完成后,只要vim打开了markdown类型的文件就会自动打开一个浏览器窗口实时预览</p>
<h2 id="python-vim-instant-markdown插件"><a href="#python-vim-instant-markdown插件" class="headerlink" title="python-vim-instant-markdown插件"></a>python-vim-instant-markdown插件</h2><p>python-vim-instant-markdown插件是用python写的,windows,linux都可以使用,安装这个插件需要python2支持,查看vim是否有python支持:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim --version | grep +python</div></pre></td></tr></table></figure></p>
<p>windows下的gvim已经有python2和python3的支持,只需要安装python2.7就可以使用。</p>
<p>安装依赖:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">pip install markdown</div><div class="line">pip install pygemnts</div></pre></td></tr></table></figure></p>
<h3 id="vundle安装"><a href="#vundle安装" class="headerlink" title="vundle安装:"></a>vundle安装:</h3><p>vim配置文件添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Plugin &apos;isnowfy/python-vim-instant-markdown&apos;</div></pre></td></tr></table></figure></p>
<p>进入vim中执行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:PluginInstall</div></pre></td></tr></table></figure></p>
<h3 id="直接安装"><a href="#直接安装" class="headerlink" title="直接安装:"></a>直接安装:</h3><p>将md_instant.vim和md_instant文件夹放到~/.vim/plugin/目录下,windows是vim安装目录的vimfiles/plugin文件夹。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>打开vim打开markdown文件后执行 <strong>:Instantmd</strong> 命令会自动打开一个浏览器窗口进行实时预览,如果浏览器没有自动打开窗口,可以访问<a href="http://localhost:7000/。" target="_blank" rel="external">http://localhost:7000/。</a></p>
<h2 id="markdown-preview"><a href="#markdown-preview" class="headerlink" title="markdown-preview"></a>markdown-preview</h2><p>一个国人写的预览插件,觉得不错支持windows,还可以同步滚动<br>详情看github:<a href="https://github.com/iamcco/markdown-preview.vim" target="_blank" rel="external">https://github.com/iamcco/markdown-preview.vim</a></p>
<p>ref:<a href="http://www.jianshu.com/p/24aefcd4ca93" target="_blank" rel="external">http://www.jianshu.com/p/24aefcd4ca93</a></p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-problem-python-compatibility</title>
    <url>/2017/09/21/Vim-problem-python-compatibility/</url>
    <content><![CDATA[<p>Solution about python compatibility with Vim.</p>
<a id="more"></a>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>环境:Win7 x64</p>
<p>从 gVim 7.4 的安装目录 /path/to/Vim/Vim74/autoload 下的 pythoncomplete.vim 看出,Vim 在这个版本已经默认内置了对 Python 的自动补全的支持。然而我在自己的笔记本上用得很好的配置,同样的、_vimrc 和插件平移到工作机上以后就出问题了, <c-x><c-o> 的时候 gVim 底部提示:</c-o></c-x></p>
<p>Error: Required vim compiled with +python<br>E117: Unknown function: pythoncomplete#Complete</p>
<p>安装其他插件比如(markdown)时也有类似问题</p>
<h2 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h2><h3 id="排查-Vim-版本编译时的-Python-支持"><a href="#排查-Vim-版本编译时的-Python-支持" class="headerlink" title="排查 Vim 版本编译时的 Python 支持"></a>排查 Vim 版本编译时的 Python 支持</h3><p>根据上面的错误提示,首先想到的是 gVim 编译时未加入 +python 选项。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim --version</div></pre></td></tr></table></figure></p>
<img src="/2017/09/21/Vim-problem-python-compatibility/vim-without-python.png" alt="vim-without-python.png" title="">
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gvim --version</div></pre></td></tr></table></figure>
<img src="/2017/09/21/Vim-problem-python-compatibility/gvim-with-python.png" alt="gvim-with-python.png" title="">
<p>由此看出,在 Vim.org 下载的 Windows 版 gVim 的 Vim 编译时倒确实未启用 Python 支持,但是 gVim 启用了。我明明使用的是 gVim,不是 Vim 呀！难道 gVim 其实只是一个调用 Vim 的壳？上 Vim.org 找了半天,从描述上没看出来提供的几个 MS-Windows 安装包的 Python 支持的相关说明,下载了一个与之前下载的版本不同的版本安装了,结果还是与上面一样,笔记本上都可以做到,那应该不是 gVim 版本的问题。</p>
<h3 id="验证-gVim-的-Python-支持"><a href="#验证-gVim-的-Python-支持" class="headerlink" title="验证 gVim 的 Python 支持"></a>验证 gVim 的 Python 支持</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:python print &apos;hello&apos;</div></pre></td></tr></table></figure>
<p>看到 gVim 下方的错误输出:</p>
<p>E370: Could not load library python27.dll<br>E263: Sorry, this command is disabled, the Python library could not be loaded.<br>提示无法加载 python27.dll。使用 everything 小工具在磁盘里找了一下,发现能找到 C:\Windows\system32\python27.dll,这个路径应该是直接在系统环境变量里的,为何会无法加载呢？除非……gVim.exe 是 32 位程序,在任务管理器里看:<br><img src="/2017/09/21/Vim-problem-python-compatibility/gvim-32bit.png" alt="gvim-32bit.png" title=""></p>
<p>那看样子我安装的 Python 是 64 位版本的。在命令行里执行 Python.exe 看了一下果然如此:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Python 2.7.9 (default, Dec 10 2014, 12:28:03) [MSC v.1500 64 bit (AMD64)] on win32</div><div class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Vim 官网下载的 Windows 版本 gVim 的 GUI 程序编译时启用了 Python 支持,但是由于 gVim.exe 是 32 位程序,需要加载 32 位的 python27.dll。</p>
<p>所以: 如果在 Windows 下使用 gVim 写 Python 而且想要自动补全,那安装的 gVim 与 Python 的版本要对应,比如使用的官网下载的 32 位 gVim,就安装 32 位的 Python 吧！</p>
<p>当然如果愿意折腾,使用 64 位 Python,然后自己编译一个 64 位的 gVim 应该也不是一个坏主意。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>卸载掉 64 位的 Python,安装 32 位的,可以看到 C:\Windows\SysWOW64 文件夹下有了之前没有的 python27.dll 文件。再执行 Python 的自动补全,ok</p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-无插件VIM编程技巧</title>
    <url>/2017/09/19/Vim-%E6%97%A0%E6%8F%92%E4%BB%B6VIM%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>这篇文章里的这些技巧全都是vim原生态的,不需要你安装什么插件。我的Vim的版本是7.2。</p>
<a id="more"></a>
<h2 id="浏览代码"><a href="#浏览代码" class="headerlink" title="浏览代码"></a>浏览代码</h2><p>首先,我们先从浏览代码开始。有时候,我们需要看多个文件,所以,传统的做法是,我们开多个tty终端,每个tty里用Vim打开一个文件,然后来回切换。这很没有什么效率。我们希望在一个Vim里打开多个文件,甚至浏览程序目录。</p>
<p>浏览目录的命令很简单:（你也可以直接vim一个目录）<br><strong>:E</strong><br>注意,是大写。于是,你会看到下面这样的界面:<br><img src="/2017/09/19/Vim-无插件VIM编程技巧/Explorer.png" alt="Explorer.png" title=""></p>
<p>这个界面中,<strong>你可以用 j, k 键上下移动,然后回车,进入一个目录,或是找开一个文件</strong>。你可以看到上面有一堆命令:</p>
<ul>
<li>【 – 】 到上级目录</li>
<li>【D】删除文件（大写）</li>
<li>【R】改文件名（大写）</li>
<li>【s】对文件排序（小写）</li>
<li>【x】执行文件</li>
</ul>
<p>当然,打开的文件会把现有已打开的文件给冲掉——也就是说你只看到了一个文件。</p>
<p>如果你要改变当前浏览的目录,或是查看当前浏览的目录,你可以使用和shell一样的命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:cd &lt;dir&gt; – 改变当前目录</div><div class="line">:pwd  – 查看当前目录</div></pre></td></tr></table></figure></p>
<h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p>其实,你用:E 浏览打开的文件都没有被关闭,这些文件都在缓冲区中。你可以用下面的命令来查看缓冲区:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:ls</div></pre></td></tr></table></figure></p>
<p>于是,在你的Vim下,你会看到如下界面:<br><img src="/2017/09/19/Vim-无插件VIM编程技巧/buffer_ls.png" alt="buffer_ls.png" title=""></p>
<p>你可以看到Vim打开了四个文件,编号是4,5,6,7,如果你要切换打开的文件,这个时候,你不要按回车（按了也没事,只不过按了就看不到:ls输出的buffer列表了）,你可以使用下面的命令切换文件（buffer后面的4表示切到4号文件也就是src/http/ngx_http.c）:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:buffer 4</div></pre></td></tr></table></figure></p>
<p>注: 个人使用 b4 / B4 貌似也可以</p>
<p>或是:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:buffer src/http/ngx_http.c</div></pre></td></tr></table></figure></p>
<p>注意,</p>
<ul>
<li>你可以像在Shell中输入命令按Tab键补全一样补全Vim的命令。</li>
<li>也可以用像gdb一样用最前面的几个字符,只要没有冲突。如:buff</li>
</ul>
<p>你还可以动用如下命令,快速切换:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:bnext      缩写 :bn</div><div class="line">:bprevious   缩写 :bp</div><div class="line">:blast  缩写 :bl</div><div class="line">:bfirst 缩写 :bf</div></pre></td></tr></table></figure></p>
<p>上图中,我们还可以看到5有一个%a,这表示当前文件,相关的标记如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">– （非活动的缓冲区）</div><div class="line">a （当前被激活缓冲区）</div><div class="line">h （隐藏的缓冲区）</div><div class="line">% （当前的缓冲区）</div><div class="line"># （交换缓冲区）</div><div class="line">= （只读缓冲区）</div><div class="line">+ （已经更改的缓冲区）</div></pre></td></tr></table></figure></p>
<h2 id="窗口分屏浏览"><a href="#窗口分屏浏览" class="headerlink" title="窗口分屏浏览"></a>窗口分屏浏览</h2><p>相信你在《<a href="https://coolshell.cn/articles/1679.html" target="_blank" rel="external">Vim的窗口分屏</a>》一文中,你已经知道了怎么拆分窗口了。其实,我更多的不是用拆分窗口的命令,而是用浏览文件的命令来分隔窗口。如:</p>
<p>把当前窗口上下分屏,并在下面进行目录浏览:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:He   全称为 :Hexplore  （在下边分屏浏览目录）</div></pre></td></tr></table></figure></p>
<p>如果你要在上面,你就在 :He后面加个 !,<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:He!  （在上分屏浏览目录）</div></pre></td></tr></table></figure></p>
<p>如果你要左右分屏的话,你可以这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:Ve 全称为 :Vexplore （在左边分屏间浏览目录,要在右边则是 :Ve!）</div></pre></td></tr></table></figure></p>
<p>下图是分别用:He 和 :Ve搞出来的同时看三个文件:</p>
<img src="/2017/09/19/Vim-无插件VIM编程技巧/WindowsExplorer-900x510.png" alt="WindowsExplorer-900x510.png" title="">
<p>在分屏间的跳转和切换在《Vim的窗口分屏》一文中提过了:<strong>先按Ctrl + W,然后按方向键:h j k l</strong></p>
<h2 id="分屏同步移动"><a href="#分屏同步移动" class="headerlink" title="分屏同步移动"></a>分屏同步移动</h2><p>要让两个分屏中的文件同步移动,很简单,你需要到需要同步移动的两个屏中都输入如下命令（相当于使用“铁锁连环”）:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:set scb</div></pre></td></tr></table></figure></p>
<p>如果你需要解开,那么就输入下面的命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:set scb!</div></pre></td></tr></table></figure></p>
<p>注:set scb 是 set scrollbind 的简写。</p>
<h2 id="Tab页浏览目录"><a href="#Tab页浏览目录" class="headerlink" title="Tab页浏览目录"></a>Tab页浏览目录</h2><p>分屏可能会让你不爽,你可能更喜欢像Chrome这样的分页式的浏览,那么你可以用下面的命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:Te  全称是 :Texplorer</div></pre></td></tr></table></figure></p>
<p>下图中,你可以看到我用Te命令打开了三页,就在顶端我们可以可以看到有三页,其中第一页Tab上的数字3表示那一页有3个文件。</p>
<img src="/2017/09/19/Vim-无插件VIM编程技巧/TabExplorer.png" alt="TabExplorer.png" title="">
<p>我们要在多个Tabe页中切换,在normal模式下,你可以使用下面三个按键（注意没有冒号）:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gt   – 到下一个页</div><div class="line">gT  – 到前一个页</div><div class="line">&#123;i&#125; gt   – i是数字,到指定页,比如:5 gt 就是到第5页</div></pre></td></tr></table></figure></p>
<p>你可以以使用 【:tabm {n}】来切换Tab页。</p>
<p>gvim应该是:Ctrl+PgDn 和 Ctrl+PgUp 来在各个页中切换。</p>
<p>如果你想看看你现在打开的窗口和Tab的情况,你可以使用下面的命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:tabs</div></pre></td></tr></table></figure></p>
<p>于是你可以看到:<br><img src="/2017/09/19/Vim-无插件VIM编程技巧/Tab01.png" alt="Tab01.png" title=""></p>
<p>使用如下命令可以关闭tab:（当然,我更喜欢使用传统的:q, :wq来关闭）<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:tabclose [i] – 如果后面指定了数字,那就关闭指定页,如果没有就关闭当前页</div></pre></td></tr></table></figure></p>
<p>最后提一下,如果你在Shell命令行下,你可以使用 vim 的 -p 参数来用Tab页的方式打开多个文件,比如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim -p cool.cpp shell.cpp haoel.cpp</div><div class="line">vim -p *.cpp</div></pre></td></tr></table></figure></p>
<p>注:如果你想把buffer中的文件全转成tab的话,你可以使用下面的命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:bufdo tab split</div></pre></td></tr></table></figure></p>
<h2 id="保存会话"><a href="#保存会话" class="headerlink" title="保存会话"></a>保存会话</h2><p>如果你用Tab或Window打开了好些文件的文件,还设置了各种滚屏同步,或是行号……,那么,你可以用下面的命令来保存会话:（你有兴趣你可以看看你的 mysession.vim文件内容,也就是一个批处理文件）<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:mksession ~/.mysession.vim</div></pre></td></tr></table></figure></p>
<p>如果文件重复,vim默认会报错,如果你想强行写入的话,你可以在mksession后加! :<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:mksession! ~/.mysession.vim</div></pre></td></tr></table></figure></p>
<p>于是下次,你可以这样打开这个会话:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim -S ~/.mysession.vim</div></pre></td></tr></table></figure></p>
<p>保存完会话后,你也没有必要一个一个Tab/Windows的去Close。你可以简单地使用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:qa   – 退出全部 </div><div class="line">:wqa  -保存全部并退出全部</div></pre></td></tr></table></figure></p>
<h2 id="Quickfix"><a href="#Quickfix" class="headerlink" title="Quickfix"></a>Quickfix</h2><p>假如我们有一个hello.cpp文件和一个makefile,于是我们可以直接在vim下输入 :make , 于是就可以make这个hello.cpp文件,如果出错了,我们需要按回车返回,这个时候,我们可以使用下面的命令来把出错显到在vim的分屏中:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:cw</div></pre></td></tr></table></figure></p>
<p>于是,就会出现下面右边的那个样子:（是不是看上去和我一样很帅？）<br><img src="/2017/09/19/Vim-无插件VIM编程技巧/quickfix.png" alt="quickfix.png" title=""></p>
<p>上图中左边是我的makefile,右边是我的错误百出的源代码,右边下面是quickfix窗屏。你可以看到quickfix窗屏指向的第一个错误已经定位到我们相就错误的文件行上了。</p>
<p>你可以使用像浏览文件那样用j, k在quckfix窗屏中上下移动到相应的错误上然后按回车,然后就可以在上面的窗屏里定位到相应的源文件的代码行。但是,如果是这样的话, 你要定位下一条错误还得用Ctrl +W 回到quickfix屏中来然后重复来过。</p>
<p>你可以使用下面的命令而不用回到quickfix中来:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:cp 跳到上一个错误</div><div class="line">:cn 跳到下一个错误</div><div class="line">:cl 列出所有错误</div><div class="line">:cc 显示错误详细信息</div></pre></td></tr></table></figure></p>
<p>下面我们来看另一个quickfix的功能。</p>
<p>如果你用过vim的cscope插件,你就知道cscope可以用来查找相当的代码,但cscope需要事先生成一个数据库,对一些简单的查找,其实,我们用vim的grep命令就可以了,不需要专门为之生成数据库。vim的grep命令和shell的几乎一样。</p>
<p>我们来看个例子:</p>
<p>比如我们正在浏览nginx的代码,这时,我想看看哪里用到了nginx的NGX_HTTP_VAR_INDEXED宏。于是,我可以在vim里输入如下的命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:grep -r –include=”*.[ch]” NGX_HTTP_VAR_INDEXED src/</div></pre></td></tr></table></figure></p>
<p>上面这个命令意思是递归查询src目录下所有的.c和.h文件,其中包括NGX_HTTP_VAR_INDEXED宏。然后,你就会看到vim到shell里去执行并找到了相关的文件,按回车返回vim后,别忘了用 【:cw 】把grep的输出取回来,于是我们就有下面的样子:</p>
<img src="/2017/09/19/Vim-无插件VIM编程技巧/quickfix_grep.png" alt="quickfix_grep.png" title="">
<p>然后同上面一样,你可以用 j,k 键移动quickfix里的光标到相应的行,然后按回车定位文件,或是使用【:cn】或【:cp】来移动到定位。（这样,你会把多个文件打开到缓冲区,别忘了【:ls】来查看缓冲区）</p>
<p>你看,到这里,一个小小的IDE就这样产生了,而且,最帅的是,我们连一点插件都没有装,也没有在.vimrc文件中配置过什么。</p>
<h2 id="关键字补全"><a href="#关键字补全" class="headerlink" title="关键字补全"></a>关键字补全</h2><p>我们还是坚持不用任何插件。我们来看看是怎么个自动补全的。</p>
<p>在insert模式下,我们可以按如下快捷键:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">【Ctrl +N】  – 当你按下这它时,你会发现Vim就开始搜索你这个目录下的代码,搜索完成了就会出现一个下拉列表（居然是粉紫色的,真是丑死了）</div></pre></td></tr></table></figure></p>
<p>下图是我输入了ngx<em>http</em>然后按ctrl+n出现的样子,它已经帮我补全了一个,但是我不想要这个。然后,在Vim的下方我们可以看到状态变成了“关键字补全”,然后后面有^N^P的提示,意思就是告诉你还有一个Ctrl+P.<br><img src="/2017/09/19/Vim-无插件VIM编程技巧/auto_complete_ctrl_n.png" alt="auto_complete_ctrl_n.png" title=""><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">【Ctrl + P】 – 接下来你可以按这个键,于是回到原点,然后你可以按上下光标键来选择相应的Word。</div></pre></td></tr></table></figure></p>
<p>对于上面那个例子,我们按下了Ctrl+P后出现下面的这个样子。我们可以看到,光标回到了一开始我输入的位置,然后你可以干两件事,一个是继续输入（这可以帮助过滤关键词）,另一个是用“光标键”上移或下移来选择下拉列表中的关键字,选好后回车,就补全了。<br><img src="/2017/09/19/Vim-无插件VIM编程技巧/auto_complete_ctrl_p.png" alt="auto_complete_ctrl_p.png" title=""></p>
<p>与此类似的,还有更多的补齐,都在Ctrl +X下面:</p>
<ul>
<li>Ctrl + X 和 Ctrl + D 宏定义补齐</li>
<li>Ctrl + X 和 Ctrl + ] 是Tag 补齐</li>
<li>Ctrl + X 和 Ctrl + F 是文件名 补齐</li>
<li>Ctrl + X 和 Ctrl + I 也是关键词补齐,但是关键后会有个文件名,告诉你这个关键词在哪个文件中</li>
<li>Ctrl + X 和 Ctrl +V 是表达式补齐</li>
<li>Ctrl + X 和 Ctrl +L 这可以对整个行补齐,变态吧。</li>
</ul>
<h2 id="其它技巧"><a href="#其它技巧" class="headerlink" title="其它技巧"></a>其它技巧</h2><h3 id="字符相关"><a href="#字符相关" class="headerlink" title="字符相关"></a>字符相关</h3><p>【guu 】 – 把一行的文字变成全小写。或是【Vu】<br>【gUU】 – 把一行的文件变成全大写。或是【VU】<br>按【v】键进入选择模式,然后移动光标选择你要的文本,按【u】转小写,按【U】转大写<br>【ga】 –  查看光标处字符的ascii码<br>【g8】 – 查看光标处字符的utf-8编码<br>【gf】  – 打开光标处所指的文件 （这个命令在打到#include头文件时挺好用的,当然,仅限于有路径的）<br>【*】或【#】在当前文件中搜索当前光标的单词</p>
<h3 id="缩进相关"><a href="#缩进相关" class="headerlink" title="缩进相关"></a>缩进相关</h3><p>【&gt;&gt;】向右给它进当前行 【&lt;&lt;】向左缩进当前行<br>【=】  – 缩进当前行 （和上面不一样的是,它会对齐缩进）<br>【=%】 – 把光标位置移到语句块的括号上,然后按=%,缩进整个语句块（%是括号匹配）<br>【G=gg】 或是 【gg=G】  – 缩进整个文件（G是到文件结尾,gg是到文件开头）</p>
<h3 id="复制粘贴相关"><a href="#复制粘贴相关" class="headerlink" title="复制粘贴相关"></a>复制粘贴相关</h3><p>按【v】 键进入选择模式,然后按h,j,k,l移动光标,选择文本,然后按 【y】 进行复制,按 【p】 进行粘贴。<br>【dd】剪切一行（前面加个数字可以剪切n行）,【p】粘贴<br>【yy】复制一行（前面加个数字可以复制n行）,【p】粘贴</p>
<h3 id="光标移动相关"><a href="#光标移动相关" class="headerlink" title="光标移动相关"></a>光标移动相关</h3><p>【Ctrl + O】向后回退你的光标移动<br>【Ctrl + I 】向前追赶你的光标移动<br>这两个快捷键很有用,可以在Tab页和Windows中向前和向后trace你的光标键,这也方便你跳转光标。</p>
<h3 id="读取Shell命令相关"><a href="#读取Shell命令相关" class="headerlink" title="读取Shell命令相关"></a>读取Shell命令相关</h3><p>【:r!date】 插入日期<br>上面这个命令,:r 是:read的缩写,!是表明要运行一个shell命令,意思是我要把shell命令的输出读到vim里来。</p>
<p>more ref 《<a href="https://coolshell.cn/articles/894.html" target="_blank" rel="external">如何在vim中得到你最喜爱的IDE特性</a>》</p>
<p>ref:<br><a href="https://coolshell.cn/articles/11312.html" target="_blank" rel="external">https://coolshell.cn/articles/11312.html</a></p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-switch-2-latest-python3</title>
    <url>/2017/09/19/Python-switch-2-latest-python3/</url>
    <content><![CDATA[<p>LinuxMint and Ubuntu installs python2.7 and python3.5 as default. But I want 2 install the latest Python3.6 and set it as the default python.</p>
<a id="more"></a>
<h2 id="check-current-python-versions"><a href="#check-current-python-versions" class="headerlink" title="check current python versions"></a>check current python versions</h2><p>use follow commands:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ran@ranux:~$ python -V</div><div class="line">Python 2.7.12</div><div class="line">ran@ranux:~$ python2 -V</div><div class="line">Python 2.7.12</div><div class="line">ran@ranux:~$ python3 -V</div><div class="line">Python 3.5.2</div><div class="line">ran@ranux:~$</div></pre></td></tr></table></figure></p>
<h2 id="install-python3-6-into-Linux"><a href="#install-python3-6-into-Linux" class="headerlink" title="install python3.6 into Linux"></a>install python3.6 into Linux</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo add-apt-repository ppa:jonathonf/python-3.6</div><div class="line">$ sudo apt update</div><div class="line">$ sudo apt install python3.6</div></pre></td></tr></table></figure>
<h2 id="check-installed-python3-6"><a href="#check-installed-python3-6" class="headerlink" title="check installed python3.6"></a>check installed python3.6</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ran@ranux:~$ python3.6 -V</div><div class="line">Python 3.6.3</div></pre></td></tr></table></figure>
<p>old python3.5 is still exist, and it is still the default python3.<br>to change python3.6 just installed as the default python3, we need the tool ‘’’update-alternatives’’’.</p>
<h2 id="change-default-python3"><a href="#change-default-python3" class="headerlink" title="change default python3"></a>change default python3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ran@ranux:~$ update-alternatives --list python3</div><div class="line">update-alternatives: error: no alternatives for python3</div></pre></td></tr></table></figure>
<p>why like this? Cauz we didn’t maintained them.<br>do as follows:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.5 1</div><div class="line">$ sudo update-alternatives --install /usr/bin/python3 python3 /usr/bin/python3.6 2</div></pre></td></tr></table></figure></p>
<p>recheck alternatives:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ran@ranux:~$ update-alternatives --list python3</div><div class="line">/usr/bin/python3.5</div><div class="line">/usr/bin/python3.6</div></pre></td></tr></table></figure>
<h2 id="switch-2-the-latest-python3"><a href="#switch-2-the-latest-python3" class="headerlink" title="switch 2 the latest python3"></a>switch 2 the latest python3</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">ran@ranux:~$ sudo update-alternatives --config python3</div><div class="line">有 2 个候选项可用于替换 python3 (提供 /usr/bin/python3)。</div><div class="line"></div><div class="line">  选择       路径              优先级  状态</div><div class="line">------------------------------------------------------------</div><div class="line">  0            /usr/bin/python3.6   2         自动模式</div><div class="line">  1            /usr/bin/python3.5   1         手动模式</div><div class="line">* 2            /usr/bin/python3.6   2         手动模式</div><div class="line"></div><div class="line">要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：</div></pre></td></tr></table></figure>
<p>then specify the latest python3 as default by select numbers.</p>
<h2 id="swith-python2-2-python3"><a href="#swith-python2-2-python3" class="headerlink" title="swith python2 2 python3"></a>swith python2 2 python3</h2><p>ps: do not do anything on python2, as many system tools may rely on it.<br>if you want 2 use python3 instead of python2, suggest you use virtualenv.<br>But, if you really really want 2 change python2 2 python3 on your system, do as follows</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo update-alternatives --install /usr/bin/python python /usr/local/lib/python2.7 1</div><div class="line">sudo update-alternatives --install /usr/bin/python python /usr/local/lib/python3.x 2</div></pre></td></tr></table></figure>
<p>then<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sudo update-alternatives --config python</div></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-简明VIM练级攻略</title>
    <url>/2017/09/19/Vim-%E7%AE%80%E6%98%8EVIM%E7%BB%83%E7%BA%A7%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<p>下面的文章翻译自《<a href="http://yannesposito.com/Scratch/en/blog/Learn-Vim-Progressively/" target="_blank" rel="external">Learn Vim Progressively</a>》,我觉得这是给新手最好的VIM的升级教程了,没有列举所有的命令,只是列举了那些最有用的命令。非常不错。</p>
<p>——————————正文开始——————————</p>
<p>你想以最快的速度学习人类史上最好的文本编辑器VIM吗？你先得懂得如何在VIM幸存下来,然后一点一点地学习各种戏法。</p>
<p>学习 vim 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了,非常地难学,但是却不可思议地好用。</p>
<p>我建议下面这四个步骤:</p>
<ol>
<li>存活</li>
<li>感觉良好</li>
<li>觉得更好,更强,更快</li>
<li>使用VIM的超能力</li>
<li>当你走完这篇文章,你会成为一个vim的 superstar。</li>
</ol>
<p>在开始学习以前,我需要给你一些警告:</p>
<ul>
<li>学习vim在开始时是痛苦的。</li>
<li>需要时间</li>
<li>需要不断地练习,就像你学习一个乐器一样。</li>
<li>不要期望你能在3天内把vim练得比别的编辑器更有效率。</li>
<li>事实上,你需要2周时间的苦练,而不是3天。</li>
</ul>
<a id="more"></a>
<h2 id="第一级-–-存活"><a href="#第一级-–-存活" class="headerlink" title="第一级 – 存活"></a>第一级 – 存活</h2><ol>
<li>安装 vim</li>
<li>启动 vim</li>
<li><strong>什么也别干</strong>！请先阅读</li>
</ol>
<p>当你安装好一个编辑器后,你一定会想在其中输入点什么东西,然后看看这个编辑器是什么样子。但vim不是这样的,请按照下面的命令操作:</p>
<ul>
<li>启 动Vim后,vim在 Normal 模式下。</li>
<li>让我们进入 Insert 模式,请按下键 i 。(注:你会看到vim左下角有一个–insert–字样,表示,你可以以插入的方式输入了）</li>
<li>此时,你可以输入文本了,就像你用“记事本”一样。</li>
<li>如果你想返回 Normal 模式,请按 ESC 键。</li>
</ul>
<p>现在,你知道如何在 Insert 和 Normal 模式下切换了。下面是一些命令,可以让你在 Normal 模式下幸存下来:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">i → Insert 模式,按 ESC 回到 Normal 模式.</div><div class="line">x → 删当前光标所在的一个字符。</div><div class="line">:wq → 存盘 + 退出 (:w 存盘, :q 退出)   （注: :w 后可以跟文件名）</div><div class="line">dd → 删除当前行,并把删除的行存到剪贴板里</div><div class="line">p → 粘贴剪贴板</div><div class="line">推荐:</div><div class="line"></div><div class="line">hjkl (强例推荐使用其移动光标,但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。</div><div class="line">:help &lt;command&gt; → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。（注:退出帮助需要输入:q）</div></pre></td></tr></table></figure></p>
<p>你能在vim幸存下来只需要上述的那5个命令,你就可以编辑文本了,你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了。</p>
<p>当是,在你进入第二级时,需要再说一下 Normal 模式。在一般的编辑器下,当你需要copy一段文字的时候,你需要使用 Ctrl 键,比如:Ctrl-C。也就是说,Ctrl键就好像功能键一样,当你按下了功能键Ctrl后,C就不在是C了,而且就是一个命令或是一个快键键了,<strong>在VIM的Normal模式下,所有的键就是功能键了</strong>。这个你需要知道。</p>
<p>标记:</p>
<ul>
<li>下面的文字中,如果是 Ctrl-λ我会写成 <c-λ>.</c-λ></li>
<li>以 : 开始的命令你需要输入 <enter>回车,例如 — 如果我写成 :q 也就是说你要输入 :q<enter>.</enter></enter></li>
</ul>
<h2 id="第二级-–-感觉良好"><a href="#第二级-–-感觉良好" class="headerlink" title="第二级 – 感觉良好"></a>第二级 – 感觉良好</h2><p>上面的那些命令只能让你存活下来,现在是时候学习一些更多的命令了,下面是我的建议:（注:所有的命令都需要在Normal模式下使用,如果你不知道现在在什么样的模式,你就狂按几次ESC键）</p>
<ol>
<li>各种插入模式</li>
</ol>
<ul>
<li>a → 在光标后插入</li>
<li>o → 在当前行后插入一个新行</li>
<li>O → 在当前行前插入一个新行</li>
<li>cw → 替换从光标所在位置后到一个单词结尾的字符</li>
</ul>
<ol>
<li>简单的移动光标</li>
</ol>
<ul>
<li>0 → 数字零,到行头</li>
<li>^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格,tab,换行,回车等）</li>
<li>$ → 到本行行尾</li>
<li>g_ → 到本行最后一个不是blank字符的位置。</li>
<li>/pattern → 搜索 pattern 的字符串（注:如果搜索出多个匹配,可按n键到下一个）</li>
</ul>
<ol>
<li>拷贝/粘贴 （注:p/P都可以,p是表示在当前位置之后,P表示在当前位置之前）</li>
</ol>
<ul>
<li>P → 粘贴</li>
<li>yy → 拷贝当前行当行于 ddP</li>
</ul>
<ol>
<li>Undo/Redo</li>
</ol>
<ul>
<li>u → undo</li>
<li><c-r> → redo</c-r></li>
</ul>
<ol>
<li>打开/保存/退出/改变文件(Buffer)</li>
</ol>
<ul>
<li>:e <path to="" file=""></path> → 打开一个文件</li>
<li>:w → 存盘</li>
<li>:saveas <path to="" file=""></path> → 另存为 <path to="" file=""></path></li>
<li>:x, ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存,ZZ不需要输入冒号并回车)</li>
<li>:q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件,就算别的文件有更改。</li>
<li>:bn 和 :bp → 你可以同时打开很多文件,使用这两个命令来切换下一个或上一个文件。（注:我喜欢使用:n到下一个文件）</li>
</ul>
<p>花点时间熟悉一下上面的命令,一旦你掌握他们了,你就几乎可以干其它编辑器都能干的事了。但是到现在为止,你还是觉得使用vim还是有点笨拙,不过没关系,你可以进阶到第三级了。</p>
<h2 id="第三级-–-更好-更强-更快"><a href="#第三级-–-更好-更强-更快" class="headerlink" title="第三级 – 更好,更强,更快"></a>第三级 – 更好,更强,更快</h2><p>先恭喜你！你干的很不错。我们可以开始一些更为有趣的事了。在第三级,我们只谈那些和vi可以兼容的命令。</p>
<h3 id="更好"><a href="#更好" class="headerlink" title="更好"></a>更好</h3><p>下面,让我们看一下vim是怎么重复自己的:</p>
<ol>
<li><strong>.</strong> → (小数点) 可以重复上一次的命令</li>
<li>N<command> → 重复某个命令N次<br>下面是一个示例,找开一个文件你可以试试下面的命令:</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2dd → 删除2行</div><div class="line">3p → 粘贴文本3次</div><div class="line">100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “</div><div class="line">. → 重复上一个命令—— 100 “desu “.</div><div class="line">3. → 重复 3 次 “desu” (注意:不是 300,你看,VIM多聪明啊).</div></pre></td></tr></table></figure>
<h3 id="更强"><a href="#更强" class="headerlink" title="更强"></a>更强</h3><p>你要让你的光标移动更有效率,你一定要了解下面的这些命令,<strong>千万别跳过</strong>。</p>
<ol>
<li>NG → 到第 N 行 （注:注意命令中的G是大写的,另我一般使用 : N 到第N行,如 :137 到第137行）</li>
<li>gg → 到第一行。（注:相当于1G,或 :1）</li>
<li>G → 到最后一行。</li>
<li>按单词移动:</li>
</ol>
<ul>
<li>w → 到下一个单词的开头。</li>
<li>e → 到下一个单词的结尾。<blockquote>
<p>如果你认为单词是由默认方式,那么就用小写的e和w。默认上来说,一个单词由字母,数字和下划线组成（注:程序变量）<br>如果你认为单词是由blank字符分隔符,那么你需要使用大写的E和W。（注:程序语句）</p>
</blockquote>
</li>
</ul>
<img src="/2017/09/19/Vim-简明VIM练级攻略/word_moves.jpg" alt="word_moves.jpg" title="">
<p>下面,让我来说说最强的光标移动:</p>
<ul>
<li>% : 匹配括号移动,包括 (, {, [. （注:你需要把光标先移到括号上）</li>
<li><ul>
<li>和 #:  匹配光标当前所在的单词,移动光标到下一个（或上一个）匹配单词（*是下一个,#是上一个）</li>
</ul>
</li>
</ul>
<p>相信我,上面这三个命令对程序员来说是相当强大的。</p>
<h3 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h3><p>你一定要记住光标的移动,因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;start position&gt;&lt;command&gt;&lt;end position&gt;</div></pre></td></tr></table></figure>
<p>例如 0y$ 命令意味着:</p>
<ul>
<li>0 → 先到行头</li>
<li>y → 从这里开始拷贝</li>
<li>$ → 拷贝到本行最后一个字符</li>
</ul>
<p>你可可以输入 ye,从当前位置拷贝到本单词的最后一个字符。</p>
<p>你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。</p>
<p>还有很多时间并不一定你就一定要按y才会拷贝,下面的命令也会被拷贝:</p>
<ul>
<li>d (删除 )</li>
<li>v (可视化的选择)</li>
<li>gU (变大写)</li>
<li>gu (变小写)</li>
<li>等等</li>
</ul>
<p>（注:可视化选择是一个很有意思的命令,你可以先按v,然后移动光标,你就会看到文本被选择,然后,你可能d,也可y,也可以变大写等）</p>
<h2 id="第四级-–-Vim-超能力"><a href="#第四级-–-Vim-超能力" class="headerlink" title="第四级 – Vim 超能力"></a>第四级 – Vim 超能力</h2><p>你只需要掌握前面的命令,你就可以很舒服的使用VIM了。但是,现在,我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。</p>
<p><strong>在当前行上移动光标: 0 ^ $ f F t T , ;</strong></p>
<ul>
<li>0 → 到行头</li>
<li>^ → 到本行的第一个非blank字符</li>
<li>$ → 到行尾</li>
<li>g_ → 到本行最后一个不是blank字符的位置。</li>
<li>fa → 到下一个为a的字符处,你也可以fs到下一个为s的字符。</li>
<li>t, → 到逗号前的第一个字符。逗号可以变成其它字符。</li>
<li>3fa → 在当前行查找第三个出现的a。</li>
<li>F 和 T → 和 f 和 t 一样,只不过是相反方向。</li>
</ul>
<img src="/2017/09/19/Vim-简明VIM练级攻略/line_moves.jpg" alt="line_moves.jpg" title="">
<p>还有一个很有用的命令是 dt” → 删除所有的内容,直到遇到双引号—— “。</p>
<h3 id="区域选择"><a href="#区域选择" class="headerlink" title="区域选择"></a>区域选择</h3><p>在visual 模式下,这些命令很强大,其命令格式为<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;action&gt;a&lt;object&gt; 和 &lt;action&gt;i&lt;object&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li>action可以是任何的命令,如 d (删除), y (拷贝), v (可以视模式选择)。</li>
<li>object 可能是: w 一个单词, W 一个以空格为分隔的单词, s 一个句字, p 一个段落。也可以是一个特别的字符:”、 ‘、 )、 }、 ]。</li>
</ul>
<p>假设你有一个字符串 (map (+) (“foo”)).而光标键在第一个 o 的位置。</p>
<ul>
<li>vi” → 会选择 foo.</li>
<li>va” → 会选择 “foo”.</li>
<li>vi) → 会选择 “foo”.</li>
<li>va) → 会选择(“foo”).</li>
<li>v2i) → 会选择 map (+) (“foo”)</li>
<li>v2a) → 会选择 (map (+) (“foo”))</li>
</ul>
<img src="/2017/09/19/Vim-简明VIM练级攻略/textobjects.png" alt="textobjects.png" title="">
<h3 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h3><p>块操作,典型的操作:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0 &lt;C-v&gt; &lt;C-d&gt; I-- [ESC]</div></pre></td></tr></table></figure></p>
<ul>
<li>^ → 到行头</li>
<li><c-v> → 开始块操作</c-v></li>
<li><c-d> → 向下移动 (你也可以使用hjkl来移动光标,或是使用%,或是别的)</c-d></li>
<li>I– [ESC] → I是插入,插入“–”,按ESC键来为每一行生效。</li>
</ul>
<img src="/2017/09/19/Vim-简明VIM练级攻略/rectangular-blocks.gif" alt="rectangular-blocks.gif" title="">
<p>在Windows下的vim,你需要使用 <c-q> 而不是 <c-v> ,<c-v> 是拷贝剪贴板。</c-v></c-v></c-q></p>
<h3 id="自动提示"><a href="#自动提示" class="headerlink" title="自动提示"></a>自动提示</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">在 Insert 模式下,你可以输入一个词的开头,然后按 &lt;C-p&gt;或是&lt;C-n&gt;,自动补齐功能就出现了……</div></pre></td></tr></table></figure>
<img src="/2017/09/19/Vim-简明VIM练级攻略/completion.gif" alt="completion.gif" title="">
<h3 id="宏录制-qa-操作序列-q-a"><a href="#宏录制-qa-操作序列-q-a" class="headerlink" title="宏录制: qa 操作序列 q, @a, @@"></a>宏录制: qa 操作序列 q, @a, @@</h3><ul>
<li>qa 把你的操作记录在寄存器 a。</li>
<li>于是 @a 会replay被录制的宏。</li>
<li>@@ 是一个快捷键用来replay最新录制的宏。</li>
</ul>
<p>示例<br>在一个只有一行且这一行只有“1”的文本中,键入如下命令:</p>
<ul>
<li><p>qaYp<c-a>q→</c-a></p>
<ul>
<li>qa 开始录制</li>
<li>Yp 复制行.</li>
<li><c-a> 增加1.</c-a></li>
<li>q 停止录制.</li>
</ul>
</li>
<li><p>@a → 在1下面写下 2</p>
</li>
<li>@@ → 在2 正面写下3</li>
<li>现在做 100@@ 会创建新的100行,并把数据增加到 103.</li>
</ul>
<img src="/2017/09/19/Vim-简明VIM练级攻略/macros.gif" alt="macros.gif" title="">
<h3 id="可视化选择"><a href="#可视化选择" class="headerlink" title="可视化选择"></a>可视化选择</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">v,V,&lt;C-v&gt;</div></pre></td></tr></table></figure>
<p>前面,我们看到了 <c-v>的示例 （在Windows下应该是<c-q>）,我们可以使用 v 和 V。一但被选好了,你可以做下面的事:</c-q></c-v></p>
<ul>
<li>J → 把所有的行连接起来（变成一行）</li>
<li>&lt; 或 &gt; → 左右缩进</li>
<li>= → 自动给缩进 （注:这个功能相当强大,我太喜欢了）</li>
</ul>
<p>在所有被选择的行后加上点东西:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;C-v&gt;</div><div class="line">选中相关的行 (可使用 j 或 &lt;C-d&gt; 或是 /pattern 或是 % 等……)</div><div class="line">$ 到行最后</div><div class="line">A, 输入字符串,按 ESC。</div></pre></td></tr></table></figure>
<img src="/2017/09/19/Vim-简明VIM练级攻略/append-to-many-lines.gif" alt="append-to-many-lines.gif" title="">
<h3 id="分屏-split-和-vsplit"><a href="#分屏-split-和-vsplit" class="headerlink" title="分屏 :split 和 vsplit."></a>分屏 :split 和 vsplit.</h3><p>下面是主要的命令,你可以使用VIM的帮助 :help split. 你可以参考本站以前的一篇文章<a href="https://coolshell.cn/articles/1679.html" target="_blank" rel="external">VIM分屏</a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:split → 创建分屏 (:vsplit创建垂直分屏)</div><div class="line">&lt;C-w&gt;&lt;dir&gt; : dir就是方向,可以是 hjkl 或是 ←↓↑→ 中的一个,其用来切换分屏。</div><div class="line">&lt;C-w&gt;_ (或 &lt;C-w&gt;|) : 最大化尺寸 (&lt;C-w&gt;| 垂直分屏)</div><div class="line">&lt;C-w&gt;+ (或 &lt;C-w&gt;-) : 增加尺寸</div></pre></td></tr></table></figure>
<img src="/2017/09/19/Vim-简明VIM练级攻略/split.gif" alt="split.gif" title="">
<p>ref:<br><a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="external">https://coolshell.cn/articles/5426.html</a></p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Thead-如何使用ConcurrentHashMap</title>
    <url>/2017/09/18/Java-Thead-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8ConcurrentHashMap/</url>
    <content><![CDATA[<p>ConcurrentHashMap(简称CHM)是在Java 1.5作为Hashtable的替代选择新引入的，是concurrent包的重要成员。在Java 1.5之前，如果想要实现一个可以在多线程和并发的程序中安全使用的Map,只能在HashTable和synchronized Map中选择，因为HashMap并不是线程安全的。但再引入了CHM之后，我们有了更好的选择。CHM不但是线程安全的，而且比HashTable和synchronizedMap的性能要好。相对于HashTable和synchronizedMap锁住了整个Map，CHM只锁住部分Map。CHM允许并发的读操作，同时通过同步锁在写操作时保持数据完整性。</p>
<a id="more"></a>
<h2 id="Java中ConcurrentHashMap的实现"><a href="#Java中ConcurrentHashMap的实现" class="headerlink" title="Java中ConcurrentHashMap的实现"></a>Java中ConcurrentHashMap的实现</h2><p>CHM引入了分割，并提供了HashTable支持的所有的功能。在CHM中，支持多线程对Map做读操作，并且不需要任何的blocking。这得益于CHM将Map分割成了不同的部分，在执行更新操作时只锁住一部分。根据默认的并发级别(concurrency level)，Map被分割成16个部分，并且由不同的锁控制。这意味着，同时最多可以有16个写线程操作Map。试想一下，由只能一个线程进入变成同时可由16个写线程同时进入(读线程几乎不受限制)，性能的提升是显而易见的。但由于一些更新操作，如put(),remove(),putAll(),clear()只锁住操作的部分，所以在检索操作不能保证返回的是最新的结果。</p>
<p>另一个重要点是在迭代遍历CHM时，keySet返回的iterator是弱一致和fail-safe的，可能不会返回某些最近的改变，并且在遍历过程中，如果已经遍历的数组上的内容变化了，不会抛出ConcurrentModificationExceptoin的异常。</p>
<p>CHM默认的并发级别是16，但可以在创建CHM时通过构造函数改变。毫无疑问，并发级别代表着并发执行更新操作的数目，所以如果只有很少的线程会更新Map，那么建议设置一个低的并发级别。另外，CHM还使用了ReentrantLock来对segments加锁。</p>
<h2 id="Java中ConcurrentHashMap-putifAbsent方法的例子"><a href="#Java中ConcurrentHashMap-putifAbsent方法的例子" class="headerlink" title="Java中ConcurrentHashMap putifAbsent方法的例子"></a>Java中ConcurrentHashMap putifAbsent方法的例子</h2><p>很多时候我们希望在元素不存在时插入元素，我们一般会像下面那样写代码<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(map)&#123;</div><div class="line">  <span class="keyword">if</span> (map.get(key) == <span class="keyword">null</span>)&#123;</div><div class="line">      <span class="keyword">return</span> map.put(key, value);</div><div class="line">  &#125; <span class="keyword">else</span>&#123;</div><div class="line">      <span class="keyword">return</span> map.get(key);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这段代码在HashMap和HashTable中是好用的，但在CHM中是有出错的风险的。这是因为CHM在put操作时并没有对整个Map加锁，所以一个线程正在put(k,v)的时候，另一个线程调用get(k)会得到null，这就会造成一个线程put的值会被另一个线程put的值所覆盖。当然，你可以将代码封装到synchronized代码块中，这样虽然线程安全了，但会使你的代码变成了单线程。CHM提供的putIfAbsent(key,value)方法原子性的实现了同样的功能，同时避免了上面的线程竞争的风险。</p>
<h2 id="什么时候使用ConcurrentHashMap"><a href="#什么时候使用ConcurrentHashMap" class="headerlink" title="什么时候使用ConcurrentHashMap"></a>什么时候使用ConcurrentHashMap</h2><p>CHM适用于读者数量超过写者时，当写者数量大于等于读者时，CHM的性能是低于Hashtable和synchronized Map的。这是因为当锁住了整个Map时，读操作要等待对同一部分执行写操作的线程结束。CHM适用于做cache,在程序启动时初始化，之后可以被多个请求线程访问。正如Javadoc说明的那样，CHM是HashTable一个很好的替代，但要记住，CHM的比HashTable的同步性稍弱。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>现在我们知道了什么是ConcurrentHashMap和什么时候该用ConcurrentHashMap，下面我们来复习一下CHM的一些关键点。</p>
<ul>
<li>CHM允许并发的读和线程安全的更新操作</li>
<li>在执行写操作时，CHM只锁住部分的Map</li>
<li>并发的更新是通过内部根据并发级别将Map分割成小部分实现的</li>
<li>高的并发级别会造成时间和空间的浪费，低的并发级别在写线程多时会引起线程间的竞争</li>
<li>CHM的所有操作都是线程安全</li>
<li>CHM返回的迭代器是弱一致性，fail-safe并且不会抛出ConcurrentModificationException异常</li>
<li>CHM不允许null的键值</li>
<li>可以使用CHM代替HashTable，但要记住CHM不会锁住整个Map</li>
</ul>
<p>以上就是Java中CHM的实现和使用场景</p>
<p>ref:<br><a href="https://yemengying.com/2015/11/06/%E3%80%90%E8%AF%91%E3%80%91%E5%A6%82%E4%BD%95%E5%9C%A8java%E4%B8%AD%E4%BD%BF%E7%94%A8ConcurrentHashMap/" target="_blank" rel="external">https://yemengying.com/2015/11/06/%E3%80%90%E8%AF%91%E3%80%91%E5%A6%82%E4%BD%95%E5%9C%A8java%E4%B8%AD%E4%BD%BF%E7%94%A8ConcurrentHashMap/</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Thread-如何线程安全的使用HashMap</title>
    <url>/2017/09/18/Java-Thread-%E5%A6%82%E4%BD%95%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%BD%BF%E7%94%A8HashMap/</url>
    <content><![CDATA[<p>总说 HashMap 是线程不安全的,不安全的,不安全的,那么到底为什么它是线程不安全的呢？要回答这个问题就要先来简单了解一下 HashMap 源码中的使用的存储结构(这里引用的是 Java 8 的源码,与7是不一样的)和它的扩容机制。</p>
<a id="more"></a>
<h3 id="HashMap的内部存储结构"><a href="#HashMap的内部存储结构" class="headerlink" title="HashMap的内部存储结构"></a>HashMap的内部存储结构</h3><p>下面是 HashMap 使用的存储结构:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</div><div class="line">        <span class="keyword">final</span> K key;</div><div class="line">        V value;</div><div class="line">        Node&lt;K,V&gt; next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到 HashMap 内部存储使用了一个 Node 数组(默认大小是16),而 Node 类包含一个类型为 Node 的 next 的变量,也就是相当于一个链表,所有根据 hash 值计算的 bucket 一样的 key 会存储到同一个链表里(即产生了冲突),大概就是下面图的样子<br><img src="/2017/09/18/Java-Thread-如何线程安全的使用HashMap/HashMap内部存储结果.png" alt="HashMap内部存储结果.png" title=""></p>
<p>需要注意的是,在 Java 8 中如果 hash 值相同的 key 数量大于指定值(默认是8)时使用平衡树来代替链表,这会将get()方法的性能从O(n)提高到O(logn)。具体的可以看我的另一篇博客<a href="https://yemengying.com/2016/02/03/%E8%AF%91-Java%E4%B8%ADHashMap%E5%92%8CLinkedHashMap%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%86%B2%E7%AA%81/" target="_blank" rel="external">Java 8中HashMap和LinkedHashMap如何解决冲突</a>。</p>
<h3 id="HashMap的自动扩容机制"><a href="#HashMap的自动扩容机制" class="headerlink" title="HashMap的自动扩容机制"></a>HashMap的自动扩容机制</h3><p>HashMap 内部的 Node 数组默认的大小是16,假设有100万个元素,那么最好的情况下每个 hash 桶里都有62500个元素,这时get(),put(),remove()等方法效率都会降低。为了解决这个问题,HashMap 提供了自动扩容机制,当元素个数达到数组大小 loadFactor 后会扩大数组的大小,在默认情况下,数组大小为16,loadFactor 为0.75,也就是说当 HashMap 中的元素超过16<em>0.75=12时,会把数组大小扩展为2</em>16=32,并且重新计算每个元素在新数组中的位置。如下图所示<br><img src="/2017/09/18/Java-Thread-如何线程安全的使用HashMap/resizing_of_java_hashmap.jpg" alt="resizing_of_java_hashmap.jpg" title=""><br>从图中可以看到没扩容前,获取 EntryE 需要遍历5个元素,扩容之后只需要2次</p>
<p>为什么线程不安全</p>
<p>个人觉得 HashMap 在并发时可能出现的问题主要是两方面,首先如果多个线程同时使用put方法添加元素,而且假设正好存在两个 put 的 key 发生了碰撞(根据 hash 值计算的 bucket 一样),那么根据 HashMap 的实现,这两个 key 会添加到数组的同一个位置,这样最终就会发生其中一个线程的 put 的数据被覆盖。第二就是如果多个线程同时检测到元素个数超过数组大小* loadFactor ,这样就会发生多个线程同时对 Node 数组进行扩容,都在重新计算元素位置以及复制数据,但是最终只有一个线程扩容后的数组会赋给 table,也就是说其他线程的都会丢失,并且各自线程 put 的数据也丢失。<br>关于 HashMap 线程不安全这一点,《Java并发编程的艺术》一书中是这样说的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">HashMap 在并发执行 put 操作时会引起死循环,导致 CPU 利用率接近100%。因为多线程会导致 HashMap 的 Node 链表形成环形数据结构,一旦形成环形数据结构,Node 的 next 节点永远不为空,就会在获取 Node 时产生死循环。</div></pre></td></tr></table></figure></p>
<p>注: 死循环并不是发生在 put 操作时,而是发生在扩容时。详细的解释可以看下面几篇博客:</p>
<ul>
<li><a href="http://coolshell.cn/articles/9606.html" target="_blank" rel="external">酷壳-Java HashMap的死循环</a></li>
<li><a href="http://firezhfox.iteye.com/blog/2241043" target="_blank" rel="external">HashMap在java并发中如何发生死循环</a></li>
<li><a href="http://coding-geek.com/how-does-a-hashmap-work-in-java/" target="_blank" rel="external">How does a HashMap work in JAVA</a></li>
</ul>
<h2 id="如何线程安全的使用HashMap"><a href="#如何线程安全的使用HashMap" class="headerlink" title="如何线程安全的使用HashMap"></a>如何线程安全的使用HashMap</h2><p>了解了 HashMap 为什么线程不安全,那现在看看如何线程安全的使用 HashMap。这个无非就是以下三种方式:</p>
<ul>
<li>Hashtable</li>
<li>ConcurrentHashMap</li>
<li>Synchronized Map</li>
</ul>
<p>例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//Hashtable  </span></div><div class="line">Map&lt;String, String&gt; hashtable = <span class="keyword">new</span> Hashtable&lt;&gt;();  </div><div class="line"><span class="comment">//synchronizedMap  </span></div><div class="line">Map&lt;String, String&gt; synchronizedHashMap = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, String&gt;());  </div><div class="line"><span class="comment">//ConcurrentHashMap  </span></div><div class="line">Map&lt;String, String&gt; concurrentHashMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div></pre></td></tr></table></figure></p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>Hashtable 源码中是使用 synchronized 来保证线程安全的,比如下面的 get 方法和 put 方法:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">   <span class="comment">// 省略实现  </span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </div><div class="line"><span class="comment">// 省略实现  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以当一个线程访问 HashTable 的同步方法时,其他线程如果也要访问同步方法,会被阻塞住。举个例子,当一个线程使用 put 方法时,另一个线程不但不可以使用 put 方法,连 get 方法都不可以,好霸道啊！！！so~~,效率很低。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>ConcurrentHashMap (以下简称CHM)是 JUC 包中的一个类,Spring 的源码中有很多使用 CHM 的地方。之前已经翻译过一篇关于 ConcurrentHashMap 的博客,<a href="http://yemengying.com/2015/11/06/%E3%80%90%E8%AF%91%E3%80%91%E5%A6%82%E4%BD%95%E5%9C%A8java%E4%B8%AD%E4%BD%BF%E7%94%A8ConcurrentHashMap/" target="_blank" rel="external">如何在java中使用ConcurrentHashMap</a>,里面介绍了 CHM 在 Java 中的实现,CHM 的一些重要特性和什么情况下应该使用 CHM。需要注意的是,上面博客是基于 Java 7 的,和8有区别,在8中 CHM 摒弃了 Segment（锁段）的概念,而是启用了一种全新的方式实现,利用 CAS 算法,有时间会重新总结一下。</p>
<h3 id="SynchronizedMap"><a href="#SynchronizedMap" class="headerlink" title="SynchronizedMap"></a>SynchronizedMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">// synchronizedMap方法  </span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> </span>&#123;  </div><div class="line">   <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);  </div><div class="line">&#125;</div><div class="line"><span class="comment">// SynchronizedMap类  </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;  </span></div><div class="line"><span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> &#123;  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1978198479659022715L</span>;  </div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map  </span></div><div class="line"><span class="keyword">final</span> Object      mutex;        <span class="comment">// Object on which to synchronize  </span></div><div class="line">SynchronizedMap(Map&lt;K,V&gt; m) &#123;  </div><div class="line">   <span class="keyword">this</span>.m = Objects.requireNonNull(m);  </div><div class="line">   mutex = <span class="keyword">this</span>;  </div><div class="line">&#125;  </div><div class="line">SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;  </div><div class="line">   <span class="keyword">this</span>.m = m;  </div><div class="line">   <span class="keyword">this</span>.mutex = mutex;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;  </div><div class="line">   <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.size();&#125;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;  </div><div class="line">   <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.isEmpty();&#125;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">   <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsKey(key);&#125;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;  </div><div class="line">   <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsValue(value);&#125;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">   <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;  </div><div class="line">   <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;  </div><div class="line">&#125;  </div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;  </div><div class="line">   <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">// 省略其他方法  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码中可以看出调用 synchronizedMap() 方法后会返回一个 SynchronizedMap 类的对象,而在 SynchronizedMap 类中使用了 synchronized 同步关键字来保证对 Map 的操作是线程安全的。</p>
<h3 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h3><p>这是要靠数据说话的时代,所以不能只靠嘴说 CHM 快,它就快了。写个测试用例,实际的比较一下这三种方式的效率,下面的代码分别通过三种方式创建 Map 对象,使用 ExecutorService 来并发运行5个线程,每个线程添加/获取500K个元素。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrunchifyConcurrentHashMapVsSynchronizedMap</span> </span>&#123;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> THREAD_POOL_SIZE = <span class="number">5</span>;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; crunchifyHashTableObject = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; crunchifySynchronizedMapObject = <span class="keyword">null</span>;  </div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; crunchifyConcurrentHashMapObject = <span class="keyword">null</span>;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </div><div class="line">        <span class="comment">// Test with Hashtable Object  </span></div><div class="line">        crunchifyHashTableObject = <span class="keyword">new</span> Hashtable&lt;&gt;();  </div><div class="line">        crunchifyPerformTest(crunchifyHashTableObject);  </div><div class="line">        <span class="comment">// Test with synchronizedMap Object  </span></div><div class="line">        crunchifySynchronizedMapObject = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, Integer&gt;());  </div><div class="line">        crunchifyPerformTest(crunchifySynchronizedMapObject);  </div><div class="line">        <span class="comment">// Test with ConcurrentHashMap Object  </span></div><div class="line">        crunchifyConcurrentHashMapObject = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();  </div><div class="line">        crunchifyPerformTest(crunchifyConcurrentHashMapObject);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">crunchifyPerformTest</span><span class="params">(<span class="keyword">final</span> Map&lt;String, Integer&gt; crunchifyThreads)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </div><div class="line">        System.out.println(<span class="string">"Test started for: "</span> + crunchifyThreads.getClass());  </div><div class="line">        <span class="keyword">long</span> averageTime = <span class="number">0</span>;  </div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;  </div><div class="line">            <span class="keyword">long</span> startTime = System.nanoTime();  </div><div class="line">            ExecutorService crunchifyExServer = Executors.newFixedThreadPool(THREAD_POOL_SIZE);  </div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; THREAD_POOL_SIZE; j++) &#123;  </div><div class="line">                crunchifyExServer.execute(<span class="keyword">new</span> Runnable() &#123;  </div><div class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)  </div><div class="line">                    <span class="meta">@Override</span>  </div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;  </div><div class="line">                            Integer crunchifyRandomNumber = (<span class="keyword">int</span>) Math.ceil(Math.random() * <span class="number">550000</span>);  </div><div class="line">                            <span class="comment">// Retrieve value. We are not using it anywhere  </span></div><div class="line">                            Integer crunchifyValue = crunchifyThreads.get(String.valueOf(crunchifyRandomNumber));  </div><div class="line">                            <span class="comment">// Put value  </span></div><div class="line">                            crunchifyThreads.put(String.valueOf(crunchifyRandomNumber), crunchifyRandomNumber);  </div><div class="line">                        &#125;  </div><div class="line">                    &#125;  </div><div class="line">                &#125;);  </div><div class="line">            &#125;  </div><div class="line">            <span class="comment">// Make sure executor stops  </span></div><div class="line">            crunchifyExServer.shutdown();  </div><div class="line">            <span class="comment">// Blocks until all tasks have completed execution after a shutdown request  </span></div><div class="line">            crunchifyExServer.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);  </div><div class="line">            <span class="keyword">long</span> entTime = System.nanoTime();  </div><div class="line">            <span class="keyword">long</span> totalTime = (entTime - startTime) / <span class="number">1000000L</span>;  </div><div class="line">            averageTime += totalTime;  </div><div class="line">            System.out.println(<span class="string">"2500K entried added/retrieved in "</span> + totalTime + <span class="string">" ms"</span>);  </div><div class="line">        &#125;  </div><div class="line">        System.out.println(<span class="string">"For "</span> + crunchifyThreads.getClass() + <span class="string">" the average time is "</span> + averageTime / <span class="number">5</span> + <span class="string">" ms\n"</span>);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Test started for: class java.util.Hashtable  </div><div class="line">2500K entried added/retrieved in 2018 ms  </div><div class="line">2500K entried added/retrieved in 1746 ms  </div><div class="line">2500K entried added/retrieved in 1806 ms  </div><div class="line">2500K entried added/retrieved in 1801 ms  </div><div class="line">2500K entried added/retrieved in 1804 ms  </div><div class="line">For class java.util.Hashtable the average time is 1835 ms  </div><div class="line">Test started for: class java.util.Collections$SynchronizedMap  </div><div class="line">2500K entried added/retrieved in 3041 ms  </div><div class="line">2500K entried added/retrieved in 1690 ms  </div><div class="line">2500K entried added/retrieved in 1740 ms  </div><div class="line">2500K entried added/retrieved in 1649 ms  </div><div class="line">2500K entried added/retrieved in 1696 ms  </div><div class="line">For class java.util.Collections$SynchronizedMap the average time is 1963 ms  </div><div class="line">Test started for: class java.util.concurrent.ConcurrentHashMap  </div><div class="line">2500K entried added/retrieved in 738 ms  </div><div class="line">2500K entried added/retrieved in 696 ms  </div><div class="line">2500K entried added/retrieved in 548 ms  </div><div class="line">2500K entried added/retrieved in 1447 ms  </div><div class="line">2500K entried added/retrieved in 531 ms  </div><div class="line">For class java.util.concurrent.ConcurrentHashMap the average time is 792 ms</div></pre></td></tr></table></figure></p>
<p>ref:<br><a href="http://yemengying.com/2016/05/07/threadsafe-hashmap/" target="_blank" rel="external">http://yemengying.com/2016/05/07/threadsafe-hashmap/</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Thread-UncaughtExceptionHandler-处理非正常的线程中止</title>
    <url>/2017/09/13/Java-Thread-UncaughtExceptionHandler-%E5%A4%84%E7%90%86%E9%9D%9E%E6%AD%A3%E5%B8%B8%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%AD%A2/</url>
    <content><![CDATA[<p>当单线程的程序发生一个未捕获的异常时我们可以采用try…catch进行异常的捕获,但是在多线程环境中,线程抛出的异常是不能用try…catch捕获的,这样就有可能导致一些问题的出现,比如异常的时候无法回收一些系统资源,或者没有关闭当前的连接等等。</p>
<a id="more"></a>
<p>首先来看一个示例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoCaughtThread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</div><div class="line">            thread.start();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            System.out.println(<span class="string">"==Exception: "</span>+e.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="number">3</span>/<span class="number">2</span>);</div><div class="line">        System.out.println(<span class="number">3</span>/<span class="number">0</span>);</div><div class="line">        System.out.println(<span class="number">3</span>/<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Exception in thread <span class="string">"Thread-0"</span> java.lang.ArithmeticException: / by zero</div><div class="line">    at com.exception.Task.run(NoCaughtThread.java:<span class="number">25</span>)</div><div class="line">    at java.lang.Thread.run(Unknown Source)</div></pre></td></tr></table></figure></p>
<p>可以看到在多线程中通过try…catch试图捕获线程的异常是不可取的。</p>
<p>Thread的run方法是不抛出任何检查型异常的,但是它自身却可能因为一个异常而被中止,导致这个线程的终结。<br>首先介绍一下如何在线程池内部构建一个工作者线程,如果任务抛出了一个未检查异常,那么它将使线程终结,但会首先通知框架该现场已经终结。然后框架可能会用新的线程来代替这个工作线程,也可能不会,因为线程池正在关闭,或者当前已有足够多的线程能满足需要。当编写一个向线程池提交任务的工作者类线程类时,或者调用不可信的外部代码时（例如动态加载的插件）,使用这些方法中的某一种可以避免某个编写得糟糕的任务或插件不会影响调用它的整个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitiativeCaught</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadDeal</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"==Exception: "</span>+t.getMessage());</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">InitialtiveThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            Throwable thrown = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                System.out.println(<span class="number">3</span>/<span class="number">2</span>);</div><div class="line">                System.out.println(<span class="number">3</span>/<span class="number">0</span>);</div><div class="line">                System.out.println(<span class="number">3</span>/<span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">catch</span>(Throwable e) &#123;</div><div class="line">                thrown e;</div><div class="line">            &#125; <span class="keyword">finally</span>&#123;</div><div class="line">                threadDeal(<span class="keyword">this</span>,thrown);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        exec.execute(<span class="keyword">new</span> InitiativeCaught().new InitialtiveThread());</div><div class="line">        exec.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">==Exception: / by zero</div></pre></td></tr></table></figure></p>
<p>上面介绍了一种主动方法来解决未检测异常。在Thread ApI中同样提供了UncaughtExceptionHandle,它能检测出某个由于未捕获的异常而终结的情况。这两种方法是互补的,通过将二者结合在一起,就能有效地防止线程泄露问题。<br>如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.Thread.UncaughtExceptionHandler;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WitchCaughtThread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</div><div class="line">        thread.setUncaughtExceptionHandler(<span class="keyword">new</span> ExceptionHandler());</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"==Exception: "</span>+e.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">==Exception: / by zero</div></pre></td></tr></table></figure></p>
<p>同样可以为所有的Thread设置一个默认的UncaughtExceptionHandler,通过调用Thread.setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)方法,这是Thread的一个static方法。</p>
<p>如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.Thread.UncaughtExceptionHandler;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WitchCaughtThread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> ExceptionHandler());</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"==Exception: "</span>+e.getMessage());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">==Exception: / by zero</div></pre></td></tr></table></figure></p>
<p>如果采用线程池通过execute的方法去捕获异常,先看下面的例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecuteCaught</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Task());</div><div class="line">        thread.setUncaughtExceptionHandler(<span class="keyword">new</span> ExceptionHandler());</div><div class="line">        exec.execute(thread);</div><div class="line">        exec.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ExceptionHandler可参考上面的例子,运行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Exception in thread &quot;pool-1-thread-1&quot; java.lang.ArithmeticException: / by zero</div><div class="line">    at com.exception.Task.run(NoCaughtThread.java:25)</div><div class="line">    at java.lang.Thread.run(Unknown Source)</div><div class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source)</div><div class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source)</div><div class="line">    at java.lang.Thread.run(Unknown Source)</div></pre></td></tr></table></figure></p>
<p>可以看到并未捕获到异常。<br>这时需要将异常的捕获封装到Runnable或者Callable中,如下所示:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecuteCaught</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        exec.execute(<span class="keyword">new</span> ThreadPoolTask());</div><div class="line">        exec.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Thread.currentThread().setUncaughtExceptionHandler(<span class="keyword">new</span> ExceptionHandler());</div><div class="line">        System.out.println(<span class="number">3</span>/<span class="number">2</span>);</div><div class="line">        System.out.println(<span class="number">3</span>/<span class="number">0</span>);</div><div class="line">        System.out.println(<span class="number">3</span>/<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">==Exception: / by zero</div></pre></td></tr></table></figure></p>
<p>只有通过execute提交的任务,才能将它抛出的异常交给UncaughtExceptionHandler,而通过submit提交的任务,无论是抛出的未检测异常还是已检查异常,都将被认为是任务返回状态的一部分。如果一个由submit提交的任务由于抛出了异常而结束,那么这个异常将被Future.get封装在ExecutionException中重新抛出。<br>下面两个例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubmitCaught</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        exec.submit(<span class="keyword">new</span> Task());</div><div class="line">        exec.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubmitCaught</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        exec.submit(<span class="keyword">new</span> ThreadPoolTask());</div><div class="line">        exec.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果都是: 1</p>
<p>这样可以证实我的观点。接下来通过这个例子可以看到捕获的异常:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</div><div class="line"><span class="keyword">import</span> java.util.concurrent.Future;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubmitCaught</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ExecutorService exec = Executors.newCachedThreadPool();</div><div class="line">        Future&lt;?&gt; future = exec.submit(<span class="keyword">new</span> Task());</div><div class="line">        exec.shutdown();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            future.get();</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</div><div class="line">            System.out.println(<span class="string">"==Exception: "</span>+e.getMessage());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">==Exception: java.lang.ArithmeticException: / by zero</div></pre></td></tr></table></figure></p>
<p>ref: <a href="http://www.importnew.com/18619.html" target="_blank" rel="external">http://www.importnew.com/18619.html</a></p>
<!-- more -->
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Thread-基础</title>
    <url>/2017/09/13/Java-Thread-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>很多人都对其中的一些概念不够明确,如同步、并发等等,让我们先建立一个数据字典,以免产生误会。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>多线程:指的是这个程序(一个进程)运行时产生了不止一个线程</li>
<li><p>并行与并发:</p>
<ul>
<li>并行:多个cpu实例或者多台机器同时执行一段处理逻辑,是真正的同时。</li>
<li>并发:通过cpu调度算法,让用户看上去同时执行,实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源,那么针对这个公用的资源往往产生瓶颈,我们会用TPS或者QPS来反应这个系统的处理能力。</li>
</ul>
</li>
<li><p>线程安全:经常用来描绘一段代码。指在并发的情况之下,该代码经过多线程使用,线程的调度顺序不影响任何结果。这个时候使用多线程,我们只需要关注系统的内存,cpu是不是够用即可。反过来,线程不安全就意味着线程的调度顺序会影响最终结果,如不加事务的转账代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(User from, User to, <span class="keyword">float</span> amount)</span></span>&#123;</div><div class="line">  to.setMoney(to.getBalance() + amount);</div><div class="line">  from.setMoney(from.getBalance() - amount);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>同步:Java中的同步指的是通过人为的控制和调度,保证共享资源的多线程访问成为线程安全,来保证结果的准确。如上面的代码简单加入@synchronized关键字。在保证结果准确的同时,提高性能,才是优秀的程序。线程安全的优先级高于性能。</p>
</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>对于单核CPU来说(对于多核CPU,此处就理解为一个核),CPU在一个时刻只能运行一个线程,当在运行一个线程的过程中转去运行另外一个线程,这个叫做线程上下文切换(对于进程也是类似)。</p>
<p>由于可能当前线程的任务并没有执行完毕,所以在切换时需要保存线程的运行状态,以便下次重新切换回来时能够继续切换之前的状态运行。举个简单的例子:比如一个线程A正在读取一个文件的内容,正读到文件的一半,此时需要暂停线程A,转去执行线程B,当再次切换回来执行线程A的时候,我们不希望线程A又从文件的开头来读取。</p>
<p>因此需要记录线程A的运行状态,那么会记录哪些数据呢？因为下次恢复时需要知道在这之前当前线程已经执行到哪条指令了,所以需要记录程序计数器的值,另外比如说线程正在进行某个计算的时候被挂起了,那么下次继续执行的时候需要知道之前挂起时变量的值时多少,因此需要记录CPU寄存器的状态。所以一般来说,线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。</p>
<p>说简单点的:对于线程的上下文切换实际上就是 <strong>存储和恢复CPU状态的过程,它使得线程执行能够从中断点恢复执行。</strong></p>
<p>虽然多线程可以使得任务执行的效率得到提升,但是由于在线程切换时同样会带来一定的开销代价,并且多个线程会导致系统资源占用的增加,所以在进行多线程编程时要注意这些因素。</p>
<h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>在java.lang包中定义, 继承Thread类必须重写run()方法<br>创建好了自己的线程类之后,就可以创建线程对象了,然后通过start()方法去启动线程。注意,不是调用run()方法启动线程,run方法中只是定义需要执行的任务,如果调用run方法,即相当于在主线程中执行run方法,跟普通的方法调用没有任何区别,此时并不会创建一个新的线程来执行定义的任务。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;</div><div class="line">        num++;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"主动创建的第"</span>+num+<span class="string">"个线程"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面代码中,通过调用start()方法,就会创建一个新的线程了。为了分清start()方法调用和run()方法调用的区别,请看下面一个例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"name:"</span>+name+<span class="string">" 子线程ID:"</span>+Thread.currentThread().getId());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        System.out.println(<span class="string">"主线程ID:"</span>+Thread.currentThread().getId());</div><div class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"thread1"</span>);</div><div class="line">        thread1.start();</div><div class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(<span class="string">"thread2"</span>);</div><div class="line">        thread2.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">运行结果:</div><div class="line">主线程ID:1</div><div class="line">name:thread2 子线程ID:1</div><div class="line">name:thread1 子线程ID:8</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>从输出结果可以得出以下结论:</p>
<ol>
<li>thread1和thread2的线程ID不同,thread2和主线程ID相同,说明通过run方法调用并不会创建新的线程,而是在主线程中直接运行run方法,跟普通的方法调用没有任何区别；</li>
<li>虽然thread1的start方法调用在thread2的run方法前面调用,但是先输出的是thread2的run方法调用的相关信息,说明新线程创建的过程不会阻塞主线程的后续执行。</li>
</ol>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>在Java中创建线程除了继承Thread类之外,还可以通过实现Runnable接口来实现类似的功能。实现Runnable接口必须重写其run方法。<br>下面是一个例子:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        System.out.println(<span class="string">"主线程ID:"</span>+Thread.currentThread().getId());</div><div class="line">        MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</div><div class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</div><div class="line">        thread.start();</div><div class="line">    &#125;</div><div class="line">&#125; </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"子线程ID:"</span>+Thread.currentThread().getId());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Runnable的中文意思是“任务”,顾名思义,通过实现Runnable接口,我们定义了一个子任务,然后将子任务交由Thread去执行。注意,这种方式必须将Runnable作为Thread类的参数,然后通过Thread的start方法来创建一个新线程来执行该子任务。如果调用Runnable的run方法的话,是不会创建新线程的,这根普通的方法调用没有任何区别。</p>
<p>事实上,查看Thread类的实现源代码会发现Thread类是实现了Runnable接口的。</p>
<p>在Java中,这2种方式都可以用来创建线程去执行子任务,具体选择哪一种方式要看自己的需求。直接继承Thread类的话,可能比实现Runnable接口看起来更加简洁,但是由于Java只允许单继承,所以如果自定义类需要继承其他类,则只能选择实现Runnable接口。</p>
<h3 id="使用ExecutorService、Callable、Future实现有返回结果的多线程"><a href="#使用ExecutorService、Callable、Future实现有返回结果的多线程" class="headerlink" title="使用ExecutorService、Callable、Future实现有返回结果的多线程"></a>使用ExecutorService、Callable、Future实现有返回结果的多线程</h3><p>ExecutorService、Callable、Future这个对象实际上都是属于Executor框架中的功能类。想要详细了解Executor框架的可以访问 <a href="http://www.iteye.com/topic/366591" target="_blank" rel="external">http://www.iteye.com/topic/366591</a> ,这里面对该框架做了很详细的解释。返回结果的线程是在JDK1.5中引入的新特征,有了这种特征我就不需要再为了得到返回值而大费周折了。</p>
<p>可返回值的任务必须实现Callable接口,类似的,无返回值的任务必须Runnable接口。执行Callable任务后,可以获取一个Future的对象,在该对象上调用get就可以获取到Callable任务返回的Object了,再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。下面提供了一个完整的有返回结果的多线程测试例子,在JDK1.5下验证过没问题可以直接使用。代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 有返回值的线程</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"----程序开始运行----"</span>);</div><div class="line">        Date date1 = <span class="keyword">new</span> Date();</div><div class="line"></div><div class="line">        <span class="keyword">int</span> taskSize = <span class="number">5</span>;</div><div class="line">        <span class="comment">// 创建一个线程池  </span></div><div class="line">        ExecutorService pool = Executors.newFixedThreadPool(taskSize);</div><div class="line">        <span class="comment">// 创建多个有返回值的任务  </span></div><div class="line">        List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</div><div class="line">            Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">" "</span>);</div><div class="line">            <span class="comment">// 执行任务并获取Future对象  </span></div><div class="line">            Future f = pool.submit(c);</div><div class="line">            list.add(f);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 关闭线程池  </span></div><div class="line">        pool.shutdown();</div><div class="line"></div><div class="line">        <span class="comment">// 获取所有并发任务的运行结果  </span></div><div class="line">        <span class="keyword">for</span> (Future f : list) &#123;</div><div class="line">            <span class="comment">// 从Future对象上获取任务的返回值,并输出到控制台  </span></div><div class="line">            System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + f.get().toString());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        Date date2 = <span class="keyword">new</span> Date();</div><div class="line">        System.out.println(<span class="string">"----程序结束运行----,程序运行时间【"</span></div><div class="line">                + (date2.getTime() - date1.getTime()) + <span class="string">"毫秒】"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> String taskNum;</div><div class="line"></div><div class="line">    MyCallable(String taskNum) &#123;</div><div class="line">        <span class="keyword">this</span>.taskNum = taskNum;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + taskNum + <span class="string">"任务启动"</span>);</div><div class="line">        Date dateTmp1 = <span class="keyword">new</span> Date();</div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">        Date dateTmp2 = <span class="keyword">new</span> Date();</div><div class="line">        <span class="keyword">long</span> time = dateTmp2.getTime() - dateTmp1.getTime();</div><div class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + taskNum + <span class="string">"任务终止"</span>);</div><div class="line">        <span class="keyword">return</span> taskNum + <span class="string">"任务返回运行结果,当前任务时间【"</span> + time + <span class="string">"毫秒】"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码说明:<br>上述代码中Executors类,提供了一系列工厂方法用于创先线程池,返回的线程池都实现了ExecutorService接口。<br>public static ExecutorService newFixedThreadPool(int nThreads)<br>创建固定数目线程的线程池。</p>
<p>public static ExecutorService newCachedThreadPool()<br>创建一个可缓存的线程池,调用execute 将重用以前构造的线程(如果线程可用)。如果现有线程没有可用的,则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</p>
<p>public static ExecutorService newSingleThreadExecutor()<br>创建一个单线程化的Executor。</p>
<p>public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)<br>创建一个支持定时及周期性的任务执行的线程池,多数情况下可用来替代Timer类。</p>
<p>ExecutoreService提供了submit()方法,传递一个Callable,或Runnable,返回Future。如果Executor后台线程池还没有完成Callable的计算,这调用返回Future对象的get()方法,会阻塞直到计算完成。</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>在正式学习Thread类中的具体方法之前,我们先来了解一下线程有哪些状态,这个将会有助于后面对Thread类中的方法的理解。</p>
<img src="/2017/09/13/Java-Thread-基础/Thread_State.png" alt="线程状态" title="线程状态">
<ul>
<li>创建(new)状态: 准备好了一个多线程的对象</li>
<li>就绪(runnable)状态: 调用了start()方法, 等待CPU进行调度</li>
<li>运行(running)状态: 执行run()方法</li>
<li>阻塞(blocked)状态: 暂时停止执行, 可能将资源交给其它线程使用</li>
<li>终止(dead)状态: 线程销毁</li>
</ul>
<p>当需要新起一个线程来执行某个子任务时,就创建了一个线程。但是线程创建之后,不会立即进入就绪状态,因为线程的运行需要一些条件(比如内存资源,在前面的JVM内存区域划分一篇博文中知道程序计数器、Java栈、本地方法栈都是线程私有的,所以需要为线程分配一定的内存空间),只有线程运行需要的所有条件满足了,才进入就绪状态。</p>
<p>当线程进入就绪状态后,不代表立刻就能获取CPU执行时间,也许此时CPU正在执行其他的事情,因此它要等待。当得到CPU执行时间之后,线程便真正进入运行状态。</p>
<p>线程在运行状态过程中,可能有多个原因导致当前线程不继续运行下去,比如用户主动让线程睡眠(睡眠一定的时间之后再重新执行)、用户主动让线程等待,或者被同步块给阻塞,此时就对应着多个状态:time waiting(睡眠或等待一定的事件)、waiting(等待被唤醒)、blocked(阻塞)。</p>
<p>当由于突然中断或者子任务执行完毕,线程就会被消亡。</p>
<p>下面这副图描述了线程从创建到消亡之间的状态:<br><img src="/2017/09/13/Java-Thread-基础/thread_status_from_new_2_dead.jpg" alt="thread_status_from_new_2_dead" title="thread_status_from_new_2_dead"></p>
<p>下图是从别处摘来的线程状态转换, 可结合以供参考<br><img src="/2017/09/13/Java-Thread-基础/Thread_State_trans.png" alt="线程状态转换" title="线程状态转换"></p>
<p>各种状态一目了然,值得一提的是”blocked”这个状态:<br>线程在Running的过程中可能会遇到阻塞(Blocked)情况</p>
<ol>
<li>调用join()和sleep()方法,sleep()时间结束或被打断,join()中断,IO完成都会回到Runnable状态,等待JVM的调度。</li>
<li>调用wait(),使该线程处于等待池(wait blocked pool),直到notify()/notifyAll(),线程被唤醒被放到锁定池(lock blocked pool ),释放同步锁使线程回到可运行状态(Runnable)</li>
<li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</li>
</ol>
<p>此外,在runnable状态的线程是处于被调度的线程,此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。</p>
<p>注:sleep和wait的区别:</p>
<ul>
<li>sleep是Thread类的方法,wait是Object类中定义的方法.</li>
<li>Thread.sleep不会导致锁行为的改变, 如果当前线程是拥有锁的, 那么Thread.sleep不会让线程释放锁.</li>
<li>Thread.sleep和Object.wait都会暂停当前的线程. OS会将执行时间分配给其它线程. 区别是, 调用wait后, 需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间.</li>
</ul>
<h2 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h2><table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">public void start()</td>
<td style="text-align:left">使该线程开始执行；Java 虚拟机调用该线程的 run 方法。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">public void run()</td>
<td style="text-align:left">如果该线程是使用独立的 Runnable 运行对象构造的,则调用该 Runnable 对象的 run 方法；否则,该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">public final void setName(String name)</td>
<td style="text-align:left">改变线程名称,使之与参数 name 相同。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">public final void setPriority(int priority)</td>
<td style="text-align:left">更改线程的优先级。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">public final void setDaemon(boolean on)</td>
<td style="text-align:left">将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">public final void join(long millisec)</td>
<td style="text-align:left">等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">public void interrupt()</td>
<td style="text-align:left">中断线程。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">public final boolean isAlive()</td>
<td style="text-align:left">测试线程是否处于活动状态。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">public static void yield()</td>
<td style="text-align:left">暂停当前正在执行的线程对象,并执行其他线程。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">public static void sleep(long millisec)</td>
<td style="text-align:left">在指定的毫秒数内让当前正在执行的线程休眠(暂停执行),此操作受到系统计时器和调度程序精度和准确性的影响。</td>
</tr>
</tbody>
</table>
<h3 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h3><p>currentThread()方法可以返回代码段正在被哪个线程调用的信息。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run1</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;                 </div><div class="line">    System.out.println(Thread.currentThread().getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h3><p>方法sleep()的作用是在指定的毫秒数内让当前“正在执行的线程”休眠(暂停执行)。这个“正在执行的线程”是指this.currentThread()返回的线程。<br>sleep方法有两个重载版本:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">sleep(<span class="keyword">long</span> millis)     <span class="comment">//参数为毫秒</span></div><div class="line">sleep(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanoseconds)    <span class="comment">//第一参数为毫秒,第二个参数为纳秒</span></div></pre></td></tr></table></figure></p>
<p>sleep相当于让线程睡眠,交出CPU,让CPU去执行其他的任务。<br>但是有一点要非常注意,sleep方法不会释放锁,也就是说如果当前线程持有对某个对象的锁,则即使调用sleep方法,其他线程也无法访问这个对象。看下面这个例子就清楚了:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">10</span>;</div><div class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</div><div class="line">        Test test = <span class="keyword">new</span> Test();</div><div class="line">        MyThread thread1 = test.new MyThread();</div><div class="line">        MyThread thread2 = test.new MyThread();</div><div class="line">        thread1.start();</div><div class="line">        thread2.start();</div><div class="line">    &#125; </div><div class="line"> </div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">synchronized</span> (object) &#123;</div><div class="line">                i++;</div><div class="line">                System.out.println(<span class="string">"i:"</span>+i);</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"进入睡眠状态"</span>);</div><div class="line">                    Thread.currentThread().sleep(<span class="number">10000</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></div><div class="line">                &#125;</div><div class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"睡眠结束"</span>);</div><div class="line">                i++;</div><div class="line">                System.out.println(<span class="string">"i:"</span>+i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">输出结果:</div><div class="line"></div><div class="line">i:11</div><div class="line">线程Thread-1进入睡眠状态</div><div class="line">线程Thread-1睡眠结束</div><div class="line">i:12</div><div class="line">i:13</div><div class="line">线程Thread-0进入睡眠状态</div><div class="line">线程Thread-0睡眠结束</div><div class="line">i:14</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>从上面输出结果可以看出,当Thread-1进入睡眠状态之后,Thread-0并没有去执行具体的任务。只有当Thread-1执行完之后,此时Thread-1释放了对象锁,Thread-0才开始执行。</p>
<p>注意,如果调用了sleep方法,必须捕获InterruptedException异常或者将该异常向上层抛出。当线程睡眠时间满后,不一定会立即得到执行,因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。</p>
<h3 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h3><p>调用yield方法会让当前线程交出CPU权限,让CPU去执行其他的线程。它跟sleep方法类似,同样不会释放锁。但是yield不能控制具体的交出CPU的时间,另外,yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。</p>
<p>注意,调用yield方法并不会让线程进入阻塞状态,而是让线程重回就绪状态,它只需要等待重新获取CPU执行时间,这一点是和sleep方法不一样的。<br>代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> beginTime=System.currentTimeMillis();</div><div class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000000</span>;i++)&#123;</div><div class="line">            count=count+(i+<span class="number">1</span>);</div><div class="line">            <span class="comment">//Thread.yield();</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> endTime=System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"用时:"</span>+(endTime-beginTime)+<span class="string">" 毫秒！"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyThread t= <span class="keyword">new</span> MyThread();</div><div class="line">        t.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">执行结果:</div><div class="line"></div><div class="line">用时:3 毫秒！</div><div class="line">如果将 //Thread.yield();的注释去掉,执行结果如下:</div><div class="line"></div><div class="line">用时:16080 毫秒！</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h3 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h3><p>start()用来启动一个线程,当调用start方法后,系统才会开启一个新的线程来执行用户定义的子任务,在这个过程中,会为相应的线程分配需要的资源。</p>
<h3 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h3><p>run()方法是<strong>不需要用户来调用</strong>的,当通过start方法启动一个线程之后,当线程获得了CPU执行时间,便进入run方法体去执行具体的任务。注意,继承Thread类必须重写run方法,在run方法中定义具体要执行的任务。</p>
<h3 id="getId"><a href="#getId" class="headerlink" title="getId()"></a>getId()</h3><p>getId()的作用是取得线程的唯一标识</p>
<h3 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h3><p>方法isAlive()的功能是判断当前线程是否处于活动状态<br>什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态,就认为线程是“存活”的。</p>
<h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h3><p>在很多情况下,主线程创建并启动了线程,如果子线程中药进行大量耗时运算,主线程往往将早于子线程结束之前结束。这时,如果主线程想等待子线程执行完成之后再结束,比如子线程处理一个数据,主线程要取得这个数据中的值,就要用到join()方法了。方法join()的作用是等待线程对象销毁。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread4</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread4</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(name);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            System.out.println(getName() + <span class="string">"  "</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">// 启动子进程</span></div><div class="line">        <span class="keyword">new</span> Thread4(<span class="string">"new thread"</span>).start();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</div><div class="line">                Thread4 th = <span class="keyword">new</span> Thread4(<span class="string">"joined thread"</span>);</div><div class="line">                th.start();</div><div class="line">                th.join();</div><div class="line">            &#125;</div><div class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  "</span> + i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">main  0</div><div class="line">main  1</div><div class="line">main  2</div><div class="line">main  3</div><div class="line">main  4</div><div class="line">new thread  0</div><div class="line">new thread  1</div><div class="line">new thread  2</div><div class="line">new thread  3</div><div class="line">new thread  4</div><div class="line">joined thread  0</div><div class="line">joined thread  1</div><div class="line">joined thread  2</div><div class="line">joined thread  3</div><div class="line">joined thread  4</div><div class="line">main  5</div><div class="line">main  6</div><div class="line">main  7</div><div class="line">main  8</div><div class="line">main  9</div></pre></td></tr></table></figure></p>
<p>由上可以看出main主线程等待joined thread线程先执行完了才结束的。如果把th.join()这行注释掉,运行结果如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">main  0</div><div class="line">main  1</div><div class="line">main  2</div><div class="line">main  3</div><div class="line">main  4</div><div class="line">main  5</div><div class="line">main  6</div><div class="line">main  7</div><div class="line">main  8</div><div class="line">main  9</div><div class="line">new thread  0</div><div class="line">new thread  1</div><div class="line">new thread  2</div><div class="line">new thread  3</div><div class="line">new thread  4</div><div class="line">joined thread  0</div><div class="line">joined thread  1</div><div class="line">joined thread  2</div><div class="line">joined thread  3</div><div class="line">joined thread  4</div></pre></td></tr></table></figure></p>
<h3 id="getName和setName"><a href="#getName和setName" class="headerlink" title="getName和setName"></a>getName和setName</h3><p>用来得到或者设置线程名称。</p>
<h3 id="getPriority和setPriority"><a href="#getPriority和setPriority" class="headerlink" title="getPriority和setPriority"></a>getPriority和setPriority</h3><p>用来获取和设置线程优先级。</p>
<h3 id="setDaemon和isDaemon"><a href="#setDaemon和isDaemon" class="headerlink" title="setDaemon和isDaemon"></a>setDaemon和isDaemon</h3><p>用来设置线程是否成为守护线程和判断线程是否是守护线程。</p>
<p>守护线程和用户线程的区别在于:守护线程依赖于创建它的线程,而用户线程则不依赖。举个简单的例子:如果在main线程中创建了一个守护线程,当main方法运行完毕之后,守护线程也会随着消亡。而用户线程则不会,用户线程会一直运行直到其运行完毕。在JVM中,像垃圾收集器线程就是守护线程。</p>
<p>在上面已经说到了Thread类中的大部分方法,那么Thread类中的方法调用到底会引起线程状态发生怎样的变化呢？下面一幅图就是在上面的图上进行改进而来的:<br><img src="/2017/09/13/Java-Thread-基础/thread_status_from_new_2_dead_with_methods.jpg" alt="thread_status_from_new_2_dead_with_methods" title="thread_status_from_new_2_dead_with_methods"></p>
<p>ps:<br>Thread类最佳实践:<br>写的时候最好要设置线程名称 Thread.name,并设置线程组 ThreadGroup,目的是方便管理。在出现问题的时候,打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题,这个线程是干什么的。</p>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><p>停止线程是在多线程开发时很重要的技术点,掌握此技术可以对线程的停止进行有效的处理。<br>停止一个线程可以使用Thread.stop()方法,但最好不用它。该方法是不安全的,已被弃用。<br>在Java中有以下3种方法可以终止正在运行的线程:</p>
<ul>
<li>使用退出标志,使线程正常退出,也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止线程,但是不推荐使用这个方法,因为stop和suspend及resume一样,都是作废过期的方法,使用他们可能产生不可预料的结果。</li>
<li>使用interrupt方法中断线程,但这个不会终止一个正在运行的线程,还需要加入一个判断才可以完成线程的停止。</li>
</ul>
<h2 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h2><p>interrupt()方法</p>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>在操作系统中,线程可以划分优先级,优先级较高的线程得到的CPU资源较多,也就是CPU优先执行优先级较高的线程对象中的任务。<br>设置线程优先级有助于帮“线程规划器”确定在下一次选择哪一个线程来优先执行。<br>设置线程的优先级使用setPriority()方法,此方法在JDK的源码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</div><div class="line">    ThreadGroup g;</div><div class="line">    checkAccess();</div><div class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</div><div class="line">            newPriority = g.getMaxPriority();</div><div class="line">        &#125;</div><div class="line">        setPriority0(priority = newPriority);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在Java中,线程的优先级分为1~10这10个等级,如果小于1或大于10,则JDK抛出异常throw new IllegalArgumentException()。<br>JDK中使用3个常量来预置定义优先级的值,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</div></pre></td></tr></table></figure></p>
<p>线程优先级特性:</p>
<ul>
<li>继承性<br>比如A线程启动B线程,则B线程的优先级与A是一样的。</li>
<li>规则性<br>高优先级的线程总是大部分先执行完,但不代表高优先级线程全部先执行完。</li>
<li>随机性<br>优先级较高的线程不一定每一次都先执行完。</li>
</ul>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>在Java线程中有两种线程,一种是User Thread(用户线程),另一种是Daemon Thread(守护线程)。<br>Daemon的作用是为其他线程的运行提供服务,比如说GC线程。其实User Thread线程和Daemon Thread守护线程本质上来说去没啥区别的,唯一的区别之处就在虚拟机的离开:如果User Thread全部撤离,那么Daemon Thread也就没啥线程好服务的了,所以虚拟机也就退出了。</p>
<p>守护线程并非虚拟机内部可以提供,用户也可以自行的设定守护线程,方法:public final void setDaemon(boolean on) ；但是有几点需要注意:</p>
<ul>
<li>thread.setDaemon(true)必须在thread.start()之前设置,否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 (备注:这点与守护进程有着明显的区别,守护进程是创建后,让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别)</li>
<li>在Daemon线程中产生的新线程也是Daemon的。 (这一点又是有着本质的区别了:守护进程fork()出来的子进程不再是守护进程,尽管它把父进程的进程相关信息复制过去了,但是子进程的进程的父进程不是init进程,所谓的守护进程本质上说就是“父进程挂掉,init收养,然后文件0,1,2都是/dev/null,当前目录到/”)</li>
<li>不是所有的应用都可以分配给Daemon线程来进行服务,比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时,虚拟机可能已经退出了。</li>
</ul>
<h2 id="每个对象都有的方法-机制"><a href="#每个对象都有的方法-机制" class="headerlink" title="每个对象都有的方法(机制)"></a>每个对象都有的方法(机制)</h2><p>synchronized, wait, notify 是任何对象都具有的同步工具。让我们先来了解他们<br>monitor<br><img src="/2017/09/13/Java-Thread-基础/a_java_monitor.png" alt="monitor" title="monitor"></p>
<p>他们是应用于同步问题的人工线程调度工具。讲其本质,首先就要明确monitor的概念,Java中的每个对象都有一个监视器,来监测并发代码的重入。在非多线程编码时该监视器不发挥作用,反之如果在synchronized 范围内,监视器发挥作用。</p>
<p>wait/notify必须存在于synchronized块中。并且,这三个关键字针对的是同一个监视器(某对象的监视器)。这意味着wait之后,其他线程可以进入同步块执行。</p>
<p>当某代码并不持有监视器的使用权时(如图中5的状态,即脱离同步块)去wait或notify,会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify,因为不同对象的监视器不同,同样会抛出此异常。</p>
<ul>
<li><p>synchronized单独使用:</p>
<ul>
<li><p>代码块:如下,在多线程环境下,synchronized块中的方法获取了lock实例的monitor,如果实例相同,那么只有一个线程能执行该块内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   Object lock;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">       <span class="keyword">synchronized</span>(lock)&#123;</div><div class="line">         ..<span class="keyword">do</span> something</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>直接用于方法: 相当于上面代码中用lock来锁定的效果,实际获取的是Thread1类的monitor。更进一步,如果修饰的是static方法,则锁定该类所有实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </div><div class="line">        ..<span class="keyword">do</span> something</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>synchronized, wait, notify结合:典型场景生产者消费者问题</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 生产者生产出来的产品交给店员</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.product &gt;= MAX_PRODUCT) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            wait();  </div><div class="line">            System.out.println(<span class="string">"产品已满,请稍候再生产"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.product++;</div><div class="line">    System.out.println(<span class="string">"生产者生产第"</span> + <span class="keyword">this</span>.product + <span class="string">"个产品."</span>);</div><div class="line">    notifyAll();   <span class="comment">//通知等待区的消费者可以取出产品了</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/**</span></div><div class="line">* 消费者从店员取产品</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.product &lt;= MIN_PRODUCT) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            wait(); </div><div class="line">            System.out.println(<span class="string">"缺货,稍候再取"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)  &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    System.out.println(<span class="string">"消费者取走了第"</span> + <span class="keyword">this</span>.product + <span class="string">"个产品."</span>);</div><div class="line">    <span class="keyword">this</span>.product--;</div><div class="line">    notifyAll();   <span class="comment">//通知等待去的生产者可以生产产品了</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>volatile</p>
<p>多线程的内存模型:main memory(主存)、working memory(线程栈),在处理数据时,线程会把值从主存load到本地栈,完成操作后再save回去(volatile关键词的作用:每次针对该变量的操作都激发一次load and save)。<br><img src="/2017/09/13/Java-Thread-基础/main_memory.png" alt="main_memory" title="main_memory"><br>针对多线程使用的变量如果不是volatile或者final修饰的,很有可能产生不可预知的结果(另一个线程修改了这个值,但是之后在某线程看到的是修改之前的值)。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的,本质上,volatile就是不去缓存,直接取值。在线程安全的情况下加volatile会牺牲性能。</p>
<h2 id="如何获取线程中的异常"><a href="#如何获取线程中的异常" class="headerlink" title="如何获取线程中的异常"></a>如何获取线程中的异常</h2><img src="/2017/09/13/Java-Thread-基础/thread_exception_catch.png" alt="thread_exception_catch" title="thread_exception_catch">
<p>不能用try,catch来获取线程中的异常</p>
<h2 id="高级多线程控制类"><a href="#高级多线程控制类" class="headerlink" title="高级多线程控制类"></a>高级多线程控制类</h2><p>以上都属于内功心法,接下来是实际项目中常用到的工具了,Java1.5提供了一个非常高效实用的多线程包:java.util.concurrent, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。</p>
<h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><p>用处:保存线程的独立变量。对一个线程类(继承自Thread)<br>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,所以每一个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本。常用于用户登录控制,如记录session信息。</p>
<p>实现:每个Thread都持有一个TreadLocalMap类型的变量(该类是一个轻量级的Map,功能与map一样,区别是桶里放的是entry而不是entry的链表。功能还是一个map。)以本身为key,以目标为value。<br>主要方法是get()和set(T a),set之后在map里维护一个threadLocal -&gt; a,get时将a返回。ThreadLocal是一个特殊的容器。</p>
<h3 id="原子类-AtomicInteger、AtomicBoolean……"><a href="#原子类-AtomicInteger、AtomicBoolean……" class="headerlink" title="原子类(AtomicInteger、AtomicBoolean……)"></a>原子类(AtomicInteger、AtomicBoolean……)</h3><p>如果使用atomic wrapper class如atomicInteger,或者使用自己保证原子的操作,则等同于synchronized<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//返回值为boolean</span></div><div class="line">AtomicInteger.compareAndSet(<span class="keyword">int</span> expect,<span class="keyword">int</span> update)</div></pre></td></tr></table></figure></p>
<p>该方法可用于实现乐观锁,考虑文中最初提到的如下场景:a给b付款10元,a扣了10元,b要加10元。此时c给b2元,但是b的加十元代码约为:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span>(b.value.compareAndSet(old, value))&#123;</div><div class="line">   <span class="keyword">return</span> ;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">   <span class="comment">//try again</span></div><div class="line">   <span class="comment">// if that fails, rollback and log</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>AtomicReference<br>对于AtomicReference 来讲,也许对象会出现,属性丢失的情况,即oldObject == current,但是oldObject.getPropertyA != current.getPropertyA。<br>这时候,AtomicStampedReference就派上用场了。这也是一个很常用的思路,即加上版本号</p>
<h3 id="Lock类"><a href="#Lock类" class="headerlink" title="Lock类"></a>Lock类</h3><p>lock: 在java.util.concurrent包内。共有三个实现:</p>
<ul>
<li>ReentrantLock</li>
<li>ReentrantReadWriteLock.ReadLock</li>
<li>ReentrantReadWriteLock.WriteLock</li>
</ul>
<p>主要目的是和synchronized一样, 两者都是为了解决同步问题,处理资源争端而产生的技术。功能类似但有一些区别。</p>
<p>区别如下:</p>
<ul>
<li>lock更灵活,可以自由定义多把锁的枷锁解锁顺序(synchronized要按照先加的后解顺序)</li>
<li>提供多种加锁方案,lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式,还有trylock的带超时时间版本。</li>
<li>本质上和监视器锁(即synchronized是一样的)</li>
<li>能力越大,责任越大,必须控制好加锁和解锁,否则会导致灾难。</li>
<li>和Condition类的结合。</li>
<li>性能更高,对比如下图:<br>synchronized和Lock性能对比<img src="/2017/09/13/Java-Thread-基础/synchronize_Lock_performance.png" alt="synchronize_Lock_performance" title="synchronize_Lock_performance">
</li>
</ul>
<p>ReentrantLock<br>可重入的意义在于持有锁的线程可以继续持有,并且要释放对等的次数后才真正释放该锁。<br>使用方法是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//1.先new一个实例</span></div><div class="line"><span class="keyword">static</span> ReentrantLock r=<span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line"><span class="comment">//2.加锁</span></div><div class="line">r.lock()<span class="comment">//或r.lockInterruptibly();</span></div><div class="line"><span class="comment">/*此处也是个不同,后者可被打断。当a线程lock后,b线程阻塞,此时如果是lockInterruptibly,那么在调用b.interrupt()之后,b线程退出阻塞,并放弃对资源的争抢,进入catch块。(如果使用后者,必须throw interruptable exception 或catch)*/</span></div><div class="line"></div><div class="line"><span class="comment">//3.释放锁</span></div><div class="line">r.unlock()</div><div class="line"></div><div class="line"><span class="comment">/*必须做！何为必须做呢,要放在finally里面。以防止异常跳出了正常流程,导致灾难。这里补充一个小知识点,finally是可以信任的:经过测试,哪怕是发生了OutofMemoryError,finally块中的语句执行也能够得到保证。*/</span></div></pre></td></tr></table></figure>
<p>ReentrantReadWriteLock</p>
<p>可重入读写锁(读写锁的一个实现)<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock()</div><div class="line">ReadLock r = lock.readLock();</div><div class="line">WriteLock w = lock.writeLock();</div></pre></td></tr></table></figure></p>
<p>两者都有lock,unlock方法。写写,写读互斥；读读不互斥。可以实现并发读的高效线程安全代码</p>
<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>这里就讨论比较常用的两个:</p>
<ul>
<li>BlockingQueue</li>
<li>ConcurrentHashMap</li>
</ul>
<p>BlockingQueue<br>阻塞队列。该类是java.util.concurrent包下的重要类,通过对Queue的学习可以得知,这个queue是单向队列,可以在队列头添加元素和在队尾删除或取出元素。类似于一个管　　道,特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue(优先队列),有兴趣可以研究</p>
<p>BlockingQueue在队列的基础上添加了多线程协作的功能:<br><img src="/2017/09/13/Java-Thread-基础/BlockingQueue.png" alt="BlockingQueue" title="BlockingQueue"></p>
<p>除了传统的queue功能(表格左边的两列)之外,还提供了阻塞接口put和take,带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞,直到有空间时被唤醒；take在队　列空的时候阻塞,直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用,堪称神器。</p>
<p>常见的阻塞队列有:</p>
<ul>
<li>ArrayListBlockingQueue</li>
<li>LinkedListBlockingQueue</li>
<li>DelayQueue</li>
<li>SynchronousQueue</li>
</ul>
<p>ConcurrentHashMap<br>高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap</p>
<h3 id="管理类"><a href="#管理类" class="headerlink" title="管理类"></a>管理类</h3><p>管理类的概念比较泛,用于管理线程,本身不是多线程的,但提供了一些机制来利用上述的工具做一些封装。<br>了解到的值得一提的管理类:ThreadPoolExecutor和 JMX框架下的系统级管理类 ThreadMXBean<br>ThreadPoolExecutor<br>如果不了解这个类,应该了解前面提到的ExecutorService,开一个自己的线程池非常方便:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ExecutorService e = Executors.newCachedThreadPool();</div><div class="line">ExecutorService e = Executors.newSingleThreadExecutor();</div><div class="line">ExecutorService e = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line"><span class="comment">// 第一种是可变大小线程池,按照任务数来分配线程,</span></div><div class="line"><span class="comment">// 第二种是单线程池,相当于FixedThreadPool(1)</span></div><div class="line"><span class="comment">// 第三种是固定大小线程池。</span></div><div class="line"><span class="comment">// 然后运行</span></div><div class="line">e.execute(<span class="keyword">new</span> MyRunnableImpl());</div></pre></td></tr></table></figure></p>
<p>该类内部是通过ThreadPoolExecutor实现的,掌握该类有助于理解线程池的管理,本质上,他们都是ThreadPoolExecutor类的各种实现版本。请参见javadoc:<br><img src="/2017/09/13/Java-Thread-基础/ThreadPoolExecutor.png" alt="ThreadPoolExecutor" title="ThreadPoolExecutor"></p>
<p>ThreadPoolExecutor参数解释<br>翻译一下:<br>corePoolSize:池内线程初始值与最小值,就算是空闲状态,也会保持该数量线程。<br>maximumPoolSize:线程最大值,线程的增长始终不会超过该值。<br>keepAliveTime:当池内线程数高于corePoolSize时,经过多少时间多余的空闲线程才会被回收。回收前处于wait状态<br>unit:时间单位,可以使用TimeUnit的实例,如TimeUnit.MILLISECONDS<br>workQueue:待入任务(Runnable)的等待场所,该参数主要影响调度策略,如公平与否,是否产生饿死(starving)<br>threadFactory:线程工厂类,有默认实现,如果有自定义的需要则需要自己实现ThreadFactory接口并作为参数传入。</p>
<p>ref:<br><a href="http://www.importnew.com/21089.html" target="_blank" rel="external">http://www.importnew.com/21089.html</a><br><a href="http://www.importnew.com/21136.html" target="_blank" rel="external">http://www.importnew.com/21136.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Thread-线程池调整</title>
    <url>/2017/09/13/Java-Thread-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<p>知道吗,你的Java web应用其实是使用线程池来处理请求的。这一实现细节被许多人忽略,但是你迟早都需要理解线程池如何使用,以及如何正确地根据应用调整线程池配置。这篇文章的目的是为了解释线程模型——什么是线程池、以及怎样正确地配置线程池。</p>
<a id="more"></a>
<h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>让我们从一些基础的线程模型开始,然后再随着线程模型的演变进行更深一步的学习。你使用的任何应用服务器或框架,如Tomcat、Dropwizard、Jetty等,它们的基本原理其实是相同的。Web服务器的最底层实际上是一个socket。这个socket监听并接受到达的TCP连接。一旦一个连接被建立,就可以通过这个新建立的连接读取、解析信息,然后将这些信息包装成一个HTTP请求。这个HTTP请求还将被移交至web应用程序,来完成请求的动作。</p>
<p>我们将通过一个简单的服务器程序来展示线程在其中所起到的作用。这个服务器程序展示了大部分应用服务器的底层实现细节。让我们以一个简单的单线程web服务器程序开始,它的代码像下面这样:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ServerSocket listener = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        Socket socket = listener.accept();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            handleRequest(socket);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    listener.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这段代码在8080端口上创建了一个ServerSocket,紧接着通过循环来监听和接受新到达的连接。一旦连接建立,会将socket传递给handleRequest方法。这个方法可能会读取该HTTP请求,处理这个请求,然后写回一个响应。在这个简单的例子中,handleRequest方法从socket中读取简单的一行数据,然后返回一个简短的HTTP响应。但是,handleRequest有可能需要处理一些更复杂的任务,例如读数据库或者执行其它一些IO操作。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">static</span> String response =</div><div class="line">    <span class="string">"HTTP/1.0 200 OKrn"</span> +</div><div class="line">    <span class="string">"Content-type: text/plainrn"</span> +</div><div class="line">    <span class="string">"rn"</span> +</div><div class="line">    <span class="string">"Hello Worldrn"</span>;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket socket)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// Read the input stream, and return "200 OK"</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        BufferedReader in = <span class="keyword">new</span> BufferedReader(</div><div class="line">            <span class="keyword">new</span> InputStreamReader(socket.getInputStream()));</div><div class="line"> </div><div class="line">        log.info(in.readLine());</div><div class="line"> </div><div class="line">        OutputStream out = socket.getOutputStream();</div><div class="line">        out.write(response.getBytes(StandardCharsets.UTF_8));</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        socket.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为只有一个线程处理所有的socket,因此只有在完全处理好一个请求后,才能再接受下一个请求。在实际的应用中,handleRequest方法可能需要经过100毫秒才能返回,那么这个服务器程序在一秒中,只能按顺序处理10个请求。</p>
<h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p>尽管handleRequest可能会被IO操作阻塞,CPU却可能是空闲的,它可以处理其它更多请求,但这对单线程模型来说是不能实现的。因此,通过创建多个线程,可以使服务器程序实现并发操作:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleRequestRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Socket socket;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HandleRequestRunnable</span><span class="params">(Socket socket)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.socket = socket;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            handleRequest(socket);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// Main loop here</span></div><div class="line">ServerSocket listener = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        Socket socket = listener.accept();</div><div class="line">        <span class="keyword">new</span> Thread( <span class="keyword">new</span> HandleRequestRunnable(socket) ).start();</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    listener.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这段代码中,accept()方法仍然是在一个单线程循环中被调用。但是当TCP连接建立,socket创建时,服务器就创建一个新的线程。这个新生的线程将执行和单线程模型中一样的handleRequest方法。</p>
<p>新线程的建立使调用accept方法的线程能够处理更多的TCP连接,这样服务器就能并发地处理请求了。这一技术被称为“thread per request”（一个线程处理一个请求),也是现在最流行的服务器技术。值得注意的是,还有一些其它的服务器技术,如NGINX和Node.js采用的事件驱动异步模型,它们都没有使用线程池。因此,它们都不在本文的讨论范围内。</p>
<p>“thread per request”方式里创建新线程（稍后销毁这个线程)的操作是昂贵的,因为Java虚拟机和操作系统都需要为这一操作分配资源。另外,在上面那段代码的中,可以创建的线程数量是不受限制的。这么做的隐患很大,因为它可能导致服务器资源迅速枯竭。</p>
<h2 id="资源枯竭"><a href="#资源枯竭" class="headerlink" title="资源枯竭"></a>资源枯竭</h2><p>每个线程都需要一定的内存空间来作为自己的栈空间。在最近的64位虚拟机版本中,默认的栈空间是1024KB。如果server收到很多请求,或者handleRequest方法的执行时间变得比较长,就会造成服务器产生很多并发线程。如果要维护1000个线程,仅就栈空间而言,虚拟机就必须耗费1GB的RAM空间。另外,为处理请求,每个线程都会在堆上产生许多对象,这就有可能导致虚拟机的堆空间被迅速占满,给虚拟机的垃圾收集器带来很大压力,造成频繁的垃圾回收,最终导致OutOfMemoryErrors。</p>
<p>线程消耗的不仅是RAM资源,这些线程还可能消耗其它有限的资源,例如文件句柄、数据库连接等。过多地消耗这类资源可能导致一些其它的错误或造成系统崩溃。因此,要防止系统资源被线程耗尽,就必须对服务器产生的线程数量做出限制。</p>
<p>通过使用-Xss参数来调整每个线程的栈空间,可以在一定程度上解决资源枯竭的问题,但它绝不是灵丹妙药。一个小的栈空间可以使得每个线程占用的内存减小,但这样可能会造成StackOverflowErrors栈溢出错误。栈空间的调整方式不尽相同,但是对许多应用来说,1024KB过于浪费了,而256KB或512KB会更加合适。Java所允许的最小栈空间的大小是160KB。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>可以通过一个简单的线程池来避免持续地创建新线程,限制最大线程数量。线程池跟踪着所有线程,在线程数量达到上限前,它会创建新的线程,当有空闲线程时,它会使用空闲线程。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">ServerSocket listener = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</div><div class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">4</span>);</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        Socket socket = listener.accept();</div><div class="line">        executor.submit( <span class="keyword">new</span> HandleRequestRunnable(socket) );</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    listener.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这段代码使用了ExecutorService类来提交任务(Runnable)。提交的任务将会被线程池中的线程执行,而不是通过新创建的线程执行。在这个例子中,所有的请求都通过一个线程数量固定为4的线程池来完成。这个线程池限制了并发执行的请求数量,从而限制了系统资源的使用。</p>
<p>除了<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html" target="_blank" rel="external">newFixedThreadPool</a>方法创建的线程池外,Executors类还提供了newCachedThreadPool 方法来创建线程池。这种线程池同样有无法限制线程数量的问题,但是它会优先使用线程池中已创建的空闲线程来处理请求。这种类型的线程池特别适用于执行短期任务的请求,因为它们不会长时间的阻塞外部资源。</p>
<p>ThreadPoolExecutors 类也可以直接创建,这样就可以对它进行一些个性化的配置。例如可以配置线程池内最小线程数和最大线程数,也可以配置线程创建和销毁的策略。稍后,本文将介绍这样的例子。</p>
<h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><p>对于线程数量固定的线程池,善于观察的读者可能会提出这样的一个疑问:当线程池中的线程都在工作时,一个新的请求到达,会发生什么呢？当线程池中的线程都在工作时,ThreadPoolExecutor可能会使用一个队列来组织新到达的请求,直到线程池中有空闲的线程可以使用。Executors.nexFixedThreadPool方法会默认创建一个没有长度限制的LinkedList。这个LinkedList也可能会产生系统资源耗尽的问题,虽然这个过程会比较缓慢,因为队列中的请求所占用的资源比线程占用的资源要少得多。但是在我们的例子中,队列中的每个请求都保持着一个socket,而每一个socket都需要打开一个文件句柄,操作系统对同时打开的文件句柄数量是有限制的,所以队列中保持socket并不是一个好的方式,除非必须这么做。因此,限制工作队列的长度也是有意义的。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newBoundedFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(capacity),</div><div class="line">        <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">boundedThreadPoolServerSocket</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ServerSocket listener = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>);</div><div class="line">    ExecutorService executor = newBoundedFixedThreadPool(<span class="number">4</span>, <span class="number">16</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            Socket socket = listener.accept();</div><div class="line">            executor.submit( <span class="keyword">new</span> HandleRequestRunnable(socket) );</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        listener.close();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们再一次创建一个线程池,这一次我们没有使用Executors.newFixedThreadPool方法,而是自定义了一个ThreadPoolExecutor,在构造方法中传递了一个大小限制为16个元素的<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/LinkedBlockingQueue.html" target="_blank" rel="external">LinkedBlockingQueue</a>。同样的,类ArrayBlockingQueue也可以被用来限制队列的长度。</p>
<p>如果所有的线程都在执行任务,而且工作队列也被请求填满了,此时对于新到达请求的处理方式,取决于ThreadPoolExecutor构造方法的最后一个参数。在我们这个例子中,我们使用的是<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" target="_blank" rel="external">DiscardPolicy</a>,这个参数会让线程池丢弃新到达的请求。还有一些其它的处理策略,例如<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" target="_blank" rel="external">AbortPolicy</a>会让Executor抛出一个异常,<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" target="_blank" rel="external">CallerRunsPolicy</a>会使任务在它的调用端线程池中执行。CallerRunsPolicy策略提供了一个简单的方式来限制任务提交的速度。但是这样做可能是有害的,因为它会阻塞一个原本不应被阻塞的线程。</p>
<p>一个好的默认策略应该是Discard或Abort,它们都会使线程池丢弃新到达的任务。这样服务器就能容易地向客户端响应一个错误,例如HTTP的503错误“Service unavailable”。有的人可能会认为,队列的长度应该是允许增长的,这样所有的任务最终都能被执行。但是用户是不愿意长时间等待的,而且若任务到达的速度超过任务处理的速度,队列将会无限地增长。队列是被用来缓冲突然爆发的请求,或者处理短期任务的,通常情况下,队列应该是空的。</p>
<h2 id="多少线程合适呢？"><a href="#多少线程合适呢？" class="headerlink" title="多少线程合适呢？"></a>多少线程合适呢？</h2><p>现在,我们知道了如何创建一个线程池。但是有一个更困难的问题,线程池里应该创建多少个线程呢？我们已经知道了线程池中的最大线程数量应该被限制,才不会导致系统资源耗尽。这些系统资源包括了内存（堆栈)、打开的文件句柄、打开的TCP连接、打开的数据库连接以及其它有限的系统资源。相反的,如果线程执行的是CPU密集型任务而不是IO密集型任务,服务器的物理内核数就应该被视为是有限的资源,这样创建的线程数就不应该超过系统的内核数。</p>
<p>系统应创建多少线程取决于这个应用执行的任务。开发人员应使用现实的请求来对系统进行负载测试,测试不同的线程池大小配置对系统的影响。每次测试都增加线程池的大小,直到系统达到崩溃的临界点。这个方法使你可以发现线程池线程数量的上限。超过这个上限,系统的资源将耗尽。在某些情况下,可以谨慎地增加系统的资源,例如分配更多的RAM空间给JVM,或者调整操作系统使其支持同时打开更多的文件句柄。然而,在某些情况下创建的线程数量会达到我们测试出的理论上限,这非常值得我们注意。稍后还会看到这方面的内容。</p>
<h2 id="利特尔法则"><a href="#利特尔法则" class="headerlink" title="利特尔法则"></a>利特尔法则</h2><img src="/2017/09/13/Java-Thread-线程池调整/Littles_Law.png" alt="Littles_Law" title="Littles_Law">
<p>排队论,特别的,Little’s Law,可以用来帮助我们理解线程池的一些特性。简单地说,利特尔法则解释了这三种变量的关系:L—系统里的请求数量、λ—请求到达的速率和W—每个请求的处理时间。例如,如果每秒10个请求到达,处理一个请求需要1秒,那么系统在每个时刻都有10个请求在处理。如果处理每个请求的时间翻倍,那么系统每时刻需要处理的请求数也翻倍为20,因此需要20个线程。</p>
<p>任务的执行时间对于系统中正在处理的请求数量有着很大的影响,一些后端资源的迟延,例如数据库,通常会使得请求的处理时间被延长,从而导致线程池中的线程被迅速用尽。因此,理论上测出的线程数上限对于这种情况就不是很合适,这个上限值还应该考虑到线程的执行时间,并结合理论上的上限值。</p>
<p>例如,假设JVM最多能同时处理的请求数为1000。如果我们预计每个请求需要耗费的时间不超过30秒,那么,在最坏的情况下我们每秒能同时处理的请求数不会超过33 ⅓个。但是,如果一切都很顺利,每个请求只需使用500ms就可以完成,那么通过1000个线程应用每秒就可以处理2000个请求。当系统突然出现短暂的任务执行迟延的问题时,通过使用一个队列来减缓这一问题是可行的。</p>
<h2 id="为什么线程数配置不当会带来麻烦？"><a href="#为什么线程数配置不当会带来麻烦？" class="headerlink" title="为什么线程数配置不当会带来麻烦？"></a>为什么线程数配置不当会带来麻烦？</h2><p>如果线程池的线程数量过少,我们就无法充分利用系统资源,这使得用户需要花费很长时间来等待请求的响应。但是,如果允许创建过多的线程,系统的资源又会被耗尽,这会对系统造成更大的破坏。</p>
<p>不仅仅是本地的资源被耗尽,其它一些应用也会受到影响。例如,许多应用都使用同一个后端数据库进行查询等操作。数据库有并发连接数量的限制。如果一个应用不加限制地占用了所有数据库连接,其它获取数据库连接的应用都将被阻塞。这将导致许多应用运行中断。</p>
<p>更糟的是,资源耗尽还会引发一些连锁故障。设想这样一个场景,一个应用有许多个实例,这些实例都运行在一个负载均衡器之后。如果一个实例因为过多的请求而占用了过多内存,JVM就需要花更多的时间进行垃圾收集工作,那么JVM处理请求的时间就减少了。这样一来,这个应用实例处理请求的能力降低了,系统中的其它实例就必须处理更多的请求。其它的实例也会因为请求数过多以及线程池大小没有限制的原因产生资源枯竭等问题。这些实例用尽了内存资源,导致虚拟机进行频繁地内存收集操作。这样的恶性循环会在这些实例中产生,直到整个系统奔溃。</p>
<p>我见过许多没有进行负载测试的应用,这些应用能够创建任意多的线程。通常情况下,这些应用只要很少数量的线程就能处理好以一定速率到达的请求。但是,如果应用需要使用其它的一些远程服务来处理用户请求,而这个远程服务的处理能力突然降低了,这将增加【大】W的值（应用处理请求的平均时间)。这样,线程池的线程就会被迅速用尽。如果对应用进行线程数量的负载测试,那么资源枯竭问题就会在测试中显现出来。</p>
<h2 id="多少个线程池合适？"><a href="#多少个线程池合适？" class="headerlink" title="多少个线程池合适？"></a>多少个线程池合适？</h2><p>对于微服务架构和面向服务的架构（SOA)来说,它们通常需要请求一些后端服务。线程池的配置非常容易导致程序失败,因此必须谨慎地配置线程池。如果远程服务的性能下降,系统中的线程数量就会迅速达到线程池的上限,其它后续到达的服务就会被丢弃。这些后续的请求也许并不是要使用性能出现故障的服务,但是它们都只能被丢弃了。</p>
<p>针对不同的后端服务请求,设置不同的线程池可以解决这一问题。在这个模式中,仍然使用同一个线程池来处理用户的请求,但是当用户的请求需要调用一个远程服务时,这个任务就被传递给一个指定的后端线程池。这样处理用户请求的主线程池就不会因为调用后端服务而产生很大的负担。当后端服务出现故障时,只有调用这个服务的线程池才会受到影响。</p>
<p>使用多个线程池还有一个好处,就是它能帮助避免出现死锁问题。如果每个空闲线程都因为一个尚未处理完毕的请求阻塞,就会发生死锁,没有一个线程可以继续往下执行。如果使用多个线程池,理解好每个线程池应负责的工作,那么死锁的问题就能在一定程度上避免。</p>
<h2 id="截止时间和一些最佳实践"><a href="#截止时间和一些最佳实践" class="headerlink" title="截止时间和一些最佳实践"></a>截止时间和一些最佳实践</h2><p>一个最佳实践是给需要远程调用的请求规定一个截止时间。如果远程服务在规定的时间内没有响应,就丢弃这个请求。这样的技术也可以用在线程池中,如果线程处理某个请求的时间超过了规定时间,那么这个线程就应被停止,为新到达的请求腾出资源,这样也就给W（处理请求的平均时间)规定了上限。虽然这样的做法看起来有些浪费,但是如果一个用户（特别是当用户在使用浏览器时),在等待请求的响应,那么30秒以后,浏览器无论如何也会放弃这个请求,或者更有可能的是:用户不会耐心地等待这个请求响应,而是进行其它操作去了。</p>
<p>快速失败也是一个可以用来处理后端请求的线程池方案。如果后端服务失效了,线程池中的线程数会迅速到达上限,这些线程都在等待没有响应的后端服务。如果使用快速失败机制,当后端服务被标记为失效时,所有的后续请求都会迅速失败,而不是进行不必要的等待。当然,它也需要一种机制来判断后端何时恢复为可用的。</p>
<p>最后,如果一个请求需要独立地调用多个后端服务,那么这个请求就应能并行地调用这些后端服务,而不是顺序地进行。这样就能降低请求的等待时间,但这是以增加线程数为代价的。</p>
<p>幸运的是,有一个非常好的库hystrix,这个库封装了许多很好的线程策略,然后以非常简单和友好的方式将这些接口暴露出来。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望这篇文章能改进对线程池的理解。一个合适的线程池配置需要理解应用的需求,还需要考虑这几个因素,系统允许的最大线程数、处理用户请求所需的时间。好的线程池配置不仅可以避免系统出现连锁故障,还能帮助计划和提供服务。</p>
<p>即使你的应用没有直接地使用一个线程池,它们也间接地通过应用服务器或其它更高级的抽象形式使用了线程池。Tomcat、JBoss、Undertow、Dropwizard 都提供了多种可配置的线程池（这些线程池正是你编写的Servlet运行的地方)。</p>
<p>ref:<br><a href="https://blog.bramp.net/post/2015/12/17/the-importance-of-tuning-your-thread-pools/" target="_blank" rel="external">https://blog.bramp.net/post/2015/12/17/the-importance-of-tuning-your-thread-pools/</a><br><a href="http://www.importnew.com/18619.html" target="_blank" rel="external">http://www.importnew.com/18619.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Thread-多线程问题总结</title>
    <url>/2017/09/13/Java-Thread-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>多线程问题总结</p>
<a id="more"></a>
<h2 id="多线程有什么用"><a href="#多线程有什么用" class="headerlink" title="多线程有什么用?"></a>多线程有什么用?</h2><ol>
<li>发挥多核CPU的优势<br>随着工业的进步,现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的,4核、8核甚至16核的也都不少见,如果是单线程的程序,那么在双核CPU上就浪费了50%,在4核CPU上就浪费了75%。<strong>单核CPU上所谓的”多线程”那是假的多线程,同一时间处理器只会处理一段逻辑,只不过线程之间切换得比较快,看着像多个线程”同时”运行罢了。</strong> 多核CPU上的多线程才是真正的多线程,它能让你的多段逻辑同时工作,多线程,可以真正发挥出多核CPU的优势来,达到充分利用CPU的目的。</li>
<li>防止阻塞<br>从程序运行效率的角度来看,单核CPU不但不会发挥出多线程的优势,反而会因为在单核CPU上运行多线程导致线程上下文的切换,而降低程序整体的效率。但是单核CPU我们还是要应用多线程,就是为了防止阻塞。试想,如果单核CPU使用单线程,那么只要这个线程阻塞了,比方说远程读取某个数据吧,对端迟迟未返回又没有设置超时时间,那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题,多条线程同时运行,哪怕一条线程的代码执行读取数据阻塞,也不会影响其它任务的执行。</li>
<li>便于建模<br>这是另外一个没有这么明显的优点了。假设有一个大的任务A,单线程编程,那么就要考虑很多,建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务,任务B、任务C、任务D,分别建立程序模型,并通过多线程分别运行这几个任务,那就简单很多了。</li>
</ol>
<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><p>比较常见的一个问题了,一般就是两种:</p>
<ol>
<li>继承Thread类</li>
<li>实现Runnable接口</li>
</ol>
<p>至于哪个好,不用说肯定是后者好,因为实现接口的方式比继承类的方式更灵活,也能减少程序之间的耦合度,面向接口编程也是设计模式6大原则的核心。</p>
<h2 id="start-方法和run-方法的区别"><a href="#start-方法和run-方法的区别" class="headerlink" title="start()方法和run()方法的区别"></a>start()方法和run()方法的区别</h2><p>只有调用了start()方法,才会表现出多线程的特性,不同线程的run()方法里面的代码交替执行。如果只是调用run()方法,那么代码还是同步执行的,必须等待一个线程的run()方法里面的代码全部执行完毕之后,另外一个线程才可以执行其run()方法里面的代码。</p>
<h2 id="Runnable接口和Callable接口的区别"><a href="#Runnable接口和Callable接口的区别" class="headerlink" title="Runnable接口和Callable接口的区别"></a>Runnable接口和Callable接口的区别</h2><p>有点深的问题了,也看出一个Java程序员学习知识的广度。</p>
<p>Runnable接口中的run()方法的返回值是void,它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的,是一个泛型,和Future、FutureTask配合可以用来获取异步执行的结果。</p>
<p>这其实是很有用的一个特性,因为<strong>多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性</strong>,某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知,我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果,可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务,真的是非常有用。</p>
<h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h2><p>两个看上去有点像的类,都在java.util.concurrent下,都可以用来表示代码运行到某个点上,二者的区别在于:</p>
<ol>
<li>CyclicBarrier的某个线程运行到某个点上之后,该线程即停止运行,直到所有的线程都到达了这个点,所有线程才重新运行；CountDownLatch则不是,某线程运行到某个点上之后,只是给某个数值-1而已,该线程继续运行</li>
<li>CyclicBarrier只能唤起一个任务,CountDownLatch可以唤起多个任务</li>
<li>CyclicBarrier可重用,CountDownLatch不可重用,计数值为0该CountDownLatch就不可再用了</li>
</ol>
<h2 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用"></a>volatile关键字的作用</h2><p>一个非常重要的问题,是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型,这里就不讲Java内存模型了,可以参见第31点,volatile关键字的作用主要有两个:</p>
<ol>
<li>多线程主要围绕可见性和原子性两个特性而展开,使用volatile关键字修饰的变量,保证了其在多线程之间的可见性,即每次读取到volatile变量,一定是最新的数据</li>
<li>代码底层执行不像我们看到的高级语言–Java程序这么简单,它的执行是<strong>Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互</strong>,现实中,为了获取更好的性能JVM可能会对指令进行重排序,多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序,当然这也一定程度上降低了代码执行效率</li>
</ol>
<p>从实践角度而言,volatile的一个重要作用就是和CAS结合,保证了原子性,详细的可以参见java.util.concurrent.atomic包下的类,比如AtomicInteger。</p>
<h2 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h2><p>又是一个理论的问题,各式各样的答案有很多,我给出一个个人认为解释地最好的:如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果,那么你的代码就是线程安全的。</p>
<p>这个问题有值得一提的地方,就是线程安全也是有几个级别的:</p>
<ol>
<li>不可变<br>像String、Integer、Long这些,都是final类型的类,任何一个线程都改变不了它们的值,要改变除非新创建一个,因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</li>
<li>绝对线程安全<br>不管运行时环境如何,调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价,Java中标注自己是线程安全的类,实际上绝大多数都不是线程安全的,不过绝对线程安全的类,Java中也有,比方说CopyOnWriteArrayList、CopyOnWriteArraySet</li>
<li>相对线程安全<br>相对线程安全也就是我们通常意义上所说的线程安全,像Vector这种,add、remove方法都是原子操作,不会被打断,但也仅限于此,如果有个线程在遍历某个Vector、有个线程同时在add这个Vector,99%的情况下都会出现ConcurrentModificationException,也就是fail-fast机制。</li>
<li>线程非安全<br>这个就没什么好说的了,ArrayList、LinkedList、HashMap等都是线程非安全的类</li>
</ol>
<h2 id="Java中如何获取到线程dump文件"><a href="#Java中如何获取到线程dump文件" class="headerlink" title="Java中如何获取到线程dump文件"></a>Java中如何获取到线程dump文件</h2><p>死循环、死锁、阻塞、页面打开慢等问题,打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈,获取到线程堆栈有两步:</p>
<ol>
<li>获取到线程的pid,可以通过使用jps命令,在Linux环境下还可以使用ps -ef | grep java</li>
<li>打印线程堆栈,可以通过使用jstack pid命令,在Linux环境下还可以使用kill -3 pid</li>
</ol>
<p>另外提一点,Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法,因此此方法是和具体线程实例绑定的,每次获取获取到的是具体某个线程当前运行的堆栈,</p>
<h2 id="一个线程如果出现了运行时异常会怎么样"><a href="#一个线程如果出现了运行时异常会怎么样" class="headerlink" title="一个线程如果出现了运行时异常会怎么样"></a>一个线程如果出现了运行时异常会怎么样</h2><p>如果这个异常没有被捕获的话,这个线程就停止执行了。另外重要的一点是:如果这个线程持有某个某个对象的监视器,那么这个对象监视器会被立即释放</p>
<h2 id="如何在两个线程之间共享数据"><a href="#如何在两个线程之间共享数据" class="headerlink" title="如何在两个线程之间共享数据"></a>如何在两个线程之间共享数据</h2><p>通过在线程之间共享对象就可以了,然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待,比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的</p>
<h2 id="sleep方法和wait方法有什么区别"><a href="#sleep方法和wait方法有什么区别" class="headerlink" title="sleep方法和wait方法有什么区别"></a>sleep方法和wait方法有什么区别</h2><p>这个问题常问,sleep方法和wait方法都可以用来放弃CPU一定的时间,不同点在于如果线程持有某个对象的监视器,sleep方法不会放弃这个对象的监视器,wait方法会放弃这个对象的监视器</p>
<h2 id="生产者消费者模型的作用是什么"><a href="#生产者消费者模型的作用是什么" class="headerlink" title="生产者消费者模型的作用是什么"></a>生产者消费者模型的作用是什么</h2><p>这个问题很理论,但是很重要:</p>
<ol>
<li>通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率,这是生产者消费者模型最重要的作用</li>
<li>解耦,这是生产者消费者模型附带的作用,解耦意味着生产者和消费者之间的联系少,联系越少越可以独自发展而不需要收到相互的制约</li>
</ol>
<h2 id="ThreadLocal有什么用"><a href="#ThreadLocal有什么用" class="headerlink" title="ThreadLocal有什么用"></a>ThreadLocal有什么用</h2><p>简单说ThreadLocal就是一种以空间换时间的做法,在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap,把数据进行隔离,数据不共享,自然就没有线程安全方面的问题了</p>
<h2 id="为什么wait-方法和notify-notifyAll-方法要在同步块中被调用"><a href="#为什么wait-方法和notify-notifyAll-方法要在同步块中被调用" class="headerlink" title="为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用"></a>为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用</h2><p>这是JDK强制的,wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁</p>
<h2 id="wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别"><a href="#wait-方法和notify-notifyAll-方法在放弃对象监视器时有什么区别" class="headerlink" title="wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别"></a>wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别</h2><p>wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于:<strong>wait()方法立即释放对象监视器,notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。</strong></p>
<h2 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h2><p>避免频繁地创建和销毁线程,达到线程对象的重用。另外,使用线程池还可以根据项目灵活地控制并发的数目。</p>
<h2 id="怎么检测一个线程是否持有对象监视器"><a href="#怎么检测一个线程是否持有对象监视器" class="headerlink" title="怎么检测一个线程是否持有对象监视器"></a>怎么检测一个线程是否持有对象监视器</h2><p>Thread类提供了一个holdsLock(Object obj)方法,当且仅当对象obj的监视器被某条线程持有的时候才会返回true,注意这是一个static方法,这意味着“某条线程”指的是当前线程。</p>
<h2 id="synchronized和ReentrantLock的区别"><a href="#synchronized和ReentrantLock的区别" class="headerlink" title="synchronized和ReentrantLock的区别"></a>synchronized和ReentrantLock的区别</h2><p>synchronized是和if、else、for、while一样的关键字,ReentrantLock是类,这是二者的本质区别。既然ReentrantLock是类,那么它就提供了比synchronized更多更灵活的特性,可以被继承、可以有方法、可以有各种各样的类变量,ReentrantLock比synchronized的扩展性体现在几点上:</p>
<ol>
<li>ReentrantLock可以对获取锁的等待时间进行设置,这样就避免了死锁</li>
<li>ReentrantLock可以获取各种锁的信息</li>
<li>ReentrantLock可以灵活地实现多路通知</li>
</ol>
<p>另外,二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁,synchronized操作的应该是对象头中mark word,这点我不能确定。</p>
<h2 id="ConcurrentHashMap的并发度是什么"><a href="#ConcurrentHashMap的并发度是什么" class="headerlink" title="ConcurrentHashMap的并发度是什么"></a>ConcurrentHashMap的并发度是什么</h2><p>ConcurrentHashMap的并发度就是segment的大小,默认为16,这意味着最多同时可以有16条线程操作ConcurrentHashMap,这也是ConcurrentHashMap对Hashtable的最大优势,任何情况下,Hashtable能同时有两条线程获取Hashtable中的数据吗？</p>
<h2 id="ReadWriteLock是什么"><a href="#ReadWriteLock是什么" class="headerlink" title="ReadWriteLock是什么"></a>ReadWriteLock是什么</h2><p>首先明确一下,不是说ReentrantLock不好,只是ReentrantLock某些时候有局限。如果使用ReentrantLock,可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致,但这样,如果线程C在读数据、线程D也在读数据,读数据是不会改变数据的,没有必要加锁,但是还是加锁了,降低了程序的性能。</p>
<p>因为这个,才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口,ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现,实现了读写的分离,读锁是共享的,写锁是独占的,读和读之间不会互斥,读和写、写和读、写和写之间才会互斥,提升了读写的性能。</p>
<h2 id="FutureTask是什么"><a href="#FutureTask是什么" class="headerlink" title="FutureTask是什么"></a>FutureTask是什么</h2><p>这个其实前面有提到过,FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类,可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然,由于FutureTask也是Runnable接口的实现类,所以FutureTask也可以放入线程池中。</p>
<h2 id="Linux环境下如何查找哪个线程使用CPU最长"><a href="#Linux环境下如何查找哪个线程使用CPU最长" class="headerlink" title="Linux环境下如何查找哪个线程使用CPU最长"></a>Linux环境下如何查找哪个线程使用CPU最长</h2><p>可以这么做:</p>
<ol>
<li>获取项目的pid,jps或者ps -ef | grep java,这个前面有讲过</li>
<li>top -H -p pid,顺序不能改变</li>
</ol>
<p>这样就可以打印出当前的项目,每条线程占用CPU时间的百分比。注意这里打出的是LWP,也就是操作系统原生线程的线程号</p>
<p>使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈,从而定位占用CPU高的原因,一般是因为不当的代码操作导致了死循环。</p>
<p>最后提一点,”top -H -p pid”打出来的LWP是十进制的,”jps pid”打出来的本地线程号是十六进制的,转换一下,就能定位到占用CPU高的线程的当前线程堆栈了。</p>
<h2 id="Java编程写一个会导致死锁的程序"><a href="#Java编程写一个会导致死锁的程序" class="headerlink" title="Java编程写一个会导致死锁的程序"></a>Java编程写一个会导致死锁的程序</h2><p>很多人都知道死锁是怎么一回事儿:线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了,问一下怎么写一个死锁的程序就不知道了,这种情况说白了就是不懂什么是死锁,懂一个理论就完事儿了,实践中碰到死锁的问题基本上是看不出来的。</p>
<p>真正理解什么是死锁,这个问题其实不难,几个步骤:</p>
<ol>
<li>两个线程里面分别持有两个Object对象:lock1和lock2。这两个lock作为同步代码块的锁；</li>
<li>线程1的run()方法中同步代码块先获取lock1的对象锁,Thread.sleep(xxx),时间不需要太多,50毫秒差不多了,然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁</li>
<li>线程2的run()方法中同步代码块先获取lock2的对象锁,接着获取lock1的对象锁,当然这时lock1的对象锁已经被线程1锁持有,线程2肯定是要等待线程1释放lock1的对象锁的</li>
</ol>
<p>这样,线程1″睡觉”睡完,线程2已经获取了lock2的对象锁了,线程1此时尝试获取lock2的对象锁,便被阻塞,此时一个死锁就形成了。代码就不写了,占的篇幅有点多,<a href="http://www.cnblogs.com/xrq730/p/4853713.html" target="_blank" rel="external">Java多线程7:死锁</a>这篇文章里面有,就是上面步骤的代码实现。</p>
<h2 id="怎么唤醒一个阻塞的线程"><a href="#怎么唤醒一个阻塞的线程" class="headerlink" title="怎么唤醒一个阻塞的线程"></a>怎么唤醒一个阻塞的线程</h2><p>如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞,可以中断线程,并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞,无能为力,因为IO是操作系统实现的,Java代码并没有办法直接接触到操作系统。</p>
<h2 id="不可变对象对多线程有什么帮助"><a href="#不可变对象对多线程有什么帮助" class="headerlink" title="不可变对象对多线程有什么帮助"></a>不可变对象对多线程有什么帮助</h2><p>不可变对象保证了对象的内存可见性,对不可变对象的读取不需要进行额外的同步手段,提升了代码执行效率。</p>
<h2 id="什么是多线程的上下文切换"><a href="#什么是多线程的上下文切换" class="headerlink" title="什么是多线程的上下文切换"></a>什么是多线程的上下文切换</h2><p>多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。</p>
<h2 id="如果你提交任务时-线程池队列已满-这时会发生什么"><a href="#如果你提交任务时-线程池队列已满-这时会发生什么" class="headerlink" title="如果你提交任务时,线程池队列已满,这时会发生什么"></a>如果你提交任务时,线程池队列已满,这时会发生什么</h2><p>如果你使用的LinkedBlockingQueue,也就是无界队列的话,没关系,继续添加任务到阻塞队列中等待执行,因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列,可以无限存放任务；<br>如果你使用的是有界队列比方说ArrayBlockingQueue的话,任务首先会被添加到ArrayBlockingQueue中,ArrayBlockingQueue满了,则会使用拒绝策略RejectedExecutionHandler处理满了的任务,默认是AbortPolicy。</p>
<h2 id="Java中用到的线程调度算法是什么"><a href="#Java中用到的线程调度算法是什么" class="headerlink" title="Java中用到的线程调度算法是什么"></a>Java中用到的线程调度算法是什么</h2><p>抢占式。一个线程用完CPU之后,操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。</p>
<h2 id="Thread-sleep-0-的作用是什么"><a href="#Thread-sleep-0-的作用是什么" class="headerlink" title="Thread.sleep(0)的作用是什么"></a>Thread.sleep(0)的作用是什么</h2><p>这个问题和上面那个问题是相关的,我就连在一起了。由于Java采用抢占式的线程调度算法,因此可能会出现某条线程常常获取到CPU控制权的情况,为了让某些优先级比较低的线程也能获取到CPU控制权,可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作,这也是平衡CPU控制权的一种操作。</p>
<h2 id="什么是自旋"><a href="#什么是自旋" class="headerlink" title="什么是自旋"></a>什么是自旋</h2><p>很多synchronized里面的代码只是一些很简单的代码,执行时间非常快,此时等待的线程都加锁可能是一种不太值得的操作,因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快,不妨让等待锁的线程不要被阻塞,而是在synchronized的边界做忙循环,这就是自旋。如果做了多次忙循环发现还没有获得锁,再阻塞,这样可能是一种更好的策略。</p>
<h2 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h2><p>Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的,我简单总结一下Java内存模型的几部分内容:</p>
<ol>
<li>Java内存模型将内存分为了主内存和工作内存。类的状态,也就是类之间共享的变量,是存储在主内存中的,每次Java线程用到这些主内存中的变量的时候,会读一次主内存中的变量,并让这些内存在自己的工作内存中有一份拷贝,运行自己线程代码的时候,用到这些变量,操作的都是自己工作内存中的那一份。在线程代码执行完毕之后,会将最新的值更新到主内存中去</li>
<li>定义了几个原子操作,用于操作主内存和工作内存中的变量</li>
<li>定义了volatile变量的使用规则</li>
<li>happens-before,即先行发生原则,定义了操作A必然先行发生于操作B的一些规则,比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等,只要符合这些规则,则不需要额外做同步措施,如果某段代码不符合所有的happens-before规则,则这段代码一定是线程非安全的</li>
</ol>
<h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS,全称为Compare and Swap,即比较-替换。假设有三个操作数:内存值V、旧的预期值A、要修改的值B,当且仅当预期值A和内存值V相同时,才会将内存值修改为B并返回true,否则什么都不做并返回false。当然CAS一定要volatile变量配合,这样才能保证每次拿到的变量是主内存中最新的那个值,否则旧的预期值A对某条线程来说,永远是一个不会变的值A,只要某次CAS操作失败,永远都不可能成功。</p>
<h2 id="什么是乐观锁和悲观锁"><a href="#什么是乐观锁和悲观锁" class="headerlink" title="什么是乐观锁和悲观锁"></a>什么是乐观锁和悲观锁</h2><ol>
<li>乐观锁:就像它的名字一样,对于并发间操作产生的线程安全问题持乐观状态,乐观锁认为竞争不总是会发生,因此它不需要持有锁,将<strong>比较-替换</strong>这两个动作作为一个原子操作尝试去修改内存中的变量,如果失败则表示发生冲突,那么就应该有相应的重试逻辑。</li>
<li>悲观锁:还是像它的名字一样,对于并发间操作产生的线程安全问题持悲观状态,悲观锁认为竞争总是会发生,因此每次对某资源进行操作时,都会持有一个独占的锁,就像synchronized,不管三七二十一,直接上了锁就操作资源了。</li>
</ol>
<h2 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h2><p>简单说一下AQS,AQS全称为AbstractQueuedSychronizer,翻译过来应该是抽象队列同步器。</p>
<p>如果说java.util.concurrent的基础是CAS的话,那么AQS就是整个Java并发包的核心了,ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry,比方说ReentrantLock,所有等待的线程都被放在一个Entry中并连成双向队列,前面一个线程使用ReentrantLock好了,则双向队列实际上的第一个Entry开始运行。</p>
<p>AQS定义了对双向队列所有的操作,而只开放了tryLock和tryRelease方法给开发者使用,开发者可以根据自己的实现重写tryLock和tryRelease方法,以实现自己的并发功能。</p>
<h2 id="单例模式的线程安全性"><a href="#单例模式的线程安全性" class="headerlink" title="单例模式的线程安全性"></a>单例模式的线程安全性</h2><p>老生常谈的问题了,首先要说的是单例模式的线程安全意味着:某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法,我总结一下:</p>
<ol>
<li>饿汉式单例模式的写法:线程安全</li>
<li>懒汉式单例模式的写法:非线程安全</li>
<li>双检锁单例模式的写法:线程安全</li>
</ol>
<h2 id="Semaphore有什么作用"><a href="#Semaphore有什么作用" class="headerlink" title="Semaphore有什么作用"></a>Semaphore有什么作用</h2><p>Semaphore就是一个信号量,它的作用是限制某段代码块的并发数。Semaphore有一个构造函数,可以传入一个int型整数n,表示某段代码最多只有n个线程可以访问,如果超出了n,那么请等待,等到某个线程执行完毕这段代码块,下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1,相当于变成了一个synchronized了。</p>
<h2 id="Hashtable的size-方法中明明只有一条语句”return-count”-为什么还要做同步？"><a href="#Hashtable的size-方法中明明只有一条语句”return-count”-为什么还要做同步？" class="headerlink" title="Hashtable的size()方法中明明只有一条语句”return count”,为什么还要做同步？"></a>Hashtable的size()方法中明明只有一条语句”return count”,为什么还要做同步？</h2><p>这是我之前的一个困惑,不知道大家有没有想过这个问题。某个方法中如果有多条语句,并且都在操作同一个类变量,那么在多线程环境下不加锁,势必会引发线程安全问题,这很好理解,但是size()方法明明只有一条语句,为什么还要加锁？</p>
<p>关于这个问题,在慢慢地工作、学习中,有了理解,主要原因有两点:</p>
<ol>
<li>同一时间只能有一条线程执行固定类的同步方法,但是对于类的非同步方法,可以多条线程同时访问。所以,这样就有问题了,可能线程A在执行Hashtable的put方法添加数据,线程B则可以正常调用size()方法读取Hashtable中当前元素的个数,那读取到的值可能不是最新的,可能线程A添加了完了数据,但是没有对size++,线程B就已经读取size了,那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后,意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用,这样就保证了线程安全性</li>
<li>CPU执行代码,执行的不是Java代码,这点很关键,一定得记住。Java代码最终是被翻译成汇编代码执行的,汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行,甚至你看到Java代码编译之后生成的字节码也只有一行,也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行,完全可能执行完第一句,线程就切换了。</li>
</ol>
<h2 id="线程类的构造方法、静态块是被哪个线程调用的"><a href="#线程类的构造方法、静态块是被哪个线程调用的" class="headerlink" title="线程类的构造方法、静态块是被哪个线程调用的"></a>线程类的构造方法、静态块是被哪个线程调用的</h2><p>这是一个非常刁钻和狡猾的问题。请记住:线程类的构造方法、静态块是被new这个线程类所在的线程所调用的,而run方法里面的代码才是被线程自身所调用的。</p>
<p>如果说上面的说法让你感到困惑,那么我举个例子,假设Thread2中new了Thread1,main函数中new了Thread2,那么:</p>
<ul>
<li>Thread2的构造方法、静态块是main线程调用的,Thread2的run()方法是Thread2自己调用的</li>
<li>Thread1的构造方法、静态块是Thread2调用的,Thread1的run()方法是Thread1自己调用的</li>
</ul>
<h2 id="同步方法和同步块-哪个是更好的选择"><a href="#同步方法和同步块-哪个是更好的选择" class="headerlink" title="同步方法和同步块,哪个是更好的选择"></a>同步方法和同步块,哪个是更好的选择</h2><p>同步块,这意味着同步块之外的代码是异步执行的,这比同步整个方法更提升代码的效率。请知道一条原则:<strong>同步的范围越小越好。</strong></p>
<p>借着这一条,我额外提一点,虽说同步的范围越少越好,但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法,这种方法就是把同步范围变大。这是有用的,比方说StringBuffer,它是一个线程安全的类,自然最常用的append()方法是一个同步方法,我们写代码的时候会反复append字符串,这意味着要进行反复的加锁-&gt;解锁,这对性能不利,因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换,因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作,将多次的append的操作扩展到append方法的头尾,变成一个大的同步块,这样就减少了加锁–&gt;解锁的次数,有效地提升了代码执行的效率。</p>
<h2 id="高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"><a href="#高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？" class="headerlink" title="高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？"></a>高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</h2><p>这是我在并发编程网上看到的一个问题,把这个问题放在最后一个,希望每个人都能看到并且思考一下,因为这个问题非常好、非常实际、非常专业。关于这个问题,个人看法是:</p>
<ol>
<li>高并发、任务执行时间短的业务,线程池线程数可以设置为CPU核数+1,减少线程上下文的切换</li>
<li>并发不高、任务执行时间长的业务要区分开看:</li>
</ol>
<ul>
<li>假如是业务时间长集中在IO操作上,也就是IO密集型的任务,因为IO操作并不占用CPU,所以不要让所有的CPU闲下来,可以加大线程池中的线程数目,让CPU处理更多的业务</li>
<li>假如是业务时间长集中在计算操作上,也就是计算密集型任务,这个就没办法了,和(1)一样吧,线程池中的线程数设置得少一些,减少线程上下文的切换</li>
</ul>
<ol>
<li>并发高、业务执行时间长,解决这种类型任务的关键不在于线程池而在于整体架构的设计,看看这些业务里面某些数据是否能做缓存是第一步,增加服务器是第二步,至于线程池的设置,设置参考(2)。最后,业务执行时间长的问题,也可能需要分析一下,看看能不能使用中间件对任务进行拆分和解耦。</li>
</ol>
<p>ps: 原文作者说:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">我不能保证写的每个地方都是对的,但是至少能保证不复制、不黏贴,保证每一句话、每一行代码都经过了认真的推敲、仔细的斟酌。每一篇文章的背后,希望都能看到自己对于技术、对于生活的态度。</div></pre></td></tr></table></figure></p>
<p>ref: <a href="http://www.importnew.com/18459.html" target="_blank" rel="external">http://www.importnew.com/18459.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_Thread_线程间共享数据的方式</title>
    <url>/2017/09/13/Java-Thread-%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>Thread_线程间共享数据的方式</p>
<a id="more"></a>
<h2 id="线程间共享数据的方式"><a href="#线程间共享数据的方式" class="headerlink" title="线程间共享数据的方式"></a>线程间共享数据的方式</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>谈到多线程共享数据,理想情况下我们希望做到“同步”和“互斥”。</p>
<p>多线程共享数据通常的场景有以下两种:</p>
<h3 id="场景一-买票"><a href="#场景一-买票" class="headerlink" title="场景一: 买票"></a>场景一: 买票</h3><p>卖票,我们都买过火车票。要买火车票我们可以去车站,也可以通过代售点(或网购),但不管有多少种方式火车票的总数是一定的。</p>
<h4 id="场景抽象"><a href="#场景抽象" class="headerlink" title="场景抽象:"></a>场景抽象:</h4><p>对于卖票系统每个线程的核心执行的代码都相同(就是票数–)。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h4><p>只需创建一个Runnable,这个Runnable里有那个共享数据。</p>
<h4 id="代码模拟"><a href="#代码模拟" class="headerlink" title="代码模拟:"></a>代码模拟:</h4><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line"> </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">while</span>(ticket&gt;<span class="number">0</span>)&#123;</div><div class="line">            ticket--;</div><div class="line">            System.out.println(<span class="string">"当前票数为:"</span>+ticket);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Ticket t = <span class="keyword">new</span> Ticket();</div><div class="line">        <span class="keyword">new</span> Thread(t).start();</div><div class="line">        <span class="keyword">new</span> Thread(t).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="场景二-银行存取款"><a href="#场景二-银行存取款" class="headerlink" title="场景二:银行存取款"></a>场景二:银行存取款</h3><p>比较常见的例子,银行问题,我们对账户可以存钱也可以取钱,怎么保证这样的数据共享呢？</p>
<h4 id="场景抽象-1"><a href="#场景抽象-1" class="headerlink" title="场景抽象:"></a>场景抽象:</h4><p>每个线程执行的代码不同(比如上面的问题,对每个账户可以执行++操作和–操作),这时候需要用不同的Runnable对象,有如下两种方式来实现这些Runnable之间的数据共享</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h4><p>有两种方法来解决此类问题:</p>
<ul>
<li>将共享数据封装成另外一个对象中,然后将这个对象逐一传递给各个Runnable对象,每个线程对共享数据的操作方法也分配到那个对象身上完成,这样容易实现针对数据进行各个操作的互斥和通信</li>
<li>将Runnable对象作为偶一个类的内部类,共享数据作为这个类的成员变量,每个线程对共享数据的操作方法也封装在外部类,以便实现对数据的各个操作的同步和互斥,作为内部类的各个Runnable对象调用外部类的这些方法。</li>
</ul>
<h4 id="代码模拟-1"><a href="#代码模拟-1" class="headerlink" title="代码模拟:"></a>代码模拟:</h4><p>以一道面试题为例:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* 第一种解法 设计4个线程。,其中两个线程每次对j增加1,另外两个线程对j每次减1*/</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</div><div class="line">     <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">     <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</div><div class="line">         j++;</div><div class="line">         System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j为:"</span>+j);</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</div><div class="line">         j--;</div><div class="line">         System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j为:"</span>+j);</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">return</span> j;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">    MyData data;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddRunnable</span><span class="params">(MyData data)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.data= data;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        data.add();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    MyData data;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecRunnable</span><span class="params">(MyData data)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            data.dec();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOne</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        MyData data = <span class="keyword">new</span> MyData();</div><div class="line">        Runnable add = <span class="keyword">new</span> AddRunnable(data);</div><div class="line">        Runnable dec = <span class="keyword">new</span> DecRunnable(data);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread(add).start();</div><div class="line">            <span class="keyword">new</span> Thread(dec).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="解法分析"><a href="#解法分析" class="headerlink" title="解法分析:"></a>解法分析:</h4><ul>
<li>优点:</li>
</ul>
<ol>
<li>这种解法代码写的有条理,简单易读,从main中很容易整理出思路</li>
<li>将数据抽象成一个类,并将对这个数据的操作作为这个类的方法,这么设计可以和容易做到同步,只要在方法上加”synchronized“</li>
</ol>
<ul>
<li>不足:</li>
</ul>
<p>代码写的比较繁琐,需要有多个类,不是那么简洁<br>个人观点:为了有条理个人比较喜欢这种写法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/* 第二种解法 */</span></div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyData</span> </span>&#123;</div><div class="line">     <span class="keyword">private</span> <span class="keyword">int</span> j=<span class="number">0</span>;</div><div class="line">     <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</div><div class="line">         j++;</div><div class="line">         System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j为:"</span>+j);</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">()</span></span>&#123;</div><div class="line">         j--;</div><div class="line">         System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"j为:"</span>+j);</div><div class="line">     &#125;</div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getData</span><span class="params">()</span></span>&#123;</div><div class="line">         <span class="keyword">return</span> j;</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> MyData data = <span class="keyword">new</span> MyData();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    data.add();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    data.dec();</div><div class="line">                &#125;</div><div class="line">            &#125;).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="解法分析-1"><a href="#解法分析-1" class="headerlink" title="解法分析:"></a>解法分析:</h4><p>与第一种方法的区别在于第二种方法巧妙的用了内部类共享外部类数据的思想,即把要共享的数据变得全局变量,这样就保证了操作的是同一份数据。同时内部类的方式使代码更加简洁。但是不如第一种解法条理那么清楚。</p>
<p>ref: <a href="http://www.importnew.com/20861.html" target="_blank" rel="external">http://www.importnew.com/20861.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit-断言</title>
    <url>/2017/09/06/Junit-%E6%96%AD%E8%A8%80/</url>
    <content><![CDATA[<p>Assert 类扩展了java.lang.Object类并为它们提供编写测试，以便检测故障。下表中有一种最常用的断言方法的更详细的解释</p>
<a id="more"></a>
<h2 id="常用的断言方法"><a href="#常用的断言方法" class="headerlink" title="常用的断言方法"></a>常用的断言方法</h2><p><img src="20180808143938.png" alt="常用的断言方法"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import static org.junit.Assert.*;</div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">public class AssertionsTest &#123;</div><div class="line"></div><div class="line">	@Test</div><div class="line">	public void test() &#123;</div><div class="line">		String obj1 = &quot;junit&quot;;</div><div class="line">		String obj2 = &quot;junit&quot;;</div><div class="line">		String obj3 = &quot;test&quot;;</div><div class="line">		String obj4 = &quot;test&quot;;</div><div class="line">		String obj5 = null;</div><div class="line">		int var1 = 1;</div><div class="line">		int var2 = 2;</div><div class="line">		int[] arithmetic1 = &#123; 1, 2, 3 &#125;;</div><div class="line">		int[] arithmetic2 = &#123; 1, 2, 3 &#125;;</div><div class="line"></div><div class="line">		assertEquals(obj1, obj2);</div><div class="line"></div><div class="line">		assertSame(obj3, obj4);</div><div class="line"></div><div class="line">		assertNotSame(obj2, obj4);</div><div class="line"></div><div class="line">		assertNotNull(obj1);</div><div class="line"></div><div class="line">		assertNull(obj5);</div><div class="line"></div><div class="line">		assertTrue(var1  var2);</div><div class="line"></div><div class="line">		assertArrayEquals(arithmetic1, arithmetic2);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://www.yiibai.com/junit/junit-assertions.html" target="_blank" rel="external">https://www.yiibai.com/junit/junit-assertions.html</a></p>
]]></content>
      <categories>
        <category>Junit</category>
      </categories>
      <tags>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title>Junit-运行参数化测试</title>
    <url>/2017/09/06/Junit-%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>Parameterized 的测试运行器允许使用不同的参数多次运行同一个测试。</p>
<a id="more"></a>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class Calculator &#123;</div><div class="line">    public double add(double a, double b)&#123;</div><div class="line">        return a + b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@RunWith(value = Parameterized.class)</div><div class="line">public class CalculatorTest &#123;</div><div class="line"></div><div class="line">    private double expected;</div><div class="line">    private double valueOne;</div><div class="line">    private double valueTwo;</div><div class="line"></div><div class="line">    @Parameters</div><div class="line">    public static Collection&lt;Integer[]&gt; getTestParameters()&#123;</div><div class="line">        return Arrays.asList(</div><div class="line">            new Integer[][]&#123;</div><div class="line">                &#123;2, 1, 1&#125;, //expected, valueOne, valueTwo</div><div class="line">                &#123;3, 2, 1&#125;,</div><div class="line">                &#123;4, 3, 1&#125;,</div><div class="line">            &#125;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public CalculatorTest(double expected, double valueOne, double valueTwo)&#123;</div><div class="line">        this.expected = expected;</div><div class="line">        this.valueOne = valueOne;</div><div class="line">        this.valueTwo = valueTwo;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void add() throws Exception &#123;</div><div class="line">        Calculator cal = new Calculator();</div><div class="line">        assertEquals(expected, cal.add(valueOne, valueTwo), 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p><img src="20180803161601.png" alt="20180803161601"><br><img src="sdfiosajfsdf.png" alt="sdfiosajfsdf"></p>
<p>ref:<br>Junit 实战第二版</p>
]]></content>
      <categories>
        <category>Junit</category>
      </categories>
      <tags>
        <tag>Junit</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux-使用梳理</title>
    <url>/2017/09/06/Tmux-%E4%BD%BF%E7%94%A8%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>Tmux是一个优秀的终端复用软件，类似GNU Screen，但来自于OpenBSD，采用BSD授权。使用它最直观的好处就是，通过一个终端登录远程主机并运行tmux后，在其中可以开启多个控制台而无需再“浪费”多余的终端来连接这台远程主机；是BSD实现的Screen替代品，相对于Screen，它更加先进：支持屏幕切分，而且具备丰富的命令行参数，使其可以灵活、动态的进行各种布局和操作。下面就Tmux的使用做一梳理</p>
<a id="more"></a>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>提供了强劲的、易于使用的命令行界面。</li>
<li>可横向和纵向分割窗口。</li>
<li>窗格可以自由移动和调整大小，或直接利用四个预设布局之一。</li>
<li>支持 UTF-8 编码及 256 色终端。</li>
<li>可在多个缓冲区进行复制和粘贴。</li>
<li>可通过交互式菜单来选择窗口、会话及客户端。</li>
<li>支持跨窗口搜索。</li>
<li>支持自动及手动锁定窗口。</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>ubuntu版本下直接apt-get安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># sudo apt-get install tmux</div></pre></td></tr></table></figure></p>
<p>centos7版本下直接yum安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># yum install -y tmux</div></pre></td></tr></table></figure></p>
<p>在Mac OS中安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">安装 Homebrew</div><div class="line">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</div><div class="line"> </div><div class="line">安装tmux</div><div class="line">$ brew install tmux</div></pre></td></tr></table></figure></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>安装完成后输入命令tmux即可打开软件，界面十分简单，类似一个下方带有状态栏的终端控制台；但根据tmux的定义，在开启了tmux服务器后，会首先创建一个会话，而这个会话则会首先创建一个窗口，其中仅包含一个面板；也就是说，这里看到的所谓终端控制台应该称作tmux的一个面板，虽然其使用方法与终端控制台完全相同。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># tmux                                   //直接进入面板，如下使用效果：</div></pre></td></tr></table></figure></p>
<img src="/2017/09/06/Tmux-使用梳理/907596-20170303181719688-2083634286.png" alt="907596-20170303181719688-2083634286.png" title="">
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><h3 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">?  列出所有快捷键；按q返回</div><div class="line">d 脱离当前会话；这样可以暂时返回Shell界面，输入tmux attach能够重新进入之前的会话</div><div class="line">D 选择要脱离的会话；在同时开启了多个会话时使用</div><div class="line">Ctrl+z 挂起当前会话</div><div class="line">r 强制重绘未脱离的会话</div><div class="line">s 选择并切换会话；在同时开启了多个会话时使用</div><div class="line">: 进入命令行模式；此时可以输入支持的命令，例如kill-server可以关闭服务器</div><div class="line">[ 进入复制模式；此时的操作与vi/emacs相同，按q/Esc退出</div><div class="line">~ 列出提示信息缓存；其中包含了之前tmux返回的各种提示信息</div></pre></td></tr></table></figure>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tmux ls</code></td>
<td>等同<code>tmux list-sessions</code>, 显示所有会话</td>
</tr>
<tr>
<td><code>tmux new -s &lt;session-name&gt;</code></td>
<td>新建会话并指定会话名称（建议制定会话名称，以便了解该会话用途）</td>
</tr>
<tr>
<td><code>tmux new</code></td>
<td>新建会话（不指定会话名称）</td>
</tr>
<tr>
<td><code>tmux a</code></td>
<td>等同<code>tmux attach</code>, 接入上一个会话</td>
</tr>
<tr>
<td><code>tmux a -t &lt;session-name&gt;</code></td>
<td>接入指定名称的会话</td>
</tr>
<tr>
<td><code>tmux detach</code></td>
<td>断开当前会话（还可以在会话中使用快捷键：<code>control+b，再按d</code>）</td>
</tr>
<tr>
<td><code>tmux kill-session -t session-name</code></td>
<td>关闭指定会话</td>
</tr>
<tr>
<td><code>tmux kill-session -a -t session-name</code></td>
<td>关闭除指定会话外的所有会话</td>
</tr>
<tr>
<td><code>tmux switch -t session_name</code></td>
<td>切换会话, 也可在会话中 <code>control+b，再按s 显示会话列表，再进行会话切换</code></td>
</tr>
<tr>
<td><code>tmux kill-server</code></td>
<td>销毁所有会话并停止tmux</td>
</tr>
</tbody>
</table>
<h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">c 创建新窗口</div><div class="line">&amp; 关闭当前窗口</div><div class="line">数字键 切换至指定窗口</div><div class="line">p 切换至上一窗口</div><div class="line">n 切换至下一窗口</div><div class="line">l 在前后两个窗口间互相切换</div><div class="line">w 通过窗口列表切换窗口</div><div class="line">, 重命名当前窗口；这样便于识别</div><div class="line">.  修改当前窗口编号；相当于窗口重新排序</div><div class="line">f 在所有窗口中查找指定文本</div></pre></td></tr></table></figure>
<h3 id="面板操作"><a href="#面板操作" class="headerlink" title="面板操作"></a>面板操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">” 将当前面板平分为上下两块</div><div class="line">% 将当前面板平分为左右两块</div><div class="line">x 关闭当前面板</div><div class="line">!  将当前面板置于新窗口；即新建一个窗口，其中仅包含当前面板</div><div class="line">Ctrl+方向键 以1个单元格为单位移动边缘以调整当前面板大小</div><div class="line">Alt+方向键 以5个单元格为单位移动边缘以调整当前面板大小</div><div class="line">Space 在预置的面板布局中循环切换；依次包括even-horizontal、even-vertical、main-horizontal、main-vertical、tiled</div><div class="line">q 显示面板编号</div><div class="line">o 在当前窗口中选择下一面板</div><div class="line">方向键 移动光标以选择面板</div><div class="line">&#123; 向前置换当前面板</div><div class="line">&#125; 向后置换当前面板</div><div class="line">Alt+o 逆时针旋转当前窗口的面板</div><div class="line">Ctrl+o 顺时针旋转当前窗口的面板</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://www.cnblogs.com/kevingrace/p/6496899.html" target="_blank" rel="external">https://www.cnblogs.com/kevingrace/p/6496899.html</a><br><a href="https://robots.thoughtbot.com/a-tmux-crash-course" target="_blank" rel="external">https://robots.thoughtbot.com/a-tmux-crash-course</a><br><a href="https://www.cnblogs.com/aioria13/p/7191080.html" target="_blank" rel="external">https://www.cnblogs.com/aioria13/p/7191080.html</a><br><a href="https://www.linuxidc.com/Linux/2015-07/120304.htm" target="_blank" rel="external">Tmux Resurrect &amp; Continuum: 持久保存 Tmux 会话</a><br><a href="https://blog.csdn.net/robertbaker/article/details/42172203" target="_blank" rel="external">tmux的使用方法和个性化配置</a><br><a href="https://www.cnblogs.com/kaiye/p/6275207.html" target="_blank" rel="external">十分钟学会 tmux</a></p>
]]></content>
      <categories>
        <category>Tmux</category>
      </categories>
      <tags>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-复制粘贴</title>
    <url>/2017/09/06/Vim-%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4/</url>
    <content><![CDATA[<p>Vim 寄存器可存储多个复制内容, 大大提高编辑效率</p>
<a id="more"></a>
<h2 id="vim常用复制粘贴命令"><a href="#vim常用复制粘贴命令" class="headerlink" title="vim常用复制粘贴命令"></a>vim常用复制粘贴命令</h2><p>Vim的复制粘贴命令无疑是 y (yank),p(paster),加上yy,P</p>
<p>PS:</p>
<p>vim有个很有意思的约定(我觉得是一种约定),就是某个命令的大小写都是实现某种功能,只是方向不同,比如;<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">w 跳转到下个word,</div><div class="line">W 跳转到上个word </div><div class="line"></div><div class="line">f 某行正向查找并跳转</div><div class="line">F 反向....</div></pre></td></tr></table></figure></p>
<p>然后部分双写的字母有行操作;<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">yy   复制一行  </div><div class="line">dd   删除一行</div></pre></td></tr></table></figure></p>
<p>所以, p 就是在当前光标后粘贴, P 就是在当前光标前粘贴  </p>
<p>另外,说完 p, 其实还有几个命令有时也是很有用的<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">gp,和p的功能基本一致,只是粘贴完,它会把光标移动至粘贴内容之后；gP同理  </div><div class="line">  </div><div class="line">:pu[t] ,注意,这个是在命令界面输入的pu/put,它的意思是把x寄存器的内容粘贴到下一行</div></pre></td></tr></table></figure></p>
<h2 id="vim的寄存器"><a href="#vim的寄存器" class="headerlink" title="vim的寄存器"></a>vim的寄存器</h2><h3 id="寄存器简介"><a href="#寄存器简介" class="headerlink" title="寄存器简介"></a>寄存器简介</h3><p>vim强大之处之一就是它自带一堆寄存器,每个寄存器独立使用,你可以在不同寄存器中存储不同数据,命令,你可以把这个想象成一个加强版的剪贴板,当然它的功能不止剪贴板这么简单。如果你想看vim的官方文档有关部分;<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:help  registers</div></pre></td></tr></table></figure></p>
<p>根据官方手册;vim有9种寄存器<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">There are nine types of registers:                      registers E354</div><div class="line">1. The unnamed register &quot;&quot;</div><div class="line">2. 10 numbered registers &quot;0 to &quot;9</div><div class="line">3. The small delete register &quot;-</div><div class="line">4. 26 named registers &quot;a to &quot;z or &quot;A to &quot;Z </div><div class="line">5. four read-only registers &quot;:, &quot;., &quot;% and &quot;#</div><div class="line">6. the expression register &quot;=</div><div class="line">7. The selection and drop registers &quot;*, &quot;+ and &quot;~ </div><div class="line">8. The black hole register &quot;_</div><div class="line">9. Last search pattern register &quot;/</div></pre></td></tr></table></figure></p>
<p>各个寄存器:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1. 无名(unnamed)寄存器;&quot;&quot;,缓存最后一次操作内容；</div><div class="line">2. 数字(numbered)寄存器;&quot;0 ～&quot;9,缓存最近操作内容,复制与删除有别, &quot;0 寄存器缓存最近一次复制的内容,&quot;1-&quot;9 缓存最近9次删除内容</div><div class="line">3. 行内删除(small delete)寄存器;&quot;-,缓存行内删除内容；</div><div class="line">4. 具名(named)寄存器;&quot;a ～ &quot;z 或 &quot;A - &quot;0Z,指定时可用；</div><div class="line">5. 只读(read-only)寄存器;&quot;:,&quot;.,&quot;%,&quot;#,分别缓存最近命令、最近插入文本、当前文件名、当前交替文件名；</div><div class="line">6. 表达式(expression)寄存器;&quot;=,只读,用于执行表达式命令；</div><div class="line">7. 选择及拖拽(selection and drop)寄存器  &quot;*,&quot;+,&quot;~ `存取GUI选择文本,可用于与外部应用交互,使用前提为系统剪切板(clipboard)可用；</div><div class="line">8. 黑洞(black hole)寄存器;&quot;_,不缓存操作内容(干净删除)；</div><div class="line">9. 模式寄存器(last search pattern);&quot;/,缓存最近的搜索模式。</div></pre></td></tr></table></figure></p>
<p>至于每个寄存器更加具体的使用方法,我希望大家能查询手册</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>现在输入命令,你就可以查询一下目前寄存器的情况<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">:reg</div></pre></td></tr></table></figure></p>
<p>寄存器的使用方法也很简单;通过 “ 加上 寄存器名,就可以访问特定的寄存器;<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot;ap      粘贴字母a寄存器内容  </div><div class="line">&quot;1y      把选取内容复制到数字寄存器1</div></pre></td></tr></table></figure></p>
<p>要将vim的内容复制到某个粘贴板, 需要退出编辑模式, 进入正常模式后, 选择要复制的内容, 然后按 “Ny 完成复制, 其中 N 为粘贴板号(注意是按一下双引号然后按粘贴板号最后按y),例如要把内容复制到粘贴板 a, 选中内容后按 “ay 就可以了,有两点需要说明一下:</p>
<ul>
<li>; 号粘贴板(临时粘贴板)比较特殊, 直接按 y 就复制到这个粘贴板中了, 直接按 p 就粘贴这个粘贴板中的内容;</li>
<li>+ 号粘贴板是系统粘贴板,用”+y 将内容复制到该粘贴板后可以使用 Ctrl＋V 将其粘贴到其他文档(如firefox、gedit)中,同理,要把在其他地方用 Ctrl＋C 或右键复制的内容复制到vim中,需要在正常模式下按 “+p ;<br>要将vim某个粘贴板里的内容粘贴进来, 需要退出编辑模式, 在正常模式按 “Np, 其中N为粘贴板号, 如上所述, 可以按 “5p 将5号粘贴板里的内容粘贴进来, 也可以按 “+p 将系统全局粘贴板里的内容粘贴进来。</li>
</ul>
<h2 id="系统剪贴板"><a href="#系统剪贴板" class="headerlink" title="系统剪贴板"></a>系统剪贴板</h2><p>细心的人已经发现我重点标注的寄存器部分了,就是那个选择及拖拽寄存器,这就是系统的剪贴板,我们通常使用的 ctrl+c  ctrl+v 的内容就保存在这个寄存器中,所以你要把需要复制的内容放在 + 寄存器中,就可以在gui界面中用粘贴或 ctrl+v 粘贴了,同理,粘贴在vim中也一样<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot;+y    复制到系统剪贴板  </div><div class="line">&quot;+p    粘贴  </div><div class="line">&quot;+gp  粘贴并且移动光标到粘贴内容后</div></pre></td></tr></table></figure></p>
<p>但是光是输入命令 “+p 就已经让人觉得很麻烦了,这时候,vim的map功能就又可以大显神通了,我们只需要把”+y  和 “+gp  map到你喜欢的快捷键上即可;</p>
<p>首先打开vimrc(如果没有,请创建一个)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">vim ~/.vimrc</div></pre></td></tr></table></figure></p>
<p>然后在其中输入;<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">nmap &lt;c-v&gt; &quot;+gp  </div><div class="line">nmap &lt;c-c&gt; &quot;+y</div></pre></td></tr></table></figure></p>
<p>你现在就可以使用ctrl+c  和ctrl+v 了,但是！我本人是不推荐用这个快捷键的,因为本身<c-v>是我很常用的块命令<br>所以,我一般修改成;<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">nmap &lt;leader&gt;v &quot;+gp  </div><div class="line">nmap &lt;leader&gt;c &quot;+y</div></pre></td></tr></table></figure></c-v></p>
<p>至于<leader>是什么按键,就可以按照你的喜好来, 我的是’,’<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let mapleader=&quot;,&quot;</div></pre></td></tr></table></figure></leader></p>
<p>ref:<br><a href="http://blog.csdn.net/hk2291976/article/details/42196559" target="_blank" rel="external">http://blog.csdn.net/hk2291976/article/details/42196559</a></p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-大小写转换</title>
    <url>/2017/09/06/Vim-%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>Vim 大小写转换</p>
<a id="more"></a>
<h2 id="Vim-大小写转换"><a href="#Vim-大小写转换" class="headerlink" title="Vim 大小写转换"></a>Vim 大小写转换</h2><p>vim中大小写转化的命令是<br>gu或者gU<br>形象一点的解释就是小u意味着转为小写；大U意味着转为大写.</p>
<p>剩下的就是对这两个命令的限定（限定操作的行，字母，单词）等等</p>
<h3 id="整篇文章大写转化为小写"><a href="#整篇文章大写转化为小写" class="headerlink" title="整篇文章大写转化为小写"></a>整篇文章大写转化为小写</h3><p>打开文件后，无须进入命令行模式。键入:ggguG </p>
<p>解释一下：ggguG分作三段gg gu G<br>gg=光标到文件第一个字符<br>gu=把选定范围全部小写<br>G=到文件结束</p>
<h3 id="整篇文章小写转化为大写"><a href="#整篇文章小写转化为大写" class="headerlink" title="整篇文章小写转化为大写"></a>整篇文章小写转化为大写</h3><p>打开文件后，无须进入命令行模式。键入:gggUG </p>
<p>解释一下：gggUG分作三段gg gU G<br>gg=光标到文件第一个字符<br>gU=把选定范围全部大写<br>G=到文件结束</p>
<h3 id="只转化某个单词"><a href="#只转化某个单词" class="headerlink" title="只转化某个单词"></a>只转化某个单词</h3><p>guw 、gue<br>gUw、gUe<br>这样，光标后面的单词便会进行大小写转换<br>想转换5个单词的命令如下：<br>gu5w、gu5e<br>gU5w、gU5e</p>
<h3 id="转换几行的大小写"><a href="#转换几行的大小写" class="headerlink" title="转换几行的大小写"></a>转换几行的大小写</h3><p>将光标定位到想转换的行上，键入：1gU 从光标所在行 往下一行都进行小写到大写的转换<br>10gU，则进行11行小写到大写的转换<br>以此类推，就出现其他的大小写转换命令<br>gU0        ：从光标所在位置到行首，都变为大写<br>gU$        ：从光标所在位置到行尾，都变为大写<br>gUG        ：从光标所在位置到文章最后一个字符，都变为大写<br>gU1G      ：从光标所在位置到文章第一个字符，都变为大写</p>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-标签</title>
    <url>/2017/09/06/Vim-%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<p>vim 标签</p>
<a id="more"></a>
<h2 id="新建标签页"><a href="#新建标签页" class="headerlink" title="新建标签页"></a>新建标签页</h2><p>使用:tabe命令和文件名参数，可以在新标签页中打开指定的文件。也可以使用:tabnew命令，在新标签页中编辑新的文件。命令:tab split将在新标签页中，打开当前缓冲区中的文件。<br>命令:tabf允许你在当前目录搜索文件，并在新标签页中打开。比如我想打开当前目录下的img.txt文件，那么就可以使用 <code>:tabf img.*</code>命令。请注意，此命令只能打开一个文件，如果搜索出多个匹配文件，将提示你“文件名过多”，这时你需要给出更精确的搜索条件以打开文件。<br>Vim默认最多只能打开10个标签页。你可以用set tabpagemax=15改变这个限制。</p>
<h2 id="列示标签页"><a href="#列示标签页" class="headerlink" title="列示标签页"></a>列示标签页</h2><p>命令:tabs可以显示已打开标签页的列表，并用“&gt;”标识出当前页面，用“+”标识出已更改的页面。<br>关闭标签页<br>命令:tabc可以关闭当前标签页。而命令:tabo将关闭所有的标签页。</p>
<h2 id="切换标签页"><a href="#切换标签页" class="headerlink" title="切换标签页"></a>切换标签页</h2><p>命令:tabn或gt可以移动到下一个标签页。而命令:tabp或gT将移动到上一个标签页。如果已经到达最后面或最前面的标签页，将会自动转向循环。<br>如果你打开了很多标签页，那么可以使用:tabfirst或:tabr命令，移动到第一个标签页。使用:tablast命令，移动到最后一个标签页。<br>移动标签页<br>如果你希望按照指定的次序排列标签页，那么你可以使用:tabm命令。请注意，标签页次序是从0开始计数的。比如命令:tabm 1将把当前标签页移动到第2的位置。如果你没有为:tabm命令指定参数，那么当前标签页将会被移动到最后。</p>
<h2 id="配置标签页"><a href="#配置标签页" class="headerlink" title="配置标签页"></a>配置标签页</h2><p>默认情况下，只有用户新建了标签页才会在窗口上方显示标签栏，这是由选项set showtabline=1决定的。如果我们希望总是显示标签栏，那么可以用set showtabline=2命令来设置。如果我们希望完全不显示标签栏，那么可以使用set showtabline=0来设置。</p>
<p>##多标签页命令<br>使用:tabdo命令，我们可以同时在多个标签页中执行命令。比如我们打开了多个标签页，需要把这些文件中的“food”都替换成“drink”，那么就可以使用:tabdo %s/food/drink/g命令，一次完成对所有文件的替换操作，而不用针对每个文件重复操作。</p>
<p>##图形界面<br>如果你使用的是带有图形界面的gVim，那么新建、关闭和打开标签页的操作，都可以通过在标签页上右击鼠标完成。只需要点击相应标签，就可以在不同的标签页间切换。<br>通过:help tab-page-intro命令，可以获得关于标签页使用的更多信息。</p>
<h2 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h2><table>
<thead>
<tr>
<th style="text-align:left">命令</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">:tabnew</td>
<td style="text-align:left">新建标签页</td>
</tr>
<tr>
<td style="text-align:left">:tabs</td>
<td style="text-align:left">显示已打开标签页的列表</td>
</tr>
<tr>
<td style="text-align:left">:tabc</td>
<td style="text-align:left">关闭当前标签页</td>
</tr>
<tr>
<td style="text-align:left">:tabn</td>
<td style="text-align:left">移动到下一个标签页</td>
</tr>
<tr>
<td style="text-align:left">:tabp</td>
<td style="text-align:left">移动到上一个标签页</td>
</tr>
<tr>
<td style="text-align:left">:tabfirst</td>
<td style="text-align:left">移动到第一个标签页</td>
</tr>
<tr>
<td style="text-align:left">:tablast</td>
<td style="text-align:left">移动到最后一个标签页</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Filter-Interceptor</title>
    <url>/2017/09/01/Java-Filter-Interceptor/</url>
    <content><![CDATA[<p>拦截器（Interceptor）和过滤器（Filter）的执行顺序和区别</p>
<a id="more"></a>
<h2 id="过滤器（Filter）"><a href="#过滤器（Filter）" class="headerlink" title="过滤器（Filter）"></a>过滤器（Filter）</h2><p>首先说一下Filter的使用地方，我们在配置web.xml时，总会配置下面一段设置字符编码，不然会导致乱码问题：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">    &lt;filter-name&gt;encoding&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;UTF-8&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;true&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line"></div><div class="line">&lt;filter-mapping&gt;</div><div class="line">    &lt;filter-name&gt;encoding&lt;/filter-name&gt;</div><div class="line">    &lt;servlet-name&gt;/*&lt;/servlet-name&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>配置这个地方的目的，是让所有的请求都需要进行字符编码的设置，下面来介绍一下Filter。</p>
<p>过滤器依赖于servlet容器。在实现上，基于函数回调，它可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的，是用来做一些过滤操作，获取我们想要获取的数据，比如：在Javaweb中，对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作。通常用的场景是：在过滤器中修改字符编码（CharacterEncodingFilter）、在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等。</p>
<h2 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）"></a>拦截器（Interceptor）</h2><p>拦截器的配置一般在SpringMVC的配置文件中，使用Interceptors标签，具体配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;mvc:interceptors&gt;</div><div class="line">    &lt;mvc:interceptor&gt;</div><div class="line">        &lt;mvc:mapping path=&quot;/**&quot; /&gt;</div><div class="line">        &lt;bean class=&quot;com.scorpios.atcrowdfunding.web.LoginInterceptor&quot;&gt;&lt;/bean&gt;</div><div class="line">    &lt;/mvc:interceptor&gt;</div><div class="line">    &lt;mvc:interceptor&gt;</div><div class="line">        &lt;mvc:mapping path=&quot;/**&quot; /&gt;</div><div class="line">        &lt;bean class=&quot;com.scorpios.atcrowdfunding.web.AuthInterceptor&quot;&gt;&lt;/bean&gt;</div><div class="line">    &lt;/mvc:interceptor&gt;</div><div class="line">&lt;/mvc:interceptors&gt;</div></pre></td></tr></table></figure></p>
<p>拦截器（Interceptor）依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。</p>
<h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>下面在一个项目中我们使用既有多个过滤器，又有多个拦截器，并观察它们的执行顺序：<br>（1）第一个过滤器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class TestFilter1 extends Filter &#123;  </div><div class="line">  </div><div class="line">		@Override</div><div class="line">  	    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;  </div><div class="line">        //在DispatcherServlet之前执行  </div><div class="line">		System.out.println(&quot;############TestFilter1 doFilterInternal executed############&quot;);  </div><div class="line">        filterChain.doFilter(request, response);  </div><div class="line">        //在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后  </div><div class="line">        System.out.println(&quot;############TestFilter1 doFilter after############&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（2）第二个过滤器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class TestFilter2 extends Filter &#123;  </div><div class="line"> </div><div class="line">	@Override</div><div class="line">    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;  </div><div class="line">	    //在DispatcherServlet之前执行  </div><div class="line">        System.out.println(&quot;############TestFilter2 doFilterInternal executed############&quot;);  </div><div class="line">        filterChain.doFilter(request, response);  </div><div class="line">        //在视图页面返回给客户端之前执行，但是执行顺序在Interceptor之后 </div><div class="line">        System.out.println(&quot;############TestFilter2 doFilter after############&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（3）在web.xml中注册这两个过滤器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- 自定义过滤器：testFilter1 --&gt;   </div><div class="line">   &lt;filter&gt;  </div><div class="line">        &lt;filter-name&gt;testFilter1&lt;/filter-name&gt;  </div><div class="line">        &lt;filter-class&gt;com.scorpios.filter.TestFilter1&lt;/filter-class&gt;  </div><div class="line">    &lt;/filter&gt;  </div><div class="line">    &lt;filter-mapping&gt;  </div><div class="line">        &lt;filter-name&gt;testFilter1&lt;/filter-name&gt;  </div><div class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  </div><div class="line">    &lt;/filter-mapping&gt;  </div><div class="line">    &lt;!-- 自定义过滤器：testFilter2 --&gt;   </div><div class="line">   &lt;filter&gt;  </div><div class="line">        &lt;filter-name&gt;testFilter2&lt;/filter-name&gt;  </div><div class="line">        &lt;filter-class&gt;com.scorpios.filter.TestFilter2&lt;/filter-class&gt;  </div><div class="line">    &lt;/filter&gt;  </div><div class="line">    &lt;filter-mapping&gt;  </div><div class="line">        &lt;filter-name&gt;testFilter2&lt;/filter-name&gt;  </div><div class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  </div><div class="line">    &lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<p>再定义两个拦截器：<br>（4）第一个拦截器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class BaseInterceptor implements HandlerInterceptor&#123;  </div><div class="line">     </div><div class="line">    /** </div><div class="line">     * 在DispatcherServlet之前执行 </div><div class="line">     * */  </div><div class="line">    public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123;  </div><div class="line">        System.out.println(&quot;************BaseInterceptor preHandle executed**********&quot;);  </div><div class="line">        return true;  </div><div class="line">    &#125;  </div><div class="line"> </div><div class="line">    /** </div><div class="line">     * 在controller执行之后的DispatcherServlet之后执行 </div><div class="line">     * */  </div><div class="line">    public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123;  </div><div class="line">        System.out.println(&quot;************BaseInterceptor postHandle executed**********&quot;);  </div><div class="line">    &#125;  </div><div class="line">     </div><div class="line">    /** </div><div class="line">     * 在页面渲染完成返回给客户端之前执行 </div><div class="line">     * */  </div><div class="line">    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)  </div><div class="line">            throws Exception &#123;  </div><div class="line">        System.out.println(&quot;************BaseInterceptor afterCompletion executed**********&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>（5）第二个拦截器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public class TestInterceptor implements HandlerInterceptor &#123;  </div><div class="line"> </div><div class="line">    public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123;  </div><div class="line">        System.out.println(&quot;************TestInterceptor preHandle executed**********&quot;);  </div><div class="line">        return true;  </div><div class="line">    &#125;  </div><div class="line"> </div><div class="line">    public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) throws Exception &#123;  </div><div class="line">        System.out.println(&quot;************TestInterceptor postHandle executed**********&quot;);  </div><div class="line">    &#125;  </div><div class="line"> </div><div class="line">    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) throws Exception &#123;  </div><div class="line">        System.out.println(&quot;************TestInterceptor afterCompletion executed**********&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>6）在SpringMVC的配置文件中，加上拦截器的配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;!-- 拦截器 --&gt;  </div><div class="line">&lt;mvc:interceptors&gt;  </div><div class="line">    &lt;!-- 对所有请求都拦截，公共拦截器可以有多个 --&gt;  </div><div class="line">    &lt;bean name=&quot;baseInterceptor&quot; class=&quot;com.scorpios.interceptor.BaseInterceptor&quot; /&gt;  </div><div class="line">	</div><div class="line">	&lt;mvc:interceptor&gt; </div><div class="line">	    &lt;!-- 对/test.html进行拦截 --&gt;       </div><div class="line">        &lt;mvc:mapping path=&quot;/test.html&quot;/&gt;  </div><div class="line">        &lt;!-- 特定请求的拦截器只能有一个 --&gt;  </div><div class="line">        &lt;bean class=&quot;com.scorpios.interceptor.TestInterceptor&quot; /&gt;  </div><div class="line">    &lt;/mvc:interceptor&gt;  </div><div class="line">&lt;/mvc:interceptors&gt;</div></pre></td></tr></table></figure></p>
<p>（7）定义一个Controller控制器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.scorpios.controller;  </div><div class="line">import org.springframework.stereotype.Controller;  </div><div class="line">import org.springframework.web.bind.annotation.RequestMapping;  </div><div class="line">import org.springframework.web.servlet.ModelAndView;  </div><div class="line">  </div><div class="line">@Controller  </div><div class="line">public class TestController &#123;  </div><div class="line">    @RequestMapping(&quot;/test&quot;)  </div><div class="line">    public ModelAndView handleRequest()&#123;  </div><div class="line">        System.out.println(&quot;---------TestController executed--------&quot;);  </div><div class="line">        return new ModelAndView(&quot;test&quot;);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(8)测试结果：</p>
<p>访问 /<br><img src="20180603132319702.png" alt=""><br>这就说明了过滤器的运行是依赖于servlet容器，跟springmvc等框架并没有关系。并且，多个过滤器的执行顺序跟xml文件中定义的先后关系有关</p>
<p>访问 /test<br><img src="20180603132536413.png" alt=""><br>从这个控制台打印输出，就可以很清晰地看到有多个拦截器和过滤器存在时的整个执行顺序了。当然，对于多个拦截器它们之间的执行顺序跟在SpringMVC的配置文件中定义的先后顺序有关</p>
<p>Filter的执行顺序在Interceptor之前，具体的流程见下图<br><img src="20180603133007923.png" alt=""></p>
<h2 id="两者的本质区别"><a href="#两者的本质区别" class="headerlink" title="两者的本质区别"></a>两者的本质区别</h2><p>拦截器（Interceptor）是基于Java的反射机制，而过滤器（Filter）是基于函数回调。从灵活性上说拦截器功能更强大些，Filter能做的事情，都能做，而且可以在请求前，请求后执行，比较灵活。Filter主要是针对URL地址做一个编码的事情、过滤掉没用的参数、安全校验（比较泛的，比如登录不登录之类），太细的话，还是建议用interceptor。不过还是根据不同情况选择合适的。</p>
<p>ref：<a href="https://blog.csdn.net/zxd1435513775/article/details/80556034" target="_blank" rel="external">https://blog.csdn.net/zxd1435513775/article/details/80556034</a> </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Filter</tag>
        <tag>Interceptor</tag>
      </tags>
  </entry>
  <entry>
    <title>Java-Mockito</title>
    <url>/2017/09/01/Java-Mockito/</url>
    <content><![CDATA[<p>Java Mockito learning experience.</p>
<a id="more"></a>
<h2 id="引入-mockito-core-依赖"><a href="#引入-mockito-core-依赖" class="headerlink" title="引入 mockito-core 依赖"></a>引入 mockito-core 依赖</h2><h3 id="gradle-方式"><a href="#gradle-方式" class="headerlink" title="gradle 方式:"></a>gradle 方式:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">repositories &#123; jcenter() &#125;</div><div class="line">dependencies &#123; testCompile &quot;org.mockito:mockito-core:2.+&quot; &#125;</div></pre></td></tr></table></figure>
<h3 id="Maven-方式"><a href="#Maven-方式" class="headerlink" title="Maven 方式:"></a>Maven 方式:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.mockito&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;2.13.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<h3 id="验证交互"><a href="#验证交互" class="headerlink" title="验证交互"></a>验证交互</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import static org.mockito.Mockito.*;</div><div class="line"></div><div class="line">// mock creation</div><div class="line">List mockedList = mock(List.class);</div><div class="line"></div><div class="line">// using mock object - it does not throw any &quot;unexpected interaction&quot; exception</div><div class="line">mockedList.add(&quot;one&quot;);</div><div class="line">mockedList.clear();</div><div class="line"></div><div class="line">// selective, explicit, highly readable verification</div><div class="line">verify(mockedList).add(&quot;one&quot;);</div><div class="line">verify(mockedList).clear();</div></pre></td></tr></table></figure>
<h3 id="存根方法调用"><a href="#存根方法调用" class="headerlink" title="存根方法调用"></a>存根方法调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">// you can mock concrete classes, not only interfaces</div><div class="line">LinkedList mockedList = mock(LinkedList.class);</div><div class="line"></div><div class="line">// stubbing appears before the actual execution</div><div class="line">when(mockedList.get(0)).thenReturn(&quot;first&quot;);</div><div class="line"></div><div class="line">// the following prints &quot;first&quot;</div><div class="line">System.out.println(mockedList.get(0));</div><div class="line"></div><div class="line">// the following prints &quot;null&quot; because get(999) was not stubbed</div><div class="line">System.out.println(mockedList.get(999));</div></pre></td></tr></table></figure>
<p>ref:<br><a href="http://site.mockito.org" target="_blank" rel="external">http://site.mockito.org</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mockito</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-面向对象</title>
    <url>/2017/09/01/Python-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。</p>
<a id="more"></a>
<h2 id="面向对象技术简介"><a href="#面向对象技术简介" class="headerlink" title="面向对象技术简介"></a>面向对象技术简介</h2><ul>
<li>类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。</li>
<li>类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。</li>
<li>数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。</li>
<li>方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。</li>
<li>实例变量：定义在方法中的变量，只作用于当前实例的类。</li>
<li>继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。</li>
<li>实例化：创建一个类的实例，类的具体对象。</li>
<li>方法：类中定义的函数。</li>
<li>对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。</li>
</ul>
<h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><p>使用class语句来创建一个新类，class之后为类的名称并以冒号结尾，如下实例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class ClassName:</div><div class="line">   &apos;类的帮助信息&apos;   #类文档字符串</div><div class="line">   class_suite  #类体</div></pre></td></tr></table></figure></p>
<p>类的帮助信息可以通过ClassName.<strong>doc</strong>查看。<br>class_suite 由类成员，方法，数据属性组成。</p>
<p>以下是一个简单的Python类实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></div><div class="line">   <span class="string">'所有员工的基类'</span></div><div class="line">   empCount = <span class="number">0</span></div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, salary)</span>:</span></div><div class="line">      self.name = name</div><div class="line">      self.salary = salary</div><div class="line">      Employee.empCount += <span class="number">1</span></div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayCount</span><span class="params">(self)</span>:</span></div><div class="line">     <span class="keyword">print</span> <span class="string">"Total Employee %d"</span> % Employee.empCount</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayEmployee</span><span class="params">(self)</span>:</span></div><div class="line">      <span class="keyword">print</span> <span class="string">"Name : "</span>, self.name,  <span class="string">", Salary: "</span>, self.salary</div></pre></td></tr></table></figure></p>
<ul>
<li>empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。</li>
<li>第一种方法<strong>init</strong>()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法</li>
<li>self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。</li>
</ul>
<h3 id="self代表类的实例，而非类"><a href="#self代表类的实例，而非类" class="headerlink" title="self代表类的实例，而非类"></a>self代表类的实例，而非类</h3><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(self)</span>:</span></div><div class="line">        print(self)</div><div class="line">        print(self.__class__)</div><div class="line"> </div><div class="line">t = Test()</div><div class="line">t.prt()</div></pre></td></tr></table></figure></p>
<p>以上实例执行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;__main__.Test instance at 0x10d066878&gt;</div><div class="line">__main__.Test</div></pre></td></tr></table></figure></p>
<p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。<br>self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prt</span><span class="params">(runoob)</span>:</span></div><div class="line">        print(runoob)</div><div class="line">        print(runoob.__class__)</div><div class="line"> </div><div class="line">t = Test()</div><div class="line">t.prt()</div></pre></td></tr></table></figure></p>
<p>以上实例执行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;__main__.Test instance at 0x10d066878&gt;</div><div class="line">__main__.Test</div></pre></td></tr></table></figure></p>
<h2 id="创建实例对象"><a href="#创建实例对象" class="headerlink" title="创建实例对象"></a>创建实例对象</h2><p>实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。<br>以下使用类的名称 Employee 来实例化，并通过 <strong>init</strong> 方法接受参数。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="string">"创建 Employee 类的第一个对象"</span></div><div class="line">emp1 = Employee(<span class="string">"Zara"</span>, <span class="number">2000</span>)</div><div class="line"><span class="string">"创建 Employee 类的第二个对象"</span></div><div class="line">emp2 = Employee(<span class="string">"Manni"</span>, <span class="number">5000</span>)</div></pre></td></tr></table></figure></p>
<h2 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h2><p>您可以使用点(.)来访问对象的属性。使用如下类的名称访问类变量:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">emp1.displayEmployee()</div><div class="line">emp2.displayEmployee()</div><div class="line"><span class="keyword">print</span> <span class="string">"Total Employee %d"</span> % Employee.empCount</div></pre></td></tr></table></figure></p>
<p>完整实例：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></div><div class="line">   <span class="string">'所有员工的基类'</span></div><div class="line">   empCount = <span class="number">0</span></div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, salary)</span>:</span></div><div class="line">      self.name = name</div><div class="line">      self.salary = salary</div><div class="line">      Employee.empCount += <span class="number">1</span></div><div class="line">   </div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayCount</span><span class="params">(self)</span>:</span></div><div class="line">     <span class="keyword">print</span> <span class="string">"Total Employee %d"</span> % Employee.empCount</div><div class="line"> </div><div class="line">   <span class="function"><span class="keyword">def</span> <span class="title">displayEmployee</span><span class="params">(self)</span>:</span></div><div class="line">      <span class="keyword">print</span> <span class="string">"Name : "</span>, self.name,  <span class="string">", Salary: "</span>, self.salary</div><div class="line"> </div><div class="line"><span class="string">"创建 Employee 类的第一个对象"</span></div><div class="line">emp1 = Employee(<span class="string">"Zara"</span>, <span class="number">2000</span>)</div><div class="line"><span class="string">"创建 Employee 类的第二个对象"</span></div><div class="line">emp2 = Employee(<span class="string">"Manni"</span>, <span class="number">5000</span>)</div><div class="line">emp1.displayEmployee()</div><div class="line">emp2.displayEmployee()</div><div class="line"><span class="keyword">print</span> <span class="string">"Total Employee %d"</span> % Employee.empCount</div></pre></td></tr></table></figure></p>
<p>执行以上代码输出结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Name :  Zara ,Salary:  2000</div><div class="line">Name :  Manni ,Salary:  5000</div><div class="line">Total Employee 2</div></pre></td></tr></table></figure></p>
<p>你可以添加，删除，修改类的属性，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">emp1.age = 7  # 添加一个 &apos;age&apos; 属性</div><div class="line">emp1.age = 8  # 修改 &apos;age&apos; 属性</div><div class="line">del emp1.age  # 删除 &apos;age&apos; 属性</div></pre></td></tr></table></figure></p>
<p>你也可以使用以下函数的方式来访问属性：</p>
<ul>
<li>getattr(obj, name[, default]) : 访问对象的属性。</li>
<li>hasattr(obj,name) : 检查是否存在一个属性。</li>
<li>setattr(obj,name,value) : 设置一个属性。如果属性不存在，会创建一个新属性。</li>
<li>delattr(obj, name) : 删除属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hasattr(emp1, &apos;age&apos;)    # 如果存在 &apos;age&apos; 属性返回 True。</div><div class="line">getattr(emp1, &apos;age&apos;)    # 返回 &apos;age&apos; 属性的值</div><div class="line">setattr(emp1, &apos;age&apos;, 8) # 添加属性 &apos;age&apos; 值为 8</div><div class="line">delattr(empl, &apos;age&apos;)    # 删除属性 &apos;age&apos;</div></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Python-命令及帮助查看</title>
    <url>/2017/09/01/Python-%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%B8%AE%E5%8A%A9%E6%9F%A5%E7%9C%8B/</url>
    <content><![CDATA[<p>类的帮助信息可以通过ClassName.<strong>doc</strong>查看</p>
<a id="more"></a>
<h2 id="整理中…"><a href="#整理中…" class="headerlink" title="整理中…"></a>整理中…</h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Command</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_基础</title>
    <url>/2017/08/26/Python-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Python 基础</p>
<a id="more"></a>
<h2 id="Python-入门"><a href="#Python-入门" class="headerlink" title="Python 入门"></a>Python 入门</h2><h3 id="Python-中文编码"><a href="#Python-中文编码" class="headerlink" title="Python 中文编码"></a>Python 中文编码</h3><p>Python 文件中如果未指定编码，在执行过程会出现报错:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="keyword">print</span> <span class="string">"你好，世界"</span>;</div></pre></td></tr></table></figure></p>
<p>以上程序执行输出结果为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">  File &quot;test.py&quot;, line 2</div><div class="line">SyntaxError: Non-ASCII character &apos;\xe4&apos; in file test.py on line 2, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details</div></pre></td></tr></table></figure></p>
<p>Python中默认的编码格式是 ASCII 格式，在没修改编码格式时无法正确打印汉字，所以在读取中文时会报错。<br>解决方法为只要在文件开头加入 # -<em>- coding: UTF-8 -</em>- 或者 #coding=utf-8 就行了。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"你好，世界"</span>;</div></pre></td></tr></table></figure></p>
<p>输出结果为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">你好，世界</div></pre></td></tr></table></figure></p>
<p>所以如果大家在学习过程中，代码中包含中文，就需要在头部指定编码。<br>注意:Python3.X 源码文件默认使用utf-8编码，所以可以正常解析中文，无需指定 UTF-8 编码。<br>注意:如果你使用编辑器，同时需要设置 py 文件存储的格式为 UTF-8，否则会出现类似以下错误信息:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">SyntaxError: (unicode error) ‘utf-8’ codec can’t decode byte 0xc4 in position 0:</div><div class="line">invalid continuation byte</div></pre></td></tr></table></figure></p>
<p>PS:<br>脚本语言的第一行，目的就是指出，你想要你的这个文件中的代码用什么可执行程序去运行它，就这么简单。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/usr/bin/python : 是告诉操作系统执行这个脚本的时候，调用 /usr/bin 下的 python 解释器；</div><div class="line">#!/usr/bin/env python(推荐）: 这种用法是为了防止操作系统用户没有将 python 装在默认的 /usr/bin 路径里。当系统看到这一行的时候，首先会到 env 设置里查找 python 的安装路径，再调用对应路径下的解释器程序完成操作。</div><div class="line">#!/usr/bin/python 相当于写死了python路径;</div><div class="line">#!/usr/bin/env python 会去环境设置寻找 python 目录,推荐这种写法</div></pre></td></tr></table></figure></p>
<p>ref: <a href="http://www.runoob.com/python/python-chinese-encoding.html" target="_blank" rel="external">http://www.runoob.com/python/python-chinese-encoding.html</a></p>
<h3 id="Python-保留字符"><a href="#Python-保留字符" class="headerlink" title="Python 保留字符"></a>Python 保留字符</h3><p>下面的列表显示了在Python中的保留字。这些保留字不能用作常数或变数，或任何其他标识符名称。<br>所有 Python 的关键字只包含小写字母。<br>and, exec, not,assert, finally, or,break, for, pass,class, from, print,continue, global, raise,def, if, return,del, import, try,elif, in, while,else, is, with,except, lambda, yield</p>
<h3 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h3><p>学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。<br>缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行。如下所示:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"True"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">  <span class="keyword">print</span> <span class="string">"False"</span></div></pre></td></tr></table></figure></p>
<p>以下代码将会执行错误:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="comment"># 文件名:test.py</span></div><div class="line"></div><div class="line"> <span class="keyword">if</span> <span class="keyword">True</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"Answer"</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"True"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"Answer"</span></div><div class="line">    <span class="comment"># 没有严格缩进，在执行时会报错</span></div><div class="line">  <span class="keyword">print</span> <span class="string">"False"</span></div></pre></td></tr></table></figure></p>
<p>执行以上代码，会出现如下错误提醒:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ python test.py</div><div class="line">  File &quot;test.py&quot;, line 5</div><div class="line">    if True:</div><div class="line">    ^</div><div class="line">IndentationError: unexpected indent</div></pre></td></tr></table></figure></p>
<p>IndentationError: unexpected indent 错误是 python 编译器是在告诉你”Hi，老兄，你的文件里格式不对了，可能是tab和空格没对齐的问题”，所有 python 对格式要求非常严格。<br>如果是 IndentationError: unindent does not match any outer indentation level错误表明，你使用的缩进方式不一致，有的是 tab 键缩进，有的是空格缩进，改为一致即可。<br>因此，在 Python 的代码块中必须使用相同数目的行首缩进空格数。<br>建议你在每个缩进层次使用 单个制表符 或 两个空格 或 四个空格 , 切记不能混用</p>
<h3 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h3><p>Python语句中一般以新行作为为语句的结束符。<br>但是我们可以使用斜杠（ \）将一行的语句分为多行显示，如下所示:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">total = item_one + \</div><div class="line">        item_two + \</div><div class="line">        item_three</div></pre></td></tr></table></figure></p>
<p>语句中包含 [], {} 或 () 括号就不需要使用多行连接符。如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">days = [<span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>,</div><div class="line">        <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>]</div></pre></td></tr></table></figure></p>
<h3 id="Python-引号"><a href="#Python-引号" class="headerlink" title="Python 引号"></a>Python 引号</h3><p>Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串，引号的开始与结束必须的相同类型的。<br>其中三引号可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">word = <span class="string">'word'</span></div><div class="line">sentence = <span class="string">"这是一个句子。"</span></div><div class="line">paragraph = <span class="string">"""这是一个段落。</span></div><div class="line">包含了多个语句"""</div></pre></td></tr></table></figure></p>
<h3 id="Python注释"><a href="#Python注释" class="headerlink" title="Python注释"></a>Python注释</h3><p>python中单行注释采用 # 开头。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="comment"># 文件名:test.py</span></div><div class="line"></div><div class="line"><span class="comment"># 第一个注释</span></div><div class="line"><span class="keyword">print</span> <span class="string">"Hello, Python!"</span>;  <span class="comment"># 第二个注释</span></div></pre></td></tr></table></figure></p>
<p>输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello, Python!</div></pre></td></tr></table></figure></p>
<p>注释可以在语句或表达式行末:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">name = <span class="string">"Madisetti"</span> <span class="comment"># 这是一个注释</span></div></pre></td></tr></table></figure></p>
<p>python 中多行注释使用三个单引号(‘’’)或三个双引号(“””)。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"><span class="comment"># 文件名:test.py</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">这是多行注释，使用单引号。</div><div class="line">这是多行注释，使用单引号。</div><div class="line">这是多行注释，使用单引号。</div><div class="line">'''</div><div class="line"></div><div class="line"><span class="string">"""</span></div><div class="line">这是多行注释，使用双引号。</div><div class="line">这是多行注释，使用双引号。</div><div class="line">这是多行注释，使用双引号。</div><div class="line">"""</div></pre></td></tr></table></figure></p>
<h3 id="Python空行"><a href="#Python空行" class="headerlink" title="Python空行"></a>Python空行</h3><p>函数之间或类的方法之间用空行分隔，表示一段新的代码的开始。类和函数入口之间也用一行空行分隔，以突出函数入口的开始。<br>空行与代码缩进不同，空行并不是Python语法的一部分。书写时不插入空行，Python解释器运行也不会出错。但是空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构。<br>记住:空行也是程序代码的一部分。<br>建议:</p>
<ol>
<li>import 与类之间空2行</li>
<li>类之间空2行</li>
<li>类与函数间空1行</li>
</ol>
<h3 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h3><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys; x = <span class="string">'runoob'</span>; sys.stdout.write(x + <span class="string">'\n'</span>)</div></pre></td></tr></table></figure></p>
<p>执行以上代码，输入结果为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ python test.py</div><div class="line">runoob</div></pre></td></tr></table></figure></p>
<h3 id="Print-输出"><a href="#Print-输出" class="headerlink" title="Print 输出"></a>Print 输出</h3><p>print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">x=<span class="string">"a"</span></div><div class="line">y=<span class="string">"b"</span></div><div class="line"><span class="comment"># 换行输出</span></div><div class="line"><span class="keyword">print</span> x</div><div class="line"><span class="keyword">print</span> y</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'---------'</span></div><div class="line"><span class="comment"># 不换行输出</span></div><div class="line"><span class="keyword">print</span> x,</div><div class="line"><span class="keyword">print</span> y,</div></pre></td></tr></table></figure></p>
<p>以上实例执行结果为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a</div><div class="line">b</div><div class="line">---------</div><div class="line">a b</div></pre></td></tr></table></figure></p>
<h3 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h3><p>缩进相同的一组语句构成一个代码块，我们称之代码组。<br>像if、while、def和class这样的复合语句，首行以关键字开始，以冒号( : )结束，该行之后的一行或多行代码构成代码组。<br>我们将首行及后面的代码组称为一个子句(clause)。<br>如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> expression :</div><div class="line">   suite</div><div class="line"><span class="keyword">elif</span> expression :</div><div class="line">   suite</div><div class="line"><span class="keyword">else</span> :</div><div class="line">   suite</div></pre></td></tr></table></figure></p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>很多程序可以执行一些操作来查看一些基本信息，Python 可以使用 -h 参数查看各参数帮助信息:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ python -h</div><div class="line">usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...</div><div class="line">Options and arguments (and corresponding environment variables):</div><div class="line">-c cmd : program passed in as string (terminates option list)</div><div class="line">-d     : debug output from parser (also PYTHONDEBUG=x)</div><div class="line">-E     : ignore environment variables (such as PYTHONPATH)</div><div class="line">-h     : print this help message and exit</div><div class="line"></div><div class="line">[ etc. ]</div></pre></td></tr></table></figure></p>
<p>我们在使用脚本形式执行 Python 时，可以接收命令行输入的参数，具体使用可以参照 <a href="http://www.runoob.com/python/python-command-line-arguments.html" target="_blank" rel="external">Python 命令行参数</a>。</p>
<h2 id="Python-变量类型"><a href="#Python-变量类型" class="headerlink" title="Python 变量类型"></a>Python 变量类型</h2><p>变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。<br>基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。<br>因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。</p>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><p>Python 中的变量赋值不需要类型声明。<br>每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。<br>每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。<br>等号（=）用来给变量赋值。<br>等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">counter = <span class="number">100</span> <span class="comment"># 赋值整型变量</span></div><div class="line">miles = <span class="number">1000.0</span> <span class="comment"># 浮点型</span></div><div class="line">name = <span class="string">"John"</span> <span class="comment"># 字符串</span></div></pre></td></tr></table></figure>
<h3 id="多个变量赋值"><a href="#多个变量赋值" class="headerlink" title="多个变量赋值"></a>多个变量赋值</h3><p>Python允许你同时为多个变量赋值。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a = b = c = 1</div></pre></td></tr></table></figure>
<p>以上实例，创建一个整型对象，值为1，三个变量被分配到相同的内存空间上。</p>
<p>您也可以为多个对象指定多个变量。例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a, b, c = 1, 2, &quot;john&quot;</div></pre></td></tr></table></figure>
<p>以上实例，两个整型对象1和2的分配给变量 a 和 b，字符串对象 “john” 分配给变量 c。</p>
<h3 id="标准数据类型"><a href="#标准数据类型" class="headerlink" title="标准数据类型"></a>标准数据类型</h3><p>在内存中存储的数据可以有多种类型。<br>例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。<br>Python 定义了一些标准类型，用于存储各种类型的数据。<br>Python有五个标准的数据类型:</p>
<ul>
<li>Numbers（数字）</li>
<li>String（字符串）</li>
<li>List（列表）</li>
<li>Tuple（元组）</li>
<li>Dictionary（字典）</li>
</ul>
<h3 id="Python数字"><a href="#Python数字" class="headerlink" title="Python数字"></a>Python数字</h3><p>数字数据类型用于存储数值。<br>他们是不可改变的数据类型，这意味着改变数字数据类型会分配一个新的对象。<br>当你指定一个值时，Number对象就会被创建:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">var1 = <span class="number">1</span></div><div class="line">var2 = <span class="number">10</span></div></pre></td></tr></table></figure></p>
<p>您也可以使用del语句删除一些对象的引用。<br>del语句的语法是:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">del var1[,var2[,var3[....,varN]]]]</div></pre></td></tr></table></figure></p>
<p>您可以通过使用del语句删除单个或多个对象的引用。例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">del var</div><div class="line">del var_a, var_b</div></pre></td></tr></table></figure></p>
<p>Python支持四种不同的数字类型:</p>
<ul>
<li>int（有符号整型）</li>
<li>long（长整型[也可以代表八进制和十六进制]）</li>
<li>float（浮点型）</li>
<li>complex（复数）</li>
</ul>
<p>实例<br>一些数值类型的实例:</p>
<table>
<thead>
<tr>
<th>int</th>
<th style="text-align:left">long</th>
<th style="text-align:left">float</th>
<th style="text-align:left">complex</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td style="text-align:left">51924361L</td>
<td style="text-align:left">0.0</td>
<td style="text-align:left">3.14j</td>
</tr>
<tr>
<td>100</td>
<td style="text-align:left">-0x19323L</td>
<td style="text-align:left">15.20</td>
<td style="text-align:left">45.j</td>
</tr>
<tr>
<td>-786</td>
<td style="text-align:left">0122L</td>
<td style="text-align:left">-21.9</td>
<td style="text-align:left">9.322e-36j</td>
</tr>
<tr>
<td>080</td>
<td style="text-align:left">0xDEFABCECBDAECBFBAEl</td>
<td style="text-align:left">32.3e+18</td>
<td style="text-align:left">.876j</td>
</tr>
<tr>
<td>-0490</td>
<td style="text-align:left">535633629843L</td>
<td style="text-align:left">-90.</td>
<td style="text-align:left">-.6545+0J</td>
</tr>
<tr>
<td>-0x260</td>
<td style="text-align:left">-052318172735L</td>
<td style="text-align:left">-32.54e100</td>
<td style="text-align:left">3e+26J</td>
</tr>
<tr>
<td>0x69</td>
<td style="text-align:left">-4721885298529L</td>
<td style="text-align:left">70.2E-12</td>
<td style="text-align:left">4.53e-7j</td>
</tr>
</tbody>
</table>
<ul>
<li>长整型也可以使用小写”L”，但是还是建议您使用大写”L”，避免与数字”1”混淆。Python使用”L”来显示长整型。</li>
<li>Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</li>
</ul>
<h3 id="Python字符串"><a href="#Python字符串" class="headerlink" title="Python字符串"></a>Python字符串</h3><p>字符串或串(String)是由数字、字母、下划线组成的一串字符。<br>一般记为 :<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">s=&quot;a1a2···an&quot;(n&gt;=0)</div></pre></td></tr></table></figure></p>
<p>它是编程语言中表示文本的数据类型。</p>
<p>python的字串列表有2种取值顺序:</p>
<ul>
<li>从左到右索引默认0开始的，最大范围是字符串长度少1</li>
<li>从右到左索引默认-1开始的，最大范围是字符串开头</li>
</ul>
<p>如果你要实现从字符串中获取一段子字符串的话，可以使用变量 [头下标:尾下标]，就可以截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。<br>比如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">s = &apos;ilovepython&apos;</div></pre></td></tr></table></figure></p>
<p>s[1:5]的结果是love。<br>当使用以冒号分隔的字符串，python返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。<br>上面的结果包含了s[1]的值l，而取到的最大范围不包括上边界，就是s[5]的值p。</p>
<p>加号（+）是字符串连接运算符，星号（*）是重复操作。如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">str = <span class="string">'Hello World!'</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> str           <span class="comment"># 输出完整字符串</span></div><div class="line"><span class="keyword">print</span> str[<span class="number">0</span>]        <span class="comment"># 输出字符串中的第一个字符</span></div><div class="line"><span class="keyword">print</span> str[<span class="number">2</span>:<span class="number">5</span>]      <span class="comment"># 输出字符串中第三个至第五个之间的字符串</span></div><div class="line"><span class="keyword">print</span> str[<span class="number">2</span>:]       <span class="comment"># 输出从第三个字符开始的字符串</span></div><div class="line"><span class="keyword">print</span> str * <span class="number">2</span>       <span class="comment"># 输出字符串两次</span></div><div class="line"><span class="keyword">print</span> str + <span class="string">"TEST"</span>  <span class="comment"># 输出连接的字符串</span></div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello World!</div><div class="line">H</div><div class="line">llo</div><div class="line">llo World!</div><div class="line">Hello World!Hello World!</div><div class="line">Hello World!TEST</div></pre></td></tr></table></figure></p>
<h3 id="Python列表"><a href="#Python列表" class="headerlink" title="Python列表"></a>Python列表</h3><p>List（列表） 是 Python 中使用最频繁的数据类型。<br>列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。<br>列表用 [ ] 标识，是 python 最通用的复合数据类型。<br>列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。<br>加号 + 是列表连接运算符，星号 * 是重复操作。如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">list = [ <span class="string">'runoob'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> ]</div><div class="line">tinylist = [<span class="number">123</span>, <span class="string">'john'</span>]</div><div class="line"></div><div class="line"><span class="keyword">print</span> list               <span class="comment"># 输出完整列表</span></div><div class="line"><span class="keyword">print</span> list[<span class="number">0</span>]            <span class="comment"># 输出列表的第一个元素</span></div><div class="line"><span class="keyword">print</span> list[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个的元素</span></div><div class="line"><span class="keyword">print</span> list[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></div><div class="line"><span class="keyword">print</span> tinylist * <span class="number">2</span>       <span class="comment"># 输出列表两次</span></div><div class="line"><span class="keyword">print</span> list + tinylist    <span class="comment"># 打印组合的列表</span></div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2]</div><div class="line">runoob</div><div class="line">[786, 2.23]</div><div class="line">[2.23, &apos;john&apos;, 70.2]</div><div class="line">[123, &apos;john&apos;, 123, &apos;john&apos;]</div><div class="line">[&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2, 123, &apos;john&apos;]</div></pre></td></tr></table></figure></p>
<h3 id="Python元组"><a href="#Python元组" class="headerlink" title="Python元组"></a>Python元组</h3><p>元组是另一个数据类型，类似于List（列表）。<br>元组用”()”标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">tuple = ( <span class="string">'runoob'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> )</div><div class="line">tinytuple = (<span class="number">123</span>, <span class="string">'john'</span>)</div><div class="line"></div><div class="line"><span class="keyword">print</span> tuple               <span class="comment"># 输出完整元组</span></div><div class="line"><span class="keyword">print</span> tuple[<span class="number">0</span>]            <span class="comment"># 输出元组的第一个元素</span></div><div class="line"><span class="keyword">print</span> tuple[<span class="number">1</span>:<span class="number">3</span>]          <span class="comment"># 输出第二个至第三个的元素</span></div><div class="line"><span class="keyword">print</span> tuple[<span class="number">2</span>:]           <span class="comment"># 输出从第三个开始至列表末尾的所有元素</span></div><div class="line"><span class="keyword">print</span> tinytuple * <span class="number">2</span>       <span class="comment"># 输出元组两次</span></div><div class="line"><span class="keyword">print</span> tuple + tinytuple   <span class="comment"># 打印组合的元组</span></div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2)</div><div class="line">runoob</div><div class="line">(786, 2.23)</div><div class="line">(2.23, &apos;john&apos;, 70.2)</div><div class="line">(123, &apos;john&apos;, 123, &apos;john&apos;)</div><div class="line">(&apos;runoob&apos;, 786, 2.23, &apos;john&apos;, 70.2, 123, &apos;john&apos;)</div></pre></td></tr></table></figure></p>
<p>以下是元组无效的，因为元组是不允许更新的。而列表是允许更新的:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">tuple = ( <span class="string">'runoob'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> )</div><div class="line">list = [ <span class="string">'runoob'</span>, <span class="number">786</span> , <span class="number">2.23</span>, <span class="string">'john'</span>, <span class="number">70.2</span> ]</div><div class="line">tuple[<span class="number">2</span>] = <span class="number">1000</span>    <span class="comment"># 元组中是非法应用</span></div><div class="line">list[<span class="number">2</span>] = <span class="number">1000</span>     <span class="comment"># 列表中是合法应用</span></div></pre></td></tr></table></figure></p>
<h3 id="Python-字典"><a href="#Python-字典" class="headerlink" title="Python 字典"></a>Python 字典</h3><p>字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。<br>两者之间的区别在于:字典当中的元素是通过键来存取的，而不是通过偏移存取。</p>
<p>字典用”{ }”标识。字典由索引(key)和它对应的值value组成。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">dict = &#123;&#125;</div><div class="line">dict[<span class="string">'one'</span>] = <span class="string">"This is one"</span></div><div class="line">dict[<span class="number">2</span>] = <span class="string">"This is two"</span></div><div class="line"></div><div class="line">tinydict = &#123;<span class="string">'name'</span>: <span class="string">'john'</span>,<span class="string">'code'</span>:<span class="number">6734</span>, <span class="string">'dept'</span>: <span class="string">'sales'</span>&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">print</span> dict[<span class="string">'one'</span>]          <span class="comment"># 输出键为'one' 的值</span></div><div class="line"><span class="keyword">print</span> dict[<span class="number">2</span>]              <span class="comment"># 输出键为 2 的值</span></div><div class="line"><span class="keyword">print</span> tinydict             <span class="comment"># 输出完整的字典</span></div><div class="line"><span class="keyword">print</span> tinydict.keys()      <span class="comment"># 输出所有键</span></div><div class="line"><span class="keyword">print</span> tinydict.values()    <span class="comment"># 输出所有值</span></div></pre></td></tr></table></figure></p>
<p>输出结果为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">This is one</div><div class="line">This is two</div><div class="line">&#123;&apos;dept&apos;: &apos;sales&apos;, &apos;code&apos;: 6734, &apos;name&apos;: &apos;john&apos;&#125;</div><div class="line">[&apos;dept&apos;, &apos;code&apos;, &apos;name&apos;]</div><div class="line">[&apos;sales&apos;, 6734, &apos;john&apos;]</div></pre></td></tr></table></figure></p>
<h3 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h3><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。<br>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">int(x [,base])</td>
<td style="text-align:left">将x转换为一个整数</td>
</tr>
<tr>
<td style="text-align:left">long(x [,base] )</td>
<td style="text-align:left">将x转换为一个长整数</td>
</tr>
<tr>
<td style="text-align:left">float(x)</td>
<td style="text-align:left">将x转换到一个浮点数</td>
</tr>
<tr>
<td style="text-align:left">complex(real [,imag])</td>
<td style="text-align:left">创建一个复数</td>
</tr>
<tr>
<td style="text-align:left">str(x)</td>
<td style="text-align:left">将对象 x 转换为字符串</td>
</tr>
<tr>
<td style="text-align:left">repr(x)</td>
<td style="text-align:left">将对象 x 转换为表达式字符串</td>
</tr>
<tr>
<td style="text-align:left">eval(str)</td>
<td style="text-align:left">用来计算在字符串中的有效Python表达式,并返回一个对象</td>
</tr>
<tr>
<td style="text-align:left">tuple(s)</td>
<td style="text-align:left">将序列 s 转换为一个元组</td>
</tr>
<tr>
<td style="text-align:left">list(s)</td>
<td style="text-align:left">将序列 s 转换为一个列表</td>
</tr>
<tr>
<td style="text-align:left">set(s)</td>
<td style="text-align:left">转换为可变集合</td>
</tr>
<tr>
<td style="text-align:left">dict(d)</td>
<td style="text-align:left">创建一个字典。d 必须是一个序列 (key,value)元组。</td>
</tr>
<tr>
<td style="text-align:left">frozenset(s)</td>
<td style="text-align:left">转换为不可变集合</td>
</tr>
<tr>
<td style="text-align:left">chr(x)</td>
<td style="text-align:left">将一个整数转换为一个字符</td>
</tr>
<tr>
<td style="text-align:left">unichr(x)</td>
<td style="text-align:left">将一个整数转换为Unicode字符</td>
</tr>
<tr>
<td style="text-align:left">ord(x)</td>
<td style="text-align:left">将一个字符转换为它的整数值</td>
</tr>
<tr>
<td style="text-align:left">hex(x)</td>
<td style="text-align:left">将一个整数转换为一个十六进制字符串</td>
</tr>
<tr>
<td style="text-align:left">oct(x)</td>
<td style="text-align:left">将一个整数转换为一个八进制字符串</td>
</tr>
</tbody>
</table>
<h3 id="python-的所有数据类型都是类-可以通过-type-查看该变量的数据类型"><a href="#python-的所有数据类型都是类-可以通过-type-查看该变量的数据类型" class="headerlink" title="python 的所有数据类型都是类,可以通过 type() 查看该变量的数据类型"></a>python 的所有数据类型都是类,可以通过 type() 查看该变量的数据类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; n=1</div><div class="line">&gt;&gt;&gt; type(n)</div><div class="line">&lt;type &apos;int&apos;&gt;</div><div class="line">&gt;&gt;&gt; n=&quot;runoob&quot;</div><div class="line">&gt;&gt;&gt; type(n)</div><div class="line">&lt;type &apos;str&apos;&gt;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>此外还可以用 isinstance 来判断:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a = 111</div><div class="line">isinstance(a, int)</div><div class="line">True</div></pre></td></tr></table></figure></p>
<p>isinstance 和 type 的区别在于:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; class A:</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; class B(A):</div><div class="line">...     pass</div><div class="line">...</div><div class="line">&gt;&gt;&gt; isinstance(A(), A)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(A()) == A</div><div class="line">False</div><div class="line">&gt;&gt;&gt; isinstance(B(), A)</div><div class="line">True</div><div class="line">&gt;&gt;&gt; type(B()) == A</div><div class="line">False</div></pre></td></tr></table></figure></p>
<p>区别就是:</p>
<ul>
<li>type()不会认为子类是一种父类类型。</li>
<li>isinstance()会认为子类是一种父类类型。</li>
</ul>
<p>ref:<a href="http://www.runoob.com/python/python-variable-types.html" target="_blank" rel="external">http://www.runoob.com/python/python-variable-types.html</a></p>
<h2 id="Python-运算符"><a href="#Python-运算符" class="headerlink" title="Python 运算符"></a>Python 运算符</h2><p>什么是运算符？<br>本章节主要说明Python的运算符。举个简单的例子 4 +5 = 9 。 例子中，4 和 5 被称为操作数，”+” 称为运算符。</p>
<p>Python语言支持以下类型的运算符:</p>
<ul>
<li>算术运算符</li>
<li>比较（关系）运算符</li>
<li>赋值运算符</li>
<li>逻辑运算符</li>
<li>位运算符</li>
<li>成员运算符</li>
<li>身份运算符</li>
<li>运算符优先级</li>
</ul>
<h3 id="Python算术运算符"><a href="#Python算术运算符" class="headerlink" title="Python算术运算符"></a>Python算术运算符</h3><p>以下假设变量: a=10，b=20:</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">加 - 两个对象相加</td>
<td style="text-align:left">a + b 输出结果 30</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">减 - 得到负数或是一个数减去另一个数</td>
<td style="text-align:left">a - b 输出结果 -10</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">乘 - 两个数相乘或是返回一个被重复若干次的字符串</td>
<td style="text-align:left">a * b 输出结果 200</td>
</tr>
<tr>
<td style="text-align:left">/</td>
<td style="text-align:left">除 - x除以y</td>
<td style="text-align:left">b / a 输出结果 2</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">取模 - 返回除法的余数</td>
<td style="text-align:left">b % a 输出结果 0</td>
</tr>
<tr>
<td style="text-align:left">**</td>
<td style="text-align:left">幂 - 返回x的y次幂</td>
<td style="text-align:left">a**b 为10的20次方， 输出结果 100000000000000000000</td>
</tr>
<tr>
<td style="text-align:left">//</td>
<td style="text-align:left">取整除 - 返回商的整数部分</td>
<td style="text-align:left">9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有算术运算符的操作:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">a = <span class="number">21</span></div><div class="line">b = <span class="number">10</span></div><div class="line">c = <span class="number">0</span></div><div class="line"></div><div class="line">c = a + b</div><div class="line"><span class="keyword">print</span> <span class="string">"1 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c = a - b</div><div class="line"><span class="keyword">print</span> <span class="string">"2 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c = a * b</div><div class="line"><span class="keyword">print</span> <span class="string">"3 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c = a / b</div><div class="line"><span class="keyword">print</span> <span class="string">"4 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c = a % b</div><div class="line"><span class="keyword">print</span> <span class="string">"5 - c 的值为:"</span>, c</div><div class="line"></div><div class="line"><span class="comment"># 修改变量 a 、b 、c</span></div><div class="line">a = <span class="number">2</span></div><div class="line">b = <span class="number">3</span></div><div class="line">c = a**b</div><div class="line"><span class="keyword">print</span> <span class="string">"6 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">a = <span class="number">10</span></div><div class="line">b = <span class="number">5</span></div><div class="line">c = a//b</div><div class="line"><span class="keyword">print</span> <span class="string">"7 - c 的值为:"</span>, c</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 - c 的值为: 31</div><div class="line">2 - c 的值为: 11</div><div class="line">3 - c 的值为: 210</div><div class="line">4 - c 的值为: 2</div><div class="line">5 - c 的值为: 1</div><div class="line">6 - c 的值为: 8</div><div class="line">7 - c 的值为: 2</div></pre></td></tr></table></figure></p>
<p>注意:Python2.x 里，整数除整数，只能得出整数。如果要得到小数部分，把其中一个数改成浮点数即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; 1/2</div><div class="line">0</div><div class="line">&gt;&gt;&gt; 1.0/2</div><div class="line">0.5</div><div class="line">&gt;&gt;&gt; 1/float(2)</div><div class="line">0.5</div></pre></td></tr></table></figure></p>
<h3 id="Python比较运算符"><a href="#Python比较运算符" class="headerlink" title="Python比较运算符"></a>Python比较运算符</h3><p>以下假设变量a为10，变量b为20:</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">==</td>
<td style="text-align:left">等于 - 比较对象是否相等</td>
<td style="text-align:left">(a == b) 返回 False。</td>
</tr>
<tr>
<td style="text-align:left">!=</td>
<td style="text-align:left">不等于 - 比较两个对象是否不相等</td>
<td style="text-align:left">(a != b) 返回 true.</td>
</tr>
<tr>
<td style="text-align:left">&lt;&gt;</td>
<td style="text-align:left">不等于 - 比较两个对象是否不相等</td>
<td style="text-align:left">(a &lt;&gt; b) 返回 true。这个运算符类似 != 。</td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于 - 返回x是否大于y</td>
<td style="text-align:left">(a &gt; b) 返回 False。</td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。</td>
<td style="text-align:left">(a &lt; b) 返回 true。</td>
</tr>
<tr>
<td style="text-align:left">>=</td>
<td style="text-align:left">大于等于 - 返回x是否大于等于y。</td>
<td style="text-align:left">(a &gt;= b) 返回 False。</td>
</tr>
<tr>
<td style="text-align:left">&lt;=</td>
<td style="text-align:left">小于等于 - 返回x是否小于等于y。</td>
<td style="text-align:left">(a &lt;= b) 返回 true。</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有比较运算符的操作<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">a = <span class="number">21</span></div><div class="line">b = <span class="number">10</span></div><div class="line">c = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a == b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"1 - a 等于 b"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"1 - a 不等于 b"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a != b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"2 - a 不等于 b"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"2 - a 等于 b"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a &lt;&gt; b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"3 - a 不等于 b"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"3 - a 等于 b"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a &lt; b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"4 - a 小于 b"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"4 - a 大于等于 b"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a &gt; b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"5 - a 大于 b"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"5 - a 小于等于 b"</span></div><div class="line"></div><div class="line"><span class="comment"># 修改变量 a 和 b 的值</span></div><div class="line">a = <span class="number">5</span></div><div class="line">b = <span class="number">20</span></div><div class="line"><span class="keyword">if</span> ( a &lt;= b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"6 - a 小于等于 b"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"6 - a 大于  b"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( b &gt;= a ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"7 - b 大于等于 a"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"7 - b 小于 a"</span></div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 - a 不等于 b</div><div class="line">2 - a 不等于 b</div><div class="line">3 - a 不等于 b</div><div class="line">4 - a 大于等于 b</div><div class="line">5 - a 大于 b</div><div class="line">6 - a 小于等于 b</div><div class="line">7 - b 大于等于 a</div></pre></td></tr></table></figure></p>
<h3 id="Python赋值运算符"><a href="#Python赋值运算符" class="headerlink" title="Python赋值运算符"></a>Python赋值运算符</h3><p>以下假设变量a为10，变量b为20:</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">=</td>
<td style="text-align:left">简单的赋值运算符</td>
<td style="text-align:left">c = a + b 将 a + b 的运算结果赋值为 c</td>
</tr>
<tr>
<td style="text-align:left">+=</td>
<td style="text-align:left">加法赋值运算符</td>
<td style="text-align:left">c += a 等效于 c = c + a</td>
</tr>
<tr>
<td style="text-align:left">-=</td>
<td style="text-align:left">减法赋值运算符</td>
<td style="text-align:left">c -= a 等效于 c = c - a</td>
</tr>
<tr>
<td style="text-align:left">*=</td>
<td style="text-align:left">乘法赋值运算符</td>
<td style="text-align:left">c <em>= a 等效于 c = c </em> a</td>
</tr>
<tr>
<td style="text-align:left">/=</td>
<td style="text-align:left">除法赋值运算符</td>
<td style="text-align:left">c /= a 等效于 c = c / a</td>
</tr>
<tr>
<td style="text-align:left">%=</td>
<td style="text-align:left">取模赋值运算符</td>
<td style="text-align:left">c %= a 等效于 c = c % a</td>
</tr>
<tr>
<td style="text-align:left">**=</td>
<td style="text-align:left">幂赋值运算符</td>
<td style="text-align:left">c <strong>= a 等效于 c = c </strong> a</td>
</tr>
<tr>
<td style="text-align:left">//=</td>
<td style="text-align:left">取整除赋值运算符</td>
<td style="text-align:left">c //= a 等效于 c = c // a</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有赋值运算符的操作:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">a = <span class="number">21</span></div><div class="line">b = <span class="number">10</span></div><div class="line">c = <span class="number">0</span></div><div class="line"></div><div class="line">c = a + b</div><div class="line"><span class="keyword">print</span> <span class="string">"1 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c += a</div><div class="line"><span class="keyword">print</span> <span class="string">"2 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c *= a</div><div class="line"><span class="keyword">print</span> <span class="string">"3 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c /= a</div><div class="line"><span class="keyword">print</span> <span class="string">"4 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c = <span class="number">2</span></div><div class="line">c %= a</div><div class="line"><span class="keyword">print</span> <span class="string">"5 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c **= a</div><div class="line"><span class="keyword">print</span> <span class="string">"6 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c //= a</div><div class="line"><span class="keyword">print</span> <span class="string">"7 - c 的值为:"</span>, c</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 - c 的值为: 31</div><div class="line">2 - c 的值为: 52</div><div class="line">3 - c 的值为: 1092</div><div class="line">4 - c 的值为: 52</div><div class="line">5 - c 的值为: 2</div><div class="line">6 - c 的值为: 2097152</div><div class="line">7 - c 的值为: 99864</div></pre></td></tr></table></figure></p>
<h3 id="Python位运算符"><a href="#Python位运算符" class="headerlink" title="Python位运算符"></a>Python位运算符</h3><p>按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下:<br>下表中变量 a 为 60，b 为 13，二进制格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a = 0011 1100</div><div class="line"></div><div class="line">b = 0000 1101</div><div class="line"></div><div class="line">-----------------</div><div class="line"></div><div class="line">a&amp;b = 0000 1100</div><div class="line"></div><div class="line">a|b = 0011 1101</div><div class="line"></div><div class="line">a^b = 0011 0001</div><div class="line"></div><div class="line">~a  = 1100 0011</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:right">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td style="text-align:right">按位与运算符:参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td>
<td style="text-align:center">(a &amp; b) 输出结果 12 ，二进制解释: 0000 1100</td>
</tr>
<tr>
<td>\</td>
<td style="text-align:right"></td>
<td style="text-align:center">按位或运算符:只要对应的二个二进位有一个为1时，结果位就为1。</td>
<td>(a \</td>
<td>b) 输出结果 61 ，二进制解释: 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td style="text-align:right">按位异或运算符:当两对应的二进位相异时，结果为1</td>
<td style="text-align:center">(a ^ b) 输出结果 49 ，二进制解释: 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td style="text-align:right">按位取反运算符:对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1  (~a ) 输出结果 -61 ，二进制解释: 1100</td>
<td style="text-align:center">0011，在一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td style="text-align:right">左移动运算符:运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。</td>
<td style="text-align:center">a &lt;&lt; 2 输出结果 240 ，二进制解释: 1111 0000</td>
</tr>
<tr>
<td>>&gt;</td>
<td style="text-align:right">右移动运算符:把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数</td>
<td style="text-align:center">a &gt;&gt; 2 输出结果 15 ，二进制解释: 0000 1111</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有位运算符的操作:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">a = <span class="number">60</span>            <span class="comment"># 60 = 0011 1100</span></div><div class="line">b = <span class="number">13</span>            <span class="comment"># 13 = 0000 1101</span></div><div class="line">c = <span class="number">0</span></div><div class="line"></div><div class="line">c = a &amp; b;        <span class="comment"># 12 = 0000 1100</span></div><div class="line"><span class="keyword">print</span> <span class="string">"1 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c = a | b;        <span class="comment"># 61 = 0011 1101</span></div><div class="line"><span class="keyword">print</span> <span class="string">"2 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c = a ^ b;        <span class="comment"># 49 = 0011 0001</span></div><div class="line"><span class="keyword">print</span> <span class="string">"3 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c = ~a;           <span class="comment"># -61 = 1100 0011</span></div><div class="line"><span class="keyword">print</span> <span class="string">"4 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c = a &lt;&lt; <span class="number">2</span>;       <span class="comment"># 240 = 1111 0000</span></div><div class="line"><span class="keyword">print</span> <span class="string">"5 - c 的值为:"</span>, c</div><div class="line"></div><div class="line">c = a &gt;&gt; <span class="number">2</span>;       <span class="comment"># 15 = 0000 1111</span></div><div class="line"><span class="keyword">print</span> <span class="string">"6 - c 的值为:"</span>, c</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 - c 的值为: 12</div><div class="line">2 - c 的值为: 61</div><div class="line">3 - c 的值为: 49</div><div class="line">4 - c 的值为: -61</div><div class="line">5 - c 的值为: 240</div><div class="line">6 - c 的值为: 15</div></pre></td></tr></table></figure></p>
<h3 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h3><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:right">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>and</td>
<td style="text-align:right">x and y    布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td>
<td style="text-align:center">(a and b) 返回 20。</td>
</tr>
<tr>
<td>or</td>
<td style="text-align:right">x or y 布尔”或” - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。</td>
<td style="text-align:center">(a or b) 返回 10。</td>
</tr>
<tr>
<td>not</td>
<td style="text-align:right">not x  布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td>
<td style="text-align:center">not(a and b) 返回 False</td>
</tr>
</tbody>
</table>
<p>以上实例输出结果:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">a = <span class="number">10</span></div><div class="line">b = <span class="number">20</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a <span class="keyword">and</span> b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"1 - 变量 a 和 b 都为 true"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"1 - 变量 a 和 b 有一个不为 true"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a <span class="keyword">or</span> b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"2 - 变量 a 和 b 都为 true，或其中一个变量为 true"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"2 - 变量 a 和 b 都不为 true"</span></div><div class="line"></div><div class="line"><span class="comment"># 修改变量 a 的值</span></div><div class="line">a = <span class="number">0</span></div><div class="line"><span class="keyword">if</span> ( a <span class="keyword">and</span> b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"3 - 变量 a 和 b 都为 true"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"3 - 变量 a 和 b 有一个不为 true"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a <span class="keyword">or</span> b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"4 - 变量 a 和 b 都为 true，或其中一个变量为 true"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"4 - 变量 a 和 b 都不为 true"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">not</span>( a <span class="keyword">and</span> b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"5 - 变量 a 和 b 都为 false，或其中一个变量为 false"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"5 - 变量 a 和 b 都为 true"</span></div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 - 变量 a 和 b 都为 true</div><div class="line">2 - 变量 a 和 b 都为 true，或其中一个变量为 true</div><div class="line">3 - 变量 a 和 b 有一个不为 true</div><div class="line">4 - 变量 a 和 b 都为 true，或其中一个变量为 true</div></pre></td></tr></table></figure></p>
<h3 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h3><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:right">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>in</td>
<td style="text-align:right">如果在指定的序列中找到值返回 True，否则返回 False。</td>
<td style="text-align:center">x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td>
</tr>
<tr>
<td>not in</td>
<td style="text-align:right">如果在指定的序列中没有找到值返回 True，否则返回 False。</td>
<td style="text-align:center">x 不在 y 序列中 , 如果 x 不在 y 序</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有成员运算符的操作:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">a = <span class="number">10</span></div><div class="line">b = <span class="number">20</span></div><div class="line">list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> ];</div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> list ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"1 - 变量 a 在给定的列表中 list 中"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"1 - 变量 a 不在给定的列表中 list 中"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( b <span class="keyword">not</span> <span class="keyword">in</span> list ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"2 - 变量 b 不在给定的列表中 list 中"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"2 - 变量 b 在给定的列表中 list 中"</span></div><div class="line"></div><div class="line"><span class="comment"># 修改变量 a 的值</span></div><div class="line">a = <span class="number">2</span></div><div class="line"><span class="keyword">if</span> ( a <span class="keyword">in</span> list ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"3 - 变量 a 在给定的列表中 list 中"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"3 - 变量 a 不在给定的列表中 list 中"</span></div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 - 变量 a 不在给定的列表中 list 中</div><div class="line">2 - 变量 b 不在给定的列表中 list 中</div><div class="line">3 - 变量 a 在给定的列表中 list 中</div></pre></td></tr></table></figure></p>
<h3 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h3><p>身份运算符用于比较两个对象的存储单元</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:right">描述</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>is</td>
<td style="text-align:right">is 是判断两个标识符是不是引用自一个对象</td>
<td style="text-align:center">x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False</td>
</tr>
<tr>
<td>is not</td>
<td style="text-align:right">is not 是判断两个标识符是不是引用自不同对象</td>
<td style="text-align:center">x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td>
</tr>
</tbody>
</table>
<p>注: id() 函数用于获取对象内存地址。</p>
<p>以下实例演示了Python所有身份运算符的操作:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">a = <span class="number">20</span></div><div class="line">b = <span class="number">20</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"1 - a 和 b 有相同的标识"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"1 - a 和 b 没有相同的标识"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> <span class="keyword">not</span> b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"2 - a 和 b 没有相同的标识"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"2 - a 和 b 有相同的标识"</span></div><div class="line"></div><div class="line"><span class="comment"># 修改变量 b 的值</span></div><div class="line">b = <span class="number">30</span></div><div class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"3 - a 和 b 有相同的标识"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"3 - a 和 b 没有相同的标识"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> ( a <span class="keyword">is</span> <span class="keyword">not</span> b ):</div><div class="line">   <span class="keyword">print</span> <span class="string">"4 - a 和 b 没有相同的标识"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> <span class="string">"4 - a 和 b 有相同的标识"</span></div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">1 - a 和 b 有相同的标识</div><div class="line">2 - a 和 b 有相同的标识</div><div class="line">3 - a 和 b 没有相同的标识</div><div class="line">4 - a 和 b 没有相同的标识</div></pre></td></tr></table></figure></p>
<p>is 与 == 区别:<br>is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; a = [1, 2, 3]</div><div class="line">&gt;&gt;&gt; b = a</div><div class="line">&gt;&gt;&gt; b is a</div><div class="line">True</div><div class="line">&gt;&gt;&gt; b == a</div><div class="line">True</div><div class="line">&gt;&gt;&gt; b = a[:]</div><div class="line">&gt;&gt;&gt; b is a</div><div class="line">False</div><div class="line">&gt;&gt;&gt; b == a</div><div class="line">True</div></pre></td></tr></table></figure></p>
<h3 id="Python运算符优先级"><a href="#Python运算符优先级" class="headerlink" title="Python运算符优先级"></a>Python运算符优先级</h3><p>以下表格列出了从最高到最低优先级的所有运算符:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>**</td>
<td style="text-align:center">指数 (最高优先级)</td>
</tr>
<tr>
<td>~ + -</td>
<td style="text-align:center">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)</td>
</tr>
<tr>
<td>* / % //</td>
<td style="text-align:center">乘，除，取模和取整除</td>
</tr>
<tr>
<td>+ -</td>
<td style="text-align:center">加法减法</td>
</tr>
<tr>
<td>>&gt; &lt;&lt;</td>
<td style="text-align:center">右移，左移运算符</td>
</tr>
<tr>
<td>&amp;</td>
<td style="text-align:center">位 ‘AND’</td>
</tr>
<tr>
<td>^ \</td>
<td style="text-align:center"></td>
<td>位运算符</td>
</tr>
<tr>
<td>&lt;= &lt; &gt; &gt;=</td>
<td style="text-align:center">比较运算符</td>
</tr>
<tr>
<td>&lt;&gt; == !=</td>
<td style="text-align:center">等于运算符</td>
</tr>
<tr>
<td>= %= /= //= -= += <em>= *</em>=</td>
<td style="text-align:center">赋值运算符</td>
</tr>
<tr>
<td>is is not</td>
<td style="text-align:center">身份运算符</td>
</tr>
<tr>
<td>in not in</td>
<td style="text-align:center">成员运算符</td>
</tr>
<tr>
<td>not or and</td>
<td style="text-align:center">逻辑运算符</td>
</tr>
</tbody>
</table>
<p>以下实例演示了Python所有运算符优先级的操作:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">a = <span class="number">20</span></div><div class="line">b = <span class="number">10</span></div><div class="line">c = <span class="number">15</span></div><div class="line">d = <span class="number">5</span></div><div class="line">e = <span class="number">0</span></div><div class="line"></div><div class="line">e = (a + b) * c / d       <span class="comment">#( 30 * 15 ) / 5</span></div><div class="line"><span class="keyword">print</span> <span class="string">"(a + b) * c / d 运算结果为:"</span>,  e</div><div class="line"></div><div class="line">e = ((a + b) * c) / d     <span class="comment"># (30 * 15 ) / 5</span></div><div class="line"><span class="keyword">print</span> <span class="string">"((a + b) * c) / d 运算结果为:"</span>,  e</div><div class="line"></div><div class="line">e = (a + b) * (c / d);    <span class="comment"># (30) * (15/5)</span></div><div class="line"><span class="keyword">print</span> <span class="string">"(a + b) * (c / d) 运算结果为:"</span>,  e</div><div class="line"></div><div class="line">e = a + (b * c) / d;      <span class="comment">#  20 + (150/5)</span></div><div class="line"><span class="keyword">print</span> <span class="string">"a + (b * c) / d 运算结果为:"</span>,  e</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(a + b) * c / d 运算结果为: 90</div><div class="line">((a + b) * c) / d 运算结果为: 90</div><div class="line">(a + b) * (c / d) 运算结果为: 90</div><div class="line">a + (b * c) / d 运算结果为: 50</div></pre></td></tr></table></figure></p>
<p>ref: <a href="http://www.runoob.com/python/python-operators.html" target="_blank" rel="external">http://www.runoob.com/python/python-operators.html</a></p>
<h2 id="Python-条件语句"><a href="#Python-条件语句" class="headerlink" title="Python 条件语句"></a>Python 条件语句</h2><p>Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false。<br>Python 编程中 if 语句用于控制程序的执行，基本形式为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if 判断条件:</div><div class="line">    执行语句……</div><div class="line">else:</div><div class="line">    执行语句……</div></pre></td></tr></table></figure></p>
<p>其中”判断条件”成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。 else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句<br>if 语句的判断条件可以用&gt;（大于）、&lt;(小于)、==（等于）、&gt;=（大于等于）、&lt;=（小于等于）来表示其关系。</p>
<p>当判断条件为多个值时，可以使用以下形式:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if 判断条件1:</div><div class="line">    执行语句1……</div><div class="line">elif 判断条件2:</div><div class="line">    执行语句2……</div><div class="line">elif 判断条件3:</div><div class="line">    执行语句3……</div><div class="line">else:</div><div class="line">    执行语句4……</div></pre></td></tr></table></figure></p>
<p>由于 python 并不支持 switch 语句，所以多个条件判断，只能用 elif 来实现，如果判断需要多个条件需同时判断时，可以使用 or （或），表示两个条件有一个成立时判断条件成功；使用 and （与）时，表示只有两个条件同时成立的情况下，判断条件才成功。<br>当if有多个条件时可使用括号来区分判断的先后顺序，括号中的判断优先执行，此外 and 和 or 的优先级低于&gt;（大于）、&lt;（小于）等判断符号，即大于和小于在没有括号的情况下会比与或要优先判断。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 判断值是否在0~5或者10~15之间</span></div><div class="line"><span class="keyword">if</span> (num &gt;= <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">5</span>) <span class="keyword">or</span> (num &gt;= <span class="number">10</span> <span class="keyword">and</span> num &lt;= <span class="number">15</span>):</div><div class="line">    <span class="keyword">print</span> <span class="string">'hello'</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'undefine'</span></div></pre></td></tr></table></figure></p>
<p>你也可以在同一行的位置上使用if条件判断语句，如下实例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if ( var  == 100 ) : print &quot;变量 var 的值为100&quot;</div></pre></td></tr></table></figure></p>
<h2 id="Python-循环语句"><a href="#Python-循环语句" class="headerlink" title="Python 循环语句"></a>Python 循环语句</h2><p>Python提供了for循环和while循环（在Python中没有do..while循环）:</p>
<table>
<thead>
<tr>
<th>循环类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>while 循环</td>
<td style="text-align:center">在给定的判断条件为 true 时执行循环体，否则退出循环体。</td>
</tr>
<tr>
<td>for 循环</td>
<td style="text-align:center">重复执行语句</td>
</tr>
<tr>
<td>嵌套循环</td>
<td style="text-align:center">你可以在while循环体中嵌套for循环</td>
</tr>
</tbody>
</table>
<p>循环控制语句可以更改语句执行的顺序。Python支持以下循环控制语句:</p>
<table>
<thead>
<tr>
<th>控制语句</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>break 语句</td>
<td style="text-align:center">在语句块执行过程中终止循环，并且跳出整个循环</td>
</tr>
<tr>
<td>continue 语句</td>
<td style="text-align:center">在语句块执行过程中终止当前循环，跳出该次循环，执行下一次循环。</td>
</tr>
<tr>
<td>pass 语句</td>
<td style="text-align:center">pass是空语句，是为了保持程序结构的完整性。</td>
</tr>
</tbody>
</table>
<h3 id="Python-While-循环语句"><a href="#Python-While-循环语句" class="headerlink" title="Python While 循环语句"></a>Python While 循环语句</h3><p>Python 编程中 while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">while 判断条件:</div><div class="line">    执行语句……</div></pre></td></tr></table></figure></p>
<p>执行语句可以是单个语句或语句块。判断条件可以是任何表达式，任何非零、或非空（null）的值均为true。 当判断条件假false时，循环结束。<br>实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">count = <span class="number">0</span></div><div class="line"><span class="keyword">while</span> (count &lt; <span class="number">9</span>):</div><div class="line">   <span class="keyword">print</span> <span class="string">'The count is:'</span>, count</div><div class="line">   count = count + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Good bye!"</span></div></pre></td></tr></table></figure></p>
<p>while 语句时还有另外两个重要的命令 continue，break 来跳过循环，continue 用于跳过该次循环，break 则是用于退出循环，此外”判断条件”还可以是个常值，表示循环必定成立，具体用法如下:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment"># continue 和 break 用法</span></div><div class="line"></div><div class="line">i = <span class="number">1</span></div><div class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</div><div class="line">    i += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> i%<span class="number">2</span> &gt; <span class="number">0</span>:     <span class="comment"># 非双数时跳过输出</span></div><div class="line">        <span class="keyword">continue</span></div><div class="line">    <span class="keyword">print</span> i         <span class="comment"># 输出双数2、4、6、8、10</span></div><div class="line"></div><div class="line">i = <span class="number">1</span></div><div class="line"><span class="keyword">while</span> <span class="number">1</span>:            <span class="comment"># 循环条件为1必定成立</span></div><div class="line">    <span class="keyword">print</span> i         <span class="comment"># 输出1~10</span></div><div class="line">    i += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span>:     <span class="comment"># 当i大于10时跳出循环</span></div><div class="line">        <span class="keyword">break</span></div></pre></td></tr></table></figure></p>
<p>循环使用 else 语句<br>在 python 中，while … else 在循环条件为 false 时执行 else 语句块:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">count = <span class="number">0</span></div><div class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</div><div class="line">   <span class="keyword">print</span> count, <span class="string">" is  less than 5"</span></div><div class="line">   count = count + <span class="number">1</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">   <span class="keyword">print</span> count, <span class="string">" is not less than 5"</span></div></pre></td></tr></table></figure></p>
<p>简单语句组<br>类似 if 语句的语法，如果你的 while 循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">flag = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">while</span> (flag): <span class="keyword">print</span> <span class="string">'Given flag is really true!'</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Good bye!"</span></div></pre></td></tr></table></figure></p>
<p>ref: <a href="http://www.runoob.com/python/python-while-loop.html" target="_blank" rel="external">http://www.runoob.com/python/python-while-loop.html</a></p>
<h3 id="Python-for-循环语句"><a href="#Python-for-循环语句" class="headerlink" title="Python for 循环语句"></a>Python for 循环语句</h3><p>Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。<br>for循环的语法格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for iterating_var in sequence:</div><div class="line">   statements(s)</div></pre></td></tr></table></figure></p>
<p>实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Python'</span>:     <span class="comment"># 第一个实例</span></div><div class="line">   <span class="keyword">print</span> <span class="string">'当前字母 :'</span>, letter</div><div class="line"></div><div class="line">fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>,  <span class="string">'mango'</span>]</div><div class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:        <span class="comment"># 第二个实例</span></div><div class="line">   <span class="keyword">print</span> <span class="string">'当前水果 :'</span>, fruit</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Good bye!"</span></div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">当前字母 : P</div><div class="line">当前字母 : y</div><div class="line">当前字母 : t</div><div class="line">当前字母 : h</div><div class="line">当前字母 : o</div><div class="line">当前字母 : n</div><div class="line">当前水果 : banana</div><div class="line">当前水果 : apple</div><div class="line">当前水果 : mango</div><div class="line">Good bye!</div></pre></td></tr></table></figure></p>
<p>通过序列索引迭代<br>另外一种执行循环的遍历方式是通过索引，如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">fruits = [<span class="string">'banana'</span>, <span class="string">'apple'</span>,  <span class="string">'mango'</span>]</div><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(len(fruits)):</div><div class="line">   <span class="keyword">print</span> <span class="string">'当前水果 :'</span>, fruits[index]</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Good bye!"</span></div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">当前水果 : banana</div><div class="line">当前水果 : apple</div><div class="line">当前水果 : mango</div><div class="line">Good bye!</div></pre></td></tr></table></figure></p>
<p>以上实例我们使用了内置函数 len() 和 range(),函数 len() 返回列表的长度，即元素的个数。 range返回一个序列的数。</p>
<p>循环使用 else 语句<br>在 python 中，for … else 表示这样的意思，for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完（即 for 不是通过 break 跳出而中断的）的情况下执行，while … else 也是一样。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">10</span>,<span class="number">20</span>):  <span class="comment"># 迭代 10 到 20 之间的数字</span></div><div class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,num): <span class="comment"># 根据因子迭代</span></div><div class="line">      <span class="keyword">if</span> num%i == <span class="number">0</span>:      <span class="comment"># 确定第一个因子</span></div><div class="line">         j=num/i          <span class="comment"># 计算第二个因子</span></div><div class="line">         <span class="keyword">print</span> <span class="string">'%d 等于 %d * %d'</span> % (num,i,j)</div><div class="line">         <span class="keyword">break</span>            <span class="comment"># 跳出当前循环</span></div><div class="line">   <span class="keyword">else</span>:                  <span class="comment"># 循环的 else 部分</span></div><div class="line">      <span class="keyword">print</span> num, <span class="string">'是一个质数'</span></div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">10 等于 2 * 5</div><div class="line">11 是一个质数</div><div class="line">12 等于 2 * 6</div><div class="line">13 是一个质数</div><div class="line">14 等于 2 * 7</div><div class="line">15 等于 3 * 5</div><div class="line">16 等于 2 * 8</div><div class="line">17 是一个质数</div><div class="line">18 等于 2 * 9</div><div class="line">19 是一个质数</div></pre></td></tr></table></figure></p>
<p>使用内置 enumerate 函数进行遍历:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> index, item <span class="keyword">in</span> enumerate(sequence):</div><div class="line">    process(index, item)</div></pre></td></tr></table></figure></p>
<p>实例<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; sequence = [12, 34, 34, 23, 45, 76, 89]</div><div class="line">&gt;&gt;&gt; for i, j in enumerate(sequence):</div><div class="line">...     print i,j</div><div class="line">...</div><div class="line">0 12</div><div class="line">1 34</div><div class="line">2 34</div><div class="line">3 23</div><div class="line">4 45</div><div class="line">5 76</div><div class="line">6 89</div></pre></td></tr></table></figure></p>
<h3 id="Python-循环嵌套"><a href="#Python-循环嵌套" class="headerlink" title="Python 循环嵌套"></a>Python 循环嵌套</h3><p>Python 语言允许在一个循环体里面嵌入另一个循环。<br>Python for 循环嵌套语法:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> iterating_var <span class="keyword">in</span> sequence:</div><div class="line">   <span class="keyword">for</span> iterating_var <span class="keyword">in</span> sequence:</div><div class="line">      statements(s)</div><div class="line">   statements(s)</div></pre></td></tr></table></figure></p>
<p>Python while 循环嵌套语法:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">while</span> expression:</div><div class="line">   <span class="keyword">while</span> expression:</div><div class="line">      statement(s)</div><div class="line">   statement(s)</div></pre></td></tr></table></figure></p>
<p>你可以在循环体内嵌入其他的循环体，如在while循环中可以嵌入for循环， 反之，你可以在for循环中嵌入while循环。</p>
<h2 id="Python-pass-语句"><a href="#Python-pass-语句" class="headerlink" title="Python pass 语句"></a>Python pass 语句</h2><p>Python pass是空语句，是为了保持程序结构的完整性。<br>pass 不做任何事情，一般用做占位语句。</p>
<p>实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 输出 Python 的每个字母</span></div><div class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">'Python'</span>:</div><div class="line">   <span class="keyword">if</span> letter == <span class="string">'h'</span>:</div><div class="line">      <span class="keyword">pass</span></div><div class="line">      <span class="keyword">print</span> <span class="string">'这是 pass 块'</span></div><div class="line">   <span class="keyword">print</span> <span class="string">'当前字母 :'</span>, letter</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Good bye!"</span></div></pre></td></tr></table></figure></p>
<p>以上实例执行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">当前字母 : P</div><div class="line">当前字母 : y</div><div class="line">当前字母 : t</div><div class="line">这是 pass 块</div><div class="line">当前字母 : h</div><div class="line">当前字母 : o</div><div class="line">当前字母 : n</div><div class="line">Good bye!</div></pre></td></tr></table></figure></p>
<h2 id="Python-Number-数字"><a href="#Python-Number-数字" class="headerlink" title="Python Number(数字)"></a>Python Number(数字)</h2><p>Python Number 数据类型用于存储数值。<br>数据类型是不允许改变的,这就意味着如果改变 Number 数据类型的值，将重新分配内存空间。</p>
<p>以下实例在变量赋值时 Number 对象将被创建:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var1 = 1</div><div class="line">var2 = 10</div></pre></td></tr></table></figure></p>
<p>您也可以使用del语句删除一些 Number 对象引用。<br>del语句的语法是:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">del var1[,var2[,var3[....,varN]]]]</div></pre></td></tr></table></figure></p>
<p>您可以通过使用del语句删除单个或多个对象，例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">del var</div><div class="line">del var_a, var_b</div></pre></td></tr></table></figure></p>
<p>Python 支持四种不同的数值类型:</p>
<ul>
<li>整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。</li>
<li>长整型(long integers) - 无限大小的整数，整数最后是一个大写或小写的L。</li>
<li>浮点型(floating point real values) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</li>
<li>复数(complex numbers) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li>
</ul>
<table>
<thead>
<tr>
<th>int</th>
<th style="text-align:right">long</th>
<th style="text-align:right">float</th>
<th style="text-align:center">complex</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td style="text-align:right">51924361L</td>
<td style="text-align:right">0.0</td>
<td style="text-align:center">3.14j</td>
</tr>
<tr>
<td>100</td>
<td style="text-align:right">-0x19323L</td>
<td style="text-align:right">15.20</td>
<td style="text-align:center">45.j</td>
</tr>
<tr>
<td>-786</td>
<td style="text-align:right">0122L</td>
<td style="text-align:right">-21.9</td>
<td style="text-align:center">9.322e-36j</td>
</tr>
<tr>
<td>080</td>
<td style="text-align:right">0xDEFABCECBDAECBFBAEl</td>
<td style="text-align:right">32.3+e18</td>
<td style="text-align:center">.876j</td>
</tr>
<tr>
<td>-0490</td>
<td style="text-align:right">535633629843L</td>
<td style="text-align:right">-90.</td>
<td style="text-align:center">-.6545+0J</td>
</tr>
<tr>
<td>-0x260</td>
<td style="text-align:right">-052318172735L</td>
<td style="text-align:right">-32.54e100</td>
<td style="text-align:center">3e+26J</td>
</tr>
<tr>
<td>0x69</td>
<td style="text-align:right">-4721885298529L</td>
<td style="text-align:right">70.2-E12</td>
<td style="text-align:center">4.53e-7j</td>
</tr>
</tbody>
</table>
<ul>
<li>长整型也可以使用小写”L”，但是还是建议您使用大写”L”，避免与数字”1”混淆。Python使用”L”来显示长整型。</li>
<li>Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</li>
</ul>
<h3 id="Python-Number-类型转换"><a href="#Python-Number-类型转换" class="headerlink" title="Python Number 类型转换"></a>Python Number 类型转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">int(x [,base ])         将x转换为一个整数</div><div class="line">long(x [,base ])        将x转换为一个长整数</div><div class="line">float(x )               将x转换到一个浮点数</div><div class="line">complex(real [,imag ])  创建一个复数</div><div class="line">str(x )                 将对象 x 转换为字符串</div><div class="line">repr(x )                将对象 x 转换为表达式字符串</div><div class="line">eval(str )              用来计算在字符串中的有效Python表达式,并返回一个对象</div><div class="line">tuple(s )               将序列 s 转换为一个元组</div><div class="line">list(s )                将序列 s 转换为一个列表</div><div class="line">chr(x )                 将一个整数转换为一个字符</div><div class="line">unichr(x )              将一个整数转换为Unicode字符</div><div class="line">ord(x )                 将一个字符转换为它的整数值</div><div class="line">hex(x )                 将一个整数转换为一个十六进制字符串</div><div class="line">oct(x )                 将一个整数转换为一个八进制字符串</div></pre></td></tr></table></figure>
<h3 id="Python数学函数"><a href="#Python数学函数" class="headerlink" title="Python数学函数"></a>Python数学函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:center">返回值 ( 描述 )</th>
</tr>
</thead>
<tbody>
<tr>
<td>abs(x)</td>
<td style="text-align:center">返回数字的绝对值，如abs(-10) 返回 10</td>
</tr>
<tr>
<td>ceil(x)</td>
<td style="text-align:center">返回数字的上入整数，如math.ceil(4.1) 返回 5</td>
</tr>
<tr>
<td>cmp(x, y)</td>
<td style="text-align:center">如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1</td>
</tr>
<tr>
<td>exp(x)</td>
<td style="text-align:center">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td>
</tr>
<tr>
<td>fabs(x)</td>
<td style="text-align:center">返回数字的绝对值，如math.fabs(-10) 返回10.0</td>
</tr>
<tr>
<td>floor(x)</td>
<td style="text-align:center">返回数字的下舍整数，如math.floor(4.9)返回 4</td>
</tr>
<tr>
<td>log(x)</td>
<td style="text-align:center">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td>
</tr>
<tr>
<td>log10(x)</td>
<td style="text-align:center">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td>
</tr>
<tr>
<td>max(x1, x2,…)</td>
<td style="text-align:center">返回给定参数的最大值，参数可以为序列。</td>
</tr>
<tr>
<td>min(x1, x2,…)</td>
<td style="text-align:center">返回给定参数的最小值，参数可以为序列。</td>
</tr>
<tr>
<td>modf(x)</td>
<td style="text-align:center">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td>
</tr>
<tr>
<td>pow(x, y)</td>
<td style="text-align:center">x**y 运算后的值。</td>
</tr>
<tr>
<td>round(x [,n])</td>
<td style="text-align:center">返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td>
</tr>
<tr>
<td>sqrt(x)</td>
<td style="text-align:center">返回数字x的平方根</td>
</tr>
</tbody>
</table>
<h3 id="Python随机数函数"><a href="#Python随机数函数" class="headerlink" title="Python随机数函数"></a>Python随机数函数</h3><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。<br>Python包含以下常用随机数函数:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>choice(seq)</td>
<td style="text-align:center">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td>
</tr>
<tr>
<td>randrange ([start,] stop [,step])</td>
<td style="text-align:center">从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1</td>
</tr>
<tr>
<td>random()</td>
<td style="text-align:center">随机生成下一个实数，它在[0,1)范围内。</td>
</tr>
<tr>
<td>seed([x])</td>
<td style="text-align:center">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td>
</tr>
<tr>
<td>shuffle(lst)</td>
<td style="text-align:center">将序列的所有元素随机排序</td>
</tr>
<tr>
<td>uniform(x, y)</td>
<td style="text-align:center">随机生成下一个实数，它在[x,y]范围内。</td>
</tr>
</tbody>
</table>
<h3 id="Python三角函数"><a href="#Python三角函数" class="headerlink" title="Python三角函数"></a>Python三角函数</h3><p>Python包括以下三角函数:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>acos(x)</td>
<td style="text-align:center">返回x的反余弦弧度值。</td>
</tr>
<tr>
<td>asin(x)</td>
<td style="text-align:center">返回x的反正弦弧度值。</td>
</tr>
<tr>
<td>atan(x)</td>
<td style="text-align:center">返回x的反正切弧度值。</td>
</tr>
<tr>
<td>atan2(y, x)</td>
<td style="text-align:center">返回给定的 X 及 Y 坐标值的反正切值。</td>
</tr>
<tr>
<td>cos(x)</td>
<td style="text-align:center">返回x的弧度的余弦值。</td>
</tr>
<tr>
<td>hypot(x, y)</td>
<td style="text-align:center">返回欧几里德范数 sqrt(x<em>x + y</em>y)。</td>
</tr>
<tr>
<td>sin(x)</td>
<td style="text-align:center">返回的x弧度的正弦值。</td>
</tr>
<tr>
<td>tan(x)</td>
<td style="text-align:center">返回x弧度的正切值。</td>
</tr>
<tr>
<td>degrees(x)</td>
<td style="text-align:center">将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0</td>
</tr>
<tr>
<td>radians(x)</td>
<td style="text-align:center">将角度转换为弧度</td>
</tr>
</tbody>
</table>
<h3 id="Python数学常量"><a href="#Python数学常量" class="headerlink" title="Python数学常量"></a>Python数学常量</h3><table>
<thead>
<tr>
<th>常量</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pi</td>
<td style="text-align:center">数学常量 pi（圆周率，一般以π来表示）</td>
</tr>
<tr>
<td>e</td>
<td style="text-align:center">数学常量 e，e即自然常数（自然常数）。</td>
</tr>
</tbody>
</table>
<h3 id="range-函数"><a href="#range-函数" class="headerlink" title="range()函数"></a>range()函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; range(1,5)        # 代表从1到5(不包含5)</div><div class="line">[1, 2, 3, 4]</div><div class="line">&gt;&gt;&gt; range(1,5,2)      # 代表从1到5，间隔2(不包含5)</div><div class="line">[1, 3]</div><div class="line">&gt;&gt;&gt; range(5)          # 代表从0到5(不包含5)</div><div class="line">[0, 1, 2, 3, 4]</div></pre></td></tr></table></figure>
<p>注意:默认情况下，range() 的起始值是 0。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; for i in range(5) :</div><div class="line">...     print(i)</div><div class="line">...</div><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td></tr></table></figure></p>
<h2 id="Python-字符串"><a href="#Python-字符串" class="headerlink" title="Python 字符串"></a>Python 字符串</h2><p>字符串是 Python 中最常用的数据类型。我们可以使用引号(‘或”)来创建字符串。<br>创建字符串很简单，只要为变量分配一个值即可。例如:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">var1 = <span class="string">'Hello World!'</span></div><div class="line">var2 = <span class="string">"Python Runoob"</span></div></pre></td></tr></table></figure></p>
<h3 id="Python访问字符串中的值"><a href="#Python访问字符串中的值" class="headerlink" title="Python访问字符串中的值"></a>Python访问字符串中的值</h3><p>Python不支持单字符类型，单字符也在Python也是作为一个字符串使用。<br>Python访问子字符串，可以使用方括号来截取字符串，如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">var1 = <span class="string">'Hello World!'</span></div><div class="line">var2 = <span class="string">"Python Runoob"</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"var1[0]: "</span>, var1[<span class="number">0</span>]</div><div class="line"><span class="keyword">print</span> <span class="string">"var2[1:5]: "</span>, var2[<span class="number">1</span>:<span class="number">5</span>]</div></pre></td></tr></table></figure></p>
<p>以上实例执行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var1[0]:  H</div><div class="line">var2[1:5]:  ytho</div></pre></td></tr></table></figure></p>
<h3 id="Python字符串更新"><a href="#Python字符串更新" class="headerlink" title="Python字符串更新"></a>Python字符串更新</h3><p>你可以对已存在的字符串进行修改，并赋值给另一个变量，如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">var1 = <span class="string">'Hello World!'</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"更新字符串 :- "</span>, var1[:<span class="number">6</span>] + <span class="string">'Runoob!'</span></div></pre></td></tr></table></figure></p>
<p>以上实例执行结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">更新字符串 :-  Hello Runoob!</div></pre></td></tr></table></figure></p>
<h3 id="Python转义字符"><a href="#Python转义字符" class="headerlink" title="Python转义字符"></a>Python转义字符</h3><p>在需要在字符中使用特殊字符时，python用反斜杠()转义字符。如下表:</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>(在行尾时)</td>
<td style="text-align:center">续行符</td>
</tr>
<tr>
<td>\</td>
<td style="text-align:center">反斜杠符号</td>
</tr>
<tr>
<td>\’</td>
<td style="text-align:center">单引号</td>
</tr>
<tr>
<td>\”</td>
<td style="text-align:center">双引号</td>
</tr>
<tr>
<td>\a</td>
<td style="text-align:center">响铃</td>
</tr>
<tr>
<td>\b</td>
<td style="text-align:center">退格(Backspace)</td>
</tr>
<tr>
<td>\e</td>
<td style="text-align:center">转义</td>
</tr>
<tr>
<td>\000</td>
<td style="text-align:center">空</td>
</tr>
<tr>
<td>\n</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td>\v</td>
<td style="text-align:center">纵向制表符</td>
</tr>
<tr>
<td>\t</td>
<td style="text-align:center">横向制表符</td>
</tr>
<tr>
<td>\r</td>
<td style="text-align:center">回车</td>
</tr>
<tr>
<td>\f</td>
<td style="text-align:center">换页</td>
</tr>
<tr>
<td>\oyy</td>
<td style="text-align:center">八进制数，yy代表的字符，例如:\o12代表换行</td>
</tr>
<tr>
<td>\xyy</td>
<td style="text-align:center">十六进制数，yy代表的字符，例如:\x0a代表换行</td>
</tr>
<tr>
<td>\other</td>
<td style="text-align:center">其它的字符以普通格式输出</td>
</tr>
</tbody>
</table>
<h3 id="Python字符串运算符"><a href="#Python字符串运算符" class="headerlink" title="Python字符串运算符"></a>Python字符串运算符</h3><p>下表实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”:</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th style="text-align:right">描述</th>
<th style="text-align:center">实例</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td style="text-align:right">字符串连接</td>
<td style="text-align:center">>&gt;&gt;a + b</td>
<td>‘HelloPython’</td>
</tr>
<tr>
<td>*</td>
<td style="text-align:right">重复输出字符串</td>
<td style="text-align:center">>&gt;&gt;a * 2</td>
<td>‘HelloHello’</td>
</tr>
<tr>
<td>[ ]</td>
<td style="text-align:right">通过索引获取字符串中字符</td>
<td style="text-align:center">>&gt;&gt;a[1]</td>
<td>‘e’</td>
</tr>
<tr>
<td>[ : ]</td>
<td style="text-align:right">截取字符串中的一部分</td>
<td style="text-align:center">>&gt;&gt;a[1:4]</td>
<td>‘ell’</td>
</tr>
<tr>
<td>in</td>
<td style="text-align:right">成员运算符 - 如果字符串中包含给定的字符返回 True</td>
<td style="text-align:center">>&gt;&gt;”H” in a</td>
<td>True</td>
</tr>
<tr>
<td>not in</td>
<td style="text-align:right">成员运算符 - 如果字符串中不包含给定的字符返回 True</td>
<td style="text-align:center">>&gt;&gt;”M” not in a</td>
<td>True</td>
</tr>
<tr>
<td>r/R</td>
<td style="text-align:right">原始字符串 - 原始字符串:所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法。</td>
<td style="text-align:center">>&gt;&gt;print r’\n’</td>
<td>\n</td>
</tr>
<tr>
<td>%</td>
<td style="text-align:right">格式字符串</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>实例如下:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">a = <span class="string">"Hello"</span></div><div class="line">b = <span class="string">"Python"</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"a + b 输出结果:"</span>, a + b</div><div class="line"><span class="keyword">print</span> <span class="string">"a * 2 输出结果:"</span>, a * <span class="number">2</span></div><div class="line"><span class="keyword">print</span> <span class="string">"a[1] 输出结果:"</span>, a[<span class="number">1</span>]</div><div class="line"><span class="keyword">print</span> <span class="string">"a[1:4] 输出结果:"</span>, a[<span class="number">1</span>:<span class="number">4</span>]</div><div class="line"></div><div class="line"><span class="keyword">if</span>( <span class="string">"H"</span> <span class="keyword">in</span> a) :</div><div class="line">    <span class="keyword">print</span> <span class="string">"H 在变量 a 中"</span></div><div class="line"><span class="keyword">else</span> :</div><div class="line">	<span class="keyword">print</span> <span class="string">"H 不在变量 a 中"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>( <span class="string">"M"</span> <span class="keyword">not</span> <span class="keyword">in</span> a) :</div><div class="line">    <span class="keyword">print</span> <span class="string">"M 不在变量 a 中"</span></div><div class="line"><span class="keyword">else</span> :</div><div class="line">	<span class="keyword">print</span> <span class="string">"M 在变量 a 中"</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">r'\n'</span></div><div class="line"><span class="keyword">print</span> R<span class="string">'\n'</span></div></pre></td></tr></table></figure></p>
<p>以上程序执行结果为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a + b 输出结果: HelloPython</div><div class="line">a * 2 输出结果: HelloHello</div><div class="line">a[1] 输出结果: e</div><div class="line">a[1:4] 输出结果: ell</div><div class="line">H 在变量 a 中</div><div class="line">M 不在变量 a 中</div><div class="line">\n</div><div class="line">\n</div></pre></td></tr></table></figure></p>
<h3 id="Python-字符串格式化"><a href="#Python-字符串格式化" class="headerlink" title="Python 字符串格式化"></a>Python 字符串格式化</h3><p>Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。<br>在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。<br>如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"My name is %s and weight is %d kg!"</span> % (<span class="string">'Zara'</span>, <span class="number">21</span>)</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">My name is Zara and weight is 21 kg!</div></pre></td></tr></table></figure></p>
<p>python字符串格式化符号:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">符号	描述</div><div class="line">%c	 格式化字符及其ASCII码</div><div class="line">%s	 格式化字符串</div><div class="line">%d	 格式化整数</div><div class="line">%u	 格式化无符号整型</div><div class="line">%o	 格式化无符号八进制数</div><div class="line">%x	 格式化无符号十六进制数</div><div class="line">%X	 格式化无符号十六进制数（大写）</div><div class="line">%f	 格式化浮点数字，可指定小数点后的精度</div><div class="line">%e	 用科学计数法格式化浮点数</div><div class="line">%E	 作用同%e，用科学计数法格式化浮点数</div><div class="line">%g	 %f和%e的简写</div><div class="line">%G	 %f 和 %E 的简写</div><div class="line">%p	 用十六进制数格式化变量的地址</div></pre></td></tr></table></figure></p>
<p>格式化操作符辅助指令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">符号	功能</div><div class="line">*	    定义宽度或者小数点精度</div><div class="line">-	    用做左对齐</div><div class="line">+	    在正数前面显示加号( + )</div><div class="line">&lt;sp&gt;	在正数前面显示空格</div><div class="line">#	    在八进制数前面显示零(&apos;0&apos;)，在十六进制前面显示&apos;0x&apos;或者&apos;0X&apos;(取决于用的是&apos;x&apos;还是&apos;X&apos;)</div><div class="line">0	    显示的数字前面填充&apos;0&apos;而不是默认的空格</div><div class="line">%	    &apos;%%&apos;输出一个单一的&apos;%&apos;</div><div class="line">(var)	映射变量(字典参数)</div><div class="line">m.n.	m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</div></pre></td></tr></table></figure></p>
<p>Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。</p>
<h3 id="Python三引号（triple-quotes）"><a href="#Python三引号（triple-quotes）" class="headerlink" title="Python三引号（triple quotes）"></a>Python三引号（triple quotes）</h3><p>python中三引号可以将复杂的字符串进行复制:<br>python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。<br>三引号的语法是一对连续的单引号或者双引号（通常都是成对的用）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> &gt;&gt;&gt; hi = &apos;&apos;&apos;hi</div><div class="line">there&apos;&apos;&apos;</div><div class="line">&gt;&gt;&gt; hi   # repr()</div><div class="line">&apos;hi\nthere&apos;</div><div class="line">&gt;&gt;&gt; print hi  # str()</div><div class="line">hi</div><div class="line">there</div></pre></td></tr></table></figure></p>
<p>三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。<br>一个典型的用例是，当你需要一块HTML或者SQL时，这时用字符串组合，特殊字符串转义将会非常的繁琐。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"> errHTML = &apos;&apos;&apos;</div><div class="line">&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;</div><div class="line">Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;</div><div class="line">&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;</div><div class="line">&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;</div><div class="line">&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=Back</div><div class="line">ONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt;</div><div class="line">&lt;/BODY&gt;&lt;/HTML&gt;</div><div class="line">&apos;&apos;&apos;</div><div class="line">cursor.execute(&apos;&apos;&apos;</div><div class="line">CREATE TABLE users (</div><div class="line">login VARCHAR(8),</div><div class="line">uid INTEGER,</div><div class="line">prid INTEGER)</div><div class="line">&apos;&apos;&apos;)</div></pre></td></tr></table></figure></p>
<h3 id="Unicode-字符串"><a href="#Unicode-字符串" class="headerlink" title="Unicode 字符串"></a>Unicode 字符串</h3><p>Python 中定义一个 Unicode 字符串和定义一个普通字符串一样简单:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; u&apos;Hello World !&apos;</div><div class="line">u&apos;Hello World !&apos;</div></pre></td></tr></table></figure></p>
<p>引号前小写的”u”表示这里创建的是一个 Unicode 字符串。如果你想加入一个特殊字符，可以使用 Python 的 Unicode-Escape 编码。如下例所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; u&apos;Hello\u0020World !&apos;</div><div class="line">u&apos;Hello World !&apos;</div></pre></td></tr></table></figure></p>
<p>被替换的 \u0020 标识表示在给定位置插入编码值为 0x0020 的 Unicode 字符（空格符）。</p>
<h3 id="python的字符串内建函数"><a href="#python的字符串内建函数" class="headerlink" title="python的字符串内建函数"></a>python的字符串内建函数</h3><p>字符串方法是从python1.6到2.0慢慢加进来的——它们也被加到了Jython中。<br>这些方法实现了string模块的大部分方法，如下表所示列出了目前字符串内建支持的方法，所有的方法都包含了对Unicode的支持，有一些甚至是专门用于Unicode的。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>string.capitalize()</td>
<td style="text-align:center">把字符串的第一个字符大写</td>
</tr>
<tr>
<td>string.center(width)</td>
<td style="text-align:center">返回一个原字符串居中,并使用空格填充至长度 width 的新字符串</td>
</tr>
<tr>
<td>string.count(str, beg=0, end=len(string))</td>
<td style="text-align:center">返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数</td>
</tr>
<tr>
<td>string.decode(encoding=’UTF-8’, errors=’strict’)</td>
<td style="text-align:center">以 encoding 指定的编码格式解码 string，如果出错默认报一个 ValueError 的 异 常 ， 除 非 errors 指 定 的 是 ‘ignore’ 或 者’replace’</td>
</tr>
<tr>
<td>string.encode(encoding=’UTF-8’, errors=’strict’)</td>
<td style="text-align:center">以 encoding 指定的编码格式编码 string，如果出错默认报一个ValueError 的异常，除非 errors 指定的是’ignore’或者’replace’</td>
</tr>
<tr>
<td>string.endswith(obj, beg=0, end=len(string))</td>
<td style="text-align:center">检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.</td>
</tr>
<tr>
<td>string.expandtabs(tabsize=8)</td>
<td style="text-align:center">把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8。</td>
</tr>
<tr>
<td>string.find(str, beg=0, end=len(string))</td>
<td style="text-align:center">检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1</td>
</tr>
<tr>
<td>string.format()</td>
<td style="text-align:center">格式化字符串</td>
</tr>
<tr>
<td>string.index(str, beg=0, end=len(string))</td>
<td style="text-align:center">跟find()方法一样，只不过如果str不在 string中会报一个异常.</td>
</tr>
<tr>
<td>string.isalnum()</td>
<td style="text-align:center">如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True,否则返回 False</td>
</tr>
<tr>
<td>string.isalpha()</td>
<td style="text-align:center">如果 string 至少有一个字符并且所有字符都是字母则返回 True,否则返回 False</td>
</tr>
<tr>
<td>string.isdecimal()</td>
<td style="text-align:center">如果 string 只包含十进制数字则返回 True 否则返回 False.</td>
</tr>
<tr>
<td>string.isdigit()</td>
<td style="text-align:center">如果 string 只包含数字则返回 True 否则返回 False.</td>
</tr>
<tr>
<td>string.islower()</td>
<td style="text-align:center">如果 string中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False</td>
</tr>
<tr>
<td>string.isnumeric()</td>
<td style="text-align:center">如果 string 中只包含数字字符，则返回 True，否则返回 False</td>
</tr>
<tr>
<td>string.isspace()</td>
<td style="text-align:center">如果 string 中只包含空格，则返回 True，否则返回 False.</td>
</tr>
<tr>
<td>string.istitle()</td>
<td style="text-align:center">如果 string 是标题化的(见 title())则返回 True，否则返回 False</td>
</tr>
<tr>
<td>string.isupper()</td>
<td style="text-align:center">如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False</td>
</tr>
<tr>
<td>string.join(seq)</td>
<td style="text-align:center">以 string 作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串</td>
</tr>
<tr>
<td>string.ljust(width)</td>
<td style="text-align:center">返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串</td>
</tr>
<tr>
<td>string.lower()</td>
<td style="text-align:center">转换 string 中所有大写字符为小写.</td>
</tr>
<tr>
<td>string.lstrip()</td>
<td style="text-align:center">截掉 string 左边的空格</td>
</tr>
<tr>
<td>string.maketrans(intab, outtab])</td>
<td style="text-align:center">maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</td>
</tr>
<tr>
<td>max(str)</td>
<td style="text-align:center">返回字符串 str 中最大的字母。</td>
</tr>
<tr>
<td>min(str)</td>
<td style="text-align:center">返回字符串 str 中最小的字母。</td>
</tr>
<tr>
<td>string.partition(str)</td>
<td style="text-align:center">有点像 find()和 split()的结合体,从 str 出现的第一个位置起,把 字 符 串 string 分 成 一 个 3 元 素 的 元 组 (string_pre_str,str,string_post_str),如果 string 中不包含str 则 string_pre_str == string.</td>
</tr>
<tr>
<td>string.replace(str1, str2,  num=string.count(str1))</td>
<td style="text-align:center">把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次.</td>
</tr>
<tr>
<td>string.rfind(str, beg=0,end=len(string) )</td>
<td style="text-align:center">类似于 find()函数，不过是从右边开始查找.</td>
</tr>
<tr>
<td>string.rindex( str, beg=0,end=len(string))</td>
<td style="text-align:center">类似于 index()，不过是从右边开始.</td>
</tr>
<tr>
<td>string.rjust(width)</td>
<td style="text-align:center">返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串</td>
</tr>
<tr>
<td>string.rpartition(str)</td>
<td style="text-align:center">类似于 partition()函数,不过是从右边开始查找.</td>
</tr>
<tr>
<td>string.rstrip()</td>
<td style="text-align:center">删除 string 字符串末尾的空格.</td>
</tr>
<tr>
<td>string.split(str=””, num=string.count(str))</td>
<td style="text-align:center">以 str 为分隔符切片 string，如果 num有指定值，则仅分隔 num 个子字符串</td>
</tr>
<tr>
<td>string.splitlines([keepends])</td>
<td style="text-align:center">按照行(‘\r’, ‘\r\n’, \n’)分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。</td>
</tr>
<tr>
<td>string.startswith(obj, beg=0,end=len(string))</td>
<td style="text-align:center">检查字符串是否是以 obj 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查.</td>
</tr>
<tr>
<td>string.strip([obj])</td>
<td style="text-align:center">在 string 上执行 lstrip()和 rstrip()</td>
</tr>
<tr>
<td>string.swapcase()</td>
<td style="text-align:center">翻转 string 中的大小写</td>
</tr>
<tr>
<td>string.title()</td>
<td style="text-align:center">返回”标题化”的 string,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())</td>
</tr>
<tr>
<td>string.translate(str, del=””)</td>
<td style="text-align:center">根据 str 给出的表(包含 256 个字符)转换 string 的字符,要过滤掉的字符放到 del 参数中</td>
</tr>
<tr>
<td>string.upper()</td>
<td style="text-align:center">转换 string 中的小写字母为大写</td>
</tr>
<tr>
<td>string.zfill(width)</td>
<td style="text-align:center">返回长度为 width 的字符串，原字符串 string 右对齐，前面填充0</td>
</tr>
<tr>
<td>string.isdecimal()</td>
<td style="text-align:center">isdecimal()方法检查字符串是否只包含十进制字符。这种方法只存在于unicode对象。</td>
</tr>
</tbody>
</table>
<p>PS:<br>计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。<br>ASCII编码和Unicode编码的区别:<br>ASCII编码是1个字节，而Unicode编码通常是2个字节，举例如下。<br>　　字母 A 用ASCII编码是十进制的65，二进制的01000001；<br>　　字符 0 用ASCII编码是十进制的48，二进制的00110000，注意字符 ‘0’ 和整数<br>0 是不同的；<br>　　汉字 中 已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。<br>　　如果把ASCII编码的 A 用Unicode编码，只需要在前面补0就可以，因此， A 的Unicode编码是00000000 01000001。</p>
<p>ref: <a href="http://www.runoob.com/python/python-strings.html" target="_blank" rel="external">http://www.runoob.com/python/python-strings.html</a></p>
<h2 id="Python-列表-List"><a href="#Python-列表-List" class="headerlink" title="Python 列表(List)"></a>Python 列表(List)</h2><p>序列是Python中最基本的数据结构。序列中的每个元素都分配一个数字 - 它的位置，或索引，第一个索引是0，第二个索引是1，依此类推。<br>Python有6个序列的内置类型，但最常见的是列表和元组。<br>序列都可以进行的操作包括索引，切片，加，乘，检查成员。<br>此外，Python已经内置确定序列的长度以及确定最大和最小的元素的方法。<br>列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。<br>列表的数据项不需要具有相同的类型<br>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">list1 = [&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000];</div><div class="line">list2 = [1, 2, 3, 4, 5 ];</div><div class="line">list3 = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;];</div></pre></td></tr></table></figure></p>
<p>与字符串的索引一样，列表索引从0开始。列表可以进行截取、组合等。</p>
<h3 id="访问列表中的值"><a href="#访问列表中的值" class="headerlink" title="访问列表中的值"></a>访问列表中的值</h3><p>使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">list1 = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>];</div><div class="line">list2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> ];</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"list1[0]: "</span>, list1[<span class="number">0</span>]</div><div class="line"><span class="keyword">print</span> <span class="string">"list2[1:5]: "</span>, list2[<span class="number">1</span>:<span class="number">5</span>]</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">list1[0]:  physics</div><div class="line">list2[1:5]:  [2, 3, 4, 5]</div></pre></td></tr></table></figure></p>
<h3 id="更新列表"><a href="#更新列表" class="headerlink" title="更新列表"></a>更新列表</h3><p>你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">list = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>];</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Value available at index 2 : "</span></div><div class="line"><span class="keyword">print</span> list[<span class="number">2</span>];</div><div class="line">list[<span class="number">2</span>] = <span class="number">2001</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"New value available at index 2 : "</span></div><div class="line"><span class="keyword">print</span> list[<span class="number">2</span>];</div></pre></td></tr></table></figure></p>
<p>注意:我们会在接下来的章节讨论append()方法的使用<br>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Value available at index 2 :</div><div class="line">1997</div><div class="line">New value available at index 2 :</div><div class="line">2001</div></pre></td></tr></table></figure></p>
<h3 id="删除列表元素"><a href="#删除列表元素" class="headerlink" title="删除列表元素"></a>删除列表元素</h3><p>可以使用 del 语句来删除列表的的元素，如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">list1 = [<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>];</div><div class="line"></div><div class="line"><span class="keyword">print</span> list1;</div><div class="line"><span class="keyword">del</span> list1[<span class="number">2</span>];</div><div class="line"><span class="keyword">print</span> <span class="string">"After deleting value at index 2 : "</span></div><div class="line"><span class="keyword">print</span> list1;</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000]</div><div class="line">After deleting value at index 2 :</div><div class="line">[&apos;physics&apos;, &apos;chemistry&apos;, 2000]</div></pre></td></tr></table></figure></p>
<p>注意:我们会在接下来的章节讨论remove()方法的使用</p>
<h3 id="Python列表脚本操作符"><a href="#Python列表脚本操作符" class="headerlink" title="Python列表脚本操作符"></a>Python列表脚本操作符</h3><p>列表对 + 和 <em> 的操作符与字符串相似。+ 号用于组合列表，</em> 号用于重复列表。<br>如下所示:</p>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th style="text-align:right">结果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len([1, 2, 3])</td>
<td style="text-align:right">3</td>
<td style="text-align:center">长度</td>
</tr>
<tr>
<td>[1, 2, 3] + [4, 5, 6]</td>
<td style="text-align:right">[1, 2, 3, 4, 5, 6]</td>
<td style="text-align:center">组合</td>
</tr>
<tr>
<td>[‘Hi!’] * 4</td>
<td style="text-align:right">[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td>
<td style="text-align:center">重复</td>
</tr>
<tr>
<td>3 in [1, 2, 3]</td>
<td style="text-align:right">True</td>
<td style="text-align:center">元素是否存在于列表中</td>
</tr>
<tr>
<td>for x in [1, 2, 3]: print x,</td>
<td style="text-align:right">1 2 3</td>
<td style="text-align:center">迭代</td>
</tr>
</tbody>
</table>
<h3 id="Python列表截取"><a href="#Python列表截取" class="headerlink" title="Python列表截取"></a>Python列表截取</h3><p>Python 的列表截取实例如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; L = [&apos;Google&apos;, &apos;Runoob&apos;, &apos;Taobao&apos;]</div><div class="line">&gt;&gt;&gt; L[2]</div><div class="line">&apos;Taobao&apos;</div><div class="line">&gt;&gt;&gt; L[-2]</div><div class="line">&apos;Runoob&apos;</div><div class="line">&gt;&gt;&gt; L[1:]</div><div class="line">[&apos;Runoob&apos;, &apos;Taobao&apos;]</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<p>描述:</p>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th style="text-align:right">结果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>[2]</td>
<td style="text-align:right">‘Taobao’</td>
<td style="text-align:center">读取列表中第三个元素</td>
</tr>
<tr>
<td>L[-2]</td>
<td style="text-align:right">‘Runoob’</td>
<td style="text-align:center">读取列表中倒数第二个元素</td>
</tr>
<tr>
<td>L[1:]</td>
<td style="text-align:right">[‘Runoob’, ‘Taobao’]</td>
<td style="text-align:center">从第二个元素开始截取列表</td>
</tr>
</tbody>
</table>
<h3 id="Python列表函数-amp-方法"><a href="#Python列表函数-amp-方法" class="headerlink" title="Python列表函数&amp;方法"></a>Python列表函数&amp;方法</h3><p>Python包含以下函数:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmp(list1, list2)</td>
<td style="text-align:center">比较两个列表的元素</td>
</tr>
<tr>
<td>len(list)</td>
<td style="text-align:center">列表元素个数</td>
</tr>
<tr>
<td>max(list)</td>
<td style="text-align:center">返回列表元素最大值</td>
</tr>
<tr>
<td>min(list)</td>
<td style="text-align:center">返回列表元素最小值</td>
</tr>
<tr>
<td>list(seq)</td>
<td style="text-align:center">将元组转换为列表</td>
</tr>
</tbody>
</table>
<p>Python包含以下方法:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>list.append(obj)</td>
<td style="text-align:center">在列表末尾添加新的对象</td>
</tr>
<tr>
<td>list.count(obj)</td>
<td style="text-align:center">统计某个元素在列表中出现的次数</td>
</tr>
<tr>
<td>list.extend(seq)</td>
<td style="text-align:center">在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</td>
</tr>
<tr>
<td>list.index(obj)</td>
<td style="text-align:center">从列表中找出某个值第一个匹配项的索引位置</td>
</tr>
<tr>
<td>list.insert(index, obj)</td>
<td style="text-align:center">将对象插入列表</td>
</tr>
<tr>
<td>list.pop(obj=list[-1])</td>
<td style="text-align:center">移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</td>
</tr>
<tr>
<td>list.remove(obj)</td>
<td style="text-align:center">移除列表中某个值的第一个匹配项</td>
</tr>
<tr>
<td>list.reverse()</td>
<td style="text-align:center">反向列表中元素</td>
</tr>
<tr>
<td>list.sort([func])</td>
<td style="text-align:center">对原列表进行排序</td>
</tr>
</tbody>
</table>
<p>ref:<a href="http://www.runoob.com/python/python-lists.html" target="_blank" rel="external">http://www.runoob.com/python/python-lists.html</a></p>
<h2 id="Python-元组"><a href="#Python-元组" class="headerlink" title="Python 元组"></a>Python 元组</h2><p>Python的元组与列表类似，不同之处在于元组的元素不能修改。<br>元组使用小括号，列表使用方括号。<br>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。<br>如下实例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tup1 = (&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000);</div><div class="line">tup2 = (1, 2, 3, 4, 5 );</div><div class="line">tup3 = &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;;</div></pre></td></tr></table></figure></p>
<p>创建空元组<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tup1 = ();</div></pre></td></tr></table></figure></p>
<p>元组中只包含一个元素时，需要在元素后面添加逗号<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tup1 = (50,);</div></pre></td></tr></table></figure></p>
<p>元组与字符串类似，下标索引从0开始，可以进行截取，组合等。</p>
<p>PS:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; tup1 = (&quot;all&quot;)</div><div class="line">&gt;&gt;&gt; print tup1</div><div class="line">all</div></pre></td></tr></table></figure></p>
<p>输出字符串 all，这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号。<br>所以，如果元组只有1个元素，就必须加一个逗号，防止被当作括号运算:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; tup1 = (&quot;all&quot;,)</div><div class="line">&gt;&gt;&gt; print tup1</div><div class="line">(&apos;all&apos;,)</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<h3 id="访问元组"><a href="#访问元组" class="headerlink" title="访问元组"></a>访问元组</h3><p>元组可以使用下标索引来访问元组中的值，如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">tup1 = (<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>);</div><div class="line">tup2 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> );</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"tup1[0]: "</span>, tup1[<span class="number">0</span>]</div><div class="line"><span class="keyword">print</span> <span class="string">"tup2[1:5]: "</span>, tup2[<span class="number">1</span>:<span class="number">5</span>]</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tup1[0]:  physics</div><div class="line">tup2[1:5]:  (2, 3, 4, 5)</div></pre></td></tr></table></figure></p>
<h3 id="修改元组"><a href="#修改元组" class="headerlink" title="修改元组"></a>修改元组</h3><p>元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">tup1 = (<span class="number">12</span>, <span class="number">34.56</span>);</div><div class="line">tup2 = (<span class="string">'abc'</span>, <span class="string">'xyz'</span>);</div><div class="line"></div><div class="line"><span class="comment"># 以下修改元组元素操作是非法的。</span></div><div class="line"><span class="comment"># tup1[0] = 100;</span></div><div class="line"></div><div class="line"><span class="comment"># 创建一个新的元组</span></div><div class="line">tup3 = tup1 + tup2;</div><div class="line"><span class="keyword">print</span> tup3;</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(12, 34.56, &apos;abc&apos;, &apos;xyz&apos;)</div></pre></td></tr></table></figure></p>
<h3 id="删除元组"><a href="#删除元组" class="headerlink" title="删除元组"></a>删除元组</h3><p>元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">tup = (<span class="string">'physics'</span>, <span class="string">'chemistry'</span>, <span class="number">1997</span>, <span class="number">2000</span>);</div><div class="line"></div><div class="line"><span class="keyword">print</span> tup;</div><div class="line"><span class="keyword">del</span> tup;</div><div class="line"><span class="keyword">print</span> <span class="string">"After deleting tup : "</span></div><div class="line"><span class="keyword">print</span> tup;</div></pre></td></tr></table></figure></p>
<p>以上实例元组被删除后，输出变量会有异常信息，输出如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">(&apos;physics&apos;, &apos;chemistry&apos;, 1997, 2000)</div><div class="line">After deleting tup :</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;test.py&quot;, line 9, in &lt;module&gt;</div><div class="line">    print tup;</div><div class="line">NameError: name &apos;tup&apos; is not defined</div></pre></td></tr></table></figure></p>
<h3 id="元组运算符"><a href="#元组运算符" class="headerlink" title="元组运算符"></a>元组运算符</h3><p>与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。</p>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th style="text-align:right">结果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>len((1, 2, 3))</td>
<td style="text-align:right">3</td>
<td style="text-align:center">计算元素个数</td>
</tr>
<tr>
<td>(1, 2, 3) + (4, 5, 6)</td>
<td style="text-align:right">(1, 2, 3, 4, 5, 6)</td>
<td style="text-align:center">连接</td>
</tr>
<tr>
<td>(‘Hi!’,) * 4</td>
<td style="text-align:right">(‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’)</td>
<td style="text-align:center">复制</td>
</tr>
<tr>
<td>3 in (1, 2, 3)</td>
<td style="text-align:right">True</td>
<td style="text-align:center">元素是否存在</td>
</tr>
<tr>
<td>for x in (1, 2, 3): print x,</td>
<td style="text-align:right">1 2 3</td>
<td style="text-align:center">迭代</td>
</tr>
</tbody>
</table>
<h3 id="元组索引，截取"><a href="#元组索引，截取" class="headerlink" title="元组索引，截取"></a>元组索引，截取</h3><p>因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示:<br>元组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">L = (&apos;spam&apos;, &apos;Spam&apos;, &apos;SPAM!&apos;)</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>Python 表达式</th>
<th style="text-align:right">结果</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>L[2]</td>
<td style="text-align:right">‘SPAM!’</td>
<td style="text-align:center">读取第三个元素</td>
</tr>
<tr>
<td>L[-2]</td>
<td style="text-align:right">‘Spam’</td>
<td style="text-align:center">反向读取；读取倒数第二个元素</td>
</tr>
<tr>
<td>L[1:]</td>
<td style="text-align:right">(‘Spam’, ‘SPAM!’)</td>
<td style="text-align:center">截取元素</td>
</tr>
</tbody>
</table>
<h3 id="无关闭分隔符"><a href="#无关闭分隔符" class="headerlink" title="无关闭分隔符"></a>无关闭分隔符</h3><p>任意无符号的对象，以逗号隔开，默认为元组，如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">'abc'</span>, <span class="number">-4.24e93</span>, <span class="number">18</span>+<span class="number">6.6j</span>, <span class="string">'xyz'</span>;</div><div class="line">x, y = <span class="number">1</span>, <span class="number">2</span>;</div><div class="line"><span class="keyword">print</span> <span class="string">"Value of x , y : "</span>, x,y;</div></pre></td></tr></table></figure></p>
<p>以上实例运行结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">abc -4.24e+93 (18+6.6j) xyz</div><div class="line">Value of x , y : 1 2</div></pre></td></tr></table></figure></p>
<h3 id="元组内置函数"><a href="#元组内置函数" class="headerlink" title="元组内置函数"></a>元组内置函数</h3><p>Python元组包含了以下内置函数</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmp(tuple1, tuple2)</td>
<td style="text-align:center">比较两个元组元素。</td>
</tr>
<tr>
<td>len(tuple)</td>
<td style="text-align:center">计算元组元素个数。</td>
</tr>
<tr>
<td>max(tuple)</td>
<td style="text-align:center">返回元组中元素最大值。</td>
</tr>
<tr>
<td>min(tuple)</td>
<td style="text-align:center">返回元组中元素最小值。</td>
</tr>
<tr>
<td>tuple(seq)</td>
<td style="text-align:center">将列表转换为元组。</td>
</tr>
</tbody>
</table>
<p>ref: <a href="http://www.runoob.com/python/python-tuples.html" target="_blank" rel="external">http://www.runoob.com/python/python-tuples.html</a></p>
<h2 id="Python-字典-Dictionary"><a href="#Python-字典-Dictionary" class="headerlink" title="Python 字典(Dictionary)"></a>Python 字典(Dictionary)</h2><p>字典是另一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值(key=&gt;value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ,格式如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">d = &#123;key1 : value1, key2 : value2 &#125;</div></pre></td></tr></table></figure></p>
<p>键必须是唯一的，但值则不必。</p>
<p>值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。</p>
<p>一个简单的字典实例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dict = &#123;&apos;Alice&apos;: &apos;2341&apos;, &apos;Beth&apos;: &apos;9102&apos;, &apos;Cecil&apos;: &apos;3258&apos;&#125;</div></pre></td></tr></table></figure></p>
<p>也可如此创建字典:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dict1 = &#123; &apos;abc&apos;: 456 &#125;;</div><div class="line">dict2 = &#123; &apos;abc&apos;: 123, 98.6: 37 &#125;;</div></pre></td></tr></table></figure></p>
<h3 id="访问字典里的值"><a href="#访问字典里的值" class="headerlink" title="访问字典里的值"></a>访问字典里的值</h3><p>把相应的键放入熟悉的方括弧，如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>];</div><div class="line"><span class="keyword">print</span> <span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>];</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dict[&apos;Name&apos;]:  Zara</div><div class="line">dict[&apos;Age&apos;]:  7</div></pre></td></tr></table></figure></p>
<p>如果用字典里没有的键访问数据，会输出错误如下:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"dict['Alice']: "</span>, dict[<span class="string">'Alice'</span>];</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dict[&apos;Alice&apos;]:</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;test.py&quot;, line 5, in &lt;module&gt;</div><div class="line">    print &quot;dict[&apos;Alice&apos;]: &quot;, dict[&apos;Alice&apos;];</div><div class="line">KeyError: &apos;Alice&apos;</div></pre></td></tr></table></figure></p>
<h3 id="修改字典"><a href="#修改字典" class="headerlink" title="修改字典"></a>修改字典</h3><p>向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;;</div><div class="line"></div><div class="line">dict[<span class="string">'Age'</span>] = <span class="number">8</span>; <span class="comment"># update existing entry</span></div><div class="line">dict[<span class="string">'School'</span>] = <span class="string">"DPS School"</span>; <span class="comment"># Add new entry</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>];</div><div class="line"><span class="keyword">print</span> <span class="string">"dict['School']: "</span>, dict[<span class="string">'School'</span>];</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dict[&apos;Age&apos;]:  8</div><div class="line">dict[&apos;School&apos;]:  DPS School</div></pre></td></tr></table></figure></p>
<h3 id="删除字典元素"><a href="#删除字典元素" class="headerlink" title="删除字典元素"></a>删除字典元素</h3><p>能删单一的元素也能清空字典，清空只需一项操作。</p>
<p>显示删除一个字典用del命令，如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">del</span> dict[<span class="string">'Name'</span>]; <span class="comment"># 删除键是'Name'的条目</span></div><div class="line">dict.clear();     <span class="comment"># 清空词典所有条目</span></div><div class="line"><span class="keyword">del</span> dict ;        <span class="comment"># 删除词典</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"dict['Age']: "</span>, dict[<span class="string">'Age'</span>];</div><div class="line"><span class="keyword">print</span> <span class="string">"dict['School']: "</span>, dict[<span class="string">'School'</span>];</div></pre></td></tr></table></figure></p>
<p>但这会引发一个异常，因为用del后字典不再存在:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dict[&apos;Age&apos;]:</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;test.py&quot;, line 8, in &lt;module&gt;</div><div class="line">    print &quot;dict[&apos;Age&apos;]: &quot;, dict[&apos;Age&apos;];</div><div class="line">TypeError: &apos;type&apos; object is unsubscriptable</div></pre></td></tr></table></figure></p>
<p>注:del()方法后面也会讨论。</p>
<h3 id="字典键的特性"><a href="#字典键的特性" class="headerlink" title="字典键的特性"></a>字典键的特性</h3><p>字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的，但键不行。</p>
<p>两个重要的点需要记住:</p>
<p>1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">dict = &#123;<span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Name'</span>: <span class="string">'Manni'</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>];</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">dict[&apos;Name&apos;]:  Manni</div></pre></td></tr></table></figure></p>
<p>2）键必须不可变，所以可以用数字，字符串或元组充当，所以用列表就不行，如下<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"></div><div class="line">dict = &#123;[<span class="string">'Name'</span>]: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;;</div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"dict['Name']: "</span>, dict[<span class="string">'Name'</span>];</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;test.py&quot;, line 3, in &lt;module&gt;</div><div class="line">    dict = &#123;[&apos;Name&apos;]: &apos;Zara&apos;, &apos;Age&apos;: 7&#125;;</div><div class="line">TypeError: list objects are unhashable</div></pre></td></tr></table></figure></p>
<h3 id="字典内置函数-amp-方法"><a href="#字典内置函数-amp-方法" class="headerlink" title="字典内置函数&amp;方法"></a>字典内置函数&amp;方法</h3><p>Python字典包含了以下内置函数:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmp(dict1, dict2)</td>
<td style="text-align:center">比较两个字典元素。</td>
</tr>
<tr>
<td>len(dict)</td>
<td style="text-align:center">计算字典元素个数，即键的总数。</td>
</tr>
<tr>
<td>str(dict)</td>
<td style="text-align:center">输出字典可打印的字符串表示。</td>
</tr>
<tr>
<td>type(variable)</td>
<td style="text-align:center">返回输入的变量类型，如果变量是字典就返回字典类型。</td>
</tr>
</tbody>
</table>
<p>Python字典包含了以下内置方法:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>dict.clear()</td>
<td style="text-align:center">删除字典内所有元素</td>
</tr>
<tr>
<td>dict.copy()</td>
<td style="text-align:center">返回一个字典的浅复制</td>
</tr>
<tr>
<td>dict.fromkeys(seq[, val]))</td>
<td style="text-align:center">创建一个新字典，以序列 seq 中元素做字典的键，val 为字典所有键对应的初始值</td>
</tr>
<tr>
<td>dict.get(key, default=None)</td>
<td style="text-align:center">返回指定键的值，如果值不在字典中返回default值</td>
</tr>
<tr>
<td>dict.has_key(key)</td>
<td style="text-align:center">如果键在字典dict里返回true，否则返回false</td>
</tr>
<tr>
<td>dict.items()</td>
<td style="text-align:center">以列表返回可遍历的(键, 值) 元组数组</td>
</tr>
<tr>
<td>dict.keys()</td>
<td style="text-align:center">以列表返回一个字典所有的键</td>
</tr>
<tr>
<td>dict.setdefault(key, default=None)</td>
<td style="text-align:center">和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default</td>
</tr>
<tr>
<td>dict.update(dict2)</td>
<td style="text-align:center">把字典dict2的键/值对更新到dict里</td>
</tr>
<tr>
<td>dict.values()</td>
<td style="text-align:center">以列表返回字典中的所有值</td>
</tr>
<tr>
<td>pop(key[,default])</td>
<td style="text-align:center">删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</td>
</tr>
<tr>
<td>popitem()</td>
<td style="text-align:center">随机返回并删除字典中的一对键和值。</td>
</tr>
</tbody>
</table>
<p>ref:<a href="http://www.runoob.com/python/python-dictionary.html" target="_blank" rel="external">http://www.runoob.com/python/python-dictionary.html</a></p>
<h3 id="字典合并的几种方法"><a href="#字典合并的几种方法" class="headerlink" title="字典合并的几种方法"></a>字典合并的几种方法</h3><h4 id="update"><a href="#update" class="headerlink" title="update()"></a>update()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; dic1=&#123;&apos;Bob&apos;:70, &apos;Asia&apos;:99&#125;</div><div class="line">&gt;&gt;&gt; dic2=&#123;&apos;Sery&apos;:80, &apos;Jony&apos;:92&#125;</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; dic3=&#123;&#125;</div><div class="line">&gt;&gt;&gt; dic3.update(dic1)</div><div class="line">&gt;&gt;&gt; dic3.update(dic2)</div><div class="line">&gt;&gt;&gt; print(dic3)</div><div class="line">&#123;&apos;Bob&apos;: 70, &apos;Asia&apos;: 99, &apos;Sery&apos;: 80, &apos;Jony&apos;: 92&#125;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; dic1=&#123;&apos;Bob&apos;:70, &apos;Asia&apos;:99&#125;</div><div class="line">&gt;&gt;&gt; dic2=&#123;&apos;Sery&apos;:80, &apos;Jony&apos;:92&#125;</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; dic3=&#123;&#125;</div><div class="line">&gt;&gt;&gt; dic3=dic1.copy()</div><div class="line">&gt;&gt;&gt; print(dic3)</div><div class="line">&#123;&apos;Bob&apos;: 70, &apos;Asia&apos;: 99&#125;</div><div class="line">&gt;&gt;&gt; dic3.update(dic2)</div><div class="line">&gt;&gt;&gt; print(dic3)</div><div class="line">&#123;&apos;Bob&apos;: 70, &apos;Asia&apos;: 99, &apos;Sery&apos;: 80, &apos;Jony&apos;: 92&#125;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h4 id="dict-d1-d2-or-dict-d1-d2"><a href="#dict-d1-d2-or-dict-d1-d2" class="headerlink" title="dict(d1, **d2) or dict(**d1, **d2)"></a>dict(d1, <code>**</code>d2) or dict(<code>**</code>d1, <code>**</code>d2)</h4><p>Python 3.5 之后<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; dic1=&#123;&apos;Bob&apos;:70, &apos;Asia&apos;:99&#125;</div><div class="line">&gt;&gt;&gt; dic2=&#123;&apos;Sery&apos;:80, &apos;Jony&apos;:92&#125;</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; dic3=&#123;&#125;</div><div class="line">&gt;&gt;&gt; dic3=dict(dic1, **dic2)</div><div class="line">&gt;&gt;&gt; print(dic3)</div><div class="line">&#123;&apos;Bob&apos;: 70, &apos;Asia&apos;: 99, &apos;Sery&apos;: 80, &apos;Jony&apos;: 92&#125;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; dic1=&#123;&apos;Bob&apos;:70, &apos;Asia&apos;:99&#125;</div><div class="line">&gt;&gt;&gt; dic2=&#123;&apos;Sery&apos;:80, &apos;Jony&apos;:92&#125;</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; dic3=&#123;&#125;</div><div class="line">&gt;&gt;&gt; dic3=dict(**dic1, **dic2)</div><div class="line">&gt;&gt;&gt; print(dic3)</div><div class="line">&#123;&apos;Bob&apos;: 70, &apos;Asia&apos;: 99, &apos;Sery&apos;: 80, &apos;Jony&apos;: 92&#125;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h4 id="常规处理方法"><a href="#常规处理方法" class="headerlink" title="常规处理方法"></a>常规处理方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; dic1=&#123;&apos;Bob&apos;:70, &apos;Asia&apos;:99&#125;</div><div class="line">&gt;&gt;&gt; dic2=&#123;&apos;Sery&apos;:80, &apos;Jony&apos;:92&#125;</div><div class="line">&gt;&gt;&gt;</div><div class="line">&gt;&gt;&gt; dic3=&#123;&#125;</div><div class="line">&gt;&gt;&gt; for k,v in dic1.items():</div><div class="line">...     dic3[k]=v</div><div class="line">...</div><div class="line">&gt;&gt;&gt; for k,v in dic2.items():</div><div class="line">...     dic3[k]=v</div><div class="line">...</div><div class="line">&gt;&gt;&gt; print(dic3)</div><div class="line">&#123;&apos;Bob&apos;: 70, &apos;Asia&apos;: 99, &apos;Sery&apos;: 80, &apos;Jony&apos;: 92&#125;</div><div class="line">&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<h2 id="Python-日期和时间"><a href="#Python-日期和时间" class="headerlink" title="Python 日期和时间"></a>Python 日期和时间</h2><p>Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。<br>Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。<br>时间间隔是以秒为单位的浮点小数。<br>每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示。<br>Python 的 time 模块下有很多函数可以转换常见日期格式。如函数time.time()用于获取当前时间戳, 如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> time;  <span class="comment"># 引入time模块</span></div><div class="line"></div><div class="line">ticks = time.time()</div><div class="line"><span class="keyword">print</span> <span class="string">"当前时间戳为:"</span>, ticks</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">当前时间戳为: 1459994552.51</div></pre></td></tr></table></figure></p>
<p>时间戳单位最适于做日期运算。但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年。</p>
<h3 id="什么是时间元组？"><a href="#什么是时间元组？" class="headerlink" title="什么是时间元组？"></a>什么是时间元组？</h3><p>很多Python函数用一个元组装起来的9组数字处理时间,也就是struct_time元组。这种结构具有如下属性:</p>
<table>
<thead>
<tr>
<th>字段</th>
<th style="text-align:right">含义</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td>tm_year</td>
<td style="text-align:right">4位数年</td>
<td style="text-align:center">2008</td>
</tr>
<tr>
<td>tm_mon</td>
<td style="text-align:right">月</td>
<td style="text-align:center">1 到 12</td>
</tr>
<tr>
<td>tm_mday</td>
<td style="text-align:right">日</td>
<td style="text-align:center">1 到 31</td>
</tr>
<tr>
<td>tm_hour</td>
<td style="text-align:right">小时</td>
<td style="text-align:center">0 到 23</td>
</tr>
<tr>
<td>tm_min</td>
<td style="text-align:right">分钟</td>
<td style="text-align:center">0 到 59</td>
</tr>
<tr>
<td>tm_sec</td>
<td style="text-align:right">秒</td>
<td style="text-align:center">0 到 61 (60或61 是闰秒)</td>
</tr>
<tr>
<td>tm_wday</td>
<td style="text-align:right">一周的第几日</td>
<td style="text-align:center">0到6 (0是周日)</td>
</tr>
<tr>
<td>tm_yday</td>
<td style="text-align:right">一年的第几日</td>
<td style="text-align:center">1 到 366(儒略历)</td>
</tr>
<tr>
<td>tm_isdst</td>
<td style="text-align:right">夏令时</td>
<td style="text-align:center">-1, 0, 1, -1是决定是否为夏令时的旗帜</td>
</tr>
</tbody>
</table>
<h3 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h3><p>从返回浮点数的时间辍方式向时间元组转换，只要将浮点数传递给如localtime之类的函数。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">localtime = time.localtime(time.time())</div><div class="line"><span class="keyword">print</span> <span class="string">"本地时间为 :"</span>, localtime</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">本地时间为 : time.struct_time(tm_year=2016, tm_mon=4, tm_mday=7, tm_hour=10, tm_min=3, tm_sec=27, tm_wday=3, tm_yday=98, tm_isdst=0)</div></pre></td></tr></table></figure></p>
<h3 id="获取格式化的时间"><a href="#获取格式化的时间" class="headerlink" title="获取格式化的时间"></a>获取格式化的时间</h3><p>你可以根据需求选取各种格式，但是最简单的获取可读的时间模式的函数是asctime():<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">localtime = time.asctime( time.localtime(time.time()) )</div><div class="line"><span class="keyword">print</span> <span class="string">"本地时间为 :"</span>, localtime</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">本地时间为 : Thu Apr  7 10:05:21 2016</div></pre></td></tr></table></figure></p>
<h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><p>我们可以使用 time 模块的 strftime 方法来格式化日期，:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">time.strftime(format[, t])</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="comment"># 格式化成2016-03-20 11:45:39形式</span></div><div class="line"><span class="keyword">print</span> time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, time.localtime())</div><div class="line"></div><div class="line"><span class="comment"># 格式化成Sat Mar 28 22:24:24 2016形式</span></div><div class="line"><span class="keyword">print</span> time.strftime(<span class="string">"%a %b %d %H:%M:%S %Y"</span>, time.localtime())</div><div class="line"></div><div class="line"><span class="comment"># 将格式字符串转换为时间戳</span></div><div class="line">a = <span class="string">"Sat Mar 28 22:24:24 2016"</span></div><div class="line"><span class="keyword">print</span> time.mktime(time.strptime(a,<span class="string">"%a %b %d %H:%M:%S %Y"</span>))</div></pre></td></tr></table></figure>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2016-04-07 10:25:09</div><div class="line">Thu Apr 07 10:25:09 2016</div><div class="line">1459175064.0</div></pre></td></tr></table></figure></p>
<p>python中时间日期格式化符号:</p>
<ul>
<li>%y 两位数的年份表示（00-99）</li>
<li>%Y 四位数的年份表示（000-9999）</li>
<li>%m 月份（01-12）</li>
<li>%d 月内中的一天（0-31）</li>
<li>%H 24小时制小时数（0-23）</li>
<li>%I 12小时制小时数（01-12）</li>
<li>%M 分钟数（00=59）</li>
<li>%S 秒（00-59）</li>
<li>%a 本地简化星期名称</li>
<li>%A 本地完整星期名称</li>
<li>%b 本地简化的月份名称</li>
<li>%B 本地完整的月份名称</li>
<li>%c 本地相应的日期表示和时间表示</li>
<li>%j 年内的一天（001-366）</li>
<li>%p 本地A.M.或P.M.的等价符</li>
<li>%U 一年中的星期数（00-53）星期天为星期的开始</li>
<li>%w 星期（0-6），星期天为星期的开始</li>
<li>%W 一年中的星期数（00-53）星期一为星期的开始</li>
<li>%x 本地相应的日期表示</li>
<li>%X 本地相应的时间表示</li>
<li>%Z 当前时区的名称</li>
<li>%% %号本身</li>
</ul>
<h3 id="获取某月日历"><a href="#获取某月日历" class="headerlink" title="获取某月日历"></a>获取某月日历</h3><p>Calendar模块有很广泛的方法用来处理年历和月历，例如打印某月的月历:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> calendar</div><div class="line"></div><div class="line">cal = calendar.month(<span class="number">2016</span>, <span class="number">1</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"以下输出2016年1月份的日历:"</span></div><div class="line"><span class="keyword">print</span> cal;</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">以下输出2016年1月份的日历:</div><div class="line">    January 2016</div><div class="line">Mo Tu We Th Fr Sa Su</div><div class="line">             1  2  3</div><div class="line"> 4  5  6  7  8  9 10</div><div class="line">11 12 13 14 15 16 17</div><div class="line">18 19 20 21 22 23 24</div><div class="line">25 26 27 28 29 30 31</div></pre></td></tr></table></figure></p>
<h3 id="Time-模块"><a href="#Time-模块" class="headerlink" title="Time 模块"></a>Time 模块</h3><p>Time 模块包含了以下内置函数，既有时间处理相的，也有转换时间格式的:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>time.altzone</td>
<td style="text-align:center">返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。</td>
</tr>
<tr>
<td>time.asctime([tupletime])</td>
<td style="text-align:center">接受时间元组并返回一个可读的形式为”Tue Dec 11 18:07:14 2008”（2008年12月11日 周二18时07分14秒）的24个字符的字符串。</td>
</tr>
<tr>
<td>time.clock( )</td>
<td style="text-align:center">用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。</td>
</tr>
<tr>
<td>time.ctime([secs])</td>
<td style="text-align:center">作用相当于asctime(localtime(secs))，未给参数相当于asctime()</td>
</tr>
<tr>
<td>time.gmtime([secs])</td>
<td style="text-align:center">接收时间辍（1970纪元后经过的浮点秒数）并返回格林威治天文时间下的时间元组t。注:t.tm_isdst始终为0</td>
</tr>
<tr>
<td>time.localtime([secs])</td>
<td style="text-align:center">接收时间辍（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。</td>
</tr>
<tr>
<td>time.mktime(tupletime)</td>
<td style="text-align:center">接受时间元组并返回时间辍（1970纪元后经过的浮点秒数）。</td>
</tr>
<tr>
<td>time.sleep(secs)</td>
<td style="text-align:center">推迟调用线程的运行，secs指秒数。</td>
</tr>
<tr>
<td>time.strftime(fmt[,tupletime])</td>
<td style="text-align:center">接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。</td>
</tr>
<tr>
<td>time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y’)</td>
<td style="text-align:center">根据fmt的格式把一个时间字符串解析为时间元组。</td>
</tr>
<tr>
<td>time.time( )</td>
<td style="text-align:center">返回当前时间的时间戳（1970纪元后经过的浮点秒数）。</td>
</tr>
<tr>
<td>time.tzset()</td>
<td style="text-align:center">根据环境变量TZ重新初始化时间相关设置。</td>
</tr>
</tbody>
</table>
<p>Time模块包含了以下2个非常重要的属性:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>time.timezone</td>
<td style="text-align:center">属性time.timezone是当地时区（未启动夏令时）距离格林威治的偏移秒数（&gt;0，美洲;&lt;=0大部分欧洲，亚洲，非洲）。</td>
</tr>
<tr>
<td>time.tzname</td>
<td style="text-align:center">属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。</td>
</tr>
</tbody>
</table>
<h3 id="日历（Calendar）模块"><a href="#日历（Calendar）模块" class="headerlink" title="日历（Calendar）模块"></a>日历（Calendar）模块</h3><p>此模块的函数都是日历相关的，例如打印某月的字符月历。<br>星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数。模块包含了以下内置函数:</p>
<table>
<thead>
<tr>
<th>函数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>calendar.calendar(year,w=2,l=1,c=6)</td>
<td style="text-align:center">返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21<em> W+18+2</em> C。l是每星期行数。</td>
</tr>
<tr>
<td>calendar.firstweekday( )</td>
<td style="text-align:center">返回当前每周起始日期的设置。默认情况下，首次载入caendar模块时返回0，即星期一。</td>
</tr>
<tr>
<td>calendar.isleap(year)</td>
<td style="text-align:center">是闰年返回True，否则为false。</td>
</tr>
<tr>
<td>calendar.leapdays(y1,y2)</td>
<td style="text-align:center">返回在Y1，Y2两年之间的闰年总数。</td>
</tr>
<tr>
<td>calendar.month(year,month,w=2,l=1)</td>
<td style="text-align:center">返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。</td>
</tr>
<tr>
<td>calendar.monthcalendar(year,month)</td>
<td style="text-align:center">返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。</td>
</tr>
<tr>
<td>calendar.monthrange(year,month)</td>
<td style="text-align:center">返回两个整数。第一个是该月的星期几的日期码，第二个是该月的日期码。日从0（星期一）到6（星期日）;月从1到12。</td>
</tr>
<tr>
<td>calendar.prcal(year,w=2,l=1,c=6)</td>
<td style="text-align:center">相当于 print calendar.calendar(year,w,l,c).</td>
</tr>
<tr>
<td>calendar.prmonth(year,month,w=2,l=1)</td>
<td style="text-align:center">相当于 print calendar.calendar（year，w，l，c）。</td>
</tr>
<tr>
<td>calendar.setfirstweekday(weekday)</td>
<td style="text-align:center">设置每周的起始日期码。0（星期一）到6（星期日）。</td>
</tr>
<tr>
<td>calendar.timegm(tupletime)</td>
<td style="text-align:center">和time.gmtime相反:接受一个时间元组形式，返回该时刻的时间辍（1970纪元后经过的浮点秒数）。</td>
</tr>
<tr>
<td>calendar.weekday(year,month,day)</td>
<td style="text-align:center">返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。</td>
</tr>
</tbody>
</table>
<h3 id="其他相关模块和函数"><a href="#其他相关模块和函数" class="headerlink" title="其他相关模块和函数"></a>其他相关模块和函数</h3><p>在Python中，其他处理日期和时间的模块还有:</p>
<ul>
<li><a href="http://docs.python.org/library/datetime.html#module-datetime" target="_blank" rel="external">datetime模块</a></li>
<li><a href="http://www.twinsun.com/tz/tz-link.htm" target="_blank" rel="external">pytz模块</a></li>
<li><a href="http://labix.org/python-dateutil" target="_blank" rel="external">dateutil模块</a></li>
</ul>
<p>PS:<br>使用datetime模块来获取当前的日期和时间<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> datetime</div><div class="line">i = datetime.datetime.now()</div><div class="line"><span class="keyword">print</span> (<span class="string">"当前的日期和时间是 %s"</span> % i)</div><div class="line"><span class="keyword">print</span> (<span class="string">"ISO格式的日期和时间是 %s"</span> % i.isoformat() )</div><div class="line"><span class="keyword">print</span> (<span class="string">"当前的年份是 %s"</span> %i.year)</div><div class="line"><span class="keyword">print</span> (<span class="string">"当前的月份是 %s"</span> %i.month)</div><div class="line"><span class="keyword">print</span> (<span class="string">"当前的日期是  %s"</span> %i.day)</div><div class="line"><span class="keyword">print</span> (<span class="string">"dd/mm/yyyy 格式是  %s/%s/%s"</span> % (i.day, i.month, i.year) )</div><div class="line"><span class="keyword">print</span> (<span class="string">"当前小时是 %s"</span> %i.hour)</div><div class="line"><span class="keyword">print</span> (<span class="string">"当前分钟是 %s"</span> %i.minute)</div><div class="line"><span class="keyword">print</span> (<span class="string">"当前秒是  %s"</span> %i.second)</div></pre></td></tr></table></figure></p>
<p>ref: <a href="http://www.runoob.com/python/python-date-time.html" target="_blank" rel="external">http://www.runoob.com/python/python-date-time.html</a></p>
<h2 id="Python-函数"><a href="#Python-函数" class="headerlink" title="Python 函数"></a>Python 函数</h2><p>函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。<br>函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。</p>
<h3 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h3><p>你可以定义一个由自己想要功能的函数，以下是简单的规则:<br>函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()。<br>任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数。<br>函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。<br>函数内容以冒号起始，并且缩进。<br>return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。<br>语法<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def functionname( parameters ):</div><div class="line">   &quot;函数_文档字符串&quot;</div><div class="line">   function_suite</div><div class="line">   return [expression]</div></pre></td></tr></table></figure></p>
<p>默认情况下，参数值和参数名称是按函数声明中定义的的顺序匹配起来的。<br>实例<br>以下为一个简单的Python函数，它将一个字符串作为传入参数，再打印到标准显示设备上。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def printme( str ):</div><div class="line">   &quot;打印传入的字符串到标准显示设备上&quot;</div><div class="line">   print str</div><div class="line">   return</div></pre></td></tr></table></figure></p>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。<br>这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。<br>如下实例调用了printme（）函数:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 定义函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></div><div class="line">   <span class="string">"打印任何传入的字符串"</span></div><div class="line">   <span class="keyword">print</span> str;</div><div class="line">   <span class="keyword">return</span>;</div><div class="line"></div><div class="line"><span class="comment"># 调用函数</span></div><div class="line">printme(<span class="string">"我要调用用户自定义函数!"</span>);</div><div class="line">printme(<span class="string">"再次调用同一函数"</span>);</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">我要调用用户自定义函数!</div><div class="line">再次调用同一函数</div></pre></td></tr></table></figure></p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在 python 中，类型属于对象，变量是没有类型的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a=[1,2,3]</div><div class="line"></div><div class="line">a=&quot;Runoob&quot;</div></pre></td></tr></table></figure></p>
<p>以上代码中，[1,2,3] 是 List 类型，”Runoob” 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是 List 类型对象，也可以指向 String 类型对象。</p>
<h4 id="可更改-mutable-与不可更改-immutable-对象"><a href="#可更改-mutable-与不可更改-immutable-对象" class="headerlink" title="可更改(mutable)与不可更改(immutable)对象"></a>可更改(mutable)与不可更改(immutable)对象</h4><p>在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。</p>
<ul>
<li>不可变类型:变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。</li>
<li>可变类型:变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。</li>
</ul>
<p>python 函数的参数传递:</p>
<ul>
<li>不可变类型:类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。</li>
<li>可变类型:类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响</li>
</ul>
<p>python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。</p>
<h4 id="python-传不可变对象实例"><a href="#python-传不可变对象实例" class="headerlink" title="python 传不可变对象实例"></a>python 传不可变对象实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ChangeInt</span><span class="params">( a )</span>:</span></div><div class="line">    a = <span class="number">10</span></div><div class="line"></div><div class="line">b = <span class="number">2</span></div><div class="line">ChangeInt(b)</div><div class="line"><span class="keyword">print</span> b <span class="comment"># 结果是 2</span></div></pre></td></tr></table></figure>
<p>实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。</p>
<h4 id="传可变对象实例"><a href="#传可变对象实例" class="headerlink" title="传可变对象实例"></a>传可变对象实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 可写函数说明</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">changeme</span><span class="params">( mylist )</span>:</span></div><div class="line">   <span class="string">"修改传入的列表"</span></div><div class="line">   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</div><div class="line">   <span class="keyword">print</span> <span class="string">"函数内取值: "</span>, mylist</div><div class="line">   <span class="keyword">return</span></div><div class="line"></div><div class="line"><span class="comment"># 调用changeme函数</span></div><div class="line">mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>];</div><div class="line">changeme( mylist );</div><div class="line"><span class="keyword">print</span> <span class="string">"函数外取值: "</span>, mylist</div></pre></td></tr></table></figure>
<p>实例中传入函数的和在末尾添加新内容的对象用的是同一个引用，故输出结果如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">函数内取值:  [10, 20, 30, [1, 2, 3, 4]]</div><div class="line">函数外取值:  [10, 20, 30, [1, 2, 3, 4]]</div></pre></td></tr></table></figure></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>以下是调用函数时可使用的正式参数类型:</p>
<ul>
<li>必备参数</li>
<li>关键字参数</li>
<li>默认参数</li>
<li>不定长参数</li>
</ul>
<h4 id="必备参数"><a href="#必备参数" class="headerlink" title="必备参数"></a>必备参数</h4><p>必备参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。<br>调用printme()函数，你必须传入一个参数，不然会出现语法错误:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment">#可写函数说明</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></div><div class="line">   <span class="string">"打印任何传入的字符串"</span></div><div class="line">   <span class="keyword">print</span> str;</div><div class="line">   <span class="keyword">return</span>;</div><div class="line"></div><div class="line"><span class="comment">#调用printme函数</span></div><div class="line">printme();</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;test.py&quot;, line 11, in &lt;module&gt;</div><div class="line">    printme();</div><div class="line">TypeError: printme() takes exactly 1 argument (0 given)</div></pre></td></tr></table></figure></p>
<h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。<br>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。<br>以下实例在函数 printme() 调用时使用参数名:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment">#可写函数说明</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printme</span><span class="params">( str )</span>:</span></div><div class="line">   <span class="string">"打印任何传入的字符串"</span></div><div class="line">   <span class="keyword">print</span> str;</div><div class="line">   <span class="keyword">return</span>;</div><div class="line"></div><div class="line"><span class="comment">#调用printme函数</span></div><div class="line">printme( str = <span class="string">"My string"</span>);</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">My string</div></pre></td></tr></table></figure></p>
<p>下例能将关键字参数顺序不重要展示得更清楚:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment">#可写函数说明</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( name, age )</span>:</span></div><div class="line">   <span class="string">"打印任何传入的字符串"</span></div><div class="line">   <span class="keyword">print</span> <span class="string">"Name: "</span>, name;</div><div class="line">   <span class="keyword">print</span> <span class="string">"Age "</span>, age;</div><div class="line">   <span class="keyword">return</span>;</div><div class="line"></div><div class="line"><span class="comment">#调用printinfo函数</span></div><div class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"miki"</span> );</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Name:  miki</div><div class="line">Age  50</div></pre></td></tr></table></figure></p>
<p>PS:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">官网陈述, 关键字参数既可以用标识符(name=)的形式, 也可以用字典(**&#123;&apos;key1&apos;, value1, &apos;key2&apos;, value2&#125;)的形式</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">keyword argument: an argument preceded by an identifier (e.g. name=) in a function call or passed as a value in a dictionary preceded by **. For example, 3 and 5 are both keyword arguments in the following calls to complex():</div><div class="line"></div><div class="line">complex(real=3, imag=5)</div><div class="line">complex(**&#123;&apos;real&apos;: 3, &apos;imag&apos;: 5&#125;)</div></pre></td></tr></table></figure>
<p>ref: <a href="https://docs.python.org/2.7/glossary.html#glossary" target="_blank" rel="external">https://docs.python.org/2.7/glossary.html#glossary</a></p>
<h4 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h4><p>调用函数时，缺省参数的值如果没有传入，则被认为是默认值。下例会打印默认的age，如果age没有被传入:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment">#可写函数说明</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( name, age = <span class="number">35</span> )</span>:</span></div><div class="line">   <span class="string">"打印任何传入的字符串"</span></div><div class="line">   <span class="keyword">print</span> <span class="string">"Name: "</span>, name;</div><div class="line">   <span class="keyword">print</span> <span class="string">"Age "</span>, age;</div><div class="line">   <span class="keyword">return</span>;</div><div class="line"></div><div class="line"><span class="comment">#调用printinfo函数</span></div><div class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">"miki"</span> );</div><div class="line">printinfo( name=<span class="string">"miki"</span> );</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Name:  miki</div><div class="line">Age  50</div><div class="line">Name:  miki</div><div class="line">Age  35</div></pre></td></tr></table></figure></p>
<h4 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h4><p>你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述2种参数不同，声明时不会命名。基本语法如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def functionname([formal_args,] *var_args_tuple ):</div><div class="line">   &quot;函数_文档字符串&quot;</div><div class="line">   function_suite</div><div class="line">   return [expression]</div></pre></td></tr></table></figure></p>
<p>加了星号（*）的变量名会存放所有未命名的变量参数。选择不多传参数也可。如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 可写函数说明</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">( arg1, *vartuple )</span>:</span></div><div class="line">   <span class="string">"打印任何传入的参数"</span></div><div class="line">   <span class="keyword">print</span> <span class="string">"输出: "</span></div><div class="line">   <span class="keyword">print</span> arg1</div><div class="line">   <span class="keyword">for</span> var <span class="keyword">in</span> vartuple:</div><div class="line">      <span class="keyword">print</span> var</div><div class="line">   <span class="keyword">return</span>;</div><div class="line"></div><div class="line"><span class="comment"># 调用printinfo 函数</span></div><div class="line">printinfo( <span class="number">10</span> );</div><div class="line">printinfo( <span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span> );</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">输出:</div><div class="line">10</div><div class="line">输出:</div><div class="line">70</div><div class="line">60</div><div class="line">50</div></pre></td></tr></table></figure></p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>python 使用 lambda 来创建匿名函数。</p>
<ul>
<li>lambda只是一个表达式，函数体比def简单很多。</li>
<li>lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。</li>
<li>lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。</li>
<li>虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。</li>
</ul>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>lambda函数的语法只包含一个语句，如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">lambda [arg1 [,arg2,.....argn]]:expression</div></pre></td></tr></table></figure></p>
<p>如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 可写函数说明</span></div><div class="line">sum = <span class="keyword">lambda</span> arg1, arg2: arg1 + arg2;</div><div class="line"></div><div class="line"><span class="comment"># 调用sum函数</span></div><div class="line"><span class="keyword">print</span> <span class="string">"相加后的值为 : "</span>, sum( <span class="number">10</span>, <span class="number">20</span> )</div><div class="line"><span class="keyword">print</span> <span class="string">"相加后的值为 : "</span>, sum( <span class="number">20</span>, <span class="number">20</span> )</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">相加后的值为 :  30</div><div class="line">相加后的值为 :  40</div></pre></td></tr></table></figure></p>
<h3 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h3><p>return语句[表达式]退出函数，选择性地向调用方返回一个表达式。不带参数值的return语句返回None。之前的例子都没有示范如何返回数值，下例便告诉你怎么做:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 可写函数说明</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">( arg1, arg2 )</span>:</span></div><div class="line">   <span class="comment"># 返回2个参数的和."</span></div><div class="line">   total = arg1 + arg2</div><div class="line">   <span class="keyword">print</span> <span class="string">"函数内 : "</span>, total</div><div class="line">   <span class="keyword">return</span> total;</div><div class="line"></div><div class="line"><span class="comment"># 调用sum函数</span></div><div class="line">total = sum( <span class="number">10</span>, <span class="number">20</span> );</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">函数内 :  30</div></pre></td></tr></table></figure></p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>一个程序的所有的变量并不是在哪个位置都可以访问的。访问权限决定于这个变量是在哪里赋值的。<br>变量的作用域决定了在哪一部分程序你可以访问哪个特定的变量名称。两种最基本的变量作用域如下:</p>
<ul>
<li>全局变量</li>
<li>局部变量</li>
</ul>
<h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><p>定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。</p>
<p>局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">total = <span class="number">0</span>; <span class="comment"># 这是一个全局变量</span></div><div class="line"><span class="comment"># 可写函数说明</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">( arg1, arg2 )</span>:</span></div><div class="line">   <span class="comment">#返回2个参数的和."</span></div><div class="line">   total = arg1 + arg2; <span class="comment"># total在这里是局部变量.</span></div><div class="line">   <span class="keyword">print</span> <span class="string">"函数内是局部变量 : "</span>, total</div><div class="line">   <span class="keyword">return</span> total;</div><div class="line"></div><div class="line"><span class="comment">#调用sum函数</span></div><div class="line">sum( <span class="number">10</span>, <span class="number">20</span> );</div><div class="line"><span class="keyword">print</span> <span class="string">"函数外是全局变量 : "</span>, total</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">函数内是局部变量 :  30</div><div class="line">函数外是全局变量 :  0</div></pre></td></tr></table></figure></p>
<p>PS:<br>全局变量想作用于函数内，需加 global<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">globvar = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_globvar_to_one</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">global</span> globvar    <span class="comment"># 使用 global 声明全局变量</span></div><div class="line">    globvar = <span class="number">1</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_globvar</span><span class="params">()</span>:</span></div><div class="line">    print(globvar)     <span class="comment"># 没有使用 global</span></div><div class="line"></div><div class="line">set_globvar_to_one()</div><div class="line"><span class="keyword">print</span>  globvar        <span class="comment"># 输出 1</span></div><div class="line">print_globvar()       <span class="comment"># 输出 1，函数内的 globvar 已经是全局变量</span></div></pre></td></tr></table></figure></p>
<ol>
<li>global—将变量定义为全局变量。可以通过定义为全局变量，实现在函数内部改变变量值。</li>
<li>一个global语句可以同时定义多个变量，如 global x, y, z。</li>
</ol>
<p>ref: <a href="http://www.runoob.com/python/python-functions.html" target="_blank" rel="external">http://www.runoob.com/python/python-functions.html</a></p>
<h2 id="Python-模块"><a href="#Python-模块" class="headerlink" title="Python 模块"></a>Python 模块</h2><p>Python 模块(Module)，是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。<br>模块让你能够有逻辑地组织你的 Python 代码段。<br>把相关的代码分配到一个模块里能让你的代码更好用，更易懂。<br>模块能定义函数，类和变量，模块里也能包含可执行的代码。<br>例子<br>下例是个简单的模块 support.py:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">def print_func( par ):</div><div class="line">   print &quot;Hello : &quot;, par</div><div class="line">   return</div></pre></td></tr></table></figure></p>
<h3 id="import-语句"><a href="#import-语句" class="headerlink" title="import 语句"></a>import 语句</h3><p>模块的引入<br>模块定义好后，我们可以使用 import 语句来引入模块，语法如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import module1[, module2[,... moduleN]</div></pre></td></tr></table></figure></p>
<p>比如要引用模块 math，就可以在文件最开始的地方用 import math 来引入。在调用 math 模块中的函数时，必须这样引用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">模块名.函数名</div></pre></td></tr></table></figure></p>
<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。<br>搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support.py，需要把命令放在脚本的顶端:<br>test.py 文件代码:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 导入模块</span></div><div class="line"><span class="keyword">import</span> support</div><div class="line"></div><div class="line"><span class="comment"># 现在可以调用模块里包含的函数了</span></div><div class="line">support.print_func(<span class="string">"Runoob"</span>)</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Hello : Runoob</div></pre></td></tr></table></figure></p>
<p>一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。</p>
<h3 id="from…import-语句"><a href="#from…import-语句" class="headerlink" title="from…import 语句"></a>from…import 语句</h3><p>Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中。语法如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">from modname import name1[, name2[, ... nameN]]</div></pre></td></tr></table></figure></p>
<p>例如，要导入模块 fib 的 fibonacci 函数，使用如下语句:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">from fib import fibonacci</div></pre></td></tr></table></figure></p>
<p>这个声明不会把整个 fib 模块导入到当前的命名空间中，它只会将 fib 里的 fibonacci 单个引入到执行这个声明的模块的全局符号表。</p>
<h3 id="from…import-语句-1"><a href="#from…import-语句-1" class="headerlink" title="from…import* 语句"></a>from…import* 语句</h3><p>把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">from modname import *</div></pre></td></tr></table></figure></p>
<p>这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。<br>例如我们想一次性引入 math 模块中所有的东西，语句如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">from math import *</div></pre></td></tr></table></figure></p>
<h3 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h3><p>当你导入一个模块，Python 解析器对模块位置的搜索顺序是:</p>
<ol>
<li>当前目录</li>
<li>如果不在当前目录，Python 则搜索在 shell 变量 PYTHONPATH 下的每个目录。</li>
<li>如果都找不到，Python会察看默认路径。UNIX下，默认路径一般为/usr/local/lib/python/。</li>
</ol>
<p>模块搜索路径存储在 system 模块的 sys.path 变量中。变量里包含当前目录，PYTHONPATH和由安装过程决定的默认目录。</p>
<h3 id="PYTHONPATH-变量"><a href="#PYTHONPATH-变量" class="headerlink" title="PYTHONPATH 变量"></a>PYTHONPATH 变量</h3><p>作为环境变量，PYTHONPATH 由装在一个列表里的许多目录组成。PYTHONPATH 的语法和 shell 变量 PATH 的一样。<br>在 Windows 系统，典型的 PYTHONPATH 如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">set PYTHONPATH=c:\python27\lib;</div></pre></td></tr></table></figure></p>
<p>在 UNIX 系统，典型的 PYTHONPATH 如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">set PYTHONPATH=/usr/local/lib/python</div></pre></td></tr></table></figure></p>
<h3 id="命名空间和作用域"><a href="#命名空间和作用域" class="headerlink" title="命名空间和作用域"></a>命名空间和作用域</h3><p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。<br>一个 Python 表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。<br>每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。<br>Python 会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。<br>因此，如果要给函数内的全局变量赋值，必须使用 global 语句。<br>global VarName 的表达式会告诉 Python， VarName 是一个全局变量，这样 Python 就不会在局部命名空间里寻找这个变量了。<br>例如，我们在全局命名空间里定义一个变量 Money。我们再在函数内给变量 Money 赋值，然后 Python 会假定 Money 是一个局部变量。然而，我们并没有在访问前声明一个局部变量 Money，结果就是会出现一个 UnboundLocalError 的错误。<br>错误案例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">Money = <span class="number">2000</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddMoney</span><span class="params">()</span>:</span></div><div class="line">   Money = Money + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> Money</div><div class="line">AddMoney()</div><div class="line"><span class="keyword">print</span> Money</div></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2000</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;globalvar.py&quot;, line 8, in &lt;module&gt;</div><div class="line">    AddMoney()</div><div class="line">  File &quot;globalvar.py&quot;, line 6, in AddMoney</div><div class="line">    Money = Money + 1</div><div class="line">UnboundLocalError: local variable &apos;Money&apos; referenced before assignment</div></pre></td></tr></table></figure></p>
<p>改正:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">Money = <span class="number">2000</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">AddMoney</span><span class="params">()</span>:</span></div><div class="line">   <span class="comment"># 给函数内的全局变量赋值，必须使用 global 语句</span></div><div class="line">   <span class="keyword">global</span> Money</div><div class="line">   Money = Money + <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> Money</div><div class="line">AddMoney()</div><div class="line"><span class="keyword">print</span> Money</div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">2000</div><div class="line">2001</div></pre></td></tr></table></figure></p>
<h3 id="dir-函数"><a href="#dir-函数" class="headerlink" title="dir()函数"></a>dir()函数</h3><p>dir() 函数一个排好序的字符串列表，内容是一个模块里定义过的名字。<br>返回的列表容纳了在一个模块里定义的所有模块，变量和函数。如下一个简单的实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 导入内置math模块</span></div><div class="line"><span class="keyword">import</span> math</div><div class="line"></div><div class="line">content = dir(math)</div><div class="line"></div><div class="line"><span class="keyword">print</span> content;</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[&apos;__doc__&apos;, &apos;__file__&apos;, &apos;__name__&apos;, &apos;acos&apos;, &apos;asin&apos;, &apos;atan&apos;,</div><div class="line">&apos;atan2&apos;, &apos;ceil&apos;, &apos;cos&apos;, &apos;cosh&apos;, &apos;degrees&apos;, &apos;e&apos;, &apos;exp&apos;,</div><div class="line">&apos;fabs&apos;, &apos;floor&apos;, &apos;fmod&apos;, &apos;frexp&apos;, &apos;hypot&apos;, &apos;ldexp&apos;, &apos;log&apos;,</div><div class="line">&apos;log10&apos;, &apos;modf&apos;, &apos;pi&apos;, &apos;pow&apos;, &apos;radians&apos;, &apos;sin&apos;, &apos;sinh&apos;,</div><div class="line">&apos;sqrt&apos;, &apos;tan&apos;, &apos;tanh&apos;]</div></pre></td></tr></table></figure></p>
<p>在这里，特殊字符串变量__name<strong>指向模块的名字，\</strong>file__指向该模块的导入文件名。</p>
<h3 id="globals-和-locals-函数"><a href="#globals-和-locals-函数" class="headerlink" title="globals() 和 locals() 函数"></a>globals() 和 locals() 函数</h3><p>根据调用地方的不同，globals() 和 locals() 函数可被用来返回全局和局部命名空间里的名字。<br>如果在函数内部调用 locals()，返回的是所有能在该函数里访问的命名。<br>如果在函数内部调用 globals()，返回的是所有在该函数里能访问的全局名字。<br>两个函数的返回类型都是字典。所以名字们能用 keys() 函数摘取。</p>
<h3 id="reload-函数"><a href="#reload-函数" class="headerlink" title="reload() 函数"></a>reload() 函数</h3><p>当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。<br>因此，如果你想重新执行模块里顶层部分的代码，可以用 reload() 函数。该函数会重新导入之前导入过的模块。语法如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">reload(module_name)</div></pre></td></tr></table></figure></p>
<p>在这里，module_name要直接放模块的名字，而不是一个字符串形式。比如想重载 hello 模块，如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">reload(hello)</div></pre></td></tr></table></figure></p>
<h3 id="Python中的包"><a href="#Python中的包" class="headerlink" title="Python中的包"></a>Python中的包</h3><p>包是一个分层次的文件目录结构，它定义了一个由模块及子包，和子包下的子包等组成的 Python 的应用环境。<br>简单来说，包就是文件夹，但该文件夹下必须存在 <figure class="highlight plain"><figcaption><span>文件, 该文件的内容可以为空。```__int__.py```用于标识当前文件夹是一个包。</span></figcaption><table><tr><td class="code"><pre><div class="line">考虑一个在 package_runoob 目录下的 runoob1.py、runoob2.py、```__init__.py``` 文件，test.py 为测试调用包的代码，目录结构如下:</div><div class="line">test.py</div></pre></td></tr></table></figure></p>
<p>package_runoob<br>|– <strong>init</strong>.py<br>|– runoob1.py<br>|– runoob2.py<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"></div><div class="line">源代码如下:</div><div class="line">package_runoob/runoob1.py</div><div class="line">```python</div><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line"></div><div class="line">def runoob1():</div><div class="line">   print &quot;I&apos;m in runoob1&quot;</div></pre></td></tr></table></figure></p>
<p>package_runoob/runoob2.py<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">runoob2</span><span class="params">()</span>:</span></div><div class="line">   <span class="keyword">print</span> <span class="string">"I'm in runoob2"</span></div></pre></td></tr></table></figure></p>
<p>现在，在 package_runoob 目录下创建 <strong>init</strong>.py:<br>package_runoob/<strong>init</strong>.py<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'作为主程序运行'</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">'package_runoob 初始化'</span></div></pre></td></tr></table></figure></p>
<p>然后我们在 package_runoob 同级目录下创建 test.py 来调用 package_runoob 包<br>test.py<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 导入 Phone 包</span></div><div class="line"><span class="keyword">from</span> package_runoob.runoob1 <span class="keyword">import</span> runoob1</div><div class="line"><span class="keyword">from</span> package_runoob.runoob2 <span class="keyword">import</span> runoob2</div><div class="line"></div><div class="line">runoob1()</div><div class="line">runoob2()</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package_runoob 初始化</div><div class="line">I&apos;m in runoob1</div><div class="line">I&apos;m in runoob2</div></pre></td></tr></table></figure></p>
<p>PS:<br>系统相关的信息模块: import sys<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">sys.argv 是一个 list,包含所有的命令行参数.</div><div class="line">sys.stdout sys.stdin sys.stderr 分别表示标准输入输出,错误输出的文件对象.</div><div class="line">sys.stdin.readline() 从标准输入读一行 sys.stdout.write(&quot;a&quot;) 屏幕输出a</div><div class="line">sys.exit(exit_code) 退出程序</div><div class="line">sys.modules 是一个dictionary，表示系统中所有可用的module</div><div class="line">sys.platform 得到运行的操作系统环境</div><div class="line">sys.path 是一个list,指明所有查找module，package的路径.</div></pre></td></tr></table></figure></p>
<p>操作系统相关的调用和操作: import os<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">os.environ 一个dictionary 包含环境变量的映射关系</div><div class="line">os.environ[&quot;HOME&quot;] 可以得到环境变量HOME的值</div><div class="line">os.chdir(dir) 改变当前目录 os.chdir(&apos;d:\\outlook&apos;)</div><div class="line">注意windows下用到转义</div><div class="line">os.getcwd() 得到当前目录</div><div class="line">os.getegid() 得到有效组id os.getgid() 得到组id</div><div class="line">os.getuid() 得到用户id os.geteuid() 得到有效用户id</div><div class="line">os.setegid os.setegid() os.seteuid() os.setuid()</div><div class="line">os.getgruops() 得到用户组名称列表</div><div class="line">os.getlogin() 得到用户登录名称</div><div class="line">os.getenv 得到环境变量</div><div class="line">os.putenv 设置环境变量</div><div class="line">os.umask 设置umask</div><div class="line">os.system(cmd) 利用系统调用，运行cmd命令</div></pre></td></tr></table></figure></p>
<p>内置模块(不用import就可以直接使用)常用内置函数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">help(obj) 在线帮助, obj可是任何类型</div><div class="line">callable(obj) 查看一个obj是不是可以像函数一样调用</div><div class="line">repr(obj) 得到obj的表示字符串，可以利用这个字符串eval重建该对象的一个拷贝</div><div class="line">eval_r(str) 表示合法的python表达式，返回这个表达式</div><div class="line">dir(obj) 查看obj的name space中可见的name</div><div class="line">hasattr(obj,name) 查看一个obj的name space中是否有name</div><div class="line">getattr(obj,name) 得到一个obj的name space中的一个name</div><div class="line">setattr(obj,name,value) 为一个obj的name</div><div class="line">space中的一个name指向vale这个object</div><div class="line">delattr(obj,name) 从obj的name space中删除一个name</div><div class="line">vars(obj) 返回一个object的name space。用dictionary表示</div><div class="line">locals() 返回一个局部name space,用dictionary表示</div><div class="line">globals() 返回一个全局name space,用dictionary表示</div><div class="line">type(obj) 查看一个obj的类型</div><div class="line">isinstance(obj,cls) 查看obj是不是cls的instance</div><div class="line">issubclass(subcls,supcls) 查看subcls是不是supcls的子类</div><div class="line"></div><div class="line">##################    类型转换  ##################</div><div class="line"></div><div class="line">chr(i) 把一个ASCII数值,变成字符</div><div class="line">ord(i) 把一个字符或者unicode字符,变成ASCII数值</div><div class="line">oct(x) 把整数x变成八进制表示的字符串</div><div class="line">hex(x) 把整数x变成十六进制表示的字符串</div><div class="line">str(obj) 得到obj的字符串描述</div><div class="line">list(seq) 把一个sequence转换成一个list</div><div class="line">tuple(seq) 把一个sequence转换成一个tuple</div><div class="line">dict(),dict(list) 转换成一个dictionary</div><div class="line">int(x) 转换成一个integer</div><div class="line">long(x) 转换成一个long interger</div><div class="line">float(x) 转换成一个浮点数</div><div class="line">complex(x) 转换成复数</div><div class="line">max(...) 求最大值</div><div class="line">min(...) 求最小值</div></pre></td></tr></table></figure></p>
<p>ref: <a href="http://www.runoob.com/python/python-modules.html" target="_blank" rel="external">http://www.runoob.com/python/python-modules.html</a></p>
<h2 id="Python-文件I-O"><a href="#Python-文件I-O" class="headerlink" title="Python 文件I/O"></a>Python 文件I/O</h2><p>本章只讲述所有基本的的I/O函数，更多函数请参考Python标准文档。</p>
<h3 id="打印到屏幕"><a href="#打印到屏幕" class="headerlink" title="打印到屏幕"></a>打印到屏幕</h3><p>最简单的输出方法是用print语句，你可以给它传递零个或多个用逗号隔开的表达式。此函数把你传递的表达式转换成一个字符串表达式，并将结果写到标准输出如下:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">print</span> <span class="string">"Python 是一个非常棒的语言，不是吗？"</span>;</div></pre></td></tr></table></figure></p>
<p>你的标准屏幕上会产生以下结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Python 是一个非常棒的语言，不是吗？</div></pre></td></tr></table></figure></p>
<h3 id="读取键盘输入"><a href="#读取键盘输入" class="headerlink" title="读取键盘输入"></a>读取键盘输入</h3><p>Python提供了两个内置函数从标准输入读入一行文本，默认的标准输入是键盘。如下:</p>
<ul>
<li>raw_input</li>
<li>input</li>
</ul>
<h4 id="raw-input函数"><a href="#raw-input函数" class="headerlink" title="raw_input函数"></a>raw_input函数</h4><p>raw_input([prompt]) 函数从标准输入读取一个行，并返回一个字符串（去掉结尾的换行符）:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">str = raw_input(<span class="string">"请输入:"</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"你输入的内容是: "</span>, str</div></pre></td></tr></table></figure></p>
<p>这将提示你输入任意字符串，然后在屏幕上显示相同的字符串。当我输入”Hello Python！”，它的输出如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">请输入:Hello Python！</div><div class="line">你输入的内容是:  Hello Python！</div></pre></td></tr></table></figure></p>
<h4 id="input函数"><a href="#input函数" class="headerlink" title="input函数"></a>input函数</h4><p>input([prompt]) 函数和 raw_input([prompt]) 函数基本类似，但是 input 可以接收一个Python表达式作为输入，并将运算结果返回。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line">str = input(<span class="string">"请输入:"</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"你输入的内容是: "</span>, str</div></pre></td></tr></table></figure></p>
<p>这会产生如下的对应着输入的结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">请输入:[x*5 for x in range(2,10,2)]</div><div class="line">你输入的内容是:  [10, 20, 30, 40]</div></pre></td></tr></table></figure></p>
<h3 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h3><p>现在，您已经可以向标准输入和输出进行读写。现在，来看看怎么读写实际的数据文件。<br>Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作。</p>
<h4 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h4><p>你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。<br>语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fileobject = open(file_name [, access_mode][, buffering])</div></pre></td></tr></table></figure></p>
<p>各个参数的细节如下:</p>
<ul>
<li>file_name:file_name变量是一个包含了你要访问的文件名称的字符串值。</li>
<li>access_mode:access_mode决定了打开文件的模式:只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。</li>
<li>buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。</li>
</ul>
<p>不同模式打开文件的完全列表:</p>
<table>
<thead>
<tr>
<th>模式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td style="text-align:center">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>rb</td>
<td style="text-align:center">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>r+</td>
<td style="text-align:center">打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>rb+</td>
<td style="text-align:center">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。</td>
</tr>
<tr>
<td>w</td>
<td style="text-align:center">打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb</td>
<td style="text-align:center">以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>w+</td>
<td style="text-align:center">打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>wb+</td>
<td style="text-align:center">以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>a</td>
<td style="text-align:center">打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>ab</td>
<td style="text-align:center">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td>
</tr>
<tr>
<td>a+</td>
<td style="text-align:center">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td>
</tr>
<tr>
<td>ab+</td>
<td style="text-align:center">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td>
</tr>
</tbody>
</table>
<h3 id="File对象的属性"><a href="#File对象的属性" class="headerlink" title="File对象的属性"></a>File对象的属性</h3><p>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。<br>以下是和file对象相关的所有属性的列表:</p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>file.closed</td>
<td style="text-align:center">返回true如果文件已被关闭，否则返回false。</td>
</tr>
<tr>
<td>file.mode</td>
<td style="text-align:center">返回被打开文件的访问模式。</td>
</tr>
<tr>
<td>file.name</td>
<td style="text-align:center">返回文件的名称。</td>
</tr>
<tr>
<td>file.softspace</td>
<td style="text-align:center">如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td>
</tr>
</tbody>
</table>
<p>如下实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"wb"</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"文件名: "</span>, fo.name</div><div class="line"><span class="keyword">print</span> <span class="string">"是否已关闭 : "</span>, fo.closed</div><div class="line"><span class="keyword">print</span> <span class="string">"访问模式 : "</span>, fo.mode</div><div class="line"><span class="keyword">print</span> <span class="string">"末尾是否强制加空格 : "</span>, fo.softspace</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">文件名:  foo.txt</div><div class="line">是否已关闭 :  False</div><div class="line">访问模式 :  wb</div><div class="line">末尾是否强制加空格 :  0</div></pre></td></tr></table></figure></p>
<h4 id="close-方法"><a href="#close-方法" class="headerlink" title="close()方法"></a>close()方法</h4><p>File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。<br>当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。<br>语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fileObject.close();</div></pre></td></tr></table></figure></p>
<p>例子:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"wb"</span>)</div><div class="line"><span class="keyword">print</span> <span class="string">"文件名: "</span>, fo.name</div><div class="line"></div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">文件名:  foo.txt</div></pre></td></tr></table></figure></p>
<h4 id="write-方法"><a href="#write-方法" class="headerlink" title="write()方法"></a>write()方法</h4><p>write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。<br>write()方法不会在字符串的结尾添加换行符(‘\n’):<br>语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fileObject.write(string);</div></pre></td></tr></table></figure></p>
<p>在这里，被传递的参数是要写入到已打开文件的内容。<br>例子:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"wb"</span>)</div><div class="line">fo.write( <span class="string">"www.runoob.com!\nVery good site!\n"</span>);</div><div class="line"></div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p>
<p>上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cat foo.txt</div><div class="line">www.runoob.com!</div><div class="line">Very good site!</div></pre></td></tr></table></figure></p>
<h4 id="read-方法"><a href="#read-方法" class="headerlink" title="read()方法"></a>read()方法</h4><p>read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。<br>语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">fileObject.read([count]);</div></pre></td></tr></table></figure></p>
<p>在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。</p>
<p>例子:<br>这里我们用到以上创建的 foo.txt 文件。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"r+"</span>)</div><div class="line">str = fo.read(<span class="number">10</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"读取的字符串是 : "</span>, str</div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">读取的字符串是 :  www.runoob</div></pre></td></tr></table></figure></p>
<h3 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h3><p>tell()方法告诉你文件内的当前位置；换句话说，下一次的读写会发生在文件开头这么多字节之后。<br>seek（offset [,from]）方法改变当前文件的位置。offset变量表示要移动的字节数。from变量指定开始移动字节的参考位置。<br>如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。<br>例子:<br>就用我们上面创建的文件foo.txt。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 打开一个文件</span></div><div class="line">fo = open(<span class="string">"foo.txt"</span>, <span class="string">"r+"</span>)</div><div class="line">str = fo.read(<span class="number">10</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"读取的字符串是 : "</span>, str</div><div class="line"></div><div class="line"><span class="comment"># 查找当前位置</span></div><div class="line">position = fo.tell();</div><div class="line"><span class="keyword">print</span> <span class="string">"当前文件位置 : "</span>, position</div><div class="line"></div><div class="line"><span class="comment"># 把指针再次重新定位到文件开头</span></div><div class="line">position = fo.seek(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">str = fo.read(<span class="number">10</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"重新读取字符串 : "</span>, str</div><div class="line"><span class="comment"># 关闭打开的文件</span></div><div class="line">fo.close()</div></pre></td></tr></table></figure></p>
<p>以上实例输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">读取的字符串是 :  www.runoob</div><div class="line">当前文件位置 :  10</div><div class="line">重新读取字符串 :  www.runoob</div></pre></td></tr></table></figure></p>
<h3 id="重命名和删除文件"><a href="#重命名和删除文件" class="headerlink" title="重命名和删除文件"></a>重命名和删除文件</h3><p>Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。<br>要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。</p>
<h4 id="rename-方法"><a href="#rename-方法" class="headerlink" title="rename()方法:"></a>rename()方法:</h4><p>rename()方法需要两个参数，当前的文件名和新文件名。<br>语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">os.rename(current_file_name, new_file_name)</div></pre></td></tr></table></figure></p>
<p>例子:<br>下例将重命名一个已经存在的文件test1.txt。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># 重命名文件test1.txt到test2.txt。</span></div><div class="line">os.rename( <span class="string">"test1.txt"</span>, <span class="string">"test2.txt"</span> )</div></pre></td></tr></table></figure></p>
<h4 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove()方法"></a>remove()方法</h4><p>你可以用remove()方法删除文件，需要提供要删除的文件名作为参数。<br>语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">os.remove(file_name)</div></pre></td></tr></table></figure></p>
<p>例子:<br>下例将删除一个已经存在的文件test2.txt。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># 删除一个已经存在的文件test2.txt</span></div><div class="line">os.remove(<span class="string">"test2.txt"</span>)</div></pre></td></tr></table></figure></p>
<h3 id="Python里的目录"><a href="#Python里的目录" class="headerlink" title="Python里的目录:"></a>Python里的目录:</h3><p>所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。</p>
<h4 id="mkdir-方法"><a href="#mkdir-方法" class="headerlink" title="mkdir()方法"></a>mkdir()方法</h4><p>可以使用os模块的mkdir()方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。<br>语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">os.mkdir(&quot;newdir&quot;)</div></pre></td></tr></table></figure></p>
<p>例子:<br>下例将在当前目录下创建一个新目录test。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># 创建目录test</span></div><div class="line">os.mkdir(<span class="string">"test"</span>)</div></pre></td></tr></table></figure></p>
<h4 id="chdir-方法"><a href="#chdir-方法" class="headerlink" title="chdir()方法"></a>chdir()方法</h4><p>可以用chdir()方法来改变当前的目录。chdir()方法需要的一个参数是你想设成当前目录的目录名称。<br>语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">os.chdir(&quot;newdir&quot;)</div></pre></td></tr></table></figure></p>
<p>例子:<br>下例将进入”/home/newdir”目录。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># 将当前目录改为"/home/newdir"</span></div><div class="line">os.chdir(<span class="string">"/home/newdir"</span>)</div></pre></td></tr></table></figure></p>
<h4 id="getcwd-方法"><a href="#getcwd-方法" class="headerlink" title="getcwd()方法:"></a>getcwd()方法:</h4><p>getcwd()方法显示当前的工作目录。<br>语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">os.getcwd()</div></pre></td></tr></table></figure></p>
<p>例子:<br>下例给出当前目录:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/usr/bin/python</div><div class="line"># -*- coding: UTF-8 -*-</div><div class="line"></div><div class="line">import os</div><div class="line"></div><div class="line"># 给出当前的目录</div><div class="line">print os.getcwd()</div></pre></td></tr></table></figure></p>
<h4 id="rmdir-方法"><a href="#rmdir-方法" class="headerlink" title="rmdir()方法"></a>rmdir()方法</h4><p>rmdir()方法删除目录，目录名称以参数传递。<br>在删除这个目录之前，它的所有内容应该先被清除。<br>语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">os.rmdir(&apos;dirname&apos;)</div></pre></td></tr></table></figure></p>
<p>例子:<br>以下是删除” /tmp/test”目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment"># 删除”/tmp/test”目录</span></div><div class="line">os.rmdir( <span class="string">"/tmp/test"</span>  )</div></pre></td></tr></table></figure></p>
<h3 id="文件、目录相关的方法"><a href="#文件、目录相关的方法" class="headerlink" title="文件、目录相关的方法"></a>文件、目录相关的方法</h3><p>三个重要的方法来源能对Windows和Unix操作系统上的文件及目录进行一个广泛且实用的处理及操控，如下:</p>
<ul>
<li><a href="http://www.runoob.com/python/file-methods.html" target="_blank" rel="external">File 对象方法</a>: file对象提供了操作文件的一系列方法。</li>
<li><a href="http://www.runoob.com/python/os-file-methods.html" target="_blank" rel="external">OS 对象方法</a>: 提供了处理文件及目录的一系列方法。</li>
</ul>
<p>ref: <a href="http://www.runoob.com/python/python-files-io.html" target="_blank" rel="external">http://www.runoob.com/python/python-files-io.html</a></p>
<h2 id="Python-File-文件-方法"><a href="#Python-File-文件-方法" class="headerlink" title="Python File(文件) 方法"></a>Python File(文件) 方法</h2><p>file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>file.close()</td>
<td style="text-align:center">关闭文件。关闭后文件不能再进行读写操作。</td>
</tr>
<tr>
<td>file.flush()</td>
<td style="text-align:center">刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。</td>
</tr>
<tr>
<td>file.fileno()</td>
<td style="text-align:center">返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。</td>
</tr>
<tr>
<td>file.isatty()</td>
<td style="text-align:center">如果文件连接到一个终端设备返回 True，否则返回 False。</td>
</tr>
<tr>
<td>file.next()</td>
<td style="text-align:center">返回文件下一行。</td>
</tr>
<tr>
<td>file.read([size])</td>
<td style="text-align:center">从文件读取指定的字节数，如果未给定或为负则读取所有。</td>
</tr>
<tr>
<td>file.readline([size])</td>
<td style="text-align:center">读取整行，包括 “\n” 字符。</td>
</tr>
<tr>
<td>file.readlines([sizehint])</td>
<td style="text-align:center">读取所有行并返回列表，若给定sizeint&gt;0，返回总和大约为sizeint字节的行, 实际读取值可能比sizhint较大, 因为需要填充缓冲区。</td>
</tr>
<tr>
<td>file.seek(offset[, whence])</td>
<td style="text-align:center">设置文件当前位置</td>
</tr>
<tr>
<td>file.tell()</td>
<td style="text-align:center">返回文件当前位置。</td>
</tr>
<tr>
<td>file.truncate([size])</td>
<td style="text-align:center">截取文件，截取的字节通过size指定，默认为当前文件位置。</td>
</tr>
<tr>
<td>file.write(str)</td>
<td style="text-align:center">将字符串写入文件，没有返回值。</td>
</tr>
<tr>
<td>file.writelines(sequence)</td>
<td style="text-align:center">向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。</td>
</tr>
</tbody>
</table>
<p>PS:<br>在 write 内容后，直接 read 文件输出会为空，是因为指针已经在内容末尾。<br>两种解决方式: 其一，先 close 文件，open 后再读取，其二，可以设置指针回到文件最初后再 read<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> os;</div><div class="line"></div><div class="line">document = open(<span class="string">"testfile.txt"</span>, <span class="string">"w+"</span>);</div><div class="line"><span class="keyword">print</span> <span class="string">"文件名: "</span>, document.name;</div><div class="line">document.write(<span class="string">"这是我创建的第一个测试文件！\nwelcome!"</span>);</div><div class="line"><span class="keyword">print</span> document.tell();</div><div class="line"><span class="comment">#输出当前指针位置</span></div><div class="line">document.seek(os.SEEK_SET);</div><div class="line"><span class="comment">#设置指针回到文件最初</span></div><div class="line">context = document.read();</div><div class="line"><span class="keyword">print</span> context;</div><div class="line">document.close();</div></pre></td></tr></table></figure></p>
<p>ref: <a href="http://www.runoob.com/python/file-methods.html" target="_blank" rel="external">http://www.runoob.com/python/file-methods.html</a></p>
<h2 id="Python-OS-文件-目录方法"><a href="#Python-OS-文件-目录方法" class="headerlink" title="Python OS 文件/目录方法"></a>Python OS 文件/目录方法</h2><p>os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>os.access(path, mode)</td>
<td style="text-align:center">检验权限模式</td>
</tr>
<tr>
<td>os.chdir(path)</td>
<td style="text-align:center">改变当前工作目录</td>
</tr>
<tr>
<td>os.chflags(path, flags)</td>
<td style="text-align:center">设置路径的标记为数字标记。</td>
</tr>
<tr>
<td>os.chmod(path, mode)</td>
<td style="text-align:center">更改权限</td>
</tr>
<tr>
<td>os.chown(path, uid, gid)</td>
<td style="text-align:center">更改文件所有者</td>
</tr>
<tr>
<td>os.chroot(path)</td>
<td style="text-align:center">改变当前进程的根目录</td>
</tr>
<tr>
<td>os.close(fd)</td>
<td style="text-align:center">关闭文件描述符 fd</td>
</tr>
<tr>
<td>os.closerange(fd_low, fd_high)</td>
<td style="text-align:center">关闭所有文件描述符，从 fd_low (包含)</td>
<td>到 fd_high (不包含), 错误会忽略</td>
</tr>
<tr>
<td>os.dup(fd)</td>
<td style="text-align:center">复制文件描述符 fd</td>
</tr>
<tr>
<td>os.dup2(fd, fd2)</td>
<td style="text-align:center">将一个文件描述符 fd 复制到另一个 fd2</td>
</tr>
<tr>
<td>os.fchdir(fd)</td>
<td style="text-align:center">通过文件描述符改变当前工作目录</td>
</tr>
<tr>
<td>os.fchmod(fd, mode)</td>
<td style="text-align:center">改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。</td>
</tr>
<tr>
<td>os.fchown(fd, uid, gid)</td>
<td style="text-align:center">修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。</td>
</tr>
<tr>
<td>os.fdatasync(fd)</td>
<td style="text-align:center">强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。</td>
</tr>
<tr>
<td>os.fdopen(fd[, mode[, bufsize]])</td>
<td style="text-align:center">通过文件描述符 fd 创建一个文件对象，并返回这个文件对象</td>
</tr>
<tr>
<td>os.fpathconf(fd, name)</td>
<td style="text-align:center">返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。</td>
</tr>
<tr>
<td>os.fstat(fd)</td>
<td style="text-align:center">返回文件描述符fd的状态，像stat()。</td>
</tr>
<tr>
<td>os.fstatvfs(fd)</td>
<td style="text-align:center">返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()</td>
</tr>
<tr>
<td>os.fsync(fd)</td>
<td style="text-align:center">强制将文件描述符为fd的文件写入硬盘。</td>
</tr>
<tr>
<td>os.ftruncate(fd, length)</td>
<td style="text-align:center">裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。</td>
</tr>
<tr>
<td>os.getcwd()</td>
<td style="text-align:center">返回当前工作目录</td>
</tr>
<tr>
<td>os.getcwdu()</td>
<td style="text-align:center">返回一个当前工作目录的Unicode对象</td>
</tr>
<tr>
<td>os.isatty(fd)</td>
<td style="text-align:center">如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。</td>
</tr>
<tr>
<td>os.lchflags(path, flags)</td>
<td style="text-align:center">设置路径的标记为数字标记，类似 chflags()，但是没有软链接</td>
</tr>
<tr>
<td>os.lchmod(path, mode)</td>
<td style="text-align:center">修改连接文件权限</td>
</tr>
<tr>
<td>os.lchown(path, uid, gid)</td>
<td style="text-align:center">更改文件所有者，类似 chown，但是不追踪链接。</td>
</tr>
<tr>
<td>os.link(src, dst)</td>
<td style="text-align:center">创建硬链接，名为参数 dst，指向参数 src</td>
</tr>
<tr>
<td>os.listdir(path)</td>
<td style="text-align:center">返回path指定的文件夹包含的文件或文件夹的名字的列表。</td>
</tr>
<tr>
<td>os.lseek(fd, pos, how)</td>
<td style="text-align:center">设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效</td>
</tr>
<tr>
<td>os.lstat(path)</td>
<td style="text-align:center">像stat(),但是没有软链接</td>
</tr>
<tr>
<td>os.major(device)</td>
<td style="text-align:center">从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。</td>
</tr>
<tr>
<td>os.makedev(major, minor)</td>
<td style="text-align:center">以major和minor设备号组成一个原始设备号</td>
</tr>
<tr>
<td>os.makedirs(path[, mode])</td>
<td style="text-align:center">递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。</td>
</tr>
<tr>
<td>os.minor(device)</td>
<td style="text-align:center">从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。</td>
</tr>
<tr>
<td>os.mkdir(path[, mode])</td>
<td style="text-align:center">以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。</td>
</tr>
<tr>
<td>os.mkfifo(path[, mode])</td>
<td style="text-align:center">创建命名管道，mode 为数字，默认为 0666 (八进制)</td>
</tr>
<tr>
<td>os.mknod(filename[, mode=0600, device])</td>
<td style="text-align:center">创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。</td>
</tr>
<tr>
<td>os.open(file, flags[, mode])</td>
<td style="text-align:center">打开一个文件，并且设置需要的打开选项，mode参数是可选的</td>
</tr>
<tr>
<td>os.openpty()</td>
<td style="text-align:center">打开一个新的伪终端对。返回 pty 和 tty的文件描述符。</td>
</tr>
<tr>
<td>os.pathconf(path, name)</td>
<td style="text-align:center">返回相关文件的系统配置信息。</td>
</tr>
<tr>
<td>os.pipe()</td>
<td style="text-align:center">创建一个管道. 返回一对文件描述符(r, w)</td>
<td>分别为读和写</td>
</tr>
<tr>
<td>os.popen(command[, mode[, bufsize]])</td>
<td style="text-align:center">从一个 command 打开一个管道</td>
</tr>
<tr>
<td>os.read(fd, n)</td>
<td style="text-align:center">从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。</td>
</tr>
<tr>
<td>os.readlink(path)</td>
<td style="text-align:center">返回软链接所指向的文件</td>
</tr>
<tr>
<td>os.remove(path)</td>
<td style="text-align:center">删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。</td>
</tr>
<tr>
<td>os.removedirs(path)</td>
<td style="text-align:center">递归删除目录。</td>
</tr>
<tr>
<td>os.rename(src, dst)</td>
<td style="text-align:center">重命名文件或目录，从 src 到 dst</td>
</tr>
<tr>
<td>os.renames(old, new)</td>
<td style="text-align:center">递归地对目录进行更名，也可以对文件进行更名。</td>
</tr>
<tr>
<td>os.rmdir(path)</td>
<td style="text-align:center">删除path指定的空目录，如果目录非空，则抛出一个OSError异常。</td>
</tr>
<tr>
<td>os.stat(path)</td>
<td style="text-align:center">获取path指定的路径的信息，功能等同于C API中的stat()系统调用。</td>
</tr>
<tr>
<td>os.stat_float_times([newvalue])</td>
<td style="text-align:center">决定stat_result是否以float对象显示时间戳</td>
</tr>
<tr>
<td>os.statvfs(path)</td>
<td style="text-align:center">获取指定路径的文件系统统计信息</td>
</tr>
<tr>
<td>os.symlink(src, dst)</td>
<td style="text-align:center">创建一个软链接</td>
</tr>
<tr>
<td>os.tcgetpgrp(fd)</td>
<td style="text-align:center">返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组</td>
</tr>
<tr>
<td>os.tcsetpgrp(fd, pg)</td>
<td style="text-align:center">设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。</td>
</tr>
<tr>
<td>os.tempnam([dir[, prefix]])</td>
<td style="text-align:center">返回唯一的路径名用于创建临时文件。</td>
</tr>
<tr>
<td>os.tmpfile()</td>
<td style="text-align:center">返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。</td>
</tr>
<tr>
<td>os.tmpnam()</td>
<td style="text-align:center">为创建一个临时文件返回一个唯一的路径</td>
</tr>
<tr>
<td>os.ttyname(fd)</td>
<td style="text-align:center">返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。</td>
</tr>
<tr>
<td>os.unlink(path)</td>
<td style="text-align:center">删除文件路径</td>
</tr>
<tr>
<td>os.utime(path, times)</td>
<td style="text-align:center">返回指定的path文件的访问和修改的时间。</td>
</tr>
<tr>
<td>os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])</td>
<td style="text-align:center">输出在文件夹中的文件名通过在树中游走，向上或者向下。</td>
</tr>
<tr>
<td>os.write(fd, str)</td>
<td style="text-align:center">写入字符串到文件描述符 fd中. 返回实际写入的字符串长度</td>
</tr>
</tbody>
</table>
<p>ref:<br><a href="http://www.runoob.com/python/os-file-methods.html" target="_blank" rel="external">http://www.runoob.com/python/os-file-methods.html</a><br><a href="http://python.usyiyi.cn/python_278/library/os.html" target="_blank" rel="external">http://python.usyiyi.cn/python_278/library/os.html</a></p>
<h2 id="Python-异常处理"><a href="#Python-异常处理" class="headerlink" title="Python 异常处理"></a>Python 异常处理</h2><p>python提供了两个非常重要的功能来处理python程序在运行中出现的异常和错误。你可以使用该功能来调试python程序。</p>
<ul>
<li>异常处理: 本站Python教程会具体介绍。</li>
<li>断言(Assertions):本站Python教程会具体介绍。</li>
</ul>
<h3 id="python标准异常"><a href="#python标准异常" class="headerlink" title="python标准异常"></a>python标准异常</h3><table>
<thead>
<tr>
<th>异常名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>BaseException</td>
<td style="text-align:center">所有异常的基类</td>
</tr>
<tr>
<td>SystemExit</td>
<td style="text-align:center">解释器请求退出</td>
</tr>
<tr>
<td>KeyboardInterrupt</td>
<td style="text-align:center">用户中断执行(通常是输入^C)</td>
</tr>
<tr>
<td>Exception</td>
<td style="text-align:center">常规错误的基类</td>
</tr>
<tr>
<td>StopIteration</td>
<td style="text-align:center">迭代器没有更多的值</td>
</tr>
<tr>
<td>GeneratorExit</td>
<td style="text-align:center">生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td>StandardError</td>
<td style="text-align:center">所有的内建标准异常的基类</td>
</tr>
<tr>
<td>ArithmeticError</td>
<td style="text-align:center">所有数值计算错误的基类</td>
</tr>
<tr>
<td>FloatingPointError</td>
<td style="text-align:center">浮点计算错误</td>
</tr>
<tr>
<td>OverflowError</td>
<td style="text-align:center">数值运算超出最大限制</td>
</tr>
<tr>
<td>ZeroDivisionError</td>
<td style="text-align:center">除(或取模)零 (所有数据类型)</td>
</tr>
<tr>
<td>AssertionError</td>
<td style="text-align:center">断言语句失败</td>
</tr>
<tr>
<td>AttributeError</td>
<td style="text-align:center">对象没有这个属性</td>
</tr>
<tr>
<td>EOFError</td>
<td style="text-align:center">没有内建输入,到达EOF 标记</td>
</tr>
<tr>
<td>EnvironmentError</td>
<td style="text-align:center">操作系统错误的基类</td>
</tr>
<tr>
<td>IOError</td>
<td style="text-align:center">输入/输出操作失败</td>
</tr>
<tr>
<td>OSError</td>
<td style="text-align:center">操作系统错误</td>
</tr>
<tr>
<td>WindowsError</td>
<td style="text-align:center">系统调用失败</td>
</tr>
<tr>
<td>ImportError</td>
<td style="text-align:center">导入模块/对象失败</td>
</tr>
<tr>
<td>LookupError</td>
<td style="text-align:center">无效数据查询的基类</td>
</tr>
<tr>
<td>IndexError</td>
<td style="text-align:center">序列中没有此索引(index)</td>
</tr>
<tr>
<td>KeyError</td>
<td style="text-align:center">映射中没有这个键</td>
</tr>
<tr>
<td>MemoryError</td>
<td style="text-align:center">内存溢出错误(对于Python 解释器不是致命的)</td>
</tr>
<tr>
<td>NameError</td>
<td style="text-align:center">未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td>UnboundLocalError</td>
<td style="text-align:center">访问未初始化的本地变量</td>
</tr>
<tr>
<td>ReferenceError</td>
<td style="text-align:center">弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td>RuntimeError</td>
<td style="text-align:center">一般的运行时错误</td>
</tr>
<tr>
<td>NotImplementedError</td>
<td style="text-align:center">尚未实现的方法</td>
</tr>
<tr>
<td>SyntaxError</td>
<td style="text-align:center">Python 语法错误</td>
</tr>
<tr>
<td>IndentationError</td>
<td style="text-align:center">缩进错误</td>
</tr>
<tr>
<td>TabError</td>
<td style="text-align:center">Tab 和空格混用</td>
</tr>
<tr>
<td>SystemError</td>
<td style="text-align:center">一般的解释器系统错误</td>
</tr>
<tr>
<td>TypeError</td>
<td style="text-align:center">对类型无效的操作</td>
</tr>
<tr>
<td>ValueError</td>
<td style="text-align:center">传入无效的参数</td>
</tr>
<tr>
<td>UnicodeError</td>
<td style="text-align:center">Unicode 相关的错误</td>
</tr>
<tr>
<td>UnicodeDecodeError</td>
<td style="text-align:center">Unicode 解码时的错误</td>
</tr>
<tr>
<td>UnicodeEncodeError</td>
<td style="text-align:center">Unicode 编码时错误</td>
</tr>
<tr>
<td>UnicodeTranslateError</td>
<td style="text-align:center">Unicode 转换时错误</td>
</tr>
<tr>
<td>Warning</td>
<td style="text-align:center">警告的基类</td>
</tr>
<tr>
<td>DeprecationWarning</td>
<td style="text-align:center">关于被弃用的特征的警告</td>
</tr>
<tr>
<td>FutureWarning</td>
<td style="text-align:center">关于构造将来语义会有改变的警告</td>
</tr>
<tr>
<td>OverflowWarning</td>
<td style="text-align:center">旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td>PendingDeprecationWarning</td>
<td style="text-align:center">关于特性将会被废弃的警告</td>
</tr>
<tr>
<td>RuntimeWarning</td>
<td style="text-align:center">可疑的运行时行为(runtime behavior)的警告</td>
</tr>
<tr>
<td>SyntaxWarning</td>
<td style="text-align:center">可疑的语法的警告</td>
</tr>
<tr>
<td>UserWarning</td>
<td style="text-align:center">用户代码生成的警告</td>
</tr>
</tbody>
</table>
<h3 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h3><p>异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。<br>一般情况下，在Python无法正常处理程序时就会发生一个异常。<br>异常是Python对象，表示一个错误。<br>当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>捕捉异常可以使用try/except语句。<br>try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。<br>如果你不想在异常发生时结束你的程序，只需在try里捕获它。<br>语法:<br>以下为简单的try….except…else的语法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">try:</div><div class="line">&lt;语句&gt;        #运行别的代码</div><div class="line">except &lt;名字&gt;:</div><div class="line">&lt;语句&gt;        #如果在try部份引发了&apos;name&apos;异常</div><div class="line">except &lt;名字&gt;，&lt;数据&gt;:</div><div class="line">&lt;语句&gt;        #如果引发了&apos;name&apos;异常，获得附加的数据</div><div class="line">else:</div><div class="line">&lt;语句&gt;        #如果没有异常发生</div></pre></td></tr></table></figure></p>
<p>try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。</p>
<ul>
<li>如果当try后的语句执行时发生异常，python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。</li>
<li>如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印缺省的出错信息）。</li>
<li>如果在try子句执行时没有发生异常，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。</li>
</ul>
<p>实例<br>下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，且并未发生异常:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    fh = open(<span class="string">"testfile"</span>, <span class="string">"w"</span>)</div><div class="line">    fh.write(<span class="string">"这是一个测试文件，用于测试异常!!"</span>)</div><div class="line"><span class="keyword">except</span> IOError:</div><div class="line">    <span class="keyword">print</span> <span class="string">"Error: 没有找到文件或读取文件失败"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"内容写入文件成功"</span></div><div class="line">    fh.close()</div></pre></td></tr></table></figure></p>
<p>以上程序输出结果:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ python test.py</div><div class="line">内容写入文件成功</div><div class="line">$ cat testfile       # 查看写入的内容</div><div class="line">这是一个测试文件，用于测试异常!!</div></pre></td></tr></table></figure></p>
<p>实例<br>下面是简单的例子，它打开一个文件，在该文件中的内容写入内容，但文件没有写入权限，发生了异常:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    fh = open(<span class="string">"testfile"</span>, <span class="string">"w"</span>)</div><div class="line">    fh.write(<span class="string">"这是一个测试文件，用于测试异常!!"</span>)</div><div class="line"><span class="keyword">except</span> IOError:</div><div class="line">    <span class="keyword">print</span> <span class="string">"Error: 没有找到文件或读取文件失败"</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"内容写入文件成功"</span></div><div class="line">    fh.close()</div></pre></td></tr></table></figure></p>
<p>在执行代码前为了测试方便，我们可以先去掉 testfile 文件的写权限，命令如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">chmod -w testfile</div></pre></td></tr></table></figure></p>
<p>再执行以上代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ python test.py</div><div class="line">Error: 没有找到文件或读取文件失败</div></pre></td></tr></table></figure></p>
<h3 id="使用except而不带任何异常类型"><a href="#使用except而不带任何异常类型" class="headerlink" title="使用except而不带任何异常类型"></a>使用except而不带任何异常类型</h3><p>你可以不带任何异常类型使用except，如下实例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">try:</div><div class="line">    正常的操作</div><div class="line">   ......................</div><div class="line">except:</div><div class="line">    发生异常，执行这块代码</div><div class="line">   ......................</div><div class="line">else:</div><div class="line">    如果没有异常执行这块代码</div></pre></td></tr></table></figure></p>
<p>以上方式try-except语句捕获所有发生的异常。但这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息。因为它捕获所有的异常。</p>
<h3 id="使用except而带多种异常类型"><a href="#使用except而带多种异常类型" class="headerlink" title="使用except而带多种异常类型"></a>使用except而带多种异常类型</h3><p>你也可以使用相同的except语句来处理多个异常信息，如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">try:</div><div class="line">    正常的操作</div><div class="line">   ......................</div><div class="line">except(Exception1[, Exception2[,...ExceptionN]]]):</div><div class="line">   发生以上多个异常中的一个，执行这块代码</div><div class="line">   ......................</div><div class="line">else:</div><div class="line">    如果没有异常执行这块代码</div></pre></td></tr></table></figure></p>
<h3 id="try-finally-语句"><a href="#try-finally-语句" class="headerlink" title="try-finally 语句"></a>try-finally 语句</h3><p>try-finally 语句无论是否发生异常都将执行最后的代码。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">try:</div><div class="line">&lt;语句&gt;</div><div class="line">finally:</div><div class="line">&lt;语句&gt;    #退出try时总会执行</div><div class="line">raise</div></pre></td></tr></table></figure></p>
<p>实例<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    fh = open(<span class="string">"testfile"</span>, <span class="string">"w"</span>)</div><div class="line">    fh.write(<span class="string">"这是一个测试文件，用于测试异常!!"</span>)</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    <span class="keyword">print</span> <span class="string">"Error: 没有找到文件或读取文件失败"</span></div></pre></td></tr></table></figure></p>
<p>如果打开的文件没有可写权限，输出如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ python test.py</div><div class="line">Error: 没有找到文件或读取文件失败</div></pre></td></tr></table></figure></p>
<p>同样的例子也可以写成如下方式:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    fh = open(<span class="string">"testfile"</span>, <span class="string">"w"</span>)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        fh.write(<span class="string">"这是一个测试文件，用于测试异常!!"</span>)</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        <span class="keyword">print</span> <span class="string">"关闭文件"</span></div><div class="line">        fh.close()</div><div class="line"><span class="keyword">except</span> IOError:</div><div class="line">    <span class="keyword">print</span> <span class="string">"Error: 没有找到文件或读取文件失败"</span></div></pre></td></tr></table></figure></p>
<p>当在try块中抛出一个异常，立即执行finally块代码。<br>finally块中的所有语句执行后，异常被再次触发，并执行except块代码。<br>参数的内容不同于异常。</p>
<h3 id="异常的参数"><a href="#异常的参数" class="headerlink" title="异常的参数"></a>异常的参数</h3><p>一个异常可以带上参数，可作为输出的异常信息参数。<br>你可以通过except语句来捕获异常的参数，如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">try:</div><div class="line">    正常的操作</div><div class="line">   ......................</div><div class="line">except ExceptionType, Argument:</div><div class="line">    你可以在这输出 Argument 的值...</div></pre></td></tr></table></figure></p>
<p>实例<br>以下为单个异常的实例:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 定义函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">temp_convert</span><span class="params">(var)</span>:</span></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">return</span> int(var)</div><div class="line">    <span class="keyword">except</span> ValueError, Argument:</div><div class="line">        <span class="keyword">print</span> <span class="string">"参数没有包含数字\n"</span>, Argument</div><div class="line"></div><div class="line"><span class="comment"># 调用函数</span></div><div class="line">temp_convert(<span class="string">"xyz"</span>);</div></pre></td></tr></table></figure></p>
<p>以上程序执行结果如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ python test.py</div><div class="line">参数没有包含数字</div><div class="line">invalid literal for int() with base 10: &apos;xyz&apos;</div></pre></td></tr></table></figure></p>
<p>变量接收的异常值通常包含在异常的语句中。在元组的表单中变量可以接收一个或者多个值。<br>元组通常包含错误字符串，错误数字，错误位置。</p>
<h4 id="触发异常"><a href="#触发异常" class="headerlink" title="触发异常"></a>触发异常</h4><p>我们可以使用raise语句自己触发异常<br>raise语法格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">raise [Exception [, args [, traceback]]]</div></pre></td></tr></table></figure></p>
<p>语句中Exception是异常的类型（例如，NameError）参数是一个异常参数值。该参数是可选的，如果不提供，异常的参数是”None”。<br>最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。</p>
<p>一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。<br>定义一个异常非常简单，如下所示:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">functionName</span><span class="params">( level )</span>:</span></div><div class="line">    <span class="keyword">if</span> level &lt; <span class="number">1</span>:</div><div class="line">        <span class="keyword">raise</span> Exception(<span class="string">"Invalid level!"</span>, level)</div><div class="line">        <span class="comment"># 触发异常后，后面的代码就不会再执行</span></div></pre></td></tr></table></figure></p>
<p>注意:为了能够捕获异常，”except”语句必须有用相同的异常来抛出类对象或者字符串。<br>例如我们捕获以上异常，”except”语句如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">try:</div><div class="line">    正常逻辑</div><div class="line">except &quot;Invalid level!&quot;:</div><div class="line">    触发自定义异常</div><div class="line">else:</div><div class="line">    其余代码</div></pre></td></tr></table></figure></p>
<p>实例<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/python</span></div><div class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></div><div class="line"></div><div class="line"><span class="comment"># 定义函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mye</span><span class="params">( level )</span>:</span></div><div class="line">    <span class="keyword">if</span> level &lt; <span class="number">1</span>:</div><div class="line">        <span class="keyword">raise</span> Exception(<span class="string">"Invalid level!"</span>, level)</div><div class="line">        <span class="comment"># 触发异常后，后面的代码就不会再执行</span></div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    mye(<span class="number">0</span>)                // 触发异常</div><div class="line"><span class="keyword">except</span> <span class="string">"Invalid level!"</span>:</div><div class="line">    <span class="keyword">print</span> <span class="number">1</span></div><div class="line"><span class="keyword">else</span>:</div><div class="line">    <span class="keyword">print</span> <span class="number">2</span></div></pre></td></tr></table></figure></p>
<p>执行以上代码，输出结果为:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ python test.py</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;test.py&quot;, line 11, in &lt;module&gt;</div><div class="line">    mye(0)</div><div class="line">  File &quot;test.py&quot;, line 7, in mye</div><div class="line">    raise Exception(&quot;Invalid level!&quot;, level)</div><div class="line">Exception: (&apos;Invalid level!&apos;, 0)</div></pre></td></tr></table></figure></p>
<h3 id="用户自定义异常"><a href="#用户自定义异常" class="headerlink" title="用户自定义异常"></a>用户自定义异常</h3><p>通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。<br>以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。<br>在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Networkerror</span><span class="params">(RuntimeError)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, arg)</span>:</span></div><div class="line">        self.args = arg</div></pre></td></tr></table></figure></p>
<p>在你定义以上类后，你可以触发该异常，如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">try:</div><div class="line">    raise Networkerror(&quot;Bad hostname&quot;)</div><div class="line">except Networkerror,e:</div><div class="line">    print e.args</div></pre></td></tr></table></figure></p>
<p>ref: <a href="http://www.runoob.com/python/python-exceptions.html" target="_blank" rel="external">http://www.runoob.com/python/python-exceptions.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_Excption_URISyntaxException的解决办法</title>
    <url>/2017/08/14/Java-Excption-URISyntaxException%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>URISyntaxException的解决办法</p>
<a id="more"></a>
<p>近日在用HttpClient访问抓取汇率时，为了省力，直接采用<br>String url = “<a href="http://api.liqwei.com/currency/?exchange=usd|cny&amp;count=1" target="_blank" rel="external">http://api.liqwei.com/currency/?exchange=usd|cny&amp;count=1</a>“;<br>HttpClient client    = new DefaultHttpClient();<br>HttpGet httpget = new HttpGet(url);<br>HttpResponse response = client.execute(httpget);</p>
<p>以前用这种方法都没有问题，但这次却报如下错误：<br>java.net.URISyntaxException: Illegal character in query at index 44</p>
<p>查找了一些网上资料，说地址中涉及了特殊字符，如‘｜’‘&amp;’等。所以不能直接用String代替URI来访问。必须采用%0xXX方式来替代特殊字符。但这种办法不直观。所以只能先把String转成URL，再能过URL生成URI的方法来解决问题。代码如下<br>URL url = new URL(strUrl);<br>URI uri = new URI(url.getProtocol(), url.getHost(), url.getPath(), url.getQuery(), null);<br>HttpClient client    = new DefaultHttpClient();<br>HttpGet httpget = new HttpGet(uri);</p>
<p>ref:<br><a href="http://qsfwy.iteye.com/blog/1926302" target="_blank" rel="external">http://qsfwy.iteye.com/blog/1926302</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux_Cmd_cp_两个有用的命令</title>
    <url>/2017/08/14/Linux-Cmd-cp-%E4%B8%A4%E4%B8%AA%E6%9C%89%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Linux cp_两个有用的命令</p>
<a id="more"></a>
<h2 id="高效用法-1：更新你的文件夹"><a href="#高效用法-1：更新你的文件夹" class="headerlink" title="高效用法 1：更新你的文件夹"></a>高效用法 1：更新你的文件夹</h2><p>比如说在我的电脑上有一个存放各种文件的文件夹，另外我要不时的往里面添加一些新文件，而且我会不时地修改一些文件，例如我手机里下载的照片或者是音乐。</p>
<p>假设我收集的这些文件对我而言都很有价值，我有时候会想做个拷贝，就像是“快照”一样将文件保存在其它媒体。当然目前有很多程序都支持备份，但是我想更为精确的将目录结构复制到可移动设备中，方便于我经常使用这些离线设备或者连接到其它电脑上。</p>
<p>cp 命令提供了一个易如反掌的方法。例子如下：</p>
<p>在我的 Pictures 文件夹下，我有这样一个文件夹名字为 Misc。为了方便说明，我把文件拷贝到 USB 存储设备上。让我们开始吧！<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">me@desktop:~/Pictures$ cp -r Misc /media/clh/4388-D5FE</div><div class="line">me@desktop:~/Pictures$</div></pre></td></tr></table></figure></p>
<p>输入这个命令 cp -r Misc /media/clh/4388-D5FE 并执行后 ，拷贝 Misc 目录下所有文件（这个 -r 参数，全称 “recursive”，递归处理，意思为本目录下所有文件及子目录一起处理）到我的 USB 设备的挂载目录 /media/clh/4388-D5FE。</p>
<p>执行命令后回到之前的提示，大多数命令继承了 Unix 的特性，在命令执行后，如果没有任何异常什么都不显示，在任务结束之前不会显示像 “execution succeeded” 这样的提示消息。如果想获取更多的反馈，就使用 -v 参数让执行结果更详细。</p>
<p>假设我要在原始拷贝路径下 ~/Pictures/Misc 下添加一些新文件，现在我想只拷贝新的文件到我的存储设备上，我就使用 cp 的“更新”和“详细”选项。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">me@desktop:~/Pictures$ cp -r -u -v Misc /media/clh/4388-D5FE</div><div class="line">&apos;Misc/asunder.png&apos; -&gt; &apos;/media/clh/4388-D5FE/Misc/asunder.png&apos;</div><div class="line">&apos;Misc/editing tags guayadeque.png&apos; -&gt; &apos;/media/clh/4388-D5FE/Misc/editing tags guayadeque.png&apos;</div><div class="line">&apos;Misc/misc on usb.png&apos; -&gt; &apos;/media/clh/4388-D5FE/Misc/misc on usb.png&apos;</div><div class="line">me@desktop:~/Pictures$</div></pre></td></tr></table></figure></p>
<p>上面的第一行中是 cp 命令和具体的参数（-r 是“递归”， -u 是“更新”，-v 是“详细”）。接下来的三行显示被复制文件的信息。</p>
<p>通常来说，参数 -r 也可用更详细的风格 –recursive。但是以简短的方式，也可以这么连用 -ruv。</p>
<h2 id="高效用法-2：版本备份"><a href="#高效用法-2：版本备份" class="headerlink" title="高效用法 2：版本备份"></a>高效用法 2：版本备份</h2><p>我在开发的时候定期给我的代码版本进行备份,假设我正在编写一个非常有用的 Python 程序，作为一个喜欢不断修改代码的开发者，我会在一开始编写一个程序简单版本，然后不停的往里面添加各种功能直到它能成功的运行起来。比方说我的第一个版本就是用 Python 程序打印出 “hello world”。这只有一行代码的程序就像这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">print &apos;hello world&apos;</div></pre></td></tr></table></figure></p>
<p>然后我将这个代码保存成文件命名为 test1.py。现在程序可以运行了，我想在添加新的内容之前进行备份。我决定使用带编号的备份选项，如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">clh@vancouver:~/Test$ cp --force --backup=numbered test1.py test1.py</div><div class="line">clh@vancouver:~/Test$ ls</div><div class="line">test1.py &amp;nbsp;test1.py.~1~</div><div class="line">clh@vancouver:~/Test$</div></pre></td></tr></table></figure></p>
<p>所以，上面的做法是什么意思呢？</p>
<ol>
<li><p>这个 –backup=numbered 参数意思为“我要做个备份，而且是带编号的连续备份”。所以一个备份就是 1 号，第二个就是 2 号，等等。</p>
</li>
<li><p>如果源文件和目标文件名字是一样的。通常我们使用 cp 命令去拷贝成自己，会得到这样的报错信息：<br>cp: ‘test1.py’ and ‘test1.py’ are the same file<br>在特殊情况下，如果我们想备份的源文件和目标文件名字相同，我们使用 –force 参数。</p>
</li>
<li><p>我使用 ls （意即 “list”）命令来显示现在目录下的文件，名字为 test1.py 的是原始文件，名字为 test1.py.~1~ 的是备份文件</p>
</li>
</ol>
<p>假如现在我要加上第二个功能，在程序里加上另一行代码，可以打印 “Kilroy was here.”。现在程序文件 test1.py 的内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">print &apos;hello world&apos;</div><div class="line">print &apos;Kilroy was here&apos;</div></pre></td></tr></table></figure></p>
<p>看到 Python 编程多么简单了吗？不管怎样，如果我再次执行备份的步骤，结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">clh@vancouver:~/Test$ cp --force --backup=numbered test1.py test1.py</div><div class="line">clh@vancouver:~/Test$ ls</div><div class="line">test1.py test1.py.~1~ test1.py.~2~</div><div class="line">clh@vancouver:~/Test$</div></pre></td></tr></table></figure></p>
<p>现在我有有两个备份文件： test1.py.~1~ 包含了一行代码的程序，和 test1.py.~2~ 包含两行代码的程序。</p>
<p>ref:<br><a href="https://linux.cn/article-8766-1.html" target="_blank" rel="external">https://linux.cn/article-8766-1.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Cmd</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux_软件安装目录</title>
    <url>/2017/08/14/Linux-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>Linux 的软件安装目录是也是有讲究的，理解这一点，在对系统管理是有益的</p>
<a id="more"></a>
<p><code>/usr</code>：系统级的目录，可以理解为C:/Windows/，/usr/lib理解为C:/Windows/System32。<br><code>/usr/local</code>：用户级的程序目录，可以理解为C:/Progrem Files/。用户自己编译的软件默认会安装到这个目录下。<br><code>/opt</code>：用户级的程序目录，可以理解为D:/Software，opt有可选的意思，这里可以用于放置第三方大型软件（或游戏），当你不需要时，直接rm -rf掉即可。在硬盘容量不够时，也可将/opt单独挂载到其他磁盘上使用。</p>
<p>源码放哪里？<br><code>/usr/src</code>：系统级的源码目录。<br><code>/usr/local/src</code>：用户级的源码目录。</p>
<h2 id="opt"><a href="#opt" class="headerlink" title="/opt"></a><code>/opt</code></h2><p>Here’s where optional stuff is put. Trying out the latest Firefox beta? Install it to /opt where you can delete it without affecting other settings. Programs in here usually live inside a single folder whick contains all of their data, libraries, etc.<br>这里主要存放那些可选的程序。你想尝试最新的firefox测试版吗?那就装到/opt目录下吧，<strong>这样，当你尝试完，想删掉firefox的时候，你就可 以直接删除它，而不影响系统其他任何设置</strong>。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。<br>举个例子：刚才装的测试版firefox，就可以装到/opt/firefox_beta目录下，/opt/firefox_beta目录下面就包含了运 行firefox所需要的所有文件、库、数据等等。要删除firefox的时候，你只需删除/opt/firefox_beta目录即可，非常简单。</p>
<h2 id="usr-local"><a href="#usr-local" class="headerlink" title="/usr/local"></a><code>/usr/local</code></h2><p>This is where most manually installed(ie. outside of your package manager) software goes. It has the same structure as /usr. It is a good idea to leave /usr to your package manager and put any custom scripts and things into /usr/local, since nothing important normally lives in /usr/local.</p>
<p>这里主要存放那些手动安装的软件，<strong>即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构</strong>。让软件包管理器来管理/usr目录，而把自定义的脚本(scripts)放到/usr/local目录下面，我想这应该是个不错的主意。</p>
<p>ref: <a href="https://blog.csdn.net/aqxin/article/details/48324377" target="_blank" rel="external">https://blog.csdn.net/aqxin/article/details/48324377</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_Django_JS与后端数据交互</title>
    <url>/2017/08/11/Python-Django-JS%E4%B8%8E%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<p>Python_Django_JS与后端数据交互</p>
<a id="more"></a>
<h2 id="应用一：-Js与后端数据交互，以供数据可视化"><a href="#应用一：-Js与后端数据交互，以供数据可视化" class="headerlink" title="应用一： Js与后端数据交互，以供数据可视化"></a>应用一： Js与后端数据交互，以供数据可视化</h2><p>有时候我们想把一个 list 或者 dict 传递给 javascript，处理后显示到网页上，比如要用 js 进行可视化的数据。</p>
<p>请注意：如果是不处理，直接显示在网页上，用Django模板就可以了。</p>
<p>这里讲述两种方法：</p>
<ol>
<li><p>页面加载完成后，在页面上操作，在页面上通过 ajax 方法得到新的数据（再向服务器发送一次请求）并显示在网页上，这种情况适用于页面不刷新的情况下，动态加载一些内容。比如用户输入一个值或者点击某个地方，动态地把相应内容显示在网页上。<br>这种请问详见 Django Ajax 一节的内容。</p>
</li>
<li><p>直接在视图函数（views.py中的函数）中渲染一个 list 或 dict 的内容，和网页其它部分一起显示到网页上（一次性地渲染，还是同一次请求）。<br>需要注意两点：1、views.py中返回的函数中的值要用 json.dumps()处理   2、在网页上要加一个 safe 过滤器<br>view.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</div><div class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span><span class="params">(request)</span>:</span></div><div class="line">    List = [<span class="string">'自强学堂'</span>, <span class="string">'渲染Json到模板'</span>]</div><div class="line">    Dict = &#123;<span class="string">'site'</span>: <span class="string">'自强学堂'</span>, <span class="string">'author'</span>: <span class="string">'涂伟忠'</span>&#125;</div><div class="line">    <span class="keyword">return</span> render(request, <span class="string">'home.html'</span>, &#123;</div><div class="line">            <span class="string">'List'</span>: json.dumps(List),</div><div class="line">            <span class="string">'Dict'</span>: json.dumps(Dict)</div><div class="line">        &#125;)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>home.html<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    //列表</div><div class="line">    var List = &#123;&#123; List|safe &#125;&#125;;</div><div class="line"></div><div class="line">    //下面的代码把List的每一部分放到头部和尾部</div><div class="line">    $(&apos;#list&apos;).prepend(List[0]);</div><div class="line">    $(&apos;#list&apos;).append(List[1]);</div><div class="line"></div><div class="line">    console.log(&apos;--- 遍历 List 方法 1 ---&apos;)</div><div class="line">    for(i in List)&#123;</div><div class="line">        console.log(i);// i为索引</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    console.log(&apos;--- 遍历 List 方法 2 ---&apos;)</div><div class="line">    for (var i = List.length - 1; i &gt;= 0; i--) &#123;</div><div class="line">        console.log(List[i]);</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    console.log(&apos;--- 同时遍历索引和内容，使用 jQuery.each() 方法 ---&apos;)</div><div class="line">    $.each(List, function(index, item)&#123;</div><div class="line">        console.log(index);</div><div class="line">        console.log(item);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line">    // 字典</div><div class="line">    var Dict = &#123;&#123; Dict|safe &#125;&#125;;</div><div class="line">    console.log(&quot;--- 两种字典的取值方式  ---&quot;)</div><div class="line">    console.log(Dict[&apos;site&apos;]);</div><div class="line">    console.log(Dict.author);</div><div class="line"></div><div class="line">    console.log(&quot;---  遍历字典  ---&quot;);</div><div class="line">    for(i in Dict) &#123;</div><div class="line">        console.log(i + Dict[i]);//注意，此处 i 为键值</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h2 id="应用二：不刷新网页的情况下，加载一些内容"><a href="#应用二：不刷新网页的情况下，加载一些内容" class="headerlink" title="应用二：不刷新网页的情况下，加载一些内容"></a>应用二：不刷新网页的情况下，加载一些内容</h2><p>view.py<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#coding:utf-8</span></div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</div><div class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</div><div class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">return</span> render(request, <span class="string">'oneapp/get.html'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(request)</span>:</span></div><div class="line">    a = request.GET.get(<span class="string">'a'</span>, <span class="number">0</span>)</div><div class="line">    b = request.GET.get(<span class="string">'b'</span>, <span class="number">0</span>)</div><div class="line">    c = int(a) + int(b)</div><div class="line">    <span class="keyword">return</span> HttpResponse(str(c))</div></pre></td></tr></table></figure></p>
<p>get.html<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    $(document).ready(function()&#123;</div><div class="line">      $(&quot;#sum&quot;).click(function()&#123;</div><div class="line">        var a = $(&quot;#a&quot;).val();</div><div class="line">        var b = $(&quot;#b&quot;).val();</div><div class="line"></div><div class="line">        $.get(&quot;/oneapp/add/&quot;,&#123;&apos;a&apos;:a,&apos;b&apos;:b&#125;, function(ret)&#123;</div><div class="line">            $(&apos;#result&apos;).html(ret)</div><div class="line">        &#125;)</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">...</div><div class="line">&lt;form action=&quot;/oneapp/add/&quot; method=&quot;get&quot;&gt;</div><div class="line">    a: &lt;input type=&quot;text&quot; id=&quot;a&quot; name=&quot;a&quot;&gt; &lt;br&gt;</div><div class="line">    b: &lt;input type=&quot;text&quot; id=&quot;b&quot; name=&quot;b&quot;&gt; &lt;br&gt;</div><div class="line">    &lt;p&gt;result: &lt;span id=&apos;result&apos;&gt;&lt;/span&gt;&lt;/p&gt;</div><div class="line">    &lt;button type=&quot;button&quot; id=&apos;sum&apos;&gt;提交&lt;/button&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure></p>
<h2 id="应用三：传递数字或者字典到网页，由JS处理，再显示出来"><a href="#应用三：传递数字或者字典到网页，由JS处理，再显示出来" class="headerlink" title="应用三：传递数字或者字典到网页，由JS处理，再显示出来"></a>应用三：传递数字或者字典到网页，由JS处理，再显示出来</h2><p>views.py<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment">#coding:utf-8</span></div><div class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> unicode_literals</div><div class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</div><div class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse, JsonResponse</div><div class="line"><span class="keyword">import</span> json</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ajax_list</span><span class="params">(request)</span>:</span></div><div class="line">    a = range(<span class="number">100</span>)</div><div class="line">    <span class="comment">#return HttpResponse(json.dump(a), content_type='application/json')</span></div><div class="line">    <span class="keyword">return</span> JsonResponse(a, safe=<span class="keyword">False</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ajax_dict</span><span class="params">(request)</span>:</span></div><div class="line">    name_dict = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</div><div class="line">    <span class="comment">#return HttpResponse(json.dump(name_dict), content_type='application/json')</span></div><div class="line">    <span class="keyword">return</span> JsonResponse(name_dict)</div></pre></td></tr></table></figure></p>
<p>index.html<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    $(document).ready(function()&#123;</div><div class="line">      // 求和 a + b</div><div class="line">      $(&quot;#sum&quot;).click(function()&#123;</div><div class="line">        var a = $(&quot;#a&quot;).val();</div><div class="line">        var b = $(&quot;#b&quot;).val();</div><div class="line"></div><div class="line">        $.get(&quot;&#123;% url &apos;add&apos; %&#125;&quot;,&#123;&apos;a&apos;:a,&apos;b&apos;:b&#125;, function(ret)&#123;</div><div class="line">            $(&apos;#result&apos;).html(ret);</div><div class="line">        &#125;)</div><div class="line">      &#125;);</div><div class="line"></div><div class="line">      // 列表 list</div><div class="line">      $(&apos;#list&apos;).click(function()&#123;</div><div class="line">          $.getJSON(&quot;&#123;% url &apos;ajax_list&apos; %&#125;&quot;,function(ret)&#123;</div><div class="line">            //返回值 ret 在这里是一个列表</div><div class="line">            for (var i = ret.length - 1; i &gt;= 0; i--) &#123;</div><div class="line">              // 把 ret 的每一项显示在网页上</div><div class="line">              $(&apos;#list_result&apos;).append(&apos; &apos; + ret[i])</div><div class="line">            &#125;;</div><div class="line">          &#125;)</div><div class="line">      &#125;)</div><div class="line"></div><div class="line">      // 字典 dict</div><div class="line">      $(&apos;#dict&apos;).click(function()&#123;</div><div class="line">          $.getJSON(&quot;&#123;% url &apos;ajax_dict&apos; %&#125;&quot;,function(ret)&#123;</div><div class="line">              //返回值 ret 在这里是一个字典</div><div class="line">              $(&apos;#dict_result&apos;).append(ret.a + &apos;&lt;br&gt;&apos;);</div><div class="line">              // 也可以用 ret[&apos;twz&apos;]</div><div class="line">          &#125;)</div><div class="line">      &#125;)</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div><div class="line">...</div><div class="line">&lt;form action=&quot;/add/&quot; method=&quot;get&quot;&gt;</div><div class="line">    a: &lt;input type=&quot;text&quot; id=&quot;a&quot; name=&quot;a&quot;&gt; &lt;br&gt;</div><div class="line">    b: &lt;input type=&quot;text&quot; id=&quot;b&quot; name=&quot;b&quot;&gt; &lt;br&gt;</div><div class="line">    &lt;p&gt;result: &lt;span id=&apos;result&apos;&gt;&lt;/span&gt;&lt;/p&gt;</div><div class="line">    &lt;button type=&quot;button&quot; id=&apos;sum&apos;&gt;提交&lt;/button&gt;</div><div class="line">&lt;/form&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;dict&quot;&gt;Ajax 加载字典&lt;/div&gt;</div><div class="line">&lt;p id=&quot;dict_result&quot;&gt;&lt;/p&gt;</div><div class="line"></div><div class="line">&lt;div id=&quot;list&quot;&gt;Ajax 加载列表&lt;/div&gt;</div><div class="line">&lt;p id=&quot;list_result&quot;&gt;&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<p>如果是一个复杂的字典或者列表，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">person_info_dict = [</div><div class="line">    &#123;&quot;name&quot;:&quot;xiaoming&quot;, &quot;age&quot;:20&#125;,</div><div class="line">    &#123;&quot;name&quot;:&quot;tuweizhong&quot;, &quot;age&quot;:24&#125;,</div><div class="line">    &#123;&quot;name&quot;:&quot;xiaoli&quot;, &quot;age&quot;:33&#125;,</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>这样我们遍历列表的时候，每次遍历得到一个字典，再用字典的方法去处理，当然有更简单的遍历方法：<br>用 $.each() 方法代替 for 循环<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$.getJSON(&apos;ajax_url_to_json&apos;, function(ret) &#123;</div><div class="line">    $.each(ret, function(i,item)&#123;</div><div class="line">        // i 为索引，item为遍历值</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>补充：如果 ret 是一个字典，$.each 的参数有所不同，详见：<a href="http://api.jquery.com/jquery.each/" target="_blank" rel="external">http://api.jquery.com/jquery.each/</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$.getJSON(&apos;ajax-get-a-dict&apos;, function(ret) &#123;</div><div class="line">    $.each(ret, function(key, value)&#123;</div><div class="line">        // key 为字典的 key，value 为对应的值</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="应用四：使用Django的表单"><a href="#应用四：使用Django的表单" class="headerlink" title="应用四：使用Django的表单"></a>应用四：使用Django的表单</h2><p>未完待续</p>
<p>ref:<br><a href="http://blog.csdn.net/u011138533/article/details/72629728" target="_blank" rel="external">http://blog.csdn.net/u011138533/article/details/72629728</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Frontend_div内容居中</title>
    <url>/2017/08/10/Frontend-div%E5%86%85%E5%AE%B9%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>遇到一个问题。想让一个div中元素居中，使用padding:0 auto;width:1000px;<br>行不通， 使用margin：0 auto；的话，居中的两边背景色会用空白。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>把要居中的div 设置成 display: inline-block;，然后在父div加上 text-align: center; 让div居中。</p>
]]></content>
      <categories>
        <category>Frontend</category>
      </categories>
      <tags>
        <tag>Frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_Django_从后端往前端传递html的方法</title>
    <url>/2017/08/08/Python-Django-%E4%BB%8E%E5%90%8E%E7%AB%AF%E5%BE%80%E5%89%8D%E7%AB%AF%E4%BC%A0%E9%80%92html%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Python<em>Django</em>从后端往前端传递html的方法</p>
<a id="more"></a>
<p>django从view向template传递HTML字符串的时候，django默认不渲染此HTML，原因是为了防止这段字符串里面有恶意攻击的代码。</p>
<p>如果需要渲染这段字符串，需要在view里这样写：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> django.utils.safestring <span class="keyword">import</span> mark_safe</div></pre></td></tr></table></figure></p>
<p>函数里面这样写：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">pageHtml = mark_safe(<span class="string">"&lt;a href='&#123;%url equip:listEquipmentCategory 1 %&#125;'&gt;首页&lt;/a&gt;"</span>)</div><div class="line">ret = &#123;<span class="string">"equit_cate_list"</span>:list,<span class="string">"count"</span>:count,<span class="string">"ecform"</span>:ecform,<span class="string">"page"</span>:page,<span class="string">"pageHtml"</span>:pageHtml&#125;</div><div class="line"><span class="keyword">return</span> render(request, <span class="string">"list_equip_category.html"</span>,ret)</div></pre></td></tr></table></figure></p>
<p>前端页面直接使用即可。</p>
<p>mark_safe这个函数就是确认这段函数是安全的，不是恶意攻击的。</p>
<p>ref:<br><a href="http://www.jianshu.com/p/5b304cb7c397" target="_blank" rel="external">http://www.jianshu.com/p/5b304cb7c397</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_Django_ORM_查询</title>
    <url>/2017/08/05/Python-Django-ORM-%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>Diango ORM 查询</p>
<a id="more"></a>
<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(request)</span>:</span></div><div class="line">    searchtype = request.POST.get(<span class="string">"searchtype"</span>)</div><div class="line">    keyword = request.POST.get(<span class="string">"keyword"</span>)</div><div class="line"></div><div class="line">    <span class="comment">#单个字段模糊查询</span></div><div class="line">    <span class="keyword">elif</span> searchtype == <span class="string">"author"</span>:</div><div class="line">        sciencenews = models.Sciencenews.objects.filter(author__icontains=keyword)</div><div class="line">    <span class="keyword">elif</span> searchtype == <span class="string">"title"</span>:</div><div class="line">        sciencenews = models.Sciencenews.objects.filter(title__icontains=keyword)</div><div class="line">    <span class="keyword">elif</span> searchtype == <span class="string">"content"</span>:</div><div class="line">        sciencenews = models.Sciencenews.objects.filter(content__icontains=keyword)</div><div class="line"></div><div class="line">    <span class="comment">#多个字段模糊查询， 括号中的下划线是双下划线，双下划线前是字段名，双下划线后可以是icontains或contains,区别是是否大小写敏感，竖线是或的意思</span></div><div class="line">    <span class="keyword">elif</span> searchtype == <span class="string">"all"</span>:</div><div class="line">        <span class="comment"># OR 关系用 | 实现</span></div><div class="line">        sciencenews = models.Sciencenews.objects.filter(Q(title__icontains=keyword)|Q(content__icontains=keyword)|Q(author__icontains=keyword))</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        <span class="comment"># AND 关系用 filter链 实现</span></div><div class="line">        sciencenews = models.Sciencenews.objects.filter(author__icontains=keyword).filter(title__icontains=keyword).filter(content__icontains=keyword)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> render(request,<span class="string">"show/index.html"</span>,&#123;<span class="string">"param"</span>:sciencenews,<span class="string">"searchtype"</span>:searchtype,<span class="string">"key</span></div></pre></td></tr></table></figure>
<h2 id="django使用Q来实现动态可变条件的或查询"><a href="#django使用Q来实现动态可变条件的或查询" class="headerlink" title="django使用Q来实现动态可变条件的或查询"></a>django使用Q来实现动态可变条件的或查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">from django.db.models import Q</div><div class="line"></div><div class="line"># 1.固定条件的或查询</div><div class="line">&gt;&gt;&gt; User.objects.filter(Q(is_staff=True) | Q(username=&apos;123&apos;))</div><div class="line">[&lt;User: staff_a&gt;, &lt;User: 123&gt;, &lt;User: staff_b&gt;]</div><div class="line"></div><div class="line"># 2.对于动态可变条件的或查询</div><div class="line">代码示例：</div><div class="line">&gt;&gt;&gt; di = &#123;&apos;username&apos;: &apos;123&apos;, &apos;is_staff&apos;: True&#125; # 条件不固定</div><div class="line">&gt;&gt;&gt; q = Q()</div><div class="line">&gt;&gt;&gt; for i in di:</div><div class="line">... q.add(Q(**&#123;i: di[i]&#125;), Q.OR)</div><div class="line">...</div><div class="line">&lt;django.db.models.query_utils.Q object at 0x103a84bd0&gt;</div><div class="line">&lt;django.db.models.query_utils.Q object at 0x103af1110&gt;</div><div class="line">&gt;&gt;&gt; print q</div><div class="line">(OR: (AND: ), (AND: (&apos;username&apos;, &apos;123&apos;)), (&apos;is_staff&apos;, True))</div><div class="line">&gt;&gt;&gt; User.objects.filter(q)</div><div class="line">[&lt;User: staff_a&gt;, &lt;User: 123&gt;, &lt;User: staff_b&gt;]</div></pre></td></tr></table></figure>
<h2 id="Django执行-performing-原始的SQL查询："><a href="#Django执行-performing-原始的SQL查询：" class="headerlink" title="Django执行(performing)原始的SQL查询："></a>Django执行(performing)原始的SQL查询：</h2><p> Django提供两种方式执行(performing)原始的SQL查询：</p>
<ul>
<li>Manager.raw() :执行原始查询并返回模型实例</li>
<li>Executing custom SQL directly ：直接执行自定义SQL，这种方式可以完全避免数据模型，而是直接执行原始的SQL语句。</li>
</ul>
<h3 id="raw-方法"><a href="#raw-方法" class="headerlink" title="raw()方法"></a>raw()方法</h3><p>The raw() manager method can be used to perform raw SQL queries that return model instances:<br>Manager. raw ( raw_query , params=None , translations=None )</p>
<h4 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; for p in Person.objects.raw(&apos;SELECT * FROM Person LIMIT 2&apos;):</div><div class="line">...     print p</div><div class="line">John Smith</div><div class="line">Jane Jones</div></pre></td></tr></table></figure>
<p>注意，原始SQL里的model，如果在 db_table 没有定义，则使用app的名称，后面下划线 后面接模型类的名称,如”Myblog_New”;上面的例子，在定义类的时候已经这样处理了：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Class New(models.Model):</div><div class="line">    ......</div><div class="line">    ......</div><div class="line">#自定义表名</div><div class="line">    class Meta:</div><div class="line">        db_table = &apos;New&apos;</div></pre></td></tr></table></figure></p>
<h4 id="查询字段隐射到模型字段（Mapping-query-fields-to-model-fields）"><a href="#查询字段隐射到模型字段（Mapping-query-fields-to-model-fields）" class="headerlink" title="查询字段隐射到模型字段（Mapping query fields to model fields）"></a>查询字段隐射到模型字段（Mapping query fields to model fields）</h4><p>raw() automatically maps fields in the query to fields on the model.并且是通过名称来匹配，这意味着我们可以使用SQL子句(clause)<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; Person.objects.raw(&apos;&apos;&apos;SELECT first AS first_name,</div><div class="line">...                              last AS last_name,</div><div class="line">...                              bd AS birth_date,</div><div class="line">...                              pk as id,</div><div class="line">...                       FROM some_other_table&apos;&apos;&apos;)</div></pre></td></tr></table></figure></p>
<p>返回一个RawQuerySet对象</p>
<h4 id="索引查找-Index-lookups"><a href="#索引查找-Index-lookups" class="headerlink" title="索引查找(Index lookups)"></a>索引查找(Index lookups)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">first_person = Person.objects.raw(&apos;SELECT * from myapp_person&apos;)[0]</div><div class="line">first_person = Person.objects.raw(&apos;SELECT * from myapp_person LIMIT 1&apos;)[0]</div></pre></td></tr></table></figure>
<p>然而,索引和切片不是在数据库级别上执行(除LIMIT外)</p>
<h4 id="延迟模型字段（Deferring-model-fields）"><a href="#延迟模型字段（Deferring-model-fields）" class="headerlink" title="延迟模型字段（Deferring model fields）"></a>延迟模型字段（Deferring model fields）</h4><p>Fields may also be left out（left out：忽视，不考虑；被遗忘），这意味着该字段的查询将会被排除在根据需要时的加载。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; for p in Person.objects.raw(&apos;SELECT id, first_name FROM myapp_person&apos;):</div><div class="line">...     print p.first_name, # 这将检索到原始查询</div><div class="line">...     print p.last_name # 这将检索需求</div><div class="line">...</div><div class="line">John Smith</div><div class="line">Jane Jones</div></pre></td></tr></table></figure></p>
<p>这个例子其实检索了三个字段，一个主键(必需)、一个原始SQL字段、一个需求字段。这里主键字段不能省略，否则会出错</p>
<h4 id="传递参数-Passing-parameters-into-raw"><a href="#传递参数-Passing-parameters-into-raw" class="headerlink" title="传递参数(Passing parameters into raw() )"></a>传递参数(Passing parameters into raw() )</h4><p>如果需要执行参数化查询,您可以使用params参数<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&gt;&gt;&gt; query = &apos;SELECT * FROM myapp_person WHERE last_name = %s&apos; % lname</div><div class="line">&gt;&gt;&gt; Person.objects.raw(query)</div></pre></td></tr></table></figure></p>
<p>注意： 必须使用[参数]，否则出错</p>
<h3 id="直接执行自定义SQL"><a href="#直接执行自定义SQL" class="headerlink" title="直接执行自定义SQL"></a>直接执行自定义SQL</h3><p>Manager.raw() 远远不能满足日常需求，可直接执行自定义SQL，directly execute UPDATE , INSERT , or DELETE queries.</p>
<p>大致思路:</p>
<ol>
<li>database connection调用 connection.cursor() 得到一个游标(cursor)对象。</li>
<li>cursor.execute(sql, [params]) 执行SQL</li>
<li>cursor.fetchone() 或者 cursor.fetchall()： 返回结果行<br>ps:<br>django.db.connection：代表默认的数据库连接<br>django.db.transaction ：代表默认数据库事务（transaction）</li>
</ol>
<p>如果执行修改操作，则调用 transaction.commit_unless_managed()来保证你的更改提交到数据库。<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_custom_sql</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">from</span> django.db <span class="keyword">import</span> connection, transaction</div><div class="line">    cursor = connection.cursor()</div><div class="line"></div><div class="line">    <span class="comment"># 数据修改操作——提交要求</span></div><div class="line">    cursor.execute(<span class="string">"UPDATE bar SET foo = 1 WHERE baz = %s"</span>, [self.baz])</div><div class="line">    transaction.commit_unless_managed()</div><div class="line"></div><div class="line">    <span class="comment"># 数据检索操作,不需要提交</span></div><div class="line">    cursor.execute(<span class="string">"SELECT foo FROM bar WHERE baz = %s"</span>, [self.baz])</div><div class="line">    row = cursor.fetchone()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> row</div></pre></td></tr></table></figure></p>
<p>django.db.connections ：针对使用多个数据库<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">from django.db import connections</div><div class="line">cursor = connections[&apos;my_db_alias&apos;].cursor()</div><div class="line"># Your code here...</div><div class="line">transaction.commit_unless_managed(using=&apos;my_db_alias&apos;)</div></pre></td></tr></table></figure></p>
<p>通常我们不需要手动调用 transaction.commit_unless_managed( ),我们可以使用 @commit_on_success：<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="meta">@commit_on_success</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_custom_sql_view</span><span class="params">(request, value)</span>:</span></div><div class="line">    <span class="keyword">from</span> django.db <span class="keyword">import</span> connection, transaction</div><div class="line">    cursor = connection.cursor()</div><div class="line"></div><div class="line">    <span class="comment"># Data modifying operation</span></div><div class="line">    cursor.execute(<span class="string">"UPDATE bar SET foo = 1 WHERE baz = %s"</span>, [value])</div><div class="line"></div><div class="line">    <span class="comment"># Since we modified data, mark the transaction as dirty</span></div><div class="line">    transaction.set_dirty()</div><div class="line"></div><div class="line">    <span class="comment"># Data retrieval operation. This doesn't dirty the transaction,</span></div><div class="line">    <span class="comment"># so no call to set_dirty() is required.</span></div><div class="line">    cursor.execute(<span class="string">"SELECT foo FROM bar WHERE baz = %s"</span>, [value])</div><div class="line">    row = cursor.fetchone()</div><div class="line"></div><div class="line">    <span class="keyword">return</span> render_to_response(<span class="string">'template.html'</span>, &#123;<span class="string">'row'</span>: row&#125;)</div></pre></td></tr></table></figure></p>
<p>查看Django ORM执行的SQL语句 ：   connection.queries</p>
<p>ref:<br><a href="http://blog.csdn.net/iloveyin/article/details/46380619" target="_blank" rel="external">http://blog.csdn.net/iloveyin/article/details/46380619</a><br><a href="https://www.douban.com/note/505215076/" target="_blank" rel="external">https://www.douban.com/note/505215076/</a><br><a href="http://blog.csdn.net/liuweiyuxiang/article/details/71104613" target="_blank" rel="external">http://blog.csdn.net/liuweiyuxiang/article/details/71104613</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Frontend_三步完成自适应网页设计</title>
    <url>/2017/08/03/Frontend-%E4%B8%89%E6%AD%A5%E5%AE%8C%E6%88%90%E8%87%AA%E9%80%82%E5%BA%94%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<p>自适应网页设计近来很流行，如果你接触比较少请参见 <a href="http://webdesignerwall.com/trends/inspiration-fluid-responsive-design" target="_blank" rel="external">responsive sites</a>。当然，对一个新手来说可能听起来有点复杂，其实它比你想象的简单多了。这里是一个快速教程，通过学习你会自适应网页和media queries的基本原理（前提你有css基础）。<br><a href="http://webdesignerwall.com/demo/responsive-design/index.html" target="_blank" rel="external">demo</a></p>
<a id="more"></a>
<!-- more -->
<h2 id="Step-1：Meta-标签"><a href="#Step-1：Meta-标签" class="headerlink" title="Step 1：Meta 标签"></a>Step 1：Meta 标签</h2><p>为了适应屏幕，不少移动浏览器都会把HTML页面置于较大视口宽度（一般会大于屏幕宽度），你可以使用viewport meta标签来设定。以下viewport meta标签告诉浏览器视口宽度等于设备屏幕宽度，且不进行初始缩放：<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>IE8及其更低版本不支持media query，可以使用media-queries.js或respond.js脚本实现支持。<br><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;&lt;script src="http://css3-mediaqueries-js.googlecode.com/svn/trunk/css3-mediaqueries.js"&gt;&lt;/script&gt; &lt;![endif]--&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="Step-2-HTML结构"><a href="#Step-2-HTML结构" class="headerlink" title="Step 2. HTML结构"></a>Step 2. HTML结构</h2><p>在这个例子中，页面布局包括 header，content，sidebar和<br>footer。header固定高度为180px，content宽600px，sidebar宽300px。<br><img src="/2017/08/03/Frontend-三步完成自适应网页设计/page-structure.png" alt="page-structure.png" title=""></p>
<h2 id="Step-3-Media-Queries"><a href="#Step-3-Media-Queries" class="headerlink" title="Step 3. Media Queries"></a>Step 3. Media Queries</h2><p><a href="http://webdesignerwall.com/tutorials/css3-media-queries" target="_blank" rel="external">CSS3 media query</a>是自适应网页设计的关键，他就像高级语言里的if条件语句，告诉浏览器根据不同的视口宽度（这里等于浏览器宽度）来渲染网页。</p>
<p>如果视口宽度小于等于980px，下面规则生效。</p>
<p>这里将容器绝对宽度改用百分比显示，让页面排版更加灵活。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/* for 980px or less */</div><div class="line">@media screen and (max-width: 980px) &#123;</div><div class="line"></div><div class="line">    #pagewrap&#123;</div><div class="line">        width: 94%;</div><div class="line">    &#125;</div><div class="line">    #content&#123;</div><div class="line">        width: 65%;</div><div class="line">    &#125;</div><div class="line">    #sidebar&#123;</div><div class="line">        width: 30%;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果视口宽度小于等于700px， 将#content和#sidebar宽度设为自动(auto)，并移除它的浮动属性(float)，这样它会变成满版显示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/* for 700px or less */</div><div class="line">@media screen and (max-width:700px) &#123;</div><div class="line"></div><div class="line">    #content &#123;</div><div class="line">        width: auto;</div><div class="line">        float: none;</div><div class="line">    &#125;</div><div class="line">    #sidebar &#123;</div><div class="line">        width: auto;</div><div class="line">        float: none;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当视口宽度小于等于480px时（如手机屏幕），将#header高度设为自动，h1的字体大小设定为24px，并隐藏#sidebar。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/* for 480px or less */</div><div class="line">@media screen and (max-width:480px) &#123;</div><div class="line"></div><div class="line">    #header &#123;</div><div class="line">        height: auto;</div><div class="line">    &#125;</div><div class="line">    h1 &#123;</div><div class="line">        font-size: 24px;</div><div class="line">    &#125;</div><div class="line">    #sidebar &#123;</div><div class="line">        display: none;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>根据你的喜好，可以定义更多的media queriey条件</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这里只是一个快速教程，更多可以参见<a href="http://xinyo.org/archives/62104/" target="_blank" rel="external">使用CSS3 Media Queries实现网页自适应</a><br>ref:<br><a href="http://xinyo.org/archives/64557/" target="_blank" rel="external">http://xinyo.org/archives/64557/</a></p>
]]></content>
      <categories>
        <category>Frontend</category>
      </categories>
      <tags>
        <tag>Frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo_发布博客引用自带图片的方法</title>
    <url>/2017/08/03/Hexo-%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%E5%BC%95%E7%94%A8%E8%87%AA%E5%B8%A6%E5%9B%BE%E7%89%87%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Hexo_发布博客引用自带图片的方法</p>
<a id="more"></a>
<p>有两种方法，第一种是不用插件的情况，第二种是使用一种hexo的插件。</p>
<p>无论哪种方法都有一个共同的前提：修改_config.yml配置文件post_asset_folder项为true。</p>
<p>创建博客是使用命令创建：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hexo new [layout] &lt;title&gt;</div></pre></td></tr></table></figure></p>
<p>其中的layout项可以省略，例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">hexo new &quot;这是一个新的博客&quot;</div></pre></td></tr></table></figure></p>
<p>使用完命令之后，在source/_post文件夹里面就会出现一个“这是一个新的博客.md”的文件和一个“这是一个新的博客”的文件夹。<br>下一步就是把需要的图片放到新创建的那个文件夹里面去。</p>
<!-- more -->
<h2 id="引用图片的第一种方法"><a href="#引用图片的第一种方法" class="headerlink" title="引用图片的第一种方法"></a>引用图片的第一种方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;% asset_img 这是一个新的博客的图片.jpg [这是一个新的博客的图片的说明] %&#125;</div></pre></td></tr></table></figure>
<p>用此种方法，而不是以前的![]()方法，前提是你的hexo的版本是hexo3以上，到package.json里面看一下吧。如果不是hexo3以上的版本，那就只能用第二种方法了。</p>
<p>例子<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">我现在写了一个段落，并且想在这个段落的某一个地方&#123;% asset_img 这是一个新的博客的图片.jpg 这是一个新的博客的图片的说明 %&#125;引入一张图片</div></pre></td></tr></table></figure></p>
<p>错误的例子<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">我现在写了一个段落，并且想在这个段落的某一个地方![](这是一个新的博客的图片.jpg)引入一张图片</div></pre></td></tr></table></figure></p>
<h2 id="第二种方法，hexo插件的方法"><a href="#第二种方法，hexo插件的方法" class="headerlink" title="第二种方法，hexo插件的方法"></a>第二种方法，hexo插件的方法</h2><p><a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="external">插件的链接</a><br>安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install hexo-asset-image --save</div></pre></td></tr></table></figure></p>
<p>之后就可以按照正常的方法使用</p>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">我现在写了一个段落，并且想在这个段落的某一个地方![](这是一个新的博客/这是一个新的博客的图片.jpg)引入一张图片</div></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">我现在写了一个段落，并且想在这个段落的某一个地方![](这是一个新的博客的图片.jpg)引入一张图片</div></pre></td></tr></table></figure></p>
<p>都可以实现。</p>
<p>此两种方法除了操作有些区别之外，在图片的显示上也略有不同，第一种的图片信息是会显示出来的，而第二种中括号里面的信息是不会显示的。</p>
<p>ref:<br><a href="http://www.jianshu.com/p/cf0628478a4e" target="_blank" rel="external">http://www.jianshu.com/p/cf0628478a4e</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_django_实现用户登陆访问限制</title>
    <url>/2017/08/02/Python-django-%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%99%BB%E9%99%86%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>django_实现用户登陆访问限制</p>
<a id="more"></a>
<h2 id="Limiting-access-to-logged-in-users"><a href="#Limiting-access-to-logged-in-users" class="headerlink" title="Limiting access to logged-in users"></a>Limiting access to logged-in users</h2><h3 id="The-raw-way"><a href="#The-raw-way" class="headerlink" title="The raw way"></a>The raw way</h3><p>The simple, raw way to limit access to pages is to check <a href="https://docs.djangoproject.com/en/1.10/ref/contrib/auth/#django.contrib.auth.models.User.is_authenticated" target="_blank" rel="external">request.user.is_authenticated</a> and either redirect to a login page:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</div><div class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.user.is_authenticated:</div><div class="line">        <span class="keyword">return</span> redirect(<span class="string">'%s?next=%s'</span> % (settings.LOGIN_URL, request.path))</div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure></p>
<p>…or display an error message:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> request.user.is_authenticated:</div><div class="line">        <span class="keyword">return</span> render(request, <span class="string">'myapp/login_error.html'</span>)</div><div class="line">    <span class="comment"># ...</span></div></pre></td></tr></table></figure></p>
<h3 id="The-login-required-decorator"><a href="#The-login-required-decorator" class="headerlink" title="The login_required decorator"></a>The login_required decorator</h3><p>login_required(redirect_field_name=’next’, login_url=None)<a href="https://docs.djangoproject.com/en/1.10/_modules/django/contrib/auth/decorators/#login_required" target="_blank" rel="external">[source]</a><br>As a shortcut, you can use the convenient login_required() decorator:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</div><div class="line"></div><div class="line"><span class="meta">@login_required</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>login_required() does the following:</p>
<ul>
<li>If the user isn’t logged in, redirect to settings.LOGIN_URL, passing the current absolute path in the query string. Example: <strong>/accounts/login/?next=/polls/3/</strong>.</li>
<li>If the user is logged in, execute the view normally. The view code is free to assume the user is logged in.<br>By default, the path that the user should be redirected to upon successful authentication is stored in a query string parameter called <strong>“next”</strong>. If you would prefer to use a different name for this parameter, login_required() takes an optional <strong>redirect_field_name</strong> parameter:<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</div><div class="line"></div><div class="line"><span class="meta">@login_required(redirect_field_name='my_redirect_field')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></div><div class="line">    ...</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Note that if you provide a value to redirect_field_name, you will most likely need to customize your login template as well, since the template context variable which stores the redirect path will use the value of redirect_field_name as its key rather than “next” (the default).</p>
<p>login_required() also takes an optional login_url parameter. Example:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</div><div class="line"></div><div class="line"><span class="meta">@login_required(login_url='/accounts/login/')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<p>Note that if you don’t specify the <strong>login_url parameter</strong>, you’ll need to ensure that the <strong>settings.LOGIN_URL</strong> and your login view are properly associated. For example, using the defaults, add the following lines to your URLconf:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> views <span class="keyword">as</span> auth_views</div><div class="line"></div><div class="line">url(<span class="string">r'^accounts/login/$'</span>, auth_views.login),</div></pre></td></tr></table></figure></p>
<p>settings.LOGIN_URL like this:<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line">...</div><div class="line">LOGIN_URL = <span class="string">'/accounts/login/'</span>  <span class="comment">#这个路径需要根据你网站的实际登陆地址来设置</span></div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>The settings.LOGIN_URL also accepts view function names and named URL patterns. This allows you to freely remap your login view within your URLconf without having to update the setting.</p>
<blockquote>
<p>Note<br>The login_required decorator does NOT check the is_active flag on a user, but the default AUTHENTICATION_BACKENDS reject inactive users.</p>
<p>See also<br>If you are writing custom views for Django’s admin (or need the same authorization check that the built-in views use), you may find the django.contrib.admin.views.decorators.staff_member_required() decorator a useful alternative to login_required().</p>
</blockquote>
<h2 id="Limiting-permissions-to-users"><a href="#Limiting-permissions-to-users" class="headerlink" title="Limiting permissions to users"></a>Limiting permissions to users</h2><p><strong>permission_required</strong> similer to login_required<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> permission_required</div><div class="line">...</div><div class="line"><span class="meta">@permission_required('应用名.权限标识')</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></div><div class="line">    ...</div></pre></td></tr></table></figure></p>
<h2 id="Source-code"><a href="#Source-code" class="headerlink" title="Source code"></a>Source code</h2><h3 id="login-required"><a href="#login-required" class="headerlink" title="login_required"></a>login_required</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_required</span><span class="params">(function=None, redirect_field_name=REDIRECT_FIELD_NAME, login_url=None)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Decorator for views that checks that the user is logged in, redirecting</div><div class="line">    to the log-in page if necessary.</div><div class="line">    """</div><div class="line">    actual_decorator = user_passes_test(</div><div class="line">        <span class="keyword">lambda</span> u: u.is_authenticated,</div><div class="line">        login_url=login_url,</div><div class="line">        redirect_field_name=redirect_field_name</div><div class="line">    )</div><div class="line">    <span class="keyword">if</span> function:</div><div class="line">        <span class="keyword">return</span> actual_decorator(function)</div><div class="line">    <span class="keyword">return</span> actual_decorator</div></pre></td></tr></table></figure>
<h3 id="permission-required"><a href="#permission-required" class="headerlink" title="permission_required"></a>permission_required</h3><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">permission_required</span><span class="params">(perm, login_url=None, raise_exception=False)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line">    Decorator for views that checks whether a user has a particular permission</div><div class="line">    enabled, redirecting to the log-in page if necessary.</div><div class="line">    If the raise_exception parameter is given the PermissionDenied exception</div><div class="line">    is raised.</div><div class="line">    """</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_perms</span><span class="params">(user)</span>:</span></div><div class="line">        <span class="keyword">if</span> isinstance(perm, six.string_types):</div><div class="line">            perms = (perm, )</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            perms = perm</div><div class="line">        <span class="comment"># First check if the user has the permission (even anon users)</span></div><div class="line">        <span class="keyword">if</span> user.has_perms(perms):</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line">        <span class="comment"># In case the 403 handler should be called raise the exception</span></div><div class="line">        <span class="keyword">if</span> raise_exception:</div><div class="line">            <span class="keyword">raise</span> PermissionDenied</div><div class="line">        <span class="comment"># As the last resort, show the login form</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">False</span></div><div class="line">    <span class="keyword">return</span> user_passes_test(check_perms, login_url=login_url)</div></pre></td></tr></table></figure>
<p>ref:<br><a href="https://docs.djangoproject.com/en/1.10/topics/auth/default/#the-login-required-decorator" target="_blank" rel="external">https://docs.djangoproject.com/en/1.10/topics/auth/default/#the-login-required-decorator</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_规范_PEP8代码规范</title>
    <url>/2017/08/02/Python-%E8%A7%84%E8%8C%83-PEP8%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>编程语言不是艺术，而是工作或者说是工具，所以整理并遵循一套编码规范是十分必要的</p>
<a id="more"></a>
<h2 id="代码编排"><a href="#代码编排" class="headerlink" title="代码编排"></a>代码编排</h2><ol>
<li>缩进。4个空格的缩进（编辑器都可以完成此功能），不使用Tap，更不能混合使用Tap和空格。</li>
<li>每行最大长度79，换行可以使用反斜杠，最好使用圆括号。换行点要在操作符的后边敲回车。</li>
<li>类和top-level函数定义之间空两行；类中的方法定义之间空一行；函数内逻辑无关段落之间空一行；其他地方尽量不要再空行。</li>
</ol>
<h2 id="文档编排"><a href="#文档编排" class="headerlink" title="文档编排"></a>文档编排</h2><p>1 模块内容的顺序：模块说明和docstring—import—globals&amp;constants—其他定义。其中import部分，又按标准、三方和自己编写顺序依次排放，之间空一行。<br>2 不要在一句import中多个库，比如import os, sys不推荐。<br>3 如果采用from XX import XX引用库，可以省略‘module.’，都是可能出现命名冲突，这时就要采用import XX。</p>
<h2 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h2><pre><code>总体原则，避免不必要的空格。
</code></pre><ol>
<li>各种右括号前不要加空格。</li>
<li>逗号、冒号、分号前不要加空格。</li>
<li>函数的左括号前不要加空格。如Func(1)。</li>
<li>序列的左括号前不要加空格。如list[2]。</li>
<li>操作符左右各加一个空格，不要为了对齐增加空格。</li>
<li>函数默认参数使用的赋值符左右省略空格。</li>
<li>不要将多句语句写在同一行，尽管使用‘；’允许。</li>
<li>if/for/while语句中，即使执行语句只有一句，也必须另起一行。</li>
</ol>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><pre><code>总体原则，错误的注释不如没有注释。所以当一段代码发生变化时，第一件事就是要修改注释！
注释必须使用英文，最好是完整的句子，首字母大写，句后要有结束符，结束符后跟两个空格，开始下一句。如果是短语，可以省略结束符。
</code></pre><ol>
<li><p>块注释，在一段代码前增加的注释。在‘#’后加一空格。段落之间以只有‘#’的行间隔。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="comment"># Description : Module config.</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Input : None</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Output : None</span></div></pre></td></tr></table></figure>
</li>
<li><p>行注释，在一句代码后加注释。比如：x = x + 1          # Increment x<br>但是这种方式尽量少使用。</p>
</li>
<li>避免无谓的注释。</li>
</ol>
<h2 id="文档描述"><a href="#文档描述" class="headerlink" title="文档描述"></a>文档描述</h2><ol>
<li>为所有的共有模块、函数、类、方法写docstrings；非共有的没有必要，但是可以写注释（在def的下一行）。</li>
<li>如果docstring要换行，参考如下例子,详见PEP 257<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="string">"""Return a foobang</span></div><div class="line"></div><div class="line">Optional plotz says to frobnicate the bizbaz first.</div><div class="line"></div><div class="line">"""</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h2><pre><code>总体原则，新编代码必须按下面命名风格进行，现有库的编码尽量保持风格。
</code></pre><ol>
<li>尽量单独使用小写字母‘l’，大写字母‘O’等容易混淆的字母。</li>
<li>模块命名尽量短小，使用全部小写的方式，可以使用下划线。</li>
<li>包命名尽量短小，使用全部小写的方式，不可以使用下划线。</li>
<li>类的命名使用CapWords的方式，模块内部使用的类采用_CapWords的方式。</li>
<li>异常命名使用CapWords+Error后缀的方式。</li>
<li>全局变量尽量只在模块内有效，类似C语言中的static。实现方法有两种，一是<strong>all</strong>机制;二是前缀一个下划线。</li>
<li>函数命名使用全部小写的方式，可以使用下划线。</li>
<li>常量命名使用全部大写的方式，可以使用下划线。</li>
<li>类的属性（方法和变量）命名使用全部小写的方式，可以使用下划线。</li>
<li>类的属性有3种作用域public、non-public和subclass API，可以理解成C++中的public、private、protected，non-public属性前，前缀一条下划线。</li>
<li>类的属性若与关键字名字冲突，后缀一下划线，尽量不要使用缩略等其他方式。</li>
<li>为避免与子类属性命名冲突，在类的一些属性前，前缀两条下划线。比如：类Foo中声明<strong>a,访问时，只能通过Foo._Foo</strong>a，避免歧义。如果子类也叫Foo，那就无能为力了。</li>
<li>类的方法第一个参数必须是self，而静态方法第一个参数必须是cls。</li>
</ol>
<h2 id="编码建议"><a href="#编码建议" class="headerlink" title="编码建议"></a>编码建议</h2><ol>
<li>编码中考虑到其他python实现的效率等问题，比如运算符‘+’在CPython（Python）中效率很高，都是Jython中却非常低，所以应该采用.join()的方式。</li>
<li>尽可能使用‘is’‘is not’取代‘==’，比如if x is not None 要优于if x。</li>
<li>使用基于类的异常，每个模块或包都有自己的异常类，此异常类继承自Exception。</li>
<li>异常中不要使用裸露的except，except后跟具体的exceptions。</li>
<li>异常中try的代码尽可能少。比如：<figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">value = collection[key]</div><div class="line"><span class="keyword">except</span> KeyError:</div><div class="line"><span class="keyword">return</span> key_not_found(key)</div><div class="line"><span class="keyword">else</span>:</div><div class="line"><span class="keyword">return</span> handle_value(value)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>要优于<br><figure class="highlight python"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line"><span class="comment"># Too broad!</span></div><div class="line"><span class="keyword">return</span> handle_value(collection[key])</div><div class="line"><span class="keyword">except</span> KeyError:</div><div class="line"><span class="comment"># Will also catch KeyError raised by handle_value()</span></div><div class="line"><span class="keyword">return</span> key_not_found(key)</div></pre></td></tr></table></figure></p>
<ol>
<li>使用startswith() and endswith()代替切片进行序列前缀或后缀的检查。比如：<br>Yes:  if foo.startswith(‘bar’):优于<br>No:  if foo[:3] == ‘bar’:</li>
<li>使用isinstance()比较对象的类型。比如<br>Yes:  if isinstance(obj, int): 优于<br>No:  if type(obj) is type(1):</li>
<li>判断序列空或不空，有如下规则<br>Yes:  if not seq:<br>if seq:<br>优于<br>No:  if len(seq)<br>if not len(seq)</li>
<li>字符串不要以空格收尾。</li>
<li>二进制数据判断使用 if boolvalue的方式。</li>
</ol>
<p>ref:<br><a href="https://www.douban.com/note/134971609/" target="_blank" rel="external">https://www.douban.com/note/134971609/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_改善_提倡异常封装</title>
    <url>/2017/08/01/Java-%E6%94%B9%E5%96%84-%E6%8F%90%E5%80%A1%E5%BC%82%E5%B8%B8%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p> JavaAPI提供的异常都是比较低级别的,低级别是指只有开发人员才能看懂的异常.而对于终端用户来说基本上就是天书,与业务无关,是纯计算机语言的描述.</p>
<p>异常封装的三方面的好处:</p>
<ol>
<li>提高系统的友好性</li>
<li>提高性能的可维护性</li>
<li>解决java异常机制自身的缺陷</li>
</ol>
<a id="more"></a>
<h2 id="提高系统的友好性"><a href="#提高系统的友好性" class="headerlink" title="提高系统的友好性."></a>提高系统的友好性.</h2><p>打开一个文件,如果文件不存在,则会报FileNotFoundException异常,如果该方法的编写不做任何的处理,直接抛到上层,则会降低系统的友好性.</p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"无效文件.txt"</span>);</div><div class="line">    <span class="comment">/*文件操作*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解决方法就是封装异常,可以把异常的读者分为两类:开发人员和用户.</p>
<p>开发人员查找问题需要打印出堆栈信息,而用户则需要了解具体的业务原因,比如:文件太大,不能同时编写文件等…</p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStuff2</span><span class="params">()</span> <span class="keyword">throws</span> MyBussinessException</span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"无效文件.txt"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">        <span class="comment">//为方便开发和维护人员而设置的异常信息</span></div><div class="line">        e.printStackTrace();</div><div class="line">        <span class="comment">//抛出业务异常</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyBussinessException(e);</div><div class="line">        &#125;</div><div class="line">    <span class="comment">/*文件操作*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="提高新能的可维护性"><a href="#提高新能的可维护性" class="headerlink" title="提高新能的可维护性"></a>提高新能的可维护性</h2><p>来看如下代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="comment">//do something</span></div><div class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种是很多程序员容易犯下的错误,抛出异常是吧..分类处理异常多麻烦,就写一个catch块来处理所有的异常吧,而且还信誓旦旦的说JVM会打印出出堆栈信息中的错误信息.</p>
<p>虽然没有错,但是堆栈信息只有开发人员能看懂,维护人员看到这段异常的时候基本上无法处理.因为需要深入到代码逻辑中去分析问题.</p>
<p>正确的做法是对异常进行分类处理,并进行封装输出,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doStuff2</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">try</span>&#123;</div><div class="line">        <span class="comment">//do something</span></div><div class="line">    &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</div><div class="line">        log.info(<span class="string">"文件问找到，使用默认配置文件……"</span>);</div><div class="line">    &#125;<span class="keyword">catch</span>(SecurityException e)&#123;</div><div class="line">        log.error(<span class="string">"无权访问，可能原因是……"</span>);</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="解决java异常机制自身的缺陷"><a href="#解决java异常机制自身的缺陷" class="headerlink" title="解决java异常机制自身的缺陷"></a>解决java异常机制自身的缺陷</h2><p>Java中的异常一次只能抛出一个,比如doStuff方法有两个逻辑代码片段,如果在第一个逻辑片段中抛出异常,第二个逻辑片段中就不再执行了.也就无法抛出第二个异常了,现在的问题的是如何一次抛出多个异常….</p>
<p>其实,使用自行封装的异常就可以解决问题了,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</div><div class="line">    <span class="comment">// 容纳所有的异常</span></div><div class="line">    <span class="keyword">private</span> List&lt;Throwable&gt; causes = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// 构造函数，传递一个异常列表</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(List&lt;? extends Throwable&gt; _causes)</span> </span>&#123;</div><div class="line">        causes.addAll(_causes);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 读取所有的异常</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Throwable&gt; <span class="title">getExceptions</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> causes;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如上MyExcepiton异常只是一个异常容器,可以容纳多个异常,但它本身并不代表任何异常含义,它所解决的是一次抛出多个异常的问题,具体调用如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doStuff</span><span class="params">()</span> <span class="keyword">throws</span> MyException </span>&#123;</div><div class="line">    List&lt;Throwable&gt; list = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</div><div class="line">    <span class="comment">// 第一个逻辑片段</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// Do Something</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line"></div><div class="line">        list.add(e);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 第二个逻辑片段</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">// Do Something</span></div><div class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">        list.add(e);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (list.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MyException(list);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样doStuff方法的调用者就可以一次获得多个异常了…也能够为用户提供完整的异常情况说明.</p>
<p>可能你会问,有这种情况的出现吗?怎么会要求一个方法抛出多个异常呢?</p>
<p>绝对可能出现,例如Web界面注册的时候.依次把User对象传递到逻辑层,Register方法需要对各个Field进行校验并注册,如果用户 填写的字段不只有一个错误,最好把所有的错误都一次性的提示给用户,而不是要求用户每次条件都进行修改.</p>
<p>一次性的对User对象进行校验,然后返回所有的异常.</p>
<p>ref:<br><a href="http://www.cnblogs.com/DreamDrive/p/5446819.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5446819.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>改善</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_性能_不同的列表选择不同的遍历方法</title>
    <url>/2017/07/31/Java-%E6%80%A7%E8%83%BD-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%88%97%E8%A1%A8%E9%80%89%E6%8B%A9%E4%B8%8D%E5%90%8C%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>Java 不同的列表选择不同的遍历方法</p>
<a id="more"></a>
<h2 id="标识接口"><a href="#标识接口" class="headerlink" title="标识接口"></a>标识接口</h2><p>在Java中，RandomAccess和Cloneable、Serializable一样都是标识接口，不需要任何实现，只是用来表明其实现类具有某种特质的，实现了Cloneable表明可以被拷贝，实现了Serializable接口表明被序列化了，实现了RandomAccess则表明这个类可以随机存取。<br>ArrayList数组实现了RandomAccess接口（随机存取接口），标识着ArrayList是一个可以随机存取的列表，即元素之间没有关联，即两个位置相邻的元素之间没有相互依赖关系，可以随机访问和存储。<br>LinkedList类也是一个列表，它是有序存取的，实现了双向链表、每个数据节点都有单个数据项，前面节点的引用（Previous Node）、本节点元素（Node Element）、后续节点的引用（Next Node）。也就是说LinkedList两个元素本来就是有联系的，我知道你存在，你知道我存在。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景:"></a>场景:</h2><p>我们来看一个场景，统计一个省的各科高考科目考试的平均分.<br>当然使用数据库中的一个SQL语句就能求出平均值,不过这个不再我们的考虑之列,这里只考虑使用纯Java的方式来解决.<br>看代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//学生数量,80万</span></div><div class="line">        <span class="keyword">int</span> stuNum = <span class="number">800</span>*<span class="number">1000</span>;</div><div class="line">        <span class="comment">//List集合，记录所有学生的分数</span></div><div class="line">        List&lt;Integer&gt; scores = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(stuNum);</div><div class="line">        <span class="comment">//写入分数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stuNum;i++)&#123;</div><div class="line">            scores.add(<span class="keyword">new</span> Random().nextInt(<span class="number">150</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//记录开始计算时间</span></div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"平均分是："</span> + average(scores));</div><div class="line">        System.out.println(<span class="string">"执行时间："</span> + (System.currentTimeMillis() -start) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//计算平均数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="comment">//遍历求和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:list)&#123;</div><div class="line">            sum +=i;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/*</span></div><div class="line">        Java中的foreach()语法是iterator(迭代器)的变形用法,上面的foreach语法和下面的代码等价</div><div class="line">        for(Iterator&lt;Integer&gt; i=list.iterator(); i.hasNext(); )&#123;</div><div class="line">            sum +=i.next();</div><div class="line">        &#125;</div><div class="line">         */</div><div class="line"></div><div class="line">        <span class="comment">//除以人数，计算平均值</span></div><div class="line">        <span class="keyword">return</span> sum/list.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">输出结果：</div><div class="line">平均分是：74</div><div class="line">执行时间：47ms</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h2 id="遍历优化"><a href="#遍历优化" class="headerlink" title="遍历优化"></a>遍历优化</h2><p>仅仅求一个平均值就花费了47毫秒，考虑其他诸如加权平均值、补充平均值等的话，花费时间肯定更长。我们仔细分析一下arverage方法，加号操作是最基本操作，没有可以优化，我们可以尝试对List遍历进行优化。<br>List的遍历还有另外一种形式，即通过下表方式来遍历，如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//学生数量,800万</span></div><div class="line">        <span class="keyword">int</span> stuNum = <span class="number">800</span>*<span class="number">10000</span>;</div><div class="line">        <span class="comment">//List集合，记录所有学生的分数</span></div><div class="line">        List&lt;Integer&gt; scores = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(stuNum);</div><div class="line">        <span class="comment">//写入分数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;stuNum;i++)&#123;</div><div class="line">            scores.add(<span class="keyword">new</span> Random().nextInt(<span class="number">150</span>));</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//记录开始计算时间</span></div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"平均分是："</span> + average(scores));</div><div class="line">        System.out.println(<span class="string">"执行时间："</span> + (System.currentTimeMillis() -start) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//计算平均数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="comment">//遍历求和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, size = list.size(); i &lt; size; i++)&#123;</div><div class="line">            sum += list.get(i);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//除以人数，计算平均值</span></div><div class="line">        <span class="keyword">return</span> sum/list.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">运行结果如下:</div><div class="line">平均分是：74</div><div class="line">执行时间：58ms</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>执行时间大幅提升，性能提升65%。<br>为什么会有如此提升呢？我们知道foreacher与下面代码等价：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span>(Iterator&lt;Integer&gt; i = list.iterator(); i.hasNext;)&#123;</div><div class="line">    sum += i.next();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>迭代器是23中设计模式的一种，提供一种方法访问一个容器对象中的各个元素，同时又无须暴露该对象的内部细节。也就是说对于ArrayList，需要先创建一个迭代器容器，然后屏蔽内部遍历细节，对外提供hasNext、next等方法。<br>问题是ArrayList实现了RandomAccess接口，表明元素之间本没有关系，为了使用迭代器就需要强制建立一种互相“知晓”的关系，比如上一个元素可以判断是否有下一个元素，以及下一个元素是什么等关系，这也就是通过foreach遍历耗时的原因。</p>
<p>Java为ArrayList类加上了RandomAccess接口,就是在告诉我们”ArrayList是随机存取的,采用下标方式遍历列表速度会更快”.</p>
<p>但是为什么不把RadomAccess加到所有的List实现类上呢?<br>那是因为有些List实现类是不能随机存取的,而是有序存取的,比如LinkedList类,LinkedList也是一个列表,但是它实现了双向链表,每个数据节点中都有三个数据项:前节点的引用(Previous Node),本节点元素(Node Element),后继节点的引用(Next Node),这是数据结构的节本知识,也就是在LinkedList中的两个元素本来就是有关联的,我知道你的存在,你也知道我的存在.</p>
<p>综上对于LinkedList由分析讲述，元素之间已经有关联了，使用foreach也就是迭代器方式是不是更高呢？代码如下<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">//学生数量，80万</span></div><div class="line">        <span class="keyword">int</span> stuNum = <span class="number">800</span> * <span class="number">10000</span>;</div><div class="line">        <span class="comment">//List集合，记录所有学生分数</span></div><div class="line">        List&lt;Integer&gt; scores = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line"></div><div class="line">        <span class="comment">//写入分数</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stuNum; i++)&#123;</div><div class="line">            scores.add(<span class="keyword">new</span> Random().nextInt(<span class="number">150</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//记录开始计算时间</span></div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"平均分是："</span> + average(scores));</div><div class="line">        System.out.println(<span class="string">"执行时间："</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="comment">//foreach遍历求和</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : list)&#123;</div><div class="line">            sum += i;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//除以人数，计算平均值</span></div><div class="line">        <span class="keyword">return</span> sum/list.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">运行结果:</div><div class="line">平均分是：74</div><div class="line">执行时间：118ms</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>可能这个数据量不是很适合…..用八十万量的数据量LinkedList使用foreach的速度和ArrayList使用普通for循环的速度差不多…..<br>可以测试使用下标的方式遍历LinkedList中的元素:<br>其实不用测试,效率真的非常低,直接看源代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> entry(index).element;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由entry方法查找指定下标的节点，然后返回其包含的元素，看entry方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Entry&lt;E&gt; <span class="title">entry</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="comment">//检查下标是否越界</span></div><div class="line">    Entry&lt;E&gt; e = header;</div><div class="line">    <span class="keyword">if</span>(index &lt; (size &gt;&gt; <span class="number">1</span>))&#123;</div><div class="line">        <span class="comment">//如果下标小于中间值，则从头节点开始搜索</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= index; I++)&#123;</div><div class="line">        e = e.next;</div><div class="line">    &#125;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">//如果下标大于等于中间值，则从尾节点反向遍历</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = size; i &gt; index; i++)&#123;</div><div class="line">            e = e.previous;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序会先判断输入的下标与中间值(size右移一位,也就是除以2了)的关系,小于中间值则从头开始正向搜索,大于中间值则从尾节点反向搜索,想想看,每一次的get方法都是一个遍历,”性能”两字从何说起呢!<br>明白了随机存取列表和有序存取列表的区别,average方法就必须重构,以便实现不同的列表采用不同的遍历方式.代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.LinkedList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">import</span> java.util.RandomAccess;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 学生数量,80万</span></div><div class="line">        <span class="keyword">int</span> stuNum = <span class="number">80</span> * <span class="number">10000</span>;</div><div class="line">        <span class="comment">// List集合，记录所有学生的分数</span></div><div class="line">        List&lt;Integer&gt; scores = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</div><div class="line">        <span class="comment">// 写入分数</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stuNum; i++) &#123;</div><div class="line">            scores.add(<span class="keyword">new</span> Random().nextInt(<span class="number">150</span>));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 记录开始计算时间</span></div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"平均分是："</span> + average(scores));</div><div class="line">        System.out.println(<span class="string">"执行时间："</span> + (System.currentTimeMillis() - start)</div><div class="line">                + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 计算平均数</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">average</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess) &#123;</div><div class="line">            <span class="comment">//可以随机存取，则使用下标遍历</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = list.size(); i &lt; size; i++) &#123;</div><div class="line">                sum += list.get(i);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//有序存取，使用foreach方式</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</div><div class="line">                sum += i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 除以人数，计算平均值</span></div><div class="line">        <span class="keyword">return</span> sum / list.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样无论是随机存取列表还是有序列表,程序都可以提供快速的遍历.<br>列表遍历也不是那么简单的,适时选择最优的遍历方式,不要固化为一种.<br>ref:<br><a href="http://www.cnblogs.com/DreamDrive/p/5647953.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5647953.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_性能_枚举项数量限定为64个以内</title>
    <url>/2017/07/31/Java-%E6%80%A7%E8%83%BD-%E6%9E%9A%E4%B8%BE%E9%A1%B9%E6%95%B0%E9%87%8F%E9%99%90%E5%AE%9A%E4%B8%BA64%E4%B8%AA%E4%BB%A5%E5%86%85/</url>
    <content><![CDATA[<p>枚举项的数量为什么要限制在64个以内？</p>
<a id="more"></a>
<p>为了更好地使用枚举，Java提供了两个枚举集合：EnumSet和EnumMap，这两个集合使用的方法都比较简单，EnumSet表示其元素必须是某一枚举的枚举项，EnumMap表示Key值必须是某一枚举的枚举项，由于枚举类型的实例数量固定并且有限，相对来说EnumSet和EnumMap的效率会比其它Set和Map要高。</p>
<p>虽然EnumSet很好用，但是它有一个隐藏的特点，昆明Java培训机构的老师逐步分析。在项目中一般会把枚举用作常量定义，可能会定义非常多的枚举项，然后通过EnumSet访问、遍历，但它对不同的枚举数量有不同的处理方式。为了进行对比，我们定义两个枚举，一个数量等于64，一个是65（大于64即可，为什么是64而不是128,512呢，一会解释），代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//普通枚举项，数量等于64</span></div><div class="line"><span class="keyword">enum</span> Const&#123;</div><div class="line">    A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,</div><div class="line">    AA,BB,CC,DD,EE,FF,GG,HH,II,JJ,KK,LL,MM,NN,OO,PP,QQ,RR,SS,TT,UU,VV,WW,XX,YY,ZZ,</div><div class="line">    AAA,BBB,CCC,DDD,EEE,FFF,GGG,HHH,III,JJJ,KKK,LLL</div><div class="line">&#125;</div><div class="line"><span class="comment">//大枚举，数量超过64</span></div><div class="line"><span class="keyword">enum</span> LargeConst&#123;</div><div class="line">    A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,</div><div class="line">    AA,BB,CC,DD,EE,FF,GG,HH,II,JJ,KK,LL,MM,NN,OO,PP,QQ,RR,SS,TT,UU,VV,WW,XX,YY,ZZ,</div><div class="line">    AAAA,BBBB,CCCC,DDDD,EEEE,FFFF,GGGG,HHHH,IIII,JJJJ,KKKK,LLLL,MMMM</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Const的枚举项数量是64，LagrgeConst的枚举项数量是65,接下来我们希望把这两个枚举转换为EnumSet，然后判断一下它们的class类型是否相同，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client89</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        EnumSet&lt;Const&gt; cs = EnumSet.allOf(Const.class);</div><div class="line">        EnumSet&lt;LargeConst&gt; lcs = EnumSet.allOf(LargeConst.class);</div><div class="line">        <span class="comment">//打印出枚举数量</span></div><div class="line">        System.out.println(<span class="string">"Const的枚举数量："</span>+cs.size());</div><div class="line">        System.out.println(<span class="string">"LargeConst的枚举数量："</span>+lcs.size());</div><div class="line">        <span class="comment">//输出两个EnumSet的class</span></div><div class="line">        System.out.println(cs.getClass());</div><div class="line">        System.out.println(lcs.getClass());</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序很简单，现在的问题是：cs和lcs的class类型是否相同？应该相同吧，都是EnumSet类的工厂方法allOf生成的EnumSet类，而且JDK API也没有提示EnumSet有子类。我们来看看输出结果：<br>很遗憾，两者不相等。就差一个元素，两者就不相等了？确实如此，这也是我们重点关注枚举项数量的原因。先来看看Java是如何处理的，首先跟踪allOf方法，其源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates an enum set containing all of the elements in the specified</div><div class="line"> * element type.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> &lt;E&gt; The class of the elements in the set</div><div class="line"> * <span class="doctag">@param</span> elementType the class object of the element type for this enum</div><div class="line"> *     set</div><div class="line"> * <span class="doctag">@return</span> An enum set containing all the elements in the specified type.</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException if &lt;tt&gt;elementType&lt;/tt&gt; is null</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Enum&lt;E&gt;&gt; <span class="function">EnumSet&lt;E&gt; <span class="title">allOf</span><span class="params">(Class&lt;E&gt; elementType)</span> </span>&#123;</div><div class="line">    EnumSet&lt;E&gt; result = noneOf(elementType);</div><div class="line">    result.addAll();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>allOf通过noneOf方法首先生成了一个EnumSet对象，然后把所有的枚举都加进去，问题可能就出在EnumSet的生成上了，我们来看看noneOf的源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates an empty enum set with the specified element type.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> &lt;E&gt; The class of the elements in the set</div><div class="line"> * <span class="doctag">@param</span> elementType the class object of the element type for this enum</div><div class="line"> *     set</div><div class="line"> * <span class="doctag">@return</span> An empty enum set of the specified type.</div><div class="line"> * <span class="doctag">@throws</span> NullPointerException if &lt;tt&gt;elementType&lt;/tt&gt; is null</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E extends Enum&lt;E&gt;&gt; <span class="function">EnumSet&lt;E&gt; <span class="title">noneOf</span><span class="params">(Class&lt;E&gt; elementType)</span> </span>&#123;</div><div class="line">    Enum&lt;?&gt;[] universe = getUniverse(elementType);</div><div class="line">    <span class="keyword">if</span> (universe == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassCastException(elementType + <span class="string">" not an enum"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (universe.length &lt;= <span class="number">64</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RegularEnumSet&lt;&gt;(elementType, universe);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JumboEnumSet&lt;&gt;(elementType, universe);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到这里，恍然大悟，Java原来是如此处理的：当枚举项数量小于等于64时，创建一个RegularEnumSet实例对象，大于64时则创建一个JumboEnumSet实例对象。<br>为什么要如此处理呢？这还要看看这两个类之间的差异，首先看RegularEnumSet类，源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegularEnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3411599620347842686L</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Bit vector representation of this set.  The 2^k bit indicates the</div><div class="line">     * presence of universe[k] in this set.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> elements = <span class="number">0L</span>;</div><div class="line"></div><div class="line">    RegularEnumSet(Class&lt;E&gt;elementType, Enum&lt;?&gt;[] universe) &#123;</div><div class="line">        <span class="keyword">super</span>(elementType, universe);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addRange</span><span class="params">(E from, E to)</span> </span>&#123;</div><div class="line">        elements = (-<span class="number">1L</span> &gt;&gt;&gt;  (from.ordinal() - to.ordinal() - <span class="number">1</span>)) &lt;&lt; from.ordinal();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (universe.length != <span class="number">0</span>)</div><div class="line">            elements = -<span class="number">1L</span> &gt;&gt;&gt; -universe.length;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//其它代码略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们知道枚举项的排序值ordinal是从0、1、2……依次递增的，没有重号，没有跳号，RegularEnumSet就是利用这一点把每个枚举项的ordinal映射到一个long类型的每个位置上的，注意看addAll方法的elements元素，它使用了无符号右移操作，并且操作数是负值，位移也是负值，这表示是负数(符号位是1)的”无符号左移”：符号位为0，并补充低位，简单的说，Java把一个不多于64个枚举项映射到了一个long类型变量上。这才是EnumSet处理的重点，其他的size方法、contains方法等都是根据elements方法等都是根据elements计算出来的。想想看，一个long类型的数字包含了所有的枚举项，其效率和性能能肯定是非常优秀的。<br>我们知道long类型是64位的，所以RegularEnumSet类型也就只能负责枚举项的数量不大于64的枚举(这也是我们以64来举例，而不以128,512举例的原因)，大于64则由JumboEnumSet处理，我们看它是怎么处理的：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">JumboEnumSet</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">EnumSet</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">334349849919042784L</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Bit vector representation of this set.  The ith bit of the jth</div><div class="line">     * element of this array represents the  presence of universe[64*j +i]</div><div class="line">     * in this set.</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> elements[];</div><div class="line"></div><div class="line">    <span class="comment">// Redundant - maintained for performance</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line"></div><div class="line">    JumboEnumSet(Class&lt;E&gt;elementType, Enum&lt;?&gt;[] universe) &#123;</div><div class="line">        <span class="keyword">super</span>(elementType, universe);</div><div class="line">        elements = <span class="keyword">new</span> <span class="keyword">long</span>[(universe.length + <span class="number">63</span>) &gt;&gt;&gt; <span class="number">6</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addRange</span><span class="params">(E from, E to)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> fromIndex = from.ordinal() &gt;&gt;&gt; <span class="number">6</span>;</div><div class="line">        <span class="keyword">int</span> toIndex = to.ordinal() &gt;&gt;&gt; <span class="number">6</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (fromIndex == toIndex) &#123;</div><div class="line">            elements[fromIndex] = (-<span class="number">1L</span> &gt;&gt;&gt;  (from.ordinal() - to.ordinal() - <span class="number">1</span>))</div><div class="line">                            &lt;&lt; from.ordinal();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            elements[fromIndex] = (-<span class="number">1L</span> &lt;&lt; from.ordinal());</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex + <span class="number">1</span>; i &lt; toIndex; i++)</div><div class="line">                elements[i] = -<span class="number">1</span>;</div><div class="line">            elements[toIndex] = -<span class="number">1L</span> &gt;&gt;&gt; (<span class="number">63</span> - to.ordinal());</div><div class="line">        &#125;</div><div class="line">        size = to.ordinal() - from.ordinal() + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; elements.length; i++)</div><div class="line">            elements[i] = -<span class="number">1</span>;</div><div class="line">        elements[elements.length - <span class="number">1</span>] &gt;&gt;&gt;= -universe.length;</div><div class="line">        size = universe.length;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//其它代码略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JumboEnumSet类把枚举项按照64个元素一组拆分成了多组，每组都映射到一个long类型的数字上，然后该数组再放置到elements数组中，简单来说JumboEnumSet类的原理与RegularEnumSet相似，只是JumboEnumSet使用了long数组容纳更多的枚举项。不过，这样的程序看着会不会觉得郁闷呢？其实这是因为我们在开发中很少使用位移操作。大家可以这样理解：RegularEnumSet是把每个枚举项映射到一个long类型数字的每个位上，JumboEnumSet是先按照64个一组进行拆分，然后每个组再映射到一个long类型数字的每个位上。</p>
<p>从以上分析可知，EnumSet提供的两个实现都是基本的数字类型操作，其性能肯定比其他的Set类型要好的多，特别是Enum的数量少于64的时候，那简直就是飞一般的速度。</p>
<p>注意：枚举项数量不要超过64，否则建议拆分。</p>
<p>ref:<br><a href="http://km.java.tedu.cn/news/163367.html" target="_blank" rel="external">http://km.java.tedu.cn/news/163367.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_性能_推荐使用枚举定义常量</title>
    <url>/2017/07/31/Java-%E6%94%B9%E5%96%84-%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F/</url>
    <content><![CDATA[<p>枚举和注解都是在Java1.5中引入的,虽然他们是后起之秀,但是功能不容小觑,枚举改变了常量的声明方式,注解耦合了数据和代码.</p>
<p>常量的声明是每一个项目中不可或缺的，在Java1.5之前，我们只有两种方式的声明：类常量和接口常量。不过，在1.5版之后有了改进，即新增了一种常量声明方式，枚举常量。代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> Season&#123; </div><div class="line">    Spring,Summer,Autumn,Winter; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>JLS(Java Language Specification,Java语言规范)提倡枚举项全都大写,字母之间用下划线分隔.这也是从常量的角度考虑的.</p>
<a id="more"></a>
<h2 id="枚举常量的优势"><a href="#枚举常量的优势" class="headerlink" title="枚举常量的优势"></a>枚举常量的优势</h2><p>那么枚举常量与我们的经常使用的类常量和静态常量比有什么优势呢?<br>枚举的优点主要表现在以下四个方面.</p>
<h3 id="枚举常量更简单"><a href="#枚举常量更简单" class="headerlink" title="枚举常量更简单"></a>枚举常量更简单</h3><p>先把Season枚举翻译成接口，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Season</span></span>&#123; </div><div class="line">    <span class="keyword">int</span> Sprint = <span class="number">0</span>; </div><div class="line">    <span class="keyword">int</span> Summer = <span class="number">1</span>; </div><div class="line">    <span class="keyword">int</span> Autumn = <span class="number">2</span>; </div><div class="line">    <span class="keyword">int</span> Winter = <span class="number">3</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先对比以下两者的定义,枚举常量只需要定义每个枚举项，不需要定义枚举值，而接口常量（或类常量）则必须定义值，否则编译通不过,即使我们不需要关注其值是多少也必须定义；其次,虽然两个引用的方式相同（都是“类名.属性”，如Season.Sprint），但是枚举表示的是一个枚举项，字面含义是春天，而接口常量却是一个int类型,虽然其字面含义也是春天,但在运算中我们势必要关注其int值.</p>
<h3 id="枚举常量属于稳态型"><a href="#枚举常量属于稳态型" class="headerlink" title="枚举常量属于稳态型"></a>枚举常量属于稳态型</h3><p>例如:我们要给外星人描述一下地球上的春夏秋冬是什么样子的,使用接口常量应该是这样写.<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123; </div><div class="line">    <span class="comment">//s变量不能超越边界，校验条件 </span></div><div class="line">    <span class="keyword">if</span>(s &gt;= <span class="number">0</span> &amp;&amp; s &lt;<span class="number">4</span>)&#123; </div><div class="line">        <span class="keyword">switch</span>(s)&#123; </div><div class="line">            <span class="keyword">case</span> Season.Summer: </div><div class="line">                System.out.println(<span class="string">"Summer is very hot!"</span>); </div><div class="line">                <span class="keyword">break</span>; </div><div class="line">            <span class="keyword">case</span> Season.Winter: </div><div class="line">                System.out.println(<span class="string">"Winter is very cold!"</span>); </div><div class="line">                <span class="keyword">break</span>; </div><div class="line">        ..... </div><div class="line">        &#125; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们需要用switch语句判断是哪一个常量,然后输出.但问题是我们得对输入值进行检查,确定是否越界，如果常量非常庞大，校验输入就是一件非常麻烦的事情，但这是一个不可逃避的过程,特别是如果我们的校验条件不严格,虽然可以编译照样通过,但是运行期就会产生无法预知的后果.</p>
<p>我们再来看看枚举常量是否能够避免校验问题，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describe</span><span class="params">(Season s)</span></span>&#123; </div><div class="line">    <span class="keyword">switch</span>(s)&#123; </div><div class="line">        <span class="keyword">case</span> Season.Summer: </div><div class="line">            System.out.println(<span class="string">"Summer is very hot!"</span>); </div><div class="line">            <span class="keyword">break</span>; </div><div class="line">        <span class="keyword">case</span> Season.Winter: </div><div class="line">            System.out.println(<span class="string">"Winter is very cold!"</span>); </div><div class="line">            <span class="keyword">break</span>; </div><div class="line">       ...... </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不用校验，已经限定了是Season枚举，所以只能是Season类的四个实例。这也是我们看重枚举的地方：在编译期间限定类型，不允许发生越界的情况。  </p>
<h3 id="枚举具有内置方法"><a href="#枚举具有内置方法" class="headerlink" title="枚举具有内置方法"></a>枚举具有内置方法</h3><p>有一个很简单的问题:如果要列出所有的季节常量,如何实现?接口常量或者类常量可以通过反射来实现,这没错,只是虽然能实现,但会非常繁琐.但是对于枚举就可以非常简单的实现.<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </div><div class="line">    <span class="keyword">for</span>(Season s:Season.values())&#123; </div><div class="line">            System.out.println(s); </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过values()方法获得所有的枚举项.这得益于枚举内置的方法,每个枚举都是java.lang.Enum的子类，该基类提供了诸如获得排序值的ordinal方法、compareTo比较方法等，大大简化了常量的访问。</p>
<h3 id="枚举可以自定义方法"><a href="#枚举可以自定义方法" class="headerlink" title="枚举可以自定义方法"></a>枚举可以自定义方法</h3><p>这一点似乎不是枚举的优点，类常量也可以有自己的方法，但关键是枚举常量不仅仅可以定义静态方法，还可以定义非静态方法，而且还能够从根本上杜绝常量类被实例化。比如我们在定义获取最舒服的季节，使用枚举的代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> Season&#123; </div><div class="line">    Spring,Summer,Autumn,Winter; </div><div class="line">    <span class="comment">//最舒服的季节 </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title">getComfortableSeason</span><span class="params">()</span></span>&#123; </div><div class="line">        <span class="keyword">return</span> Spring; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们知道每个枚举项都是该枚举的一个实例,对于我们的例子来说,也就表示Spring其实是Season的一个实例,Summer也是其中的一个实例.那我们再枚举中定义的静态方法既可以在类(Season类)中引用,也可以在实例(也就是枚举项Spring,Summer,Autumn,Winter)中引用,看如下代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> Season&#123; </div><div class="line">    Spring,Summer,Autumn,Winter; </div><div class="line">    <span class="comment">//最舒服的季节 </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title">getComfortableSeason</span><span class="params">()</span></span>&#123; </div><div class="line">        <span class="keyword">return</span> Spring; </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"The most comfortable season is "</span> + Season.getComfortableSeason());</div><div class="line">        System.out.println(<span class="string">"kxh test "</span> + Season.getComfortableSeason());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那如果使用类常量要如何实现呢?代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123; </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> Spring = <span class="number">0</span>; </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> Summer = <span class="number">1</span>; </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> Autumn = <span class="number">2</span>; </div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> Winter = <span class="number">3</span>; </div><div class="line"> </div><div class="line">    <span class="comment">//最舒服的季节 </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getComfortableSeason</span><span class="params">()</span></span>&#123; </div><div class="line">        <span class="keyword">return</span> Spring; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>想想看,我们要怎么才能打印出”The most comfortable season is Spring” 这句话呢? 除了使用switch判断外没有其他更好的办法了.</p>
<p>虽然枚举在很多方面都比接口常量和类常量好用，但是它有一点比不上接口常量和类常量的，就是继承，枚举类型是不能有继承的，也就是说一个枚举常量定义完毕后，除非修改重构，否则无法做扩展。 </p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>在项目开发中，推荐使用枚举常量代替接口常量或类常量。</p>
<p>ref:<br><a href="http://www.cnblogs.com/DreamDrive/p/5419555.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5419555.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>改善</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_改善_枚举和注解结合使用威力更大</title>
    <url>/2017/07/31/Java-%E6%94%B9%E5%96%84-%E6%9E%9A%E4%B8%BE%E5%92%8C%E6%B3%A8%E8%A7%A3%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E5%A8%81%E5%8A%9B%E6%9B%B4%E5%A4%A7/</url>
    <content><![CDATA[<p>_枚举和注解结合使用威力更大</p>
<a id="more"></a>
<p>注解的写法和接口很类似,都采用了关键字interface,而且都不能有实现代码,常量定义默认都是pulbic static final类型的.<br>他们的主要不同点是:注解在interface前加上@字符,而且不能继承,不能实现,这经常会给我们的开发带来一些障碍.</p>
<p>分析一个ACL(Access Contorl List ,访问控制列表)设计案例..看看如何避免这些障碍.<br>ACL中有三个重要的元素:</p>
<ol>
<li>资源,有哪些信息是要被控制起来的.</li>
<li>权限级别,不同的访问者在规划在不同的级别中.</li>
<li>控制器(也叫鉴权人),控制不同的级别访问不同的资源.</li>
</ol>
<p>鉴权人是整个ACL的实际核心,我们从最主要的鉴权人开始,看代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//鉴权者接口</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Identifier</span> </span>&#123;</div><div class="line">    <span class="comment">//无权访问时的礼貌语</span></div><div class="line">    String REFUSE_WORD = <span class="string">"您无权访问"</span>;</div><div class="line">    <span class="comment">// 鉴权</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">identify</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个鉴权人的接口,定义了一个常量和一个鉴权方法,接下来应该实现该鉴权方法,但问题是我们的权限级别和鉴权方法之间是紧耦合的,若分拆成两个类显得有点啰嗦,怎么办?我们可以直接定义一个枚举来实现.<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//常用鉴权者</span></div><div class="line"><span class="keyword">enum</span> CommonIdentifier implements Identifier &#123;</div><div class="line">    <span class="comment">//权限级别</span></div><div class="line">    Reader, Author, Admin;</div><div class="line"></div><div class="line">    <span class="comment">//实现鉴权</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">identify</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>定义了一个通用鉴权者,使用的是枚举类型,并且实现了鉴权者接口,现在就剩下资源定义了,这很容易定义,资源就是我们写的类,方法等,之后再通过配置来决定哪些类,方法允许什么级别的访问,这里的问题是:怎么把资源和权限级别关联起来呢?</p>
<p>使用XML配置文件?是个方法,但是对于我们的示例程序来说显得太过繁重,使用注解会更简洁些.需要首先定义出权限级别的注解,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@interface</span> Access &#123;</div><div class="line">    <span class="comment">//确定什么级别可以访问</span></div><div class="line">    <span class="function">CommonIdentifier <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> CommonIdentifier.Admin</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该注解是标注在类上面的,并且会保留到运行期,我们定义一个资源类,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">//商业逻辑，默认访问权限是Admin</span></div><div class="line"><span class="meta">@Access</span>(level = CommonIdentifier.Author)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Foo类只能是作者级别的人的访问,场景定义完毕,看如何模拟ACL的实现…看代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.Target;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//初始化商业逻辑</span></div><div class="line">        Foo b = <span class="keyword">new</span> Foo();</div><div class="line">        <span class="comment">//获取注解</span></div><div class="line">        Access access = b.getClass().getAnnotation(Access.class);</div><div class="line">        <span class="comment">//没有Access注解或者鉴权失败</span></div><div class="line">        <span class="keyword">if</span> (access == <span class="keyword">null</span> || !access.level().identify()) &#123;</div><div class="line">            <span class="comment">//没有Access注解或者鉴权失败</span></div><div class="line">            System.out.println(access.level().REFUSE_WORD);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//商业逻辑，默认访问权限是Admin</span></div><div class="line"><span class="meta">@Access</span>(level = CommonIdentifier.Author)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//鉴权者接口</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Identifier</span> </span>&#123;</div><div class="line">    <span class="comment">//无权访问时的礼貌语</span></div><div class="line">    String REFUSE_WORD = <span class="string">"您无权访问"</span>;</div><div class="line">    <span class="comment">// 鉴权</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">identify</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//常用鉴权者</span></div><div class="line"><span class="keyword">enum</span> CommonIdentifier implements Identifier &#123;</div><div class="line">    <span class="comment">//权限级别</span></div><div class="line">    Reader, Author, Admin;</div><div class="line"></div><div class="line">    <span class="comment">//实现鉴权</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">identify</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="meta">@interface</span> Access &#123;</div><div class="line">    <span class="comment">//确定什么级别可以访问</span></div><div class="line">    <span class="function">CommonIdentifier <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> CommonIdentifier.Admin</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//*</span></div><div class="line">打印输出:</div><div class="line">您无权访问</div><div class="line">*<span class="comment">//</span></div></pre></td></tr></table></figure></p>
<p>ref:<br><a href="http://www.cnblogs.com/DreamDrive/p/5640900.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5640900.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>改善</tag>
        <tag>Enum</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_改善_用枚举实现工厂方法模式更简洁</title>
    <url>/2017/07/31/Java-%E6%94%B9%E5%96%84-%E7%94%A8%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%9B%B4%E7%AE%80%E6%B4%81/</url>
    <content><![CDATA[<p>_用枚举实现工厂方法模式更简洁</p>
<a id="more"></a>
<h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>(Factory Method Patter)是”创建对象的接口”,让子类决定实例化哪一个类,并使一个类的实例化延迟到其子类.工厂方法模式在我们的开发工作中,经常会用到.</p>
<p>下面以汽车制造为例,看看一般的工厂方法模式是如何实现的,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//生产车辆</span></div><div class="line">        Car car = CarFactory.createCar(FordCar.class);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//抽象产品</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;&#125;;</div><div class="line"><span class="comment">//具体产品类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FordCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;&#125;;</div><div class="line"><span class="comment">//具体产品类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuickCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;&#125;;</div><div class="line"><span class="comment">//工厂类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</div><div class="line">    <span class="comment">//生产汽车</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">createCar</span><span class="params">(Class&lt;? extends Car&gt; c)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">return</span> (Car) c.newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是最原始的工厂方法模式,有两个产品”福特骑车和别克骑车,然后通过工厂方法模式来生产,有了工厂方法模式,我们就不用关心一辆车具体是怎么生成的了,只要告诉工厂”给我生产一辆福特骑车”就可以了,下面是产出一辆福特骑车时客户端的代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Car car = CarFactory.createCar(FordCar.class);</div></pre></td></tr></table></figure></p>
<p>这就是我们经常使用的工厂方法模式,但经常使用不代表就是最优秀的,最简洁的.</p>
<p>此处在介绍一种通过枚举实现工厂方法模式的方案,谁优谁劣自行评价.枚举实现工厂方法模式有两种方法:</p>
<h2 id="枚举非静态方法实现工厂方法模式"><a href="#枚举非静态方法实现工厂方法模式" class="headerlink" title="枚举非静态方法实现工厂方法模式"></a>枚举非静态方法实现工厂方法模式</h2><p>我们知道每个枚举项都是该枚举的实例对象,那是不是定义一个方法可以生成每个枚举项的对应产品来实现此模式呢?代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Car car = CarFactory.BuickCar.create();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FordCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuickCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> CarFactory &#123;</div><div class="line">    <span class="comment">//定义工厂类能生产汽车的类型</span></div><div class="line">    FordCar, BuickCar;</div><div class="line">    <span class="comment">//生产汽车</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">case</span> FordCar:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FordCar();</div><div class="line">        <span class="keyword">case</span> BuickCar:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BuickCar();</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"无效参数"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>create是一个非静态方法,也就是只有通过FordCar,BuickCar枚举项才能访问,采用这种方式实现工厂方法模式时,客户端要产生一辆汽车就很简单了.代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">Car car = CarFactory.BuickCar.create();</div></pre></td></tr></table></figure></p>
<h2 id="通过抽象方法生成产品"><a href="#通过抽象方法生成产品" class="headerlink" title="通过抽象方法生成产品"></a>通过抽象方法生成产品</h2><p>枚举类型虽然不能继承,但是可以用abstract修饰其方法,此时就标识该枚举是一个抽象枚举,需要每个枚举项自行实现该方法,也就说枚举项的类型是该枚举的一个子类,看代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Car car = CarFactory.BuickCar.create();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FordCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuickCar</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> CarFactory &#123;</div><div class="line">    FordCar &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FordCar();</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    BuickCar &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BuickCar();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">//抽象生产方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Car <span class="title">create</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先定义一个抽象制造方法create,然后 每个枚举项自行实现,这种方式编译后会产生两个CarFactory的匿名子类,因为每个枚举项都 要实现抽象create方法,客户端的调用与上一个方案相同,不再赘述.</p>
<h2 id="使用枚举类型的工厂方法模式的优点"><a href="#使用枚举类型的工厂方法模式的优点" class="headerlink" title="使用枚举类型的工厂方法模式的优点:"></a>使用枚举类型的工厂方法模式的优点:</h2><ol>
<li>避免错误调用的发生<br>一般工厂方法模式中的生产方法(也就是createCar方法)可以接收三种类型的参数:类型参数(Class),String参数(生产方法中判断String参数是需要生产什么产品),int参数(根据int值判断需要生产什么类型的产品).<br>这三种参数都是宽泛的数据类型,很容易产生错误.比如边界问题,null值问题,而且出现这类错误编译器还不会报警.例如:Car car = CarFactory.createCar(Car.class);<br>Car是一个接口,完全合乎createCar方法的要求,所以它在编译时不会报任何错误,但一运行起来就会报java.lang.InstantiationException异常,而使用枚举类型的工厂方法模式就不存在该问题.不需要传递任何参数,只需要选择好生产什么类型的产品就可以了.</li>
<li>性能好,使用便捷.<br>枚举类型的计算是以int类型的计算为基础的,这是最基本的操作,性能当然快.</li>
<li>降低类间的耦合<br>不管生产方法接收的是Class,String还是int参数,都会成为客户端类的负担.这些类并不是客户端需要的,而是因为工厂方法的限制必须输入的.</li>
</ol>
<p>ref:<br><a href="http://www.cnblogs.com/DreamDrive/p/5633233.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5633233.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>改善</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_规避_Enum使用valueOf前必须进行校验</title>
    <url>/2017/07/31/Java-%E8%A7%84%E9%81%BF-Enum%E4%BD%BF%E7%94%A8valueOf%E5%89%8D%E5%BF%85%E9%A1%BB%E8%BF%9B%E8%A1%8C%E6%A0%A1%E9%AA%8C/</url>
    <content><![CDATA[<p>避_Enum使用valueOf前必须进行校验</p>
<a id="more"></a>
<p>每个枚举都是java.lang.Enum的子类,都可以访问Enum类提供的方法,比如hashCode(),name(),valueOf()等…..</p>
<p>其中valueOf()方法会把一个String类型的名称转变为枚举项,也就是枚举项中查找出字面值与该参数相等的枚举项,虽然这个方法很简单,但是JDK却做了一个对于开发人员来说并不简单的处理:</p>
<p>看代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//注意summer是小写</span></div><div class="line">        List&lt;String&gt; params = Arrays.asList(<span class="string">"Spring"</span>, <span class="string">"summer"</span>);</div><div class="line">        <span class="keyword">for</span> (String name : params) &#123;</div><div class="line">            <span class="comment">//查找表面值与name相同的枚举项</span></div><div class="line">            Season s = Season.valueOf(name);</div><div class="line">            <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 有该枚举项时的处理</span></div><div class="line">                System.out.println(s);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 没有该枚举项时的逻辑处理</span></div><div class="line">                System.out.println(<span class="string">"无相关枚举项"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> Season &#123;</div><div class="line">    Spring, Summer, Autumn, Winter;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行输出:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Spring</div><div class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: No enum constant cn.summerchill.test.Season.summer</div><div class="line">    at java.lang.Enum.valueOf(Unknown Source)</div><div class="line">    at cn.summerchill.test.Season.valueOf(Client.java:1)</div><div class="line">    at cn.summerchill.test.Client.main(Client.java:12)</div></pre></td></tr></table></figure></p>
<p>这段代码看起来很完美了,其中考虑到从String转换成枚举类型可能不成功的情况,比如没有匹配到指定的值,此时valueof的返回值应该为空,所以后面又紧跟着if….else判断输出.</p>
<p>但是运行结果抛出异常.报告是无效参数异常…也就说summer(小写s)午饭转换为Season枚举,无法转换那也不应该抛出IllegalArgumentException异常啊,一旦抛出这个异常,后续的代码就不能执行了,这才是要命的,</p>
<p>这与我们的习惯用法不一致,例如我们从List中查找一个元素,即使不存在也不会报错,顶多indexOf方法返回-1.</p>
<p>看源码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType, String name)</span> </span>&#123;</div><div class="line">        T result = enumType.enumConstantDirectory().get(name);<span class="comment">//通过反射,从常量列表中查找.</span></div><div class="line">        <span class="keyword">if</span> (result != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="comment">//最后报无效参数异常</span></div><div class="line">            <span class="string">"No enum constant "</span> + enumType.getCanonicalName() + <span class="string">"."</span> + name);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>valueOf方法先通过反射从枚举类的常量声明中查找,若找到就直接返回,若找不到就抛出无效参数异常.</p>
<p>valueOf方法本意是保护编码中的枚举安全性,使其不产生空枚举对象,简化枚举操作,但是又引入了一个我们无法避免的IllegalArgumentException异常.</p>
<p>可能有读者会所此处valueOf()方法的源代码不对,以上源代码是要输入两个参数,而我们的Season.valueOf()值传递一个String类型的参数.</p>
<p>真的是这样吗?是的,因为valueOf(String name)方法是不可见的,是JVM内置的方法,我们只有通过阅读公开的valueOf方法来了解其运行原理.</p>
<p>在Season枚举类中引用valueOf方法有三个: valueOf(String arg0): Season-Season, values():Season[], valueOf(Class<t> enumType, String name):T-Enum</t></p>
<p>但是在Enum的源码中只有一个valueOf()的方法: 其他两个方法都是JVM的内置方法…</p>
<p>问题清楚了,我们有两种方式可以解决处理此问题:<br>(1)使用try….catch捕获异常<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Season s = Season.valueOf(name);</div><div class="line">    <span class="comment">// 有该枚举项时的处理</span></div><div class="line">    System.out.println(s);</div><div class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">    System.out.println(<span class="string">"无相关枚举项"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(2)扩展枚举类:<br>由于Enum类定义的方法基本上都是final类型的,所以不希望被覆写,那我们可以学习List和String,通过增加一个contains方法来判断是否包含指定的枚举项,然后再继续转换,看代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> Season &#123;</div><div class="line">    Spring, Summer, Autumn, Winter;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String _name)</span></span>&#123;</div><div class="line">        Season[] season = values();</div><div class="line">        <span class="keyword">for</span>(Season s:season)&#123;</div><div class="line">            <span class="keyword">if</span>(s.name().equals(_name))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Season枚举具备了静态方法contains()之后,就可以在valueOf前判断一下是否包含指定的枚举名称了,若包含则可以通过valueOf转换为Season枚举，若不包含则不转换.</p>
<p>总结代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 注意summer是小写</span></div><div class="line">        List&lt;String&gt; params = Arrays.asList(<span class="string">"Spring"</span>, <span class="string">"summer"</span>);</div><div class="line">        <span class="keyword">for</span> (String name : params) &#123;</div><div class="line">            <span class="comment">// 查找表面值与name相同的枚举项</span></div><div class="line"><span class="comment">//            Season s = Season.valueOf(name);</span></div><div class="line"><span class="comment">//            if (s != null) &#123;</span></div><div class="line"><span class="comment">//                // 有该枚举项时的处理</span></div><div class="line"><span class="comment">//                System.out.println(s);</span></div><div class="line"><span class="comment">//            &#125; else &#123;</span></div><div class="line"><span class="comment">//                // 没有该枚举项时的逻辑处理</span></div><div class="line"><span class="comment">//                System.out.println("无相关枚举项");</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line">            <span class="keyword">if</span> (Season.contains(name)) &#123;</div><div class="line">                Season s = Season.valueOf(name);</div><div class="line">                <span class="comment">// 有该枚举项时的处理</span></div><div class="line">                System.out.println(s);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.println(<span class="string">"无相关枚举项"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> Season &#123;</div><div class="line">    Spring, Summer, Autumn, Winter;</div><div class="line"></div><div class="line">    <span class="comment">// 是否包含指定名称的枚举项</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        Season[] season = values(); <span class="comment">// 所有的枚举值</span></div><div class="line"></div><div class="line">        <span class="comment">// 遍历查找</span></div><div class="line">        <span class="keyword">for</span> (Season s : season) &#123;</div><div class="line">            <span class="keyword">if</span> (s.name().equals(name)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ref:<br><a href="http://www.cnblogs.com/DreamDrive/p/5632706.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5632706.html</a></p>
<!-- more -->
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Enum</tag>
        <tag>规避</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_规避_警惕浅拷贝</title>
    <url>/2017/07/31/Java-%E8%A7%84%E9%81%BF-%E8%AD%A6%E6%83%95%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>警惕浅拷贝</p>
<a id="more"></a>
<h2 id="数组的浅拷贝"><a href="#数组的浅拷贝" class="headerlink" title="数组的浅拷贝"></a>数组的浅拷贝</h2><p>有这样一个例子，第一个箱子里面与赤橙黄绿青蓝紫7色气球，现在希望第二个箱子也放入7个气球，其中最后一个气球改为蓝色，也就是赤橙黄绿青蓝蓝七个气球。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> org.apache.commons.lang3.builder.ToStringBuilder;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="comment">//气球的数量</span></div><div class="line">        <span class="keyword">int</span> ballonNum = <span class="number">7</span>;</div><div class="line">        <span class="comment">//第一个箱子</span></div><div class="line">        Ballon[] box1 = <span class="keyword">new</span> Ballon[ballonNum];</div><div class="line">        <span class="comment">//初始化第一个箱子</span></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ballonNum; i++)&#123;</div><div class="line">            box1[i] = <span class="keyword">new</span> Ballon(Color.values()[i],i);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//第二个箱子的小球是拷贝的第一个箱子里的</span></div><div class="line">        Ballon[] box2 = Arrays.copyOf(box1,box1.length);</div><div class="line">        <span class="comment">//修改最后一个气球的颜色</span></div><div class="line">        box2[<span class="number">6</span>].setColor(Color.Blue);</div><div class="line">        <span class="comment">//打印出第一个箱子中的气球颜色</span></div><div class="line">        <span class="keyword">for</span>(Ballon b:box1)&#123;</div><div class="line">            System.out.println(b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//气球的颜色</span></div><div class="line"><span class="keyword">enum</span> Color&#123;</div><div class="line">    Red,Orange,Yellow,Green,Indigo,Blue,Violet;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//气球</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ballon</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id; <span class="comment">//编号</span></div><div class="line">    <span class="keyword">private</span> Color color; <span class="comment">//颜色</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Color <span class="title">getColor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> color;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.color = color;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ballon</span><span class="params">(Color _color,<span class="keyword">int</span> _id)</span></span>&#123;</div><div class="line">        color = _color;</div><div class="line">        id = _id;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/*id、color的getter/setter方法省略*/</span></div><div class="line">    <span class="comment">//apache-common包下的ToStringBuilder重写toString方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ToStringBuilder(<span class="keyword">this</span>).append(<span class="string">"编号"</span>,id).append(<span class="string">"颜色"</span>,color).toString();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二个箱子的最后一个气球毫无疑问是被修改了蓝色，不过是通过拷贝第一个箱子的气球实现的，那么会对第一个箱子的气球颜色有影响吗？输出结果：<br>Balloon@b2fd8f[编号=0,颜色=Red]<br>Balloon@a20892[编号=1,颜色=Orange]<br>Balloon@158b649[编号=2,颜色=Yellow]<br>Balloon@1037c71[编号=3,颜色=Green]<br>Balloon@1546e25[编号=4,颜色=Indigo]<br>Balloon@8a0d5d[编号=5,颜色=Blue]<br>Balloon@a470b8[编号=6,颜色=Blue]<br>最后一个气球竟然被修改了。这是为何？</p>
<p>这是典型的浅拷贝（Shallow Clone）问题，通过copyOf()方法产生的数组是一个浅拷贝引用地址。需要说明的是数组的clone()方法也是与此相同，同样是浅拷贝，而且集合的clone()方法也是浅拷贝。这就需要大家多留心了。<br>问题找到了，解决办法也很简单，遍历box1的每个元素，重新生成一个气球（Ballon）对象，并放置到box2数组中。<br>很多地方使用集合（如List）进行业务处理时，比如发觉需要拷贝集合中的元素，可集合没有提供任何拷贝方法，所以干脆使用 List.toArray方法转换成数组，然后通过Arrays.copyOf拷贝，然后转换成集合，简单便捷！但是，非常遗憾，这里我们又撞到浅拷贝的 枪口上了！！！！</p>
<h2 id="对象的浅拷贝"><a href="#对象的浅拷贝" class="headerlink" title="对象的浅拷贝"></a>对象的浅拷贝</h2><p>我们知道一个类实现了Cloneable接口就表示它具备了被拷贝的能力，如果再覆写clone()方法就会完全具备拷贝能力。拷贝是在内存中进行的，所以在性能方面比直接通过new生成对象要快很多，特别是在大对象的生成上，这会使性能的提升非常显著。但是对象拷贝也有一个比较容易忽略的问题：浅拷贝（Shadow Clone，也叫做影子拷贝）存在对象属性拷贝不彻底的问题。我们来看这样一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">         <span class="comment">//定义父亲</span></div><div class="line">         Person f = <span class="keyword">new</span> Person(<span class="string">"父亲"</span>);</div><div class="line">         <span class="comment">//定义大儿子</span></div><div class="line">         Person s1 = <span class="keyword">new</span> Person(<span class="string">"大儿子"</span>,f);</div><div class="line">         <span class="comment">//小儿子的信息是通过大儿子拷贝过来的</span></div><div class="line">         Person s2 = s1.clone();</div><div class="line">         s2.setName(<span class="string">"小儿子"</span>);</div><div class="line">         System.out.println(s1.getName() +<span class="string">" 的父亲是 "</span> + s1.getFather().getName());</div><div class="line">         System.out.println(s2.getName() +<span class="string">" 的父亲是 "</span> + s2.getFather().getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</div><div class="line">    <span class="comment">//姓名</span></div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="comment">//父亲</span></div><div class="line">    <span class="keyword">private</span> Person father;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String _name)</span></span>&#123;</div><div class="line">         name = _name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String _name,Person _parent)</span></span>&#123;</div><div class="line">         name = _name;</div><div class="line">         father = _parent;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/*name和parent的getter/setter方法省略*/</span></div><div class="line"></div><div class="line">    <span class="comment">//拷贝的实现</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span></span>&#123;</div><div class="line">         Person p = <span class="keyword">null</span>;</div><div class="line">         <span class="keyword">try</span> &#123;</div><div class="line">           p = (Person) <span class="keyword">super</span>.clone();</div><div class="line">         &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">           e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> p;</div><div class="line">   &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getFather</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> father;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFather</span><span class="params">(Person father)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.father = father;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>程序中，我们描述了这样一个场景：一个父亲，有两个儿子，大小儿子同根同种，所以小儿子对象就通过拷贝大儿子对象来生成，运行输出的结果如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">大儿子 的父亲是 父亲</div><div class="line">小儿子 的父亲是 父亲</div></pre></td></tr></table></figure></p>
<p>这很正确，没有问题。突然有一天，父亲心血来潮想让大儿子去认个干爹，也就是大儿子的父亲名称需要重新设置一下，代码如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static void main(String[] args) &#123;</div><div class="line">     //定义父亲</div><div class="line">     Person f = new Person(&quot;父亲&quot;);</div><div class="line">     //定义大儿子</div><div class="line">     Person s1 = new Person(&quot;大儿子&quot;,f);</div><div class="line">     //小儿子的信息是通过大儿子拷贝过来的</div><div class="line">     Person s2 = s1.clone();</div><div class="line">     s2.setName(&quot;小儿子&quot;);</div><div class="line">     //认干爹</div><div class="line">     s1.getFather().setName(&quot;干爹&quot;);</div><div class="line">     System.out.println(s1.getName() +&quot; 的父亲是 &quot; + s1.getFather().getName());</div><div class="line">     System.out.println(s2.getName() +&quot; 的父亲是 &quot; + s2.getFather().getName());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面仅仅修改了加粗字体部分，大儿子重新设置了父亲名称，我们期望的输出是：将大儿子父亲的名称修改为干爹，小儿子的父亲名称保持不变。下面来检查一下结果是否如此：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">大儿子 的父亲是 干爹</div><div class="line">小儿子 的父亲是 干爹</div></pre></td></tr></table></figure></p>
<p>怎么回事，小儿子的父亲也成了“干爹”?两个儿子都没有，岂不是要气死“父亲”了！出现这个问题的原因就在于clone方法，我们知道所有类都继承自Object，Object提供了一个对象拷贝的默认方法，即上面代码中的super.clone方法，但是该方法是有缺陷的，它提供的是一种浅拷贝方式，也就是说它并不会把对象的所有属性全部拷贝一份，而是有选择性的拷贝，它的拷贝规则如下：</p>
<ul>
<li>基本类型<br>如果变量是基本类型，则拷贝其值，比如int、float等。</li>
<li>对象<br>如果变量是一个实例对象，则拷贝地址引用，也就是说此时新拷贝出的对象与原有对象共享该实例变量，不受访问权限的限制。这在Java中是很疯狂的，因为它突破了访问权限的定义：一个private修饰的变量，竟然可以被两个不同的实例对象访问，这让Java的访问权限体系情何以堪！</li>
<li>String字符串<br>这个比较特殊，拷贝的也是一个地址，是个引用，但是在修改时，它会从字符串池（String Pool）中重新生成新的字符串，原有的字符串对象保持不变，在此处我们可以认为String是一个基本类型。</li>
</ul>
<p>明白了这三个规则，上面的例子就很清晰了，小儿子对象是通过拷贝大儿子产生的，其父亲都是同一个人，也就是同一个对象，大儿子修改了父亲名称，小儿子也就跟着修改了—于是，父亲的两个儿子都没了！其实要更正也很简单，clone方法的代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">clone</span><span class="params">()</span></span>&#123;</div><div class="line">     Person p = <span class="keyword">null</span>;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">        p = (Person) <span class="keyword">super</span>.clone();</div><div class="line">        p.setFather(<span class="keyword">new</span> Person(p.getFather().getName()));</div><div class="line">     &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后再运行，小儿子的父亲就不会是“干爹”了。如此就实现了对象的深拷贝（Deep Clone），保证拷贝出来的对象自成一体，不受“母体”的影响，和new生成的对象没有任何区别。<br>注意　浅拷贝只是Java提供的一种简单拷贝机制，不便于直接使用。</p>
<h2 id="推荐使用序列化实现对象的拷贝"><a href="#推荐使用序列化实现对象的拷贝" class="headerlink" title="推荐使用序列化实现对象的拷贝"></a>推荐使用序列化实现对象的拷贝</h2><p>上一个建议说了对象的浅拷贝问题，实现Cloneable接口就具备了拷贝能力，那我们来思考这样一个问题：如果一个项目中有大量的对象是通过拷贝生成的，那我们该如何处理？每个类都写一个clone方法，并且还要深拷贝？想想看这是何等巨大的工作量呀，是否有更好的方法呢？</p>
<p>其实，可以通过序列化方式来处理，在内存中通过字节流的拷贝来实现，也就是把母对象写到一个字节流中，再从字节流中将其读出来，这样就可以重建一个新对象了，该新对象与母对象之间不存在引用共享的问题，也就相当于深拷贝了一个新对象，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneUtils</span> </span>&#123;</div><div class="line">     <span class="comment">// 拷贝一个对象</span></div><div class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> </span>&#123;</div><div class="line">          <span class="comment">// 拷贝产生的对象</span></div><div class="line">          T clonedObj = <span class="keyword">null</span>;</div><div class="line">          <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 读取对象字节数据</span></div><div class="line">            ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</div><div class="line">            oos.writeObject(obj);</div><div class="line">            oos.close();</div><div class="line">            <span class="comment">// 分配内存空间，写入原始对象，生成新对象</span></div><div class="line">            ByteArrayInputStream bais = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</div><div class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bais);</div><div class="line">            <span class="comment">//返回新对象，并做类型转换</span></div><div class="line">            clonedObj = (T)ois.readObject();</div><div class="line">            ois.close();</div><div class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">return</span> clonedObj;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此工具类要求被拷贝的对象必须实现Serializable接口，否则是没办法拷贝的（当然，使用反射那是另外一种技巧），上一个建议中的例子只要稍微修改一下即可实现深拷贝，代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1611293231L</span>;</div><div class="line">     <span class="comment">/*删除掉clone方法，其他代码保持不变*/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们就可以通过CloneUtils工具进行对象的深拷贝了。用此方法进行对象拷贝时需要注意两点：</p>
<ul>
<li>对象的内部属性都是可序列化的<br>如果有内部属性不可序列化，则会抛出序列化异常，这会让调试者很纳闷：生成一个对象怎么会出现序列化异常呢？从这一点来考虑，也需要把CloneUtils工具的异常进行细化处理。</li>
<li>注意方法和属性的特殊修饰符<br>比如final、static变量的序列化问题会被引入到对象拷贝中来，这点需要特别注意，同时transient变量（瞬态变量，不进行序列化的变量）也会影响到拷贝的效果。</li>
</ul>
<p>当然，采用序列化方式拷贝时还有一个更简单的办法，即使用Apache下的commons工具包中的SerializationUtils类，直接使用更加简洁方便。</p>
<p>ref:<br><a href="http://www.cnblogs.com/DreamDrive/p/5422216.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5422216.html</a><br><a href="http://www.cnblogs.com/DreamDrive/p/5430479.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5430479.html</a><br><a href="http://www.cnblogs.com/DreamDrive/p/5430981.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5430981.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>规避</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_规避_避开基本类型数组转换列表陷阱</title>
    <url>/2017/07/31/Java-%E8%A7%84%E9%81%BF-%E9%81%BF%E5%BC%80%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E5%88%97%E8%A1%A8%E9%99%B7%E9%98%B1/</url>
    <content><![CDATA[<p>_避开基本类型数组转换列表陷阱</p>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>开发中经常用到Arrays和Collections这两个工具类. 在数组和列表之间进行切换.非常方便.但是也会遇到一些问题.<br>看代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">        List list = Arrays.asList(data);</div><div class="line">        System.out.println(<span class="string">"列表中的元素数量是："</span> + list.size());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">运行结果: </div><div class="line">列表中的元素数量是：1</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为什么不是5? 事实上data确实是一个有5个元素的int类型数组,只是通过asList转换列表之后就只有一个元素了.<br>看Arrays.asList的方法说明:输入一个变长参数,返回一个固定长度的列表.<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a fixed-size list backed by the specified array.  (Changes to</div><div class="line"> * the returned list "write through" to the array.)  This method acts</div><div class="line"> * as bridge between array-based and collection-based APIs, in</div><div class="line"> * combination with &#123;<span class="doctag">@link</span> Collection#toArray&#125;.  The returned list is</div><div class="line"> * serializable and implements &#123;<span class="doctag">@link</span> RandomAccess&#125;.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This method also provides a convenient way to create a fixed-size</div><div class="line"> * list initialized to contain several elements:</div><div class="line"> * &lt;pre&gt;</div><div class="line"> *     List&amp;lt;String&amp;gt; stooges = Arrays.asList("Larry", "Moe", "Curly");</div><div class="line"> * &lt;/pre&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> a the array by which the list will be backed</div><div class="line"> * <span class="doctag">@return</span> a list view of the specified array</div><div class="line"> */</div><div class="line"><span class="meta">@SafeVarargs</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>asList方法输入的是一个泛型变长参数,我们知道基本类型是不能泛型化的,也就是说8个基本类型不能作为泛型参数,要想作为泛型参数就必须使用其所对应的包装类型,那前面的例子传递了一个int类型的数组,程序为何没有编译报错?<br>Java中数组是一个对象,它是可以泛型化的,也就说例子中是把一个int类型的数组作为了T的类型,所以转换后在List中就只有一个类型为int数组的元素了.打印出来<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">        List list = Arrays.asList(data);</div><div class="line">        System.out.println(<span class="string">"元素类型："</span> + list.get(<span class="number">0</span>).getClass());</div><div class="line">        System.out.println(<span class="string">"前后是否相等："</span>+data.equals(list.get(<span class="number">0</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">运行输出:</div><div class="line">元素类型：class [I</div><div class="line">前后是否相等：true</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>放在列表中的元素是一个int数组,为什么”元素类型”后的class是”[I”?  因为JVM不可能输出Array类型,因为Array是属于java.lang.reflect包的,它是通过反射访问数组元素的工具类.在Java中任何一个数组的类都是”[I”(如果是double对应”[D”,float对应的是”[F”),究其原因就是Java中并没有定义数组这个类,它是编译器编译的时候生成的,是一个特殊的类,在JDK的帮助中也没有任何数组类的信息.</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>修改方案,直接使用包装类即可,代码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Integer[] data = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</div><div class="line">        List list = Arrays.asList(data);</div><div class="line">        System.out.println(<span class="string">"列表中的元素数量是："</span> + list.size());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">运行输出:</div><div class="line">列表中的元素数量是：5</div><div class="line">*</div></pre></td></tr></table></figure></p>
<p>仅仅把int变成Integer,即可让输出的元素数量变成5,需要说明的是,不仅仅是int类型的数组有这个问题,其他7个基本类型的数组也都存在相似的问题.<br>在把基本类型数组转换成列表时,要特别小心asList方法的陷阱,避免出现程序逻辑混乱的情况.</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>原始类型数组不能作为asList的输入参数,否则会引起程序逻辑混乱.</p>
<p>ref:<br><a href="http://www.cnblogs.com/DreamDrive/p/5641065.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5641065.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>规避</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_语法_Enum</title>
    <url>/2017/07/31/Java-%E8%AF%AD%E6%B3%95-Enum/</url>
    <content><![CDATA[<p>JDK1.5引入了新的类型——枚举。在 Java 中它虽然算个“小”功能，却给我的开发带来了“大”方便。</p>
<a id="more"></a>
<h2 id="用法一：常量"><a href="#用法一：常量" class="headerlink" title="用法一：常量"></a>用法一：常量</h2><p>在JDK1.5 之前，我们定义常量都是： public static final…. 。现在好了，有了枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;  </div><div class="line">  RED, GREEN, BLANK, YELLOW  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="用法二：switch"><a href="#用法二：switch" class="headerlink" title="用法二：switch"></a>用法二：switch</h2><p>JDK1.6之前的switch语句只支持int,char,enum类型，使用枚举，能让我们的代码可读性更强。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> Signal &#123;  </div><div class="line">    GREEN, YELLOW, RED  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficLight</span> </span>&#123;  </div><div class="line">    Signal color = Signal.RED;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">switch</span> (color) &#123;  </div><div class="line">        <span class="keyword">case</span> RED:  </div><div class="line">            color = Signal.GREEN;  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> YELLOW:  </div><div class="line">            color = Signal.RED;  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        <span class="keyword">case</span> GREEN:  </div><div class="line">            color = Signal.YELLOW;  </div><div class="line">            <span class="keyword">break</span>;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="用法三：向枚举中添加新方法"><a href="#用法三：向枚举中添加新方法" class="headerlink" title="用法三：向枚举中添加新方法"></a>用法三：向枚举中添加新方法</h2><p>如果打算自定义自己的方法，那么必须在enum实例序列的最后添加一个分号。而且 Java 要求必须先定义 enum 实例。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;  </div><div class="line">    RED(<span class="string">"红色"</span>, <span class="number">1</span>), GREEN(<span class="string">"绿色"</span>, <span class="number">2</span>), BLANK(<span class="string">"白色"</span>, <span class="number">3</span>), YELLO(<span class="string">"黄色"</span>, <span class="number">4</span>);  </div><div class="line">    <span class="comment">// 成员变量  </span></div><div class="line">    <span class="keyword">private</span> String name;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;  </div><div class="line">    <span class="comment">// 构造方法  </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">        <span class="keyword">this</span>.index = index;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// 普通方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">        <span class="keyword">for</span> (Color c : Color.values()) &#123;  </div><div class="line">            <span class="keyword">if</span> (c.getIndex() == index) &#123;  </div><div class="line">                <span class="keyword">return</span> c.name;  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">// get set 方法  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> name;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> index;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.index = index;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="用法四：覆盖枚举的方法"><a href="#用法四：覆盖枚举的方法" class="headerlink" title="用法四：覆盖枚举的方法"></a>用法四：覆盖枚举的方法</h2><p>下面给出一个toString()方法覆盖的例子。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;  </div><div class="line">    RED(<span class="string">"红色"</span>, <span class="number">1</span>), GREEN(<span class="string">"绿色"</span>, <span class="number">2</span>), BLANK(<span class="string">"白色"</span>, <span class="number">3</span>), YELLO(<span class="string">"黄色"</span>, <span class="number">4</span>);  </div><div class="line">    <span class="comment">// 成员变量  </span></div><div class="line">    <span class="keyword">private</span> String name;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;  </div><div class="line">    <span class="comment">// 构造方法  </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">        <span class="keyword">this</span>.index = index;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//覆盖方法  </span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.index+<span class="string">"_"</span>+<span class="keyword">this</span>.name;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="用法五：实现接口"><a href="#用法五：实现接口" class="headerlink" title="用法五：实现接口"></a>用法五：实现接口</h2><p>所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Behaviour</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;  </div><div class="line">    <span class="function">String <span class="title">getInfo</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color implements Behaviour&#123;  </div><div class="line">    RED(<span class="string">"红色"</span>, <span class="number">1</span>), GREEN(<span class="string">"绿色"</span>, <span class="number">2</span>), BLANK(<span class="string">"白色"</span>, <span class="number">3</span>), YELLO(<span class="string">"黄色"</span>, <span class="number">4</span>);  </div><div class="line">    <span class="comment">// 成员变量  </span></div><div class="line">    <span class="keyword">private</span> String name;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;  </div><div class="line">    <span class="comment">// 构造方法  </span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.name = name;  </div><div class="line">        <span class="keyword">this</span>.index = index;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//接口方法  </span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;  </div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//接口方法  </span></div><div class="line">    <span class="meta">@Override</span>  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;  </div><div class="line">        System.out.println(<span class="keyword">this</span>.index+<span class="string">":"</span>+<span class="keyword">this</span>.name);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="用法六：使用接口组织枚举"><a href="#用法六：使用接口组织枚举" class="headerlink" title="用法六：使用接口组织枚举"></a>用法六：使用接口组织枚举</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;  </div><div class="line">    <span class="keyword">enum</span> Coffee implements Food&#123;  </div><div class="line">        BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">enum</span> Dessert implements Food&#123;  </div><div class="line">        FRUIT, CAKE, GELATO  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="用法七：使用构造函数协助描述枚举项"><a href="#用法七：使用构造函数协助描述枚举项" class="headerlink" title="用法七：使用构造函数协助描述枚举项"></a>用法七：使用构造函数协助描述枚举项</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一般来说，我们经常使用的枚举项只有一个属性，即排序号，其默认值是从0、1、2… …。但是除了排序号外，枚举还有一个（或多个）属性:枚举描述,它的含义是通过枚举的构造函数,声明每个枚举项(也就是枚举实例)必须具有的属性和行为,这是对枚举项的描述或补充,目的是使枚举项表述的意义更加清晰准确.</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>比如，可以通过枚举构造函数声明业务值，定义可选项，添加属性，看如下代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        System.out.println(Season.Spring.getDesc());</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">enum</span> Season &#123;</div><div class="line">    Spring(<span class="string">"春"</span>), Summer(<span class="string">"夏"</span>), Autumn(<span class="string">"秋"</span>), Winter(<span class="string">"冬"</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String desc;</div><div class="line">    Season(String _desc)&#123;</div><div class="line">        desc = _desc;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//获得枚举值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> desc;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">运行输出: 春</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>其枚举项是英文的,描述是英文的,这样使其描述更加准确.方便了多个协作者共同引用常量.若不考虑描述的使用(即访问getDesc方法),它与如下定义的描述很相似.<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Season</span></span>&#123;</div><div class="line">    <span class="comment">//春</span></div><div class="line">    <span class="keyword">int</span> Spring = <span class="number">0</span>;</div><div class="line">    <span class="comment">//夏</span></div><div class="line">    <span class="keyword">int</span> Summer =<span class="number">1</span></div><div class="line">    .....</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比较上面两段代码,很容易看出使用枚举项是一个很好的解决方案,非常简单,清晰.</p>
<p>可以通过枚举构造函数声明业务值,定义可选项,添加属性等.看如下代码:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">enum</span> Role&#123; </div><div class="line">    Admin(<span class="string">"管理员"</span>,<span class="keyword">new</span> Lifetime(),<span class="keyword">new</span> Scope()); </div><div class="line">    User(<span class="string">"普通用户"</span>,<span class="keyword">new</span> Lifetime(),<span class="keyword">new</span> Scope()); </div><div class="line"> </div><div class="line">    <span class="comment">//中文描述 </span></div><div class="line">    <span class="keyword">private</span> String name; </div><div class="line">    <span class="comment">//角色生命周期 </span></div><div class="line">    <span class="keyword">private</span> Lifetime lifeTime; </div><div class="line">    <span class="comment">//权限范围 </span></div><div class="line">    <span class="keyword">private</span> Scope scope; </div><div class="line"> </div><div class="line">    Role(String _name,Lifetime _lt,Scope _scope)&#123; </div><div class="line">        name = _name; </div><div class="line">        lifeTime = _lifeTime; </div><div class="line">        scope = _scope; </div><div class="line">    &#125; </div><div class="line">    <span class="comment">/**name,lifeTime,scope的get方法较简单，不再赘述*/</span> </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这是一个角色定义类,描述了两个角色:管理员(Admin)和普通用户(User),同时它还通过构造函数对这两个角色进行了描述.:</p>
<ol>
<li>name 表示的是该角色的中文名称</li>
<li>lifeTime 表示的是该角色的生命周期,也就是多长时间角色失效</li>
<li>scope 表示的是该角色的权限范围.</li>
</ol>
<p>这样 一个描述可以使开发者对Admin和User两个常量有一个立体多维度的认知.有名称,生命期还有权限范围.而且还可以在程序中方便的获得这些属性.</p>
<p>建议在枚举定义中改为每个枚举项定义描述,特别是在大规模的项目开发中.大量的常量项定义使用枚举比在接口常量或者类常量中增加注释的方式友好简洁很多.</p>
<h2 id="用法八：关于枚举集合的使用"><a href="#用法八：关于枚举集合的使用" class="headerlink" title="用法八：关于枚举集合的使用"></a>用法八：关于枚举集合的使用</h2><p>java.util.EnumSet和java.util.EnumMap是两个枚举集合。EnumSet保证集合中的元素不重复；EnumMap中的key是enum类型，而value则可以是任意类型。关于这个两个集合的使用就不在这里赘述，可以参考JDK文档。</p>
<p>关于枚举的实现细节和原理请参考：</p>
<p>参考资料：《ThinkingInJava》第四版</p>
<p><strong>注意: 枚举类型对象之间的值比较，是可以使用==，直接来比较值，是否相等的，不是必须使用equals方法的</strong><br>见 Enum 源码<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object other)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>==other;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ref:<br><a href="http://blog.lichengwu.cn/java/2011/09/26/the-usage-of-enum-in-java/" target="_blank" rel="external">http://blog.lichengwu.cn/java/2011/09/26/the-usage-of-enum-in-java/</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_性能_使用包装类型的缓存对象</title>
    <url>/2017/07/28/Java-%E6%80%A7%E8%83%BD-%E4%BD%BF%E7%94%A8%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%93%E5%AD%98%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>使用包装类型的缓存对象</p>
<a id="more"></a>
<h2 id="Integer-自动装箱"><a href="#Integer-自动装箱" class="headerlink" title="Integer 自动装箱"></a>Integer 自动装箱</h2><p>本文将介绍 Java 中 Integer 缓存的相关知识。这是 Java5 中引入的一个有助于节省内存、提高性能的特性。首先看一个使用 Integer 的示例代码，展示了 Integer 的缓存行为。接着我们将学习这种实现的原因和目的。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIntegerCache</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... strings)</span> </span>&#123;</div><div class="line">		Integer integer1 = <span class="number">3</span>;</div><div class="line">		Integer integer2 = <span class="number">3</span>;</div><div class="line">		<span class="keyword">if</span> (integer1 == integer2)</div><div class="line">			System.out.println(<span class="string">"integer1 == integer2"</span>);</div><div class="line">		<span class="keyword">else</span></div><div class="line">			System.out.println(<span class="string">"integer1 != integer2"</span>);</div><div class="line"></div><div class="line">		Integer integer3 = <span class="number">300</span>;</div><div class="line">		Integer integer4 = <span class="number">300</span>;</div><div class="line">		<span class="keyword">if</span> (integer3 == integer4)</div><div class="line">			System.out.println(<span class="string">"integer3 == integer4"</span>);</div><div class="line">		<span class="keyword">else</span></div><div class="line">			System.out.println(<span class="string">"integer3 != integer4"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*执行结果</span></div><div class="line">integer1 == integer2</div><div class="line">integer3 != integer4</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>在 Java 5 中，为 Integer 的操作引入了一个新的特性，用来节省内存和提高性能。整型对象在内部实现中通过使用相同的对象引用实现了缓存和重用。</p>
<p>上面的规则适用于整数区间 -128 到 +127。</p>
<p>这种 Integer 缓存策略仅在自动装箱（autoboxing）的时候有用，使用构造器创建的 Integer 对象不能被缓存。</p>
<p>Java 编译器把原始类型自动转换为封装类的过程称为自动装箱（autoboxing），这相当于调用 valueOf 方法<br>Integer a = 10; //this is autoboxing<br>Integer b = Integer.valueOf(10); //under the hood</p>
<p>现在我们知道了 JDK 源码中对应实现的部分在哪里了。我们来看看 valueOf 的源码。下面是 JDK 1.8.0 中的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</div><div class="line"> * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</div><div class="line"> * required, this method should generally be used in preference to</div><div class="line"> * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</div><div class="line"> * to yield significantly better space and time performance by</div><div class="line"> * caching frequently requested values.</div><div class="line"> *</div><div class="line"> * This method will always cache values in the range -128 to 127,</div><div class="line"> * inclusive, and may cache other values outside of this range.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</div><div class="line"> * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</div><div class="line"> * <span class="doctag">@since</span>  1.5</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</div><div class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在创建新的 Integer 对象之前会先在 IntegerCache.cache (是个Integer类型的数组)中查找。有一个专门的 Java 类来负责 Integer 的缓存。</p>
<h2 id="IntegerCache-类"><a href="#IntegerCache-类" class="headerlink" title="IntegerCache 类"></a>IntegerCache 类</h2><p>IntegerCache 是 Integer 类中一个私有的静态类。我们来看看这个类，有比较详细的文档，可以提供我们很多信息。<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Cache to support the object identity semantics of autoboxing for values between</div><div class="line"> * -128 and 127 (inclusive) as required by JLS.</div><div class="line"> *</div><div class="line"> * The cache is initialized on first usage.  The size of the cache</div><div class="line"> * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</div><div class="line"> * During VM initialization, java.lang.Integer.IntegerCache.high property</div><div class="line"> * may be set and saved in the private system properties in the</div><div class="line"> * sun.misc.VM class.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        <span class="comment">// high value may be configured by property</span></div><div class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</div><div class="line">        String integerCacheHighPropValue =</div><div class="line">            sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</div><div class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</div><div class="line">                i = Math.max(i, <span class="number">127</span>);</div><div class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></div><div class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</div><div class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</div><div class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        high = h;</div><div class="line"></div><div class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</div><div class="line">        <span class="keyword">int</span> j = low;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</div><div class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</div><div class="line"></div><div class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></div><div class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Javadoc 详细的说明这个类是用来实现缓存支持，并支持 -128 到 127 之间的自动装箱过程。最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改。 缓存通过一个 for 循环实现。从小到大的创建尽可能多的整数并存储在一个名为 cache 的整数数组中。这个缓存会在 Integer 类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。</p>
<p>实际上在 Java 5 中引入这个特性的时候，范围是固定的 -128 至 +127。后来在 Java 6 中，最大值映射到 java.lang.Integer.IntegerCache.high，可以使用 JVM 的启动参数设置最大值。这使我们可以根据应用程序的实际情况灵活地调整来提高性能。是什么原因选择这个 -128 到 127 这个范围呢？因为这个范围的整数值是使用最广泛的。 在程序中第一次使用 Integer 的时候也需要一定的额外时间来初始化这个缓存。</p>
<h2 id="Java-语言规范中的缓存行为"><a href="#Java-语言规范中的缓存行为" class="headerlink" title="Java 语言规范中的缓存行为"></a>Java 语言规范中的缓存行为</h2><p>在 Boxing Conversion 部分的Java语言规范(JLS)规定如下：<br>如果一个变量 p 的值属于：-128至127之间的整数(§3.10.1这个估计是版本号吧)，true 和 false的布尔值 (§3.10.3)，’u0000′ 至 ‘u007f’ 之间的字符(§3.10.4)中时，将 p 包装成 a 和 b 两个对象时，可以直接使用 a == b 判断 a 和 b 的值是否相等。</p>
<h2 id="其他缓存的对象"><a href="#其他缓存的对象" class="headerlink" title="其他缓存的对象"></a>其他缓存的对象</h2><p>这种缓存行为不仅适用于Integer对象。我们针对所有整数类型的类都有类似的缓存机制。<br>有 ByteCache 用于缓存 Byte 对象<br>有 ShortCache 用于缓存 Short 对象<br>有 LongCache 用于缓存 Long 对象<br>有 CharacterCache 用于缓存 Character 对象<br>Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。</p>
<h2 id="学以致用"><a href="#学以致用" class="headerlink" title="学以致用"></a>学以致用</h2><p>建议声明包装类型的时候，使用valueOf()生成，而不是通过构造函数生成。这样使用整型池，不仅仅提高了系统性能，同时节约了内存空间。</p>
<p>ref:<br><a href="http://blog.csdn.net/qq_27093465/article/details/52473649" target="_blank" rel="external">http://blog.csdn.net/qq_27093465/article/details/52473649</a><br><a href="http://javapapers.com/java/java-integer-cache/" target="_blank" rel="external">http://javapapers.com/java/java-integer-cache/</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>性能</tag>
        <tag>包装类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_性能_选择适合的字符串拼接方法</title>
    <url>/2017/07/28/Java-%E6%80%A7%E8%83%BD-%E9%80%89%E6%8B%A9%E9%80%82%E5%90%88%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>_选择适合的字符串拼接方法</p>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对一个字符串拼接有三种方法:加号,contact方法,StringBuffer或者StringBuilder的append方法,其中加号是最常用的.其他两种方式偶尔会出现在一些开源项目中,那么这三者有什么区别?<br>str += “c”; //加号拼接<br>str = str.concat(“c”); //concat方法连接<br>以上是两种不同的字符串拼接方式,循环5万次后再检查执行的时间,加号方式执行的时间是1438毫秒,而concat方法的执行时间是703毫秒,时间相差一倍,如果使用StringBuilder方式,执行时间会更少.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LOOP = <span class="number">50000</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        doWithPlus();</div><div class="line">        doWithConcat();</div><div class="line">        doWithStringBuffer();</div><div class="line">        </div><div class="line">        String str =<span class="string">"abc"</span>;</div><div class="line">        String str1 = str.concat(<span class="string">"1"</span>);</div><div class="line">        String str2 = <span class="string">"abc1"</span>;</div><div class="line">        System.out.println(str1 == str2);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithPlus</span><span class="params">()</span></span>&#123;</div><div class="line">        String str = <span class="string">"a"</span>;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_LOOP;i++)&#123;</div><div class="line">            str += <span class="string">"c"</span>;</div><div class="line">            <span class="comment">//str = new StringBuilder(prefix).append("c").toString();</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> finish = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"doWithPlus:"</span> + (finish - start) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithConcat</span><span class="params">()</span></span>&#123;</div><div class="line">        String str = <span class="string">"a"</span>;</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_LOOP;i++)&#123;</div><div class="line">            str = str.concat(<span class="string">"c"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> finish = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"doWithConcat:"</span> + (finish - start) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithStringBuffer</span><span class="params">()</span></span>&#123;</div><div class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"a"</span>);</div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_LOOP;i++)&#123;</div><div class="line">            sb.append(<span class="string">"c"</span>);</div><div class="line">        &#125;</div><div class="line">        String str = sb.toString();</div><div class="line">        <span class="keyword">long</span> finish = System.currentTimeMillis();</div><div class="line">        System.out.println(<span class="string">"doWithStringBuffer:"</span> + (finish - start) + <span class="string">"ms"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">运行结果:</div><div class="line">doWithPlus:1559ms</div><div class="line">doWithConcat:748ms</div><div class="line">doWithStringBuffer:2ms</div><div class="line">false</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>StringBuffer的append方法的执行时间是0毫秒.说明时间非常的短(毫秒不足以计时,可以使用纳秒进行计算).这个实验说明在字符串拼接的方式中,append方法最快,concat方法次之,加号最慢,这是为何呢?</p>
<h2 id="三种方法区别"><a href="#三种方法区别" class="headerlink" title="三种方法区别"></a>三种方法区别</h2><h3 id="“-”方法拼接字符串"><a href="#“-”方法拼接字符串" class="headerlink" title="“+”方法拼接字符串"></a>“+”方法拼接字符串</h3><p>虽然编译器对字符串的加号做了优化,它会使用StringBuilder的append方法进行追加,按道理来说,其执行时间应该也是0毫秒,不过它最终是通过toString方法转换成String字符串的,例子中”+”拼接的代码与如下代码相同:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line">str = <span class="keyword">new</span> StringBuilder(str).append(<span class="string">"c"</span>).toString();</div></pre></td></tr></table></figure></p>
<p>它与纯粹的使用StrignBuilder的append方法是不同的,意思每次循环都会创建一个StringBuilder对象,二是每次执行完毕都要调用toString方法将其转换为字符串——它的时间都耗费在这里了.</p>
<h3 id="concat方法拼接字符串"><a href="#concat方法拼接字符串" class="headerlink" title="concat方法拼接字符串"></a>concat方法拼接字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> otherLen = str.length();</div><div class="line">    <span class="comment">//如果追加的字符串长度为0,着返回字符串本身</span></div><div class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> len = value.length;</div><div class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</div><div class="line">    <span class="comment">//追加的字符串转化成字符数组,添加到buf中</span></div><div class="line">    str.getChars(buf, len);</div><div class="line">    <span class="comment">//复制字符数组,产生一个新的字符串</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其整体看上去就是一个数组的拷贝,虽然在内存中的处理都是原子性操作,速度非常快,不过,注意看最后的return语句,每次的concat操作都会新创建一个String对象,这就是concat速度慢下来的真正原因,它创建了5万个String对象.</p>
<h3 id="append方法拼接字符串"><a href="#append方法拼接字符串" class="headerlink" title="append方法拼接字符串"></a>append方法拼接字符串</h3><p>StringBuilder的append方法直接由父类AbstractStringBuilder实现,其代码如下<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>) str = <span class="string">"null"</span>;<span class="comment">//如果是null值,则把null作为字符串处理</span></div><div class="line">    <span class="keyword">int</span> len = str.length();</div><div class="line">    ensureCapacityInternal(count + len);<span class="comment">//加长,并作数组拷贝</span></div><div class="line">    str.getChars(<span class="number">0</span>, len, value, count);</div><div class="line">    count += len;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>整个append方法都在做字符组处理,加长,然后数组拷贝,这些都是基本数据处理,没有新建任何对象,所以速度也就最快了.<br>例子中是在最后通过StringBuffer的toString返回了一个字符串,也就是在5万次循环结束之后才生成了一个String对象.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>“+”非常符合我们的编码习惯,适合人类阅读,在大多数情况下都可以使用加号操作,只有在系统性能临界的时候才考虑使用concat或者append方法.</p>
<p>而且很多时候,系统的80%的系能消耗是在20%的代码上,我们的精力应该更多的投入到算法和结构上.</p>
<p>ref:<br><a href="http://www.cnblogs.com/DreamDrive/p/5660256.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5660256.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_规避_不要主动进行垃圾回收</title>
    <url>/2017/07/28/Java-%E8%A7%84%E9%81%BF-%E4%B8%8D%E8%A6%81%E4%B8%BB%E5%8A%A8%E8%BF%9B%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p>ref: <a href="http://blog.csdn.net/p106786860/article/details/9167411" target="_blank" rel="external">http://blog.csdn.net/p106786860/article/details/9167411</a></p>
<a id="more"></a>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>不要调用system.gc，即使经常出现内存溢出也不要调用，内存溢出是可分析的，是可以查找原因的，GC可不是一个好招数。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>System.gc主动进行垃圾回收时一个非常危险的动作。因为它要停止所有的响应，才能检查内存中是否有可回收的对象，这对一个应用系统风险极大。</p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>如果一个Web应用，所有的请求都会暂停，等待垃圾回收器执行完毕，若此时堆内存（Heap）中的对象少的话则可以接受，一旦对象较多（现在的Web项目越做越大，框架工具越来越多，加载到内存中的对象就更多了），这个过程非常耗时，可能是0.01秒，也可能是1秒，甚至可能是20秒，这就会严&gt;重影响到业务的正常运行。<br>又如这样一段代码：new String(“abc”)，该对象没有任何引用，对JVM来说就是个垃圾对象。JVM的垃圾回收器线程第一次扫描（扫描时间不确定，在系统不繁忙的时候执行）时把它贴上一个标签，说“你是可以给回收的”，第二次扫描时才真正地回收该对象，并释放空间。如果我们直接调用System.gc，就等于说“嗨，你，那个垃圾回收器过来检查一下有没有垃圾对象，回收一下”。程序主动招来了垃圾回收器，这意味着正在运行着的系统要让出资源，以供垃圾回收器执行。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>规避</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_规避_不要随便设置随机种子</title>
    <url>/2017/07/28/Java-%E8%A7%84%E9%81%BF-%E4%B8%8D%E8%A6%81%E9%9A%8F%E4%BE%BF%E8%AE%BE%E7%BD%AE%E9%9A%8F%E6%9C%BA%E7%A7%8D%E5%AD%90/</url>
    <content><![CDATA[<p>不要随便设置随机种子</p>
<a id="more"></a>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>随机数在太多的地方使用了，比如加密、混淆数据等，我们使用随机数是期望获得一个唯一的、不可仿造的数字，以避免产生相同的业务数据造成混乱。在Java项目中通常是通过Math.random方法和Random类来获得随机数的，我们来看一段代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Random r = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">4</span>;i++)&#123;</div><div class="line">            System.out.println(<span class="string">"第"</span>+i+<span class="string">"次："</span>+r.nextInt());</div><div class="line">        &#125;  </div><div class="line">     &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码很简单，我们一般都是这样获得随机数的，运行此程序可知：三次打印的随机数都不相同，即使多次运行结果也不同，这也正是我们想要随机数的原因。<br>我们再来看下面的程序：<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Random r = <span class="keyword">new</span> Random(<span class="number">1000</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">            System.out.println(<span class="string">"第"</span> + i + <span class="string">"次："</span> + r.nextInt());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*运行结果:</span></div><div class="line">第1次：-1244746321</div><div class="line">第2次：1060493871</div><div class="line">第3次：-1826063944</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>计算机不同输出的随机数也不同，但是有一点是相同的：在同一台机器上，甭管运行多少次，所打印的随机数都是相同的，也就是说第一次运行，会打印出这三个随机数，第二次运行还是打印出这三个随机数，只要是在同一台硬件机器上，就永远都会打印出相同的随机数，似乎随机数不随机了，问题何在？</p>
<p>那是因为产生随机数的种子被固定了，在Java中，随机数的产生取决于种子，随机数和种子之间的关系遵从以下两个规则：</p>
<ol>
<li>种子不同，产生不同的随机数。</li>
<li>种子相同，即使实例不同也产生相同的随机数。</li>
</ol>
<p>看完上面两个规则，我们再来看这个例子，会发现问题就出在有参构造上，Random类的默认种子（无参构造）是System.nanoTime()的返回值（JDK 1.5版本以前默认种子是System. currentTimeMillis()的返回值），注意这个值是距离某一个固定时间点的纳秒数，不同的操作系统和硬件有不同的固定时间点，也就是说不同的操作系统其纳秒值是不同的，而同一个操作系统纳秒值也会不同，随机数自然也就不同了。（顺便说下，System.nanoTime不能用于计算日期，那是因为“固定”的时间点是不确定的，纳秒值甚至可能是负值，这点与System. currentTimeMillis不同。）</p>
<p>new Random(1000)显式地设置了随机种子为1000，运行多次，虽然实例不同，但都会获得相同的三个随机数。所以，除非必要，否则不要设置随机种子。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates a new random number generator. This constructor sets</div><div class="line"> * the seed of the random number generator to a value very likely</div><div class="line"> * to be distinct from any other invocation of this constructor.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(seedUniquifier() ^ System.nanoTime());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates a new random number generator using a single &#123;<span class="doctag">@code</span> long&#125; seed.</div><div class="line"> * The seed is the initial value of the internal state of the pseudorandom</div><div class="line"> * number generator which is maintained by method &#123;<span class="doctag">@link</span> #next&#125;.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;The invocation &#123;<span class="doctag">@code</span> new Random(seed)&#125; is equivalent to:</div><div class="line"> *  &lt;pre&gt; &#123;<span class="doctag">@code</span></div><div class="line"> * Random rnd = new Random();</div><div class="line"> * rnd.setSeed(seed);&#125;&lt;/pre&gt;</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> seed the initial seed</div><div class="line"> * <span class="doctag">@see</span>   #setSeed(long)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Random</span><span class="params">(<span class="keyword">long</span> seed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (getClass() == Random.class)</div><div class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong(initialScramble(seed));</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// subclass might have overriden setSeed</span></div><div class="line">        <span class="keyword">this</span>.seed = <span class="keyword">new</span> AtomicLong();</div><div class="line">        setSeed(seed);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>顺便提一下，在Java中有两种方法可以获得不同的随机数：通过java.util.Random类获得随机数的原理和Math.random方法相同，Math.random()方法也是通过生成一个Random类的实例，然后委托nextDouble()方法的，两者是殊途同归，没有差别。<br>Math.random()源码如下:<br><figure class="highlight java"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Returns a &#123;<span class="doctag">@code</span> double&#125; value with a positive sign, greater</div><div class="line"> * than or equal to &#123;<span class="doctag">@code</span> 0.0&#125; and less than &#123;<span class="doctag">@code</span> 1.0&#125;.</div><div class="line"> * Returned values are chosen pseudorandomly with (approximately)</div><div class="line"> * uniform distribution from that range.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;When this method is first called, it creates a single new</div><div class="line"> * pseudorandom-number generator, exactly as if by the expression</div><div class="line"> *</div><div class="line"> * &lt;blockquote&gt;&#123;<span class="doctag">@code</span> new java.util.Random()&#125;&lt;/blockquote&gt;</div><div class="line"> *</div><div class="line"> * This new pseudorandom-number generator is used thereafter for</div><div class="line"> * all calls to this method and is used nowhere else.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;This method is properly synchronized to allow correct use by</div><div class="line"> * more than one thread. However, if many threads need to generate</div><div class="line"> * pseudorandom numbers at a great rate, it may reduce contention</div><div class="line"> * for each thread to have its own pseudorandom-number generator.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@return</span>  a pseudorandom &#123;<span class="doctag">@code</span> double&#125; greater than or equal</div><div class="line"> * to &#123;<span class="doctag">@code</span> 0.0&#125; and less than &#123;<span class="doctag">@code</span> 1.0&#125;.</div><div class="line"> * <span class="doctag">@see</span> Random#nextDouble()</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">random</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomNumberGeneratorHolder</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Random randomNumberGenerator = <span class="keyword">new</span> Random();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>注意　若非必要，不要设置随机数种子。<br>ref:<br><a href="http://www.cnblogs.com/DreamDrive/p/5425094.html" target="_blank" rel="external">http://www.cnblogs.com/DreamDrive/p/5425094.html</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>规避</tag>
      </tags>
  </entry>
  <entry>
    <title>Git_clone某个分支</title>
    <url>/2017/07/28/Git-clone%E6%9F%90%E4%B8%AA%E5%88%86%E6%94%AF/</url>
    <content><![CDATA[<p>Git clone 指定分支</p>
<a id="more"></a>
<h2 id="clone-某个分支："><a href="#clone-某个分支：" class="headerlink" title="clone 某个分支："></a>clone 某个分支：</h2><p>git clone -b srcbr git://github.com/xxx/xxx.git</p>
<h2 id="clone所有分支"><a href="#clone所有分支" class="headerlink" title="clone所有分支"></a>clone所有分支</h2><p>git clone git://github.com/xxx/xxx.git</p>
<h2 id="List-or-delete-if-used-with-d-the-remote-tracking-branches"><a href="#List-or-delete-if-used-with-d-the-remote-tracking-branches" class="headerlink" title="List or delete (if used with -d) the remote-tracking branches."></a>List or delete (if used with -d) the remote-tracking branches.</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">git branch -r           </div><div class="line">* master</div><div class="line">  origin/HEAD -&gt; origin/master</div><div class="line">  origin/master</div><div class="line">  origin/b1</div></pre></td></tr></table></figure>
<h2 id="Switch-branches-or-restore-working-tree-files"><a href="#Switch-branches-or-restore-working-tree-files" class="headerlink" title="Switch branches or restore working tree files."></a>Switch branches or restore working tree files.</h2><p>git checkout b1</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建静态博客-04添加站内搜索</title>
    <url>/2017/07/28/Hexo-Github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-04%E6%B7%BB%E5%8A%A0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,但Swiftype和Algolia都只有一段时间的试用期。所以我采用了Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml/json文件，通过这个文件实现搜索功能。</p>
<a id="more"></a>
<h3 id="为hexo和next增加站内搜索功能"><a href="#为hexo和next增加站内搜索功能" class="headerlink" title="为hexo和next增加站内搜索功能"></a>为hexo和next增加站内搜索功能</h3><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">npm install hexo-generator-search</div><div class="line">npm install hexo-generator-searchdb</div></pre></td></tr></table></figure>
<h4 id="修改hexo配置"><a href="#修改hexo配置" class="headerlink" title="修改hexo配置"></a>修改hexo配置</h4><p>在你的hexo目录下的_config.yml中增加如下配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">search:</div><div class="line">  path: search.xml</div><div class="line">  field: post</div><div class="line">  format: html</div><div class="line">  limit: 10000</div></pre></td></tr></table></figure></p>
<p>配置上之后，其实搜索已经配置完成了，但现在我们还看不到搜索的入口，接下来我们需要在next的主体上进行配置</p>
<h4 id="配置next中的搜索入口"><a href="#配置next中的搜索入口" class="headerlink" title="配置next中的搜索入口"></a>配置next中的搜索入口</h4><p>打开themes\next_config.yml，打开local search:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Local search</div><div class="line">local_search:</div><div class="line">  enable: true</div><div class="line">  # if auto, trigger search by changing input</div><div class="line">  # if manual, trigger search by pressing enter key or search button</div><div class="line">  trigger: auto</div><div class="line">  # show top n results per article, show all results by setting to -1</div><div class="line">  top_n_per_article: 1</div></pre></td></tr></table></figure></p>
<p>接下来就可以运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo s</div></pre></td></tr></table></figure></p>
<p>在本地打开<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>进行查看了。</p>
<h4 id="travis-ci构建搜索模块"><a href="#travis-ci构建搜索模块" class="headerlink" title="travis-ci构建搜索模块"></a>travis-ci构建搜索模块</h4><p>如果你的博客是使用travis-ci自动进行构建的话，需要将上面提到的两个插件在.travis.yml中进行配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># S: Build Lifecycle</div><div class="line">install:</div><div class="line">  - npm install</div><div class="line">  - npm install hexo-generator-search</div><div class="line">  - npm install hexo-generator-searchdb</div></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建静态博客-03添加tags和categories</title>
    <url>/2017/07/27/Hexo-Github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-03%E6%B7%BB%E5%8A%A0tags%E5%92%8Ccategories/</url>
    <content><![CDATA[<p>之前我们已经写了怎么安装设置Hexo和怎么部署到gitHub上，下面我们说一下怎么完善我们的blog，今天先介绍下怎么添加分类和标签页面</p>
<a id="more"></a>
<h3 id="创建Tag页面"><a href="#创建Tag页面" class="headerlink" title="创建Tag页面"></a>创建Tag页面</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new page &quot;tags&quot;</div></pre></td></tr></table></figure>
<p>编辑刚新建的页面，将页面的类型设置为tags，主题将自动为这个页面显示标签云。页面内容如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">---</div><div class="line">title: Tagcloud</div><div class="line">date: 2017-06-22 12:39:04</div><div class="line">type: &quot;tags&quot;</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>注意：如果有启用多说 或者Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">---</div><div class="line">title: Tagcloud</div><div class="line">date: 2017-06-22 12:39:04</div><div class="line">type: &quot;tags&quot;</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure></p>
<h3 id="创建Categories页面"><a href="#创建Categories页面" class="headerlink" title="创建Categories页面"></a>创建Categories页面</h3><p>创建分类页和Tag页是差不多的步骤。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new page &quot;categories&quot;</div><div class="line"></div><div class="line">---</div><div class="line">title: categories</div><div class="line">date: 2017-06-22 12:39:04</div><div class="line">type: &quot;categories&quot;</div><div class="line">comments: false</div><div class="line">---</div></pre></td></tr></table></figure></p>
<h3 id="添加菜单"><a href="#添加菜单" class="headerlink" title="添加菜单"></a>添加菜单</h3><p>在菜单中添加链接。编辑 主题配置文件 ，添加 tags 到 menu 中，如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">menu:</div><div class="line">  home: /</div><div class="line">  categories: /categories/</div><div class="line">  #about: /about/</div><div class="line">  archives: /archives/</div><div class="line">  tags: /tags/</div><div class="line">  #sitemap: /sitemap.xml</div><div class="line">  #commonweal: /404.html</div></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建静态博客-02部署到github</title>
    <url>/2017/07/27/Hexo-Github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-02%E9%83%A8%E7%BD%B2%E5%88%B0github/</url>
    <content><![CDATA[<p>将hexo部署到github上，这篇文章中我将介绍两种方法</p>
<a id="more"></a>
<h2 id="github准备工作"><a href="#github准备工作" class="headerlink" title="github准备工作"></a>github准备工作</h2><h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><p>如果你已经有了github账号，这一步可以忽略， 注册细节详见官网</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>New Repository<br>Repo name: your_user_name.github.io<br>类型勾选 ‘public’</p>
<h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><h3 id="生成网站"><a href="#生成网站" class="headerlink" title="生成网站"></a>生成网站</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>此时会将/source的.md文件生成到/public中，形成网站的静态文件。</p>
<h3 id="开启本地服务器"><a href="#开启本地服务器" class="headerlink" title="开启本地服务器"></a>开启本地服务器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>输入<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 即可查看网站。指定端口号方式: hexo server -p 3000,此时，输入<a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a> 查看网站。</p>
<h3 id="部署网站"><a href="#部署网站" class="headerlink" title="部署网站"></a>部署网站</h3><p>第一步需要在_config.yml中配置你所要部署的站点：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repository: https://github.com/mamadown/mamadown.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>部署命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure></p>
<p>部署网站之前需要生成静态文件，也可以用$ hexo generate -d直接生成并部署。<br>到此为止完成网站的雏形。输入yourname.github.io可访问博客主页。例如：<a href="http://your_user_name.github.io/" target="_blank" rel="external">http://your_user_name.github.io/</a> 。</p>
<p>部署的时候若出错，加这一步:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>PS:这种方式，如果需要多台电脑之间操作blog，会很麻烦。个人建议使用第二种方式。</p>
<h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>第一种方法，我们需要每次写完文章后自己进行编译静态文件并部署到  github 上, 太麻烦，可借助 Travis CI 持续集成构建项目来完成自动编译部署。</p>
<h3 id="什么是Travis-CI"><a href="#什么是Travis-CI" class="headerlink" title="什么是Travis CI"></a>什么是Travis CI</h3><p>Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，Go的很明显的特别在于采用yaml格式，同时他是在在线的服务，不像jenkins需要你本地打架服务器，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。对于做开源项目或者github的使用者，如果你的项目还没有加入Travis CI构建队列，那么我真的想对你说out了。</p>
<h3 id="github代码位置"><a href="#github代码位置" class="headerlink" title="github代码位置"></a>github代码位置</h3><p>使用Travis CI需要在github上创建两个分支，一个是默认的master，还有一个是source_branch分支。</p>
<p>master：博客的静态文件，也就是hexo生成后的HTML文件，因为要使用Github Pages服务，所以他规定的网页文件必须是在master分支。<br>source_branch：是博客的源代码，我们需要将hexo的代码上传到这个分支。</p>
<p>我们只需要将你的blog clone到本地，在source_branch分支写blog，写完之后 git push到github，然后Travis自动构建，构建完成后自动推送到Github上的master分支下。</p>
<h3 id="启用要构建的项目"><a href="#启用要构建的项目" class="headerlink" title="启用要构建的项目"></a>启用要构建的项目</h3><p>首先如果你要使用Travis CI，你必须要GIthub账号（目前Travis CI只支持构建github的项目）和一个项目。</p>
<p>使用Github账号登录Travis CI官网，接下来我们点击 My Repositories旁边的+，意思是添加一个要自动构建的仓库，然后<br>可以看到当前github账号的所有项目，如果没有显示，点击右上角的“Sync account”按钮，就可以同步过来了。</p>
<p>下一步肯定是要选中并开启你需要构建的仓库(your_user_name/your_user_name.github.io)</p>
<p>开启后我们还需要进行如下配置：<br>More opertions &gt; Settings, 然后勾选 Build only if .travis.yml is present 和 Build branch updates<br>Build only if .travis.yml is present：是只有在.travis.yml文件中配置的分支改变了才构建；<br>Build branch updates：当推送完这个分支后开始构建；</p>
<p>到这一步， 我们已经开启了要构建的仓库，但是还有个问题就是，构建完后，我们怎么将生成的文件推送到github上呢，如果不能推送那我们就不需要倒腾一番来使用Travis CI服务了，我们要的结果就是，我们只要想github一push，他就自动构建并push静态文件到github pages呢，那么下面要解决的就是Travis CI怎么访问github了。</p>
<h3 id="在Travis-CI配置Github的Access-Token"><a href="#在Travis-CI配置Github的Access-Token" class="headerlink" title="在Travis CI配置Github的Access Token"></a>在Travis CI配置Github的Access Token</h3><p>标题已经说得很明白了吧，我们需要在Travis上配置Access Token，这样我们就可以在他构建完后自动push到github pages了。</p>
<p>在github上生成Access Token<br>首先我们来到github的设置界面，Personal access tokens &gt; Generate new token</p>
<p>在Travis CI配置<br>配置界面还是在项目的setting里面, 在Environment Variables 添加刚刚新生成的 Access Token</p>
<p>至于为什么我们要在这里配置，我想大家肯定应该明白了，写在程序里不安全，配置到这里相当于一个环境变量，我们在构建的时候就可以引用他。<br>到这里我已经配置了要构建的仓库和要访问的Token，但是问题来了，他知道怎么构建，怎么生成静态文件吗，怎么push的github pages，又push到那个仓库吗，所以这里我们还需要在源代码的仓库(source_branch)里创建一个.travis.yml配置文件，放到源代码的根目录<br>文件内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">language: node_js</div><div class="line">node_js: stable</div><div class="line"></div><div class="line"># S: Build Lifecycle</div><div class="line">install:</div><div class="line">  - npm install</div><div class="line"></div><div class="line"></div><div class="line">#before_script:</div><div class="line"> # - npm install -g gulp</div><div class="line"></div><div class="line">script:</div><div class="line">  - hexo g</div><div class="line"></div><div class="line">after_script:</div><div class="line">  - cd ./public</div><div class="line">  - git init</div><div class="line">  - git config user.name &quot;your nickname&quot;</div><div class="line">  - git config user.email &quot;your email&quot;</div><div class="line">  - git add .</div><div class="line">  - git commit -m &quot;Update docs&quot;</div><div class="line">  - git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master</div><div class="line">  # GH_TOKEN is Access Token name</div><div class="line"># E: Build LifeCycle</div><div class="line"></div><div class="line">branches:</div><div class="line">  only:</div><div class="line">    - blog-source</div><div class="line">env:</div><div class="line"> global:</div><div class="line">   - GH_REF: github.com/your_user_name/your_user_name.github.io.git</div></pre></td></tr></table></figure></p>
<p>记得配置一下你的昵称、邮箱和你的git地址(GH_REF)。<br>到这一步，我们可以写一篇文章，添加到你的博客的_posts目录下，然后commit并push到你的Github上。<br>如果不出意外，我们可以就可以在Travis CI网站看到它已经在构建了，构建完成后，我们去blog上就能看到这篇文章了。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建静态博客-01本地服务</title>
    <url>/2017/07/27/Hexo-Github%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-01%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p>Hexo+Github搭建静态博客-01本地服务</p>
<a id="more"></a>
<h2 id="安装Git和NodeJS环境"><a href="#安装Git和NodeJS环境" class="headerlink" title="安装Git和NodeJS环境"></a>安装Git和NodeJS环境</h2><p>因为hexo需要依赖Git和NodeJs，所以需要先安装环境。</p>
<p>Git下载地址：<a href="https://git-scm.com/download/win" target="_blank" rel="external">https://git-scm.com/download/win</a><br>NodeJS下载地址：<a href="https://nodejs.org/download/" target="_blank" rel="external">https://nodejs.org/download/</a><br>安装过程详见官网</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div><div class="line">$ hexo init &amp;lt;your-hexo-site&amp;gt;</div><div class="line">$ cd &amp;lt;your-hexo-site&amp;gt;</div><div class="line">$ npm install</div></pre></td></tr></table></figure>
<h2 id="使用-alpha-dust-主题"><a href="#使用-alpha-dust-主题" class="headerlink" title="使用 alpha-dust 主题"></a>使用 alpha-dust 主题</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ cd &lt;your-hexo-site&gt;</div><div class="line">$ git clone https://github.com/klugjo/hexo-theme-alpha-dust themes/alpha-dust</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改_config.yml中的blog的主题:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># Extensions</div><div class="line">## Plugins: https://hexo.io/plugins/</div><div class="line">## Themes: https://hexo.io/themes/</div><div class="line">theme: alpha-dust</div></pre></td></tr></table></figure></p>
<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$ hexo new &quot;Hello World&quot;</div><div class="line">$ hexo s --debug</div></pre></td></tr></table></figure>
<p>访问<a href="http://localhost:4000，确保站点正确运行。" target="_blank" rel="external">http://localhost:4000，确保站点正确运行。</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/07/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>SpringBoot-Maven-Dependencies</title>
    <url>/2017/01/07/SpringBoot-Maven-Dependencies/</url>
    <content><![CDATA[<p>SpringBoot 下 Maven 依赖关系</p>
<a id="more"></a>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>SpringBoot 2.0</li>
<li>项目 gs-rest-service (download from spring.io)</li>
</ul>
<h2 id="查看-SpringBoot-的依赖"><a href="#查看-SpringBoot-的依赖" class="headerlink" title="查看 SpringBoot 的依赖"></a>查看 SpringBoot 的依赖</h2><p>借助 Maven Helper 插件, 查看步骤如下：<br>核心依赖 spring-boot-starter-web<br><img src="20180828170931.png" alt="20180828170931"><br>查看依赖关系<br><img src="20180828171116.png" alt="20180828171116"><br><img src="springboot_mvn_dependency.png" alt="springboot_mvn_dependency"><br><img src="springboot_mvn_dependency_test.png" alt="springboot_mvn_dependency_test"></p>
<p>或者使用 mvn:dependency:tree &gt; tree.txt<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">[INFO] org.springframework:gs-rest-service:jar:0.1.0</div><div class="line">[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:2.0.3.RELEASE:compile</div><div class="line">[INFO] |  +- org.springframework.boot:spring-boot-starter:jar:2.0.3.RELEASE:compile</div><div class="line">[INFO] |  |  +- org.springframework.boot:spring-boot:jar:2.0.3.RELEASE:compile</div><div class="line">[INFO] |  |  +- org.springframework.boot:spring-boot-autoconfigure:jar:2.0.3.RELEASE:compile</div><div class="line">[INFO] |  |  +- org.springframework.boot:spring-boot-starter-logging:jar:2.0.3.RELEASE:compile</div><div class="line">[INFO] |  |  |  +- ch.qos.logback:logback-classic:jar:1.2.3:compile</div><div class="line">[INFO] |  |  |  |  \- ch.qos.logback:logback-core:jar:1.2.3:compile</div><div class="line">[INFO] |  |  |  +- org.apache.logging.log4j:log4j-to-slf4j:jar:2.10.0:compile</div><div class="line">[INFO] |  |  |  |  \- org.apache.logging.log4j:log4j-api:jar:2.10.0:compile</div><div class="line">[INFO] |  |  |  \- org.slf4j:jul-to-slf4j:jar:1.7.25:compile</div><div class="line">[INFO] |  |  +- javax.annotation:javax.annotation-api:jar:1.3.2:compile</div><div class="line">[INFO] |  |  \- org.yaml:snakeyaml:jar:1.19:runtime</div><div class="line">[INFO] |  +- org.springframework.boot:spring-boot-starter-json:jar:2.0.3.RELEASE:compile</div><div class="line">[INFO] |  |  +- com.fasterxml.jackson.core:jackson-databind:jar:2.9.6:compile</div><div class="line">[INFO] |  |  |  +- com.fasterxml.jackson.core:jackson-annotations:jar:2.9.0:compile</div><div class="line">[INFO] |  |  |  \- com.fasterxml.jackson.core:jackson-core:jar:2.9.6:compile</div><div class="line">[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.9.6:compile</div><div class="line">[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.9.6:compile</div><div class="line">[INFO] |  |  \- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.9.6:compile</div><div class="line">[INFO] |  +- org.springframework.boot:spring-boot-starter-tomcat:jar:2.0.3.RELEASE:compile</div><div class="line">[INFO] |  |  +- org.apache.tomcat.embed:tomcat-embed-core:jar:8.5.31:compile</div><div class="line">[INFO] |  |  +- org.apache.tomcat.embed:tomcat-embed-el:jar:8.5.31:compile</div><div class="line">[INFO] |  |  \- org.apache.tomcat.embed:tomcat-embed-websocket:jar:8.5.31:compile</div><div class="line">[INFO] |  +- org.hibernate.validator:hibernate-validator:jar:6.0.10.Final:compile</div><div class="line">[INFO] |  |  +- javax.validation:validation-api:jar:2.0.1.Final:compile</div><div class="line">[INFO] |  |  +- org.jboss.logging:jboss-logging:jar:3.3.2.Final:compile</div><div class="line">[INFO] |  |  \- com.fasterxml:classmate:jar:1.3.4:compile</div><div class="line">[INFO] |  +- org.springframework:spring-web:jar:5.0.7.RELEASE:compile</div><div class="line">[INFO] |  |  \- org.springframework:spring-beans:jar:5.0.7.RELEASE:compile</div><div class="line">[INFO] |  \- org.springframework:spring-webmvc:jar:5.0.7.RELEASE:compile</div><div class="line">[INFO] |     +- org.springframework:spring-aop:jar:5.0.7.RELEASE:compile</div><div class="line">[INFO] |     +- org.springframework:spring-context:jar:5.0.7.RELEASE:compile</div><div class="line">[INFO] |     \- org.springframework:spring-expression:jar:5.0.7.RELEASE:compile</div><div class="line">...</div></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-Filter</title>
    <url>/2017/01/06/SpringBoot-Filter/</url>
    <content><![CDATA[<p>SpringBoot 下添加 Filter</p>
<a id="more"></a>
<h2 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h2><p>传统的javaEE增加Filter是在web.xml中配置，如以下代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;filter&gt;</div><div class="line">   &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;</div><div class="line">    &lt;filter-class&gt;com.cppba.filter.TestFilter&lt;/filter-class&gt;</div><div class="line">&lt;/filter&gt;</div><div class="line">&lt;filter-mapping&gt;</div><div class="line">  &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;</div><div class="line">  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</div><div class="line">  &lt;init-param&gt;</div><div class="line">    &lt;param-name&gt;paramName&lt;/param-name&gt;</div><div class="line">    &lt;param-value&gt;paramValue&lt;/param-value&gt;</div><div class="line">  &lt;/init-param&gt;</div><div class="line">&lt;/filter-mapping&gt;</div></pre></td></tr></table></figure></p>
<h2 id="SpringBoot-中-Bean-方式"><a href="#SpringBoot-中-Bean-方式" class="headerlink" title="SpringBoot 中 @Bean 方式"></a>SpringBoot 中 @Bean 方式</h2><h3 id="创建-Filter"><a href="#创建-Filter" class="headerlink" title="创建 Filter"></a>创建 Filter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.cppba.filter;</div><div class="line"> </div><div class="line">import javax.servlet.*;</div><div class="line">import java.io.IOException;</div><div class="line"> </div><div class="line">public class TestFilter implements Filter &#123;</div><div class="line">  @Override</div><div class="line">  public void init(FilterConfig filterConfig) throws ServletException &#123;</div><div class="line"> </div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  @Override</div><div class="line">  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</div><div class="line">      throws IOException, ServletException &#123;</div><div class="line">    System.out.println(&quot;TestFilter&quot;);</div><div class="line">    chain.doFilter(servletRequest, servletResponse);//放行,否则被拦截</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  @Override</div><div class="line">  public void destroy() &#123;</div><div class="line"> </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Application-中增加一个-bean"><a href="#Application-中增加一个-bean" class="headerlink" title="Application 中增加一个@bean"></a>Application 中增加一个@bean</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Bean</div><div class="line"> public FilterRegistrationBean testFilterRegistration() &#123;</div><div class="line"> </div><div class="line">   FilterRegistrationBean registration = new FilterRegistrationBean();</div><div class="line">   registration.setFilter(new TestFilter());</div><div class="line">   registration.addUrlPatterns(&quot;/*&quot;);</div><div class="line">   registration.addInitParameter(&quot;paramName&quot;, &quot;paramValue&quot;);</div><div class="line">   registration.setName(&quot;testFilter&quot;);</div><div class="line">   registration.setOrder(1);</div><div class="line">   return registration;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>启动项目会看到控制台打印如下<br><img src="20180824195419.png" alt="20180824195419"><br>访问项目<a href="http://127.0.0.1:8080/test，" target="_blank" rel="external">http://127.0.0.1:8080/test，</a> 看到控制台打印出:TestFilter<br><img src="20180824195459.png" alt="20180824195459"></p>
<h2 id="SpringBoot-中-WebFilter-方式"><a href="#SpringBoot-中-WebFilter-方式" class="headerlink" title="SpringBoot 中 @WebFilter 方式"></a>SpringBoot 中 @WebFilter 方式</h2><h3 id="更改-Filter"><a href="#更改-Filter" class="headerlink" title="更改 Filter"></a>更改 Filter</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">package com.cppba.filter;</div><div class="line"> </div><div class="line">import javax.servlet.*;</div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">@Component</div><div class="line">@WebFilter(filterName = &quot;testFilter1&quot;, urlPatterns = &quot;/*&quot;)</div><div class="line">@Order(1)</div><div class="line">public class TestFilter implements Filter &#123;</div><div class="line">  @Override</div><div class="line">  public void init(FilterConfig filterConfig) throws ServletException &#123;</div><div class="line"> </div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  @Override</div><div class="line">  public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</div><div class="line">      throws IOException, ServletException &#123;</div><div class="line">    System.out.println(&quot;TestFilter&quot;);</div><div class="line">    chain.doFilter(servletRequest, servletResponse);//放行,否则被拦截</div><div class="line">  &#125;</div><div class="line"> </div><div class="line">  @Override</div><div class="line">  public void destroy() &#123;</div><div class="line"> </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比较核心的代码是自定义类上面加上 @WebFilter, 其中 @Order 注解表示执行过滤顺序，值越小，越先执行,<br>@compontent 注入Bean</p>
<h3 id="spring-boot的入口处加上scanBasePackages"><a href="#spring-boot的入口处加上scanBasePackages" class="headerlink" title="spring-boot的入口处加上scanBasePackages"></a>spring-boot的入口处加上scanBasePackages</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@SpringBootApplication(scanBasePackages = &quot;com.cppba&quot;)</div><div class="line">public class Application &#123;</div><div class="line">  public static void main(String[] args) throws UnknownHostException &#123;</div><div class="line">    SpringApplication app = new SpringApplication(Application.class);</div><div class="line">    Environment environment = app.run(args).getEnvironment();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法效果和上面版本一样</p>
<p>ref:<br><a href="https://www.cnblogs.com/OnlyCT/p/7133639.html" target="_blank" rel="external">Spring boot下添加filter</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Filter</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-Interceptor</title>
    <url>/2017/01/06/SpringBoot-Interceptor/</url>
    <content><![CDATA[<p>SpringBoot 下添加 Interceptor</p>
<a id="more"></a>
<h2 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;mvc:interceptors&gt;</div><div class="line">    &lt;bean class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;/&gt;</div><div class="line">    &lt;mvc:interceptor&gt;</div><div class="line">        &lt;mvc:mapping path=&quot;/**&quot;/&gt;</div><div class="line">        &lt;mvc:exclude-mapping path=&quot;/admin/**&quot;/&gt;</div><div class="line">        &lt;bean class=&quot;org.springframework.web.servlet.theme.ThemeChangeInterceptor&quot;/&gt;</div><div class="line">    &lt;/mvc:interceptor&gt;</div><div class="line">    &lt;mvc:interceptor&gt;</div><div class="line">        &lt;mvc:mapping path=&quot;/secure/*&quot;/&gt;</div><div class="line">        &lt;bean class=&quot;org.example.SecurityInterceptor&quot;/&gt;</div><div class="line">    &lt;/mvc:interceptor&gt;</div><div class="line">&lt;/mvc:interceptors&gt;</div></pre></td></tr></table></figure>
<h2 id="SpringBoot-中-Configuration-方式"><a href="#SpringBoot-中-Configuration-方式" class="headerlink" title="SpringBoot 中 @Configuration 方式"></a>SpringBoot 中 @Configuration 方式</h2><h3 id="创建-Interceptor"><a href="#创建-Interceptor" class="headerlink" title="创建 Interceptor"></a>创建 Interceptor</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Component</div><div class="line">public class Interceptor1 extends HandlerInterceptorAdapter &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</div><div class="line">        System.out.println(&quot;preHandle1&quot;);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123;</div><div class="line">        System.out.println(&quot;postHandle1&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123;</div><div class="line">        System.out.println(&quot;afterCompletion1&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Interceptor1 同理</p>
<h3 id="创建-InterceptorConfig"><a href="#创建-InterceptorConfig" class="headerlink" title="创建 InterceptorConfig"></a>创建 InterceptorConfig</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">@Configuration</div><div class="line">public class InterceptorConfig extends WebMvcConfigurerAdapter &#123;</div><div class="line"></div><div class="line">    @Autowired</div><div class="line">    private Interceptor1 interceptor1;</div><div class="line">    @Autowired</div><div class="line">    private Interceptor2 interceptor2;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void addInterceptors(InterceptorRegistry registry) &#123;</div><div class="line">        registry.addInterceptor(interceptor1).addPathPatterns(&quot;/**&quot;);</div><div class="line">        registry.addInterceptor(interceptor2).addPathPatterns(&quot;/**&quot;)/*.excludePathPatterns(&quot;/api/xxx&quot;)*/;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>访问 <a href="http://localhost:8080/greeting" target="_blank" rel="external">http://localhost:8080/greeting</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">preHandle1</div><div class="line">preHandle2</div><div class="line">postHandle2</div><div class="line">postHandle1</div><div class="line">afterCompletion2</div><div class="line">afterCompletion1</div></pre></td></tr></table></figure></p>
<p>ref:<br><a href="http://jinnianshilongnian.iteye.com/blog/1670856" target="_blank" rel="external">http://jinnianshilongnian.iteye.com/blog/1670856</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Interceptor</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
</search>
